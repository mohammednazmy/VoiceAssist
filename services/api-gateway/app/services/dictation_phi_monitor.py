"""
Dictation PHI Monitor - Real-Time PHI Detection

Phase 9: HIPAA compliance monitoring for medical dictation.

Features:
- Real-time PHI detection in dictated text
- Alert when unexpected PHI spoken outside patient context
- Pattern-based detection of common PHI types
- Audit logging of PHI access and handling
- Support for de-identification recommendations
"""

import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple

from app.core.logging import get_logger

logger = get_logger(__name__)


# ==============================================================================
# Enums and Types
# ==============================================================================


class PHIType(str, Enum):
    """Types of Protected Health Information."""

    NAME = "name"
    DOB = "date_of_birth"
    SSN = "ssn"
    MRN = "mrn"
    PHONE = "phone"
    EMAIL = "email"
    ADDRESS = "address"
    ACCOUNT_NUMBER = "account_number"
    LICENSE_NUMBER = "license_number"
    VEHICLE_ID = "vehicle_id"
    DEVICE_ID = "device_id"
    IP_ADDRESS = "ip_address"
    BIOMETRIC = "biometric"
    PHOTO = "photo"
    DATE = "date"  # Dates more specific than year
    AGE_OVER_89 = "age_over_89"
    OTHER = "other"


class PHIAlertLevel(str, Enum):
    """Alert levels for PHI detection."""

    INFO = "info"  # PHI detected but expected (current patient)
    WARNING = "warning"  # PHI detected, verify context
    CRITICAL = "critical"  # Unexpected PHI, potential breach


class PHIAction(str, Enum):
    """Recommended actions for PHI handling."""

    ALLOW = "allow"  # PHI is expected and authorized
    MASK = "mask"  # Mask the PHI in display/storage
    REDACT = "redact"  # Remove the PHI entirely
    ALERT = "alert"  # Alert clinician and log
    BLOCK = "block"  # Prevent recording/transmission


# ==============================================================================
# Data Classes
# ==============================================================================


@dataclass
class PHIMatch:
    """A detected PHI match in text."""

    phi_type: PHIType
    value: str
    start_pos: int
    end_pos: int
    confidence: float  # 0-1
    masked_value: str = ""  # Value with PHI masked
    pattern_name: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "phi_type": self.phi_type.value,
            "value": self.value,
            "start_pos": self.start_pos,
            "end_pos": self.end_pos,
            "confidence": self.confidence,
            "masked_value": self.masked_value,
            "pattern_name": self.pattern_name,
        }


@dataclass
class PHIAlert:
    """An alert generated by PHI detection."""

    alert_level: PHIAlertLevel
    phi_type: PHIType
    message: str
    recommended_action: PHIAction
    match: Optional[PHIMatch] = None
    context: Optional[Dict[str, Any]] = None
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "alert_level": self.alert_level.value,
            "phi_type": self.phi_type.value,
            "message": self.message,
            "recommended_action": self.recommended_action.value,
            "match": self.match.to_dict() if self.match else None,
            "context": self.context,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class PHIScanResult:
    """Result of scanning text for PHI."""

    text: str
    matches: List[PHIMatch]
    alerts: List[PHIAlert]
    sanitized_text: str  # Text with PHI masked
    phi_count: int = 0
    has_critical_phi: bool = False
    scan_timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "matches": [m.to_dict() for m in self.matches],
            "alerts": [a.to_dict() for a in self.alerts],
            "sanitized_text": self.sanitized_text,
            "phi_count": self.phi_count,
            "has_critical_phi": self.has_critical_phi,
            "scan_timestamp": self.scan_timestamp.isoformat(),
        }


@dataclass
class PatientPHIContext:
    """Known PHI for the current patient context."""

    patient_id: str
    known_names: Set[str] = field(default_factory=set)
    known_dob: Optional[str] = None
    known_mrn: Optional[str] = None
    known_phone: Optional[str] = None
    known_address_parts: Set[str] = field(default_factory=set)


# ==============================================================================
# PHI Patterns
# ==============================================================================


# Regex patterns for PHI detection
PHI_PATTERNS = {
    # SSN: 123-45-6789 or 123456789
    PHIType.SSN: [
        (r"\b\d{3}-\d{2}-\d{4}\b", "ssn_dashed", 0.95),
        (r"\b\d{9}\b", "ssn_nodash", 0.3),  # Low confidence - could be other numbers
    ],
    # MRN: Various formats (common patterns)
    PHIType.MRN: [
        (r"\bMRN[:\s#]*\d{6,10}\b", "mrn_labeled", 0.95),
        (r"\bmedical record[:\s#]*\d{6,10}\b", "mrn_full", 0.95),
    ],
    # Phone: (123) 456-7890 or 123-456-7890 or 1234567890
    PHIType.PHONE: [
        (r"\(\d{3}\)\s*\d{3}-\d{4}", "phone_parens", 0.9),
        (r"\b\d{3}-\d{3}-\d{4}\b", "phone_dashed", 0.85),
        (r"\b\d{10}\b", "phone_nodash", 0.2),  # Low confidence
    ],
    # Email
    PHIType.EMAIL: [
        (
            r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
            "email_standard",
            0.95,
        ),
    ],
    # Dates (more specific than year)
    PHIType.DATE: [
        (r"\b\d{1,2}/\d{1,2}/\d{2,4}\b", "date_slash", 0.7),
        (r"\b\d{1,2}-\d{1,2}-\d{2,4}\b", "date_dash", 0.7),
        (
            r"\b(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4}\b",
            "date_full",
            0.8,
        ),
    ],
    # Address patterns
    PHIType.ADDRESS: [
        (
            r"\b\d{1,5}\s+(?:[A-Za-z]+\s+){1,3}(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Court|Ct)\b",
            "address_street",
            0.75,
        ),
        (r"\b(?:P\.?O\.?\s*Box|PO\s*Box)\s+\d+\b", "address_pobox", 0.85),
    ],
    # Age over 89 (HIPAA considers this PHI)
    PHIType.AGE_OVER_89: [
        (r"\b(?:9[0-9]|1[0-2][0-9])\s*(?:year|yr)s?\s*old\b", "age_over_89", 0.9),
        (r"\bage\s*(?:of\s*)?\s*(?:9[0-9]|1[0-2][0-9])\b", "age_over_89_labeled", 0.9),
    ],
}

# Common name patterns (simplified - would use NER in production)
NAME_PREFIXES = {"mr", "mrs", "ms", "dr", "miss", "prof", "professor"}
NAME_SUFFIXES = {"jr", "sr", "ii", "iii", "iv", "md", "phd", "rn", "np"}


# ==============================================================================
# Dictation PHI Monitor Service
# ==============================================================================


class DictationPHIMonitor:
    """
    Real-time PHI detection and monitoring for dictation.

    Monitors dictated text for Protected Health Information and
    generates alerts when unexpected PHI is detected.

    Usage:
        monitor = DictationPHIMonitor()

        # Set current patient context
        monitor.set_patient_context(PatientPHIContext(
            patient_id="123",
            known_names={"John Smith"},
            known_mrn="MRN001234"
        ))

        # Scan dictated text
        result = monitor.scan_text("Patient John Smith, MRN 001234...")

        # Check alerts
        for alert in result.alerts:
            print(f"[{alert.alert_level}] {alert.message}")
    """

    def __init__(self):
        self._compiled_patterns: Dict[PHIType, List[Tuple[re.Pattern, str, float]]] = {}
        self._patient_context: Optional[PatientPHIContext] = None
        self._compile_patterns()

    def _compile_patterns(self) -> None:
        """Compile regex patterns for efficiency."""
        for phi_type, patterns in PHI_PATTERNS.items():
            self._compiled_patterns[phi_type] = [
                (re.compile(pattern, re.IGNORECASE), name, confidence) for pattern, name, confidence in patterns
            ]

    def set_patient_context(self, context: PatientPHIContext) -> None:
        """
        Set the current patient context.

        PHI matching the patient context will be flagged as INFO
        rather than WARNING/CRITICAL.
        """
        self._patient_context = context
        logger.debug(f"Set PHI context for patient {context.patient_id}")

    def clear_patient_context(self) -> None:
        """Clear the current patient context."""
        self._patient_context = None
        logger.debug("Cleared PHI patient context")

    def scan_text(self, text: str) -> PHIScanResult:
        """
        Scan text for PHI.

        Args:
            text: Text to scan for PHI

        Returns:
            PHIScanResult with matches and alerts
        """
        matches: List[PHIMatch] = []
        alerts: List[PHIAlert] = []

        # Scan with all patterns
        for phi_type, patterns in self._compiled_patterns.items():
            for pattern, pattern_name, base_confidence in patterns:
                for match in pattern.finditer(text):
                    value = match.group(0)
                    phi_match = PHIMatch(
                        phi_type=phi_type,
                        value=value,
                        start_pos=match.start(),
                        end_pos=match.end(),
                        confidence=base_confidence,
                        masked_value=self._mask_value(value, phi_type),
                        pattern_name=pattern_name,
                    )
                    matches.append(phi_match)

                    # Generate alert
                    alert = self._create_alert(phi_match)
                    if alert:
                        alerts.append(alert)

        # Scan for potential names (simplified)
        name_matches = self._scan_for_names(text)
        matches.extend(name_matches)
        for nm in name_matches:
            alert = self._create_alert(nm)
            if alert:
                alerts.append(alert)

        # Create sanitized text
        sanitized_text = self._sanitize_text(text, matches)

        # Determine if critical PHI found
        has_critical = any(a.alert_level == PHIAlertLevel.CRITICAL for a in alerts)

        return PHIScanResult(
            text=text,
            matches=matches,
            alerts=alerts,
            sanitized_text=sanitized_text,
            phi_count=len(matches),
            has_critical_phi=has_critical,
        )

    def _scan_for_names(self, text: str) -> List[PHIMatch]:
        """
        Scan for potential names in text.

        In production, this would use NER (Named Entity Recognition).
        For now, uses simplified heuristics.
        """
        matches = []

        # Pattern: Title + Capitalized words
        # e.g., "Mr. John Smith" or "Dr. Jane Doe"
        title_pattern = r"\b(?:Mr|Mrs|Ms|Miss|Dr|Prof)\.?\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,2})\b"
        for match in re.finditer(title_pattern, text):
            name = match.group(0)
            matches.append(
                PHIMatch(
                    phi_type=PHIType.NAME,
                    value=name,
                    start_pos=match.start(),
                    end_pos=match.end(),
                    confidence=0.8,
                    masked_value=self._mask_value(name, PHIType.NAME),
                    pattern_name="name_with_title",
                )
            )

        # Pattern: "Patient [Name]" or "patient named [Name]"
        patient_pattern = r"\bpatient(?:\s+named?)?\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})\b"
        for match in re.finditer(patient_pattern, text, re.IGNORECASE):
            name = match.group(1)
            full_match = match.group(0)
            matches.append(
                PHIMatch(
                    phi_type=PHIType.NAME,
                    value=name,
                    start_pos=match.start() + len(full_match) - len(name),
                    end_pos=match.end(),
                    confidence=0.85,
                    masked_value=self._mask_value(name, PHIType.NAME),
                    pattern_name="patient_name",
                )
            )

        return matches

    def _mask_value(self, value: str, phi_type: PHIType) -> str:
        """Create a masked version of PHI value."""
        if phi_type == PHIType.SSN:
            return "***-**-****"
        elif phi_type == PHIType.PHONE:
            return "(***) ***-****"
        elif phi_type == PHIType.EMAIL:
            parts = value.split("@")
            if len(parts) == 2:
                return f"***@{parts[1]}"
            return "***@***.***"
        elif phi_type == PHIType.MRN:
            return "MRN ******"
        elif phi_type == PHIType.NAME:
            # Mask all but first letter of each word
            words = value.split()
            masked_words = [w[0] + "*" * (len(w) - 1) if len(w) > 1 else w for w in words]
            return " ".join(masked_words)
        elif phi_type == PHIType.DATE:
            return "**/**/****"
        elif phi_type == PHIType.ADDRESS:
            return "[ADDRESS REDACTED]"
        else:
            return "*" * min(len(value), 10)

    def _create_alert(self, match: PHIMatch) -> Optional[PHIAlert]:
        """Create an alert for a PHI match."""
        # Check if PHI matches current patient context
        if self._patient_context:
            if self._is_expected_phi(match):
                # PHI is expected for current patient
                return PHIAlert(
                    alert_level=PHIAlertLevel.INFO,
                    phi_type=match.phi_type,
                    message=f"Detected {match.phi_type.value} matching current patient",
                    recommended_action=PHIAction.ALLOW,
                    match=match,
                )

        # Unexpected PHI
        alert_level = self._determine_alert_level(match)
        action = self._determine_action(match, alert_level)

        return PHIAlert(
            alert_level=alert_level,
            phi_type=match.phi_type,
            message=self._create_alert_message(match, alert_level),
            recommended_action=action,
            match=match,
        )

    def _is_expected_phi(self, match: PHIMatch) -> bool:
        """Check if PHI matches current patient context."""
        if not self._patient_context:
            return False

        value_lower = match.value.lower()

        if match.phi_type == PHIType.NAME:
            for known_name in self._patient_context.known_names:
                if known_name.lower() in value_lower or value_lower in known_name.lower():
                    return True

        elif match.phi_type == PHIType.MRN:
            if self._patient_context.known_mrn:
                mrn_digits = re.sub(r"\D", "", match.value)
                known_digits = re.sub(r"\D", "", self._patient_context.known_mrn)
                if mrn_digits == known_digits:
                    return True

        elif match.phi_type == PHIType.DOB:
            if self._patient_context.known_dob:
                if self._patient_context.known_dob in match.value:
                    return True

        return False

    def _determine_alert_level(self, match: PHIMatch) -> PHIAlertLevel:
        """Determine alert level based on PHI type and confidence."""
        # Critical PHI types
        if match.phi_type in (PHIType.SSN, PHIType.MRN) and match.confidence > 0.8:
            return PHIAlertLevel.CRITICAL

        # High confidence matches
        if match.confidence > 0.85:
            return PHIAlertLevel.WARNING

        # Lower confidence
        return PHIAlertLevel.INFO

    def _determine_action(self, match: PHIMatch, alert_level: PHIAlertLevel) -> PHIAction:
        """Determine recommended action based on alert level."""
        if alert_level == PHIAlertLevel.CRITICAL:
            return PHIAction.ALERT
        elif alert_level == PHIAlertLevel.WARNING:
            return PHIAction.MASK
        else:
            return PHIAction.ALLOW

    def _create_alert_message(self, match: PHIMatch, alert_level: PHIAlertLevel) -> str:
        """Create a human-readable alert message."""
        phi_type_name = match.phi_type.value.replace("_", " ").title()

        if alert_level == PHIAlertLevel.CRITICAL:
            return f"CRITICAL: Unexpected {phi_type_name} detected. Verify patient context."
        elif alert_level == PHIAlertLevel.WARNING:
            return f"Warning: Potential {phi_type_name} detected. Please verify."
        else:
            return f"Info: Possible {phi_type_name} detected (low confidence)."

    def _sanitize_text(self, text: str, matches: List[PHIMatch]) -> str:
        """Create a sanitized version of text with PHI masked."""
        if not matches:
            return text

        # Sort matches by position (reverse order to preserve positions)
        sorted_matches = sorted(matches, key=lambda m: m.start_pos, reverse=True)

        sanitized = text
        for match in sorted_matches:
            sanitized = sanitized[: match.start_pos] + match.masked_value + sanitized[match.end_pos :]

        return sanitized

    def get_phi_summary(self, result: PHIScanResult) -> Dict[str, Any]:
        """Get a summary of PHI detection results."""
        phi_by_type: Dict[str, int] = {}
        for match in result.matches:
            phi_type = match.phi_type.value
            phi_by_type[phi_type] = phi_by_type.get(phi_type, 0) + 1

        alert_by_level: Dict[str, int] = {}
        for alert in result.alerts:
            level = alert.alert_level.value
            alert_by_level[level] = alert_by_level.get(level, 0) + 1

        return {
            "total_phi_detected": result.phi_count,
            "has_critical_phi": result.has_critical_phi,
            "phi_by_type": phi_by_type,
            "alert_by_level": alert_by_level,
            "scan_timestamp": result.scan_timestamp.isoformat(),
        }


# Global service instance
dictation_phi_monitor = DictationPHIMonitor()
