{
  "path": "packages/api-client/src/retry.ts",
  "language": "typescript",
  "size": 2574,
  "last_modified": "2025-11-23T21:33:23.535Z",
  "lines": 107,
  "content": "/**\n * Retry Logic Utility\n * Implements exponential backoff for failed API calls\n */\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number; // milliseconds\n  maxDelay: number; // milliseconds\n  retryableStatuses: number[];\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 10000, // 10 seconds\n  retryableStatuses: [408, 429, 500, 502, 503, 504],\n};\n\n/**\n * Sleep for a given number of milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Calculate exponential backoff delay\n */\nfunction calculateDelay(attempt: number, config: RetryConfig): number {\n  const exponentialDelay = config.baseDelay * Math.pow(2, attempt);\n  const jitter = Math.random() * 0.1 * exponentialDelay; // Add 10% jitter\n  return Math.min(exponentialDelay + jitter, config.maxDelay);\n}\n\n/**\n * Check if an error is retryable\n */\nfunction isRetryableError(error: any, config: RetryConfig): boolean {\n  // Network errors (no response)\n  if (!error.response) {\n    return true;\n  }\n\n  // Specific HTTP status codes\n  if (config.retryableStatuses.includes(error.response.status)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Retry a function with exponential backoff\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  config: Partial<RetryConfig> = {},\n  onRetry?: (attempt: number, error: any) => void,\n): Promise<T> {\n  const finalConfig = { ...DEFAULT_RETRY_CONFIG, ...config };\n  let lastError: any;\n\n  for (let attempt = 0; attempt <= finalConfig.maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry if it's not a retryable error\n      if (!isRetryableError(error, finalConfig)) {\n        throw error;\n      }\n\n      // Don't retry if we've exhausted all attempts\n      if (attempt === finalConfig.maxRetries) {\n        throw error;\n      }\n\n      // Calculate delay and wait\n      const delay = calculateDelay(attempt, finalConfig);\n\n      // Notify caller of retry attempt\n      if (onRetry) {\n        onRetry(attempt + 1, error);\n      }\n\n      await sleep(delay);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Create a retry wrapper for a function\n */\nexport function createRetryWrapper<T extends any[], R>(\n  fn: (...args: T) => Promise<R>,\n  config?: Partial<RetryConfig>,\n  onRetry?: (attempt: number, error: any) => void,\n): (...args: T) => Promise<R> {\n  return (...args: T) => {\n    return withRetry(() => fn(...args), config, onRetry);\n  };\n}\n"
}
