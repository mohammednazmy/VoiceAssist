{
  "path": "services/api-gateway/app/api/admin_attachments.py",
  "language": "python",
  "size": 25602,
  "last_modified": "2025-12-04T11:26:45.523Z",
  "lines": 786,
  "content": "\"\"\"Admin Attachments API endpoints.\n\nProvides comprehensive attachment management for the Admin Panel:\n- List all attachments across users with filtering\n- View attachment details and metadata\n- Storage statistics and analytics\n- Bulk operations for cleanup\n- File type and size analytics\n\nSecurity: All admin access to attachments is audit logged.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional\nfrom uuid import UUID\n\nfrom app.core.api_envelope import error_response, success_response\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_admin_user\nfrom app.models.attachment import MessageAttachment\nfrom app.models.message import Message\nfrom app.models.session import Session\nfrom app.models.user import User\nfrom app.services.audit_service import AuditService\nfrom app.services.storage_service import get_storage_service\nfrom fastapi import APIRouter, Depends, Query, Request\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import desc, func\nfrom sqlalchemy.orm import Session as DBSession\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/attachments\", tags=[\"admin\", \"attachments\"])\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass AttachmentInfo(BaseModel):\n    \"\"\"Attachment information for admin view.\"\"\"\n\n    id: str\n    message_id: str\n    session_id: Optional[str] = None\n    user_id: Optional[str] = None\n    user_email: Optional[str] = None\n    file_name: str\n    file_type: str\n    file_size: int\n    file_size_formatted: str\n    file_url: str\n    mime_type: Optional[str] = None\n    file_metadata: Optional[Dict[str, Any]] = None\n    uploaded_at: str\n    created_at: str\n\n\nclass AttachmentStats(BaseModel):\n    \"\"\"Attachment storage statistics.\"\"\"\n\n    total_attachments: int = 0\n    total_storage_bytes: int = 0\n    total_storage_formatted: str = \"0 B\"\n    by_file_type: Dict[str, int] = {}\n    by_mime_type: Dict[str, int] = {}\n    size_by_file_type: Dict[str, int] = {}\n    uploads_today: int = 0\n    uploads_this_week: int = 0\n    uploads_this_month: int = 0\n    by_day: List[Dict[str, Any]] = []\n    largest_files: List[Dict[str, Any]] = []\n    top_uploaders: List[Dict[str, Any]] = []\n\n\nclass BulkDeleteRequest(BaseModel):\n    \"\"\"Request for bulk deletion of attachments.\"\"\"\n\n    attachment_ids: List[str] = Field(..., min_length=1, max_length=100)\n    delete_files: bool = True  # Also delete from storage\n\n\nclass BulkDeleteResult(BaseModel):\n    \"\"\"Result of bulk deletion.\"\"\"\n\n    deleted_count: int\n    failed_count: int\n    errors: List[str] = []\n    storage_freed_bytes: int = 0\n    storage_freed_formatted: str = \"0 B\"\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\n\ndef format_file_size(size_bytes: int) -> str:\n    \"\"\"Format file size in human readable format.\"\"\"\n    if size_bytes < 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes < 1024 * 1024:\n        return f\"{size_bytes / 1024:.1f} KB\"\n    elif size_bytes < 1024 * 1024 * 1024:\n        return f\"{size_bytes / (1024 * 1024):.1f} MB\"\n    else:\n        return f\"{size_bytes / (1024 * 1024 * 1024):.2f} GB\"\n\n\ndef attachment_to_info(\n    attachment: MessageAttachment,\n    session: Optional[Session] = None,\n    user: Optional[User] = None,\n) -> AttachmentInfo:\n    \"\"\"Convert attachment to admin info view.\"\"\"\n    return AttachmentInfo(\n        id=str(attachment.id),\n        message_id=str(attachment.message_id),\n        session_id=str(session.id) if session else None,\n        user_id=str(user.id) if user else None,\n        user_email=user.email if user else None,\n        file_name=attachment.file_name,\n        file_type=attachment.file_type,\n        file_size=attachment.file_size,\n        file_size_formatted=format_file_size(attachment.file_size),\n        file_url=attachment.file_url,\n        mime_type=attachment.mime_type,\n        file_metadata=attachment.file_metadata,\n        uploaded_at=(attachment.uploaded_at.isoformat() if attachment.uploaded_at else \"\"),\n        created_at=attachment.created_at.isoformat() if attachment.created_at else \"\",\n    )\n\n\nasync def log_admin_attachment_access(\n    db: DBSession,\n    admin_user: User,\n    action: str,\n    resource_id: Optional[str] = None,\n    request: Optional[Request] = None,\n    details: Optional[Dict] = None,\n) -> None:\n    \"\"\"Log admin attachment access for audit.\"\"\"\n    try:\n        await AuditService.log_event(\n            db=db,\n            action=f\"admin_attachment_{action}\",\n            success=True,\n            user=admin_user,\n            resource_type=\"attachment\",\n            resource_id=resource_id,\n            request=request,\n            metadata=details,\n        )\n    except Exception as e:\n        logger.error(f\"Failed to log attachment access: {e}\")\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"\")\nasync def list_attachments(\n    limit: int = Query(50, ge=1, le=200),\n    offset: int = Query(0, ge=0),\n    user_id: Optional[str] = Query(None, description=\"Filter by user ID\"),\n    session_id: Optional[str] = Query(None, description=\"Filter by session ID\"),\n    file_type: Optional[str] = Query(None, description=\"Filter by file type (pdf, image, etc)\"),\n    mime_type: Optional[str] = Query(None, description=\"Filter by MIME type\"),\n    min_size: Optional[int] = Query(None, description=\"Minimum file size in bytes\"),\n    max_size: Optional[int] = Query(None, description=\"Maximum file size in bytes\"),\n    uploaded_since: Optional[str] = Query(None, description=\"Filter by upload date (ISO format)\"),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"List all attachments with filtering options.\n\n    Provides comprehensive view of all uploaded files across users.\n    \"\"\"\n    try:\n        # Build query with joins\n        query = (\n            db.query(MessageAttachment, Message, Session, User)\n            .join(Message, MessageAttachment.message_id == Message.id)\n            .outerjoin(Session, Message.session_id == Session.id)\n            .outerjoin(User, Session.user_id == User.id)\n        )\n\n        # Apply filters\n        if user_id:\n            try:\n                query = query.filter(User.id == UUID(user_id))\n            except ValueError:\n                return error_response(\n                    code=\"INVALID_USER_ID\",\n                    message=\"Invalid user ID format\",\n                    status_code=400,\n                )\n\n        if session_id:\n            try:\n                query = query.filter(Session.id == UUID(session_id))\n            except ValueError:\n                return error_response(\n                    code=\"INVALID_SESSION_ID\",\n                    message=\"Invalid session ID format\",\n                    status_code=400,\n                )\n\n        if file_type:\n            query = query.filter(MessageAttachment.file_type == file_type)\n\n        if mime_type:\n            query = query.filter(MessageAttachment.mime_type.ilike(f\"%{mime_type}%\"))\n\n        if min_size is not None:\n            query = query.filter(MessageAttachment.file_size >= min_size)\n\n        if max_size is not None:\n            query = query.filter(MessageAttachment.file_size <= max_size)\n\n        if uploaded_since:\n            try:\n                since_date = datetime.fromisoformat(uploaded_since.replace(\"Z\", \"+00:00\"))\n                query = query.filter(MessageAttachment.uploaded_at >= since_date)\n            except ValueError:\n                return error_response(\n                    code=\"INVALID_DATE\",\n                    message=\"Invalid date format. Use ISO format.\",\n                    status_code=400,\n                )\n\n        # Get total count\n        total = query.count()\n\n        # Get paginated results\n        results = query.order_by(desc(MessageAttachment.uploaded_at)).offset(offset).limit(limit).all()\n\n        # Convert to info objects\n        attachments = [\n            attachment_to_info(attachment, session, user).model_dump() for attachment, message, session, user in results\n        ]\n\n        # Log access\n        await log_admin_attachment_access(\n            db=db,\n            admin_user=admin_user,\n            action=\"list\",\n            request=request,\n            details={\n                \"count\": len(attachments),\n                \"filters\": {\"user_id\": user_id, \"file_type\": file_type},\n            },\n        )\n\n        return success_response(\n            data={\n                \"attachments\": attachments,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to list attachments: {e}\")\n        return error_response(\n            code=\"LIST_ERROR\",\n            message=\"Failed to list attachments\",\n            status_code=500,\n        )\n\n\n@router.get(\"/stats\")\nasync def get_attachment_stats(\n    days: int = Query(30, ge=1, le=365),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Get attachment storage statistics and analytics.\n\n    Returns comprehensive storage metrics without exposing file content.\n    \"\"\"\n    try:\n        stats = AttachmentStats()\n\n        # Total counts and storage\n        totals = db.query(\n            func.count(MessageAttachment.id).label(\"count\"),\n            func.sum(MessageAttachment.file_size).label(\"total_size\"),\n        ).first()\n\n        stats.total_attachments = totals.count or 0\n        stats.total_storage_bytes = int(totals.total_size or 0)\n        stats.total_storage_formatted = format_file_size(stats.total_storage_bytes)\n\n        # By file type\n        type_counts = (\n            db.query(\n                MessageAttachment.file_type,\n                func.count(MessageAttachment.id).label(\"count\"),\n                func.sum(MessageAttachment.file_size).label(\"total_size\"),\n            )\n            .group_by(MessageAttachment.file_type)\n            .all()\n        )\n\n        stats.by_file_type = {row.file_type: row.count for row in type_counts if row.file_type}\n        stats.size_by_file_type = {row.file_type: int(row.total_size or 0) for row in type_counts if row.file_type}\n\n        # By MIME type\n        mime_counts = (\n            db.query(\n                MessageAttachment.mime_type,\n                func.count(MessageAttachment.id).label(\"count\"),\n            )\n            .group_by(MessageAttachment.mime_type)\n            .all()\n        )\n\n        stats.by_mime_type = {row.mime_type: row.count for row in mime_counts if row.mime_type}\n\n        # Time-based stats\n        now = datetime.now(timezone.utc)\n        today = now.replace(hour=0, minute=0, second=0, microsecond=0)\n        week_ago = today - timedelta(days=7)\n        month_ago = today - timedelta(days=30)\n\n        stats.uploads_today = db.query(MessageAttachment).filter(MessageAttachment.uploaded_at >= today).count()\n\n        stats.uploads_this_week = db.query(MessageAttachment).filter(MessageAttachment.uploaded_at >= week_ago).count()\n\n        stats.uploads_this_month = (\n            db.query(MessageAttachment).filter(MessageAttachment.uploaded_at >= month_ago).count()\n        )\n\n        # Daily breakdown\n        for i in range(days):\n            day_start = today - timedelta(days=i)\n            day_end = day_start + timedelta(days=1)\n\n            day_stats = (\n                db.query(\n                    func.count(MessageAttachment.id).label(\"count\"),\n                    func.sum(MessageAttachment.file_size).label(\"total_size\"),\n                )\n                .filter(\n                    MessageAttachment.uploaded_at >= day_start,\n                    MessageAttachment.uploaded_at < day_end,\n                )\n                .first()\n            )\n\n            stats.by_day.append(\n                {\n                    \"date\": day_start.strftime(\"%Y-%m-%d\"),\n                    \"count\": day_stats.count or 0,\n                    \"total_size\": int(day_stats.total_size or 0),\n                    \"total_size_formatted\": format_file_size(int(day_stats.total_size or 0)),\n                }\n            )\n\n        stats.by_day.sort(key=lambda x: x[\"date\"])\n\n        # Largest files\n        largest = db.query(MessageAttachment).order_by(desc(MessageAttachment.file_size)).limit(10).all()\n\n        stats.largest_files = [\n            {\n                \"id\": str(a.id),\n                \"file_name\": a.file_name,\n                \"file_size\": a.file_size,\n                \"file_size_formatted\": format_file_size(a.file_size),\n                \"file_type\": a.file_type,\n                \"uploaded_at\": a.uploaded_at.isoformat() if a.uploaded_at else \"\",\n            }\n            for a in largest\n        ]\n\n        # Top uploaders (by count)\n        top_uploaders_query = (\n            db.query(\n                User.id,\n                User.email,\n                func.count(MessageAttachment.id).label(\"upload_count\"),\n                func.sum(MessageAttachment.file_size).label(\"total_size\"),\n            )\n            .join(Session, Session.user_id == User.id)\n            .join(Message, Message.session_id == Session.id)\n            .join(MessageAttachment, MessageAttachment.message_id == Message.id)\n            .group_by(User.id, User.email)\n            .order_by(desc(func.count(MessageAttachment.id)))\n            .limit(10)\n            .all()\n        )\n\n        stats.top_uploaders = [\n            {\n                \"user_id\": str(row.id),\n                \"user_email\": row.email,\n                \"upload_count\": row.upload_count,\n                \"total_size\": int(row.total_size or 0),\n                \"total_size_formatted\": format_file_size(int(row.total_size or 0)),\n            }\n            for row in top_uploaders_query\n        ]\n\n        return success_response(data=stats.model_dump())\n\n    except Exception as e:\n        logger.error(f\"Failed to get attachment stats: {e}\")\n        return error_response(\n            code=\"STATS_ERROR\",\n            message=\"Failed to retrieve statistics\",\n            status_code=500,\n        )\n\n\n@router.get(\"/{attachment_id}\")\nasync def get_attachment(\n    attachment_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Get details of a specific attachment.\"\"\"\n    try:\n        attachment_uuid = UUID(attachment_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid attachment ID format\",\n            status_code=400,\n        )\n\n    # Query with joins\n    result = (\n        db.query(MessageAttachment, Message, Session, User)\n        .join(Message, MessageAttachment.message_id == Message.id)\n        .outerjoin(Session, Message.session_id == Session.id)\n        .outerjoin(User, Session.user_id == User.id)\n        .filter(MessageAttachment.id == attachment_uuid)\n        .first()\n    )\n\n    if not result:\n        return error_response(\n            code=\"NOT_FOUND\",\n            message=\"Attachment not found\",\n            status_code=404,\n        )\n\n    attachment, message, session, user = result\n    info = attachment_to_info(attachment, session, user)\n\n    # Log access\n    await log_admin_attachment_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"view\",\n        resource_id=attachment_id,\n        request=request,\n    )\n\n    return success_response(data=info.model_dump())\n\n\n@router.delete(\"/{attachment_id}\")\nasync def delete_attachment(\n    attachment_id: str,\n    delete_file: bool = Query(True, description=\"Also delete file from storage\"),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Delete an attachment.\n\n    Optionally deletes the file from storage as well.\n    \"\"\"\n    try:\n        attachment_uuid = UUID(attachment_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid attachment ID format\",\n            status_code=400,\n        )\n\n    attachment = db.query(MessageAttachment).filter(MessageAttachment.id == attachment_uuid).first()\n\n    if not attachment:\n        return error_response(\n            code=\"NOT_FOUND\",\n            message=\"Attachment not found\",\n            status_code=404,\n        )\n\n    file_size = attachment.file_size\n    file_url = attachment.file_url\n\n    # Delete from storage if requested\n    storage_deleted = False\n    if delete_file:\n        try:\n            storage_service = get_storage_service()\n            await storage_service.delete_file(file_url)\n            storage_deleted = True\n        except Exception as e:\n            logger.warning(f\"Failed to delete file from storage: {e}\")\n\n    # Delete database record\n    db.delete(attachment)\n    db.commit()\n\n    # Log deletion\n    await log_admin_attachment_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"delete\",\n        resource_id=attachment_id,\n        request=request,\n        details={\n            \"file_size\": file_size,\n            \"storage_deleted\": storage_deleted,\n        },\n    )\n\n    logger.info(f\"Attachment {attachment_id} deleted by admin {admin_user.email}\")\n\n    return success_response(\n        data={\n            \"deleted\": True,\n            \"attachment_id\": attachment_id,\n            \"storage_deleted\": storage_deleted,\n            \"storage_freed\": file_size if storage_deleted else 0,\n            \"storage_freed_formatted\": (format_file_size(file_size) if storage_deleted else \"0 B\"),\n        },\n        message=\"Attachment deleted successfully\",\n    )\n\n\n@router.post(\"/bulk-delete\")\nasync def bulk_delete_attachments(\n    request_body: BulkDeleteRequest,\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Bulk delete multiple attachments.\n\n    Useful for storage cleanup operations.\n    \"\"\"\n    result = BulkDeleteResult(\n        deleted_count=0,\n        failed_count=0,\n        errors=[],\n        storage_freed_bytes=0,\n    )\n\n    storage_service = get_storage_service() if request_body.delete_files else None\n\n    for attachment_id in request_body.attachment_ids:\n        try:\n            attachment_uuid = UUID(attachment_id)\n            attachment = db.query(MessageAttachment).filter(MessageAttachment.id == attachment_uuid).first()\n\n            if not attachment:\n                result.failed_count += 1\n                result.errors.append(f\"Attachment {attachment_id} not found\")\n                continue\n\n            file_size = attachment.file_size\n\n            # Delete from storage if requested\n            if storage_service:\n                try:\n                    await storage_service.delete_file(attachment.file_url)\n                    result.storage_freed_bytes += file_size\n                except Exception as e:\n                    logger.warning(f\"Failed to delete file {attachment_id} from storage: {e}\")\n\n            # Delete database record\n            db.delete(attachment)\n            result.deleted_count += 1\n\n        except ValueError:\n            result.failed_count += 1\n            result.errors.append(f\"Invalid attachment ID: {attachment_id}\")\n        except Exception as e:\n            result.failed_count += 1\n            result.errors.append(f\"Error deleting {attachment_id}: {str(e)}\")\n\n    # Commit all deletions\n    db.commit()\n\n    result.storage_freed_formatted = format_file_size(result.storage_freed_bytes)\n\n    # Log bulk deletion\n    await log_admin_attachment_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"bulk_delete\",\n        request=request,\n        details={\n            \"deleted_count\": result.deleted_count,\n            \"failed_count\": result.failed_count,\n            \"storage_freed\": result.storage_freed_bytes,\n        },\n    )\n\n    logger.info(\n        f\"Bulk delete by admin {admin_user.email}: \" f\"{result.deleted_count} deleted, {result.failed_count} failed\"\n    )\n\n    return success_response(data=result.model_dump())\n\n\n@router.get(\"/users/{user_id}/attachments\")\nasync def get_user_attachments(\n    user_id: str,\n    limit: int = Query(50, ge=1, le=200),\n    offset: int = Query(0, ge=0),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Get all attachments uploaded by a specific user.\"\"\"\n    try:\n        user_uuid = UUID(user_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid user ID format\",\n            status_code=400,\n        )\n\n    # Verify user exists\n    user = db.query(User).filter(User.id == user_uuid).first()\n    if not user:\n        return error_response(\n            code=\"USER_NOT_FOUND\",\n            message=\"User not found\",\n            status_code=404,\n        )\n\n    # Query attachments for this user\n    query = (\n        db.query(MessageAttachment, Message, Session)\n        .join(Message, MessageAttachment.message_id == Message.id)\n        .join(Session, Message.session_id == Session.id)\n        .filter(Session.user_id == user_uuid)\n    )\n\n    total = query.count()\n\n    results = query.order_by(desc(MessageAttachment.uploaded_at)).offset(offset).limit(limit).all()\n\n    attachments = [\n        attachment_to_info(attachment, session, user).model_dump() for attachment, message, session in results\n    ]\n\n    # Calculate user storage usage\n    storage_usage = (\n        db.query(func.sum(MessageAttachment.file_size))\n        .join(Message, MessageAttachment.message_id == Message.id)\n        .join(Session, Message.session_id == Session.id)\n        .filter(Session.user_id == user_uuid)\n        .scalar()\n        or 0\n    )\n\n    # Log access\n    await log_admin_attachment_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"list_user_attachments\",\n        resource_id=user_id,\n        request=request,\n        details={\"attachment_count\": len(attachments)},\n    )\n\n    return success_response(\n        data={\n            \"user_id\": user_id,\n            \"user_email\": user.email,\n            \"attachments\": attachments,\n            \"total\": total,\n            \"limit\": limit,\n            \"offset\": offset,\n            \"storage_usage_bytes\": storage_usage,\n            \"storage_usage_formatted\": format_file_size(storage_usage),\n        }\n    )\n\n\n@router.post(\"/cleanup/orphaned\")\nasync def cleanup_orphaned_attachments(\n    dry_run: bool = Query(True, description=\"Only report what would be deleted\"),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Find and optionally delete orphaned attachments.\n\n    Orphaned attachments are those whose parent message no longer exists.\n    \"\"\"\n    # Find orphaned attachments (message_id points to non-existent message)\n    orphaned = (\n        db.query(MessageAttachment)\n        .outerjoin(Message, MessageAttachment.message_id == Message.id)\n        .filter(Message.id.is_(None))\n        .all()\n    )\n\n    orphaned_info = [\n        {\n            \"id\": str(a.id),\n            \"file_name\": a.file_name,\n            \"file_size\": a.file_size,\n            \"file_size_formatted\": format_file_size(a.file_size),\n            \"uploaded_at\": a.uploaded_at.isoformat() if a.uploaded_at else \"\",\n        }\n        for a in orphaned\n    ]\n\n    total_size = sum(a.file_size for a in orphaned)\n\n    if dry_run:\n        return success_response(\n            data={\n                \"dry_run\": True,\n                \"orphaned_count\": len(orphaned),\n                \"orphaned_size_bytes\": total_size,\n                \"orphaned_size_formatted\": format_file_size(total_size),\n                \"orphaned_attachments\": orphaned_info,\n            },\n            message=f\"Found {len(orphaned)} orphaned attachments. Set dry_run=false to delete.\",\n        )\n\n    # Actually delete\n    storage_service = get_storage_service()\n    deleted_count = 0\n    storage_freed = 0\n\n    for attachment in orphaned:\n        try:\n            await storage_service.delete_file(attachment.file_url)\n            storage_freed += attachment.file_size\n        except Exception as e:\n            logger.warning(f\"Failed to delete orphaned file: {e}\")\n\n        db.delete(attachment)\n        deleted_count += 1\n\n    db.commit()\n\n    # Log cleanup\n    await log_admin_attachment_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"cleanup_orphaned\",\n        request=request,\n        details={\n            \"deleted_count\": deleted_count,\n            \"storage_freed\": storage_freed,\n        },\n    )\n\n    logger.info(f\"Orphaned attachment cleanup by {admin_user.email}: {deleted_count} deleted\")\n\n    return success_response(\n        data={\n            \"dry_run\": False,\n            \"deleted_count\": deleted_count,\n            \"storage_freed_bytes\": storage_freed,\n            \"storage_freed_formatted\": format_file_size(storage_freed),\n        },\n        message=f\"Deleted {deleted_count} orphaned attachments\",\n    )\n"
}
