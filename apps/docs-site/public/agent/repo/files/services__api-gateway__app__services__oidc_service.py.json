{
  "path": "services/api-gateway/app/services/oidc_service.py",
  "language": "python",
  "size": 25096,
  "last_modified": "2025-12-05T03:07:13.134Z",
  "lines": 768,
  "content": "\"\"\"\nOpenID Connect (OIDC) Authentication Service\n\nProvides SSO authentication with Nextcloud and other OIDC providers.\n\nFeatures:\n- Authorization code flow with PKCE\n- ID token validation with JWKS\n- Token refresh handling\n- Session management\n- Multi-provider support (Nextcloud, Google, Microsoft)\n\nSecurity:\n- PKCE for code exchange\n- State parameter for CSRF protection\n- Nonce for replay attack prevention\n- Token encryption at rest\n\"\"\"\n\nimport base64\nimport hashlib\nimport secrets\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom urllib.parse import urlencode\n\nimport httpx\nfrom app.core.config import settings\nfrom app.core.logging import get_logger\nfrom jose import jwt\nfrom jose.exceptions import JWTError\n\nlogger = get_logger(__name__)\n\n\nclass OIDCProvider(str, Enum):\n    \"\"\"Supported OIDC providers.\"\"\"\n\n    NEXTCLOUD = \"nextcloud\"\n    GOOGLE = \"google\"\n    MICROSOFT = \"microsoft\"\n    CUSTOM = \"custom\"\n\n\n@dataclass\nclass OIDCProviderConfig:\n    \"\"\"Configuration for an OIDC provider.\"\"\"\n\n    provider: OIDCProvider\n    issuer: str\n    client_id: str\n    client_secret: str\n    redirect_uri: str\n    scopes: List[str] = field(default_factory=lambda: [\"openid\", \"profile\", \"email\"])\n\n    # Endpoints (auto-discovered or manual)\n    authorization_endpoint: Optional[str] = None\n    token_endpoint: Optional[str] = None\n    userinfo_endpoint: Optional[str] = None\n    jwks_uri: Optional[str] = None\n    end_session_endpoint: Optional[str] = None\n\n    # Provider-specific settings\n    additional_params: Dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass OIDCTokens:\n    \"\"\"OIDC token response.\"\"\"\n\n    access_token: str\n    token_type: str = \"Bearer\"\n    id_token: Optional[str] = None\n    refresh_token: Optional[str] = None\n    expires_in: int = 3600\n    scope: Optional[str] = None\n    issued_at: datetime = field(default_factory=datetime.utcnow)\n\n    @property\n    def expires_at(self) -> datetime:\n        \"\"\"Calculate token expiration time.\"\"\"\n        return self.issued_at + timedelta(seconds=self.expires_in)\n\n    @property\n    def is_expired(self) -> bool:\n        \"\"\"Check if token is expired.\"\"\"\n        return datetime.utcnow() >= self.expires_at\n\n\n@dataclass\nclass OIDCClaims:\n    \"\"\"Standard OIDC ID token claims.\"\"\"\n\n    sub: str  # Subject identifier\n    iss: str  # Issuer\n    aud: str  # Audience\n    exp: int  # Expiration time\n    iat: int  # Issued at\n    nonce: Optional[str] = None\n\n    # Optional standard claims\n    email: Optional[str] = None\n    email_verified: Optional[bool] = None\n    name: Optional[str] = None\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    preferred_username: Optional[str] = None\n    picture: Optional[str] = None\n    locale: Optional[str] = None\n\n    # Provider-specific claims\n    extra_claims: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass NextcloudUser:\n    \"\"\"Nextcloud user info from OCS API.\"\"\"\n\n    id: str\n    display_name: str\n    email: Optional[str] = None\n    groups: List[str] = field(default_factory=list)\n    quota: Optional[Dict[str, Any]] = None\n    phone: Optional[str] = None\n    address: Optional[str] = None\n    website: Optional[str] = None\n    twitter: Optional[str] = None\n    language: Optional[str] = None\n    backend: Optional[str] = None\n    enabled: bool = True\n\n\n@dataclass\nclass AuthorizationRequest:\n    \"\"\"Authorization request parameters.\"\"\"\n\n    state: str\n    nonce: str\n    code_verifier: Optional[str] = None  # For PKCE\n    code_challenge: Optional[str] = None\n    redirect_uri: str = \"\"\n    provider: OIDCProvider = OIDCProvider.NEXTCLOUD\n    created_at: datetime = field(default_factory=datetime.utcnow)\n\n\nclass OIDCService:\n    \"\"\"\n    OpenID Connect authentication service.\n\n    Supports multiple OIDC providers with automatic discovery\n    and secure token handling.\n    \"\"\"\n\n    # Well-known configuration path\n    WELL_KNOWN_PATH = \"/.well-known/openid-configuration\"\n\n    def __init__(self):\n        self.providers: Dict[OIDCProvider, OIDCProviderConfig] = {}\n        self._jwks_cache: Dict[str, Dict] = {}\n        self._jwks_cache_time: Dict[str, datetime] = {}\n        self._discovery_cache: Dict[str, Dict] = {}\n        self._pending_requests: Dict[str, AuthorizationRequest] = {}\n\n    def register_provider(self, config: OIDCProviderConfig) -> None:\n        \"\"\"Register an OIDC provider configuration.\"\"\"\n        self.providers[config.provider] = config\n        logger.info(f\"Registered OIDC provider: {config.provider.value}\")\n\n    def register_nextcloud(\n        self,\n        base_url: str,\n        client_id: str,\n        client_secret: str,\n        redirect_uri: str,\n    ) -> None:\n        \"\"\"Register Nextcloud as OIDC provider with known endpoints.\"\"\"\n        config = OIDCProviderConfig(\n            provider=OIDCProvider.NEXTCLOUD,\n            issuer=base_url,\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=redirect_uri,\n            scopes=[\"openid\", \"profile\", \"email\"],\n            # Nextcloud OAuth2/OIDC endpoints\n            authorization_endpoint=f\"{base_url}/apps/oauth2/authorize\",\n            token_endpoint=f\"{base_url}/apps/oauth2/api/v1/token\",\n            userinfo_endpoint=f\"{base_url}/ocs/v2.php/cloud/user\",\n            jwks_uri=f\"{base_url}/apps/oidc/.well-known/jwks.json\",\n        )\n        self.register_provider(config)\n\n    def register_google(\n        self,\n        client_id: str,\n        client_secret: str,\n        redirect_uri: str,\n    ) -> None:\n        \"\"\"Register Google as OIDC provider.\"\"\"\n        config = OIDCProviderConfig(\n            provider=OIDCProvider.GOOGLE,\n            issuer=\"https://accounts.google.com\",\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=redirect_uri,\n            scopes=[\"openid\", \"profile\", \"email\"],\n            # Google OIDC endpoints\n            authorization_endpoint=\"https://accounts.google.com/o/oauth2/v2/auth\",\n            token_endpoint=\"https://oauth2.googleapis.com/token\",\n            userinfo_endpoint=\"https://openidconnect.googleapis.com/v1/userinfo\",\n            jwks_uri=\"https://www.googleapis.com/oauth2/v3/certs\",\n        )\n        self.register_provider(config)\n\n    def register_microsoft(\n        self,\n        tenant_id: str,\n        client_id: str,\n        client_secret: str,\n        redirect_uri: str,\n    ) -> None:\n        \"\"\"Register Microsoft/Azure AD as OIDC provider.\"\"\"\n        base_url = f\"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0\"\n        config = OIDCProviderConfig(\n            provider=OIDCProvider.MICROSOFT,\n            issuer=f\"https://login.microsoftonline.com/{tenant_id}/v2.0\",\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=redirect_uri,\n            scopes=[\"openid\", \"profile\", \"email\", \"offline_access\"],\n            authorization_endpoint=f\"{base_url}/authorize\",\n            token_endpoint=f\"{base_url}/token\",\n            userinfo_endpoint=\"https://graph.microsoft.com/oidc/userinfo\",\n            jwks_uri=f\"https://login.microsoftonline.com/{tenant_id}/discovery/v2.0/keys\",\n        )\n        self.register_provider(config)\n\n    async def discover_configuration(\n        self,\n        issuer: str,\n    ) -> Dict[str, Any]:\n        \"\"\"Discover OIDC configuration from well-known endpoint.\"\"\"\n        if issuer in self._discovery_cache:\n            return self._discovery_cache[issuer]\n\n        discovery_url = f\"{issuer.rstrip('/')}{self.WELL_KNOWN_PATH}\"\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(discovery_url, timeout=10.0)\n            response.raise_for_status()\n            config = response.json()\n\n        self._discovery_cache[issuer] = config\n        logger.info(f\"Discovered OIDC configuration for {issuer}\")\n        return config\n\n    def generate_state(self) -> str:\n        \"\"\"Generate cryptographically secure state parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def generate_nonce(self) -> str:\n        \"\"\"Generate cryptographically secure nonce.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def generate_pkce(self) -> tuple[str, str]:\n        \"\"\"\n        Generate PKCE code verifier and challenge.\n\n        Returns:\n            Tuple of (code_verifier, code_challenge)\n        \"\"\"\n        # Generate random 43-128 character verifier\n        code_verifier = secrets.token_urlsafe(64)\n\n        # SHA256 hash and base64url encode for challenge (RFC 7636)\n        digest = hashlib.sha256(code_verifier.encode()).digest()\n        code_challenge = base64.urlsafe_b64encode(digest).rstrip(b\"=\").decode()\n\n        return code_verifier, code_challenge\n\n    def create_authorization_request(\n        self,\n        provider: OIDCProvider = OIDCProvider.NEXTCLOUD,\n        use_pkce: bool = True,\n    ) -> AuthorizationRequest:\n        \"\"\"Create a new authorization request with security parameters.\"\"\"\n        code_verifier = None\n        code_challenge = None\n\n        if use_pkce:\n            code_verifier, code_challenge = self.generate_pkce()\n\n        config = self.providers.get(provider)\n        redirect_uri = config.redirect_uri if config else \"\"\n        auth_request = AuthorizationRequest(\n            state=self.generate_state(),\n            nonce=self.generate_nonce(),\n            code_verifier=code_verifier,\n            code_challenge=code_challenge,\n            redirect_uri=redirect_uri,\n            provider=provider,\n        )\n\n        # Track pending request for CSRF protection and nonce validation\n        self._pending_requests[auth_request.state] = auth_request\n        self._cleanup_expired_requests()\n\n        return auth_request\n\n    async def get_authorization_url(\n        self,\n        auth_request: AuthorizationRequest,\n    ) -> str:\n        \"\"\"\n        Generate authorization URL for redirect.\n\n        Args:\n            auth_request: Authorization request parameters\n\n        Returns:\n            Full authorization URL for redirect\n        \"\"\"\n        config = self.providers.get(auth_request.provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {auth_request.provider}\")\n\n        # Ensure the state/nonce pair matches a pending request\n        pending = self._pending_requests.get(auth_request.state)\n        if not pending or pending.nonce != auth_request.nonce:\n            raise ValueError(\"Authorization request missing or has expired\")\n\n        params = {\n            \"response_type\": \"code\",\n            \"client_id\": config.client_id,\n            \"redirect_uri\": config.redirect_uri,\n            \"scope\": \" \".join(config.scopes),\n            \"state\": auth_request.state,\n            \"nonce\": auth_request.nonce,\n        }\n\n        # Add PKCE challenge if available\n        if auth_request.code_challenge:\n            params[\"code_challenge\"] = auth_request.code_challenge\n            params[\"code_challenge_method\"] = \"S256\"\n\n        # Add provider-specific parameters\n        params.update(config.additional_params)\n\n        endpoint = config.authorization_endpoint\n        if not endpoint:\n            discovery = await self.discover_configuration(config.issuer)\n            endpoint = discovery[\"authorization_endpoint\"]\n\n        return f\"{endpoint}?{urlencode(params)}\"\n\n    async def exchange_code(\n        self,\n        code: str,\n        auth_request: AuthorizationRequest,\n    ) -> OIDCTokens:\n        \"\"\"\n        Exchange authorization code for tokens.\n\n        Args:\n            code: Authorization code from callback\n            auth_request: Original authorization request\n\n        Returns:\n            OIDCTokens with access_token, id_token, etc.\n        \"\"\"\n        config = self.providers.get(auth_request.provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {auth_request.provider}\")\n\n        data = {\n            \"grant_type\": \"authorization_code\",\n            \"code\": code,\n            \"redirect_uri\": config.redirect_uri,\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n        }\n\n        # Add PKCE verifier if used\n        if auth_request.code_verifier:\n            data[\"code_verifier\"] = auth_request.code_verifier\n\n        endpoint = config.token_endpoint\n        if not endpoint:\n            discovery = await self.discover_configuration(config.issuer)\n            endpoint = discovery[\"token_endpoint\"]\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                endpoint,\n                data=data,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n            token_data = response.json()\n\n        return OIDCTokens(\n            access_token=token_data[\"access_token\"],\n            token_type=token_data.get(\"token_type\", \"Bearer\"),\n            id_token=token_data.get(\"id_token\"),\n            refresh_token=token_data.get(\"refresh_token\"),\n            expires_in=token_data.get(\"expires_in\", 3600),\n            scope=token_data.get(\"scope\"),\n        )\n\n    def _cleanup_expired_requests(self) -> None:\n        \"\"\"Remove stale authorization requests (older than 15 minutes).\"\"\"\n        cutoff = datetime.utcnow() - timedelta(minutes=15)\n        expired = [state for state, req in self._pending_requests.items() if req.created_at < cutoff]\n        for state in expired:\n            self._pending_requests.pop(state, None)\n\n    def pop_pending_request(self, state: str) -> Optional[AuthorizationRequest]:\n        \"\"\"Retrieve and remove a pending authorization request by state.\"\"\"\n        self._cleanup_expired_requests()\n        return self._pending_requests.pop(state, None)\n\n    async def complete_authorization_flow(\n        self, code: str, state: str, expected_nonce: Optional[str] = None\n    ) -> tuple[OIDCTokens, Optional[OIDCClaims]]:\n        \"\"\"Helper to validate state/nonce and exchange an authorization code.\"\"\"\n\n        auth_request = self.pop_pending_request(state)\n        if not auth_request:\n            raise ValueError(\"Unknown or expired state\")\n\n        tokens = await self.exchange_code(code, auth_request)\n\n        claims: Optional[OIDCClaims] = None\n        if tokens.id_token:\n            nonce = expected_nonce or auth_request.nonce\n            claims = await self.validate_id_token(tokens.id_token, nonce, auth_request.provider)\n\n        return tokens, claims\n\n    async def refresh_tokens(\n        self,\n        refresh_token: str,\n        provider: OIDCProvider = OIDCProvider.NEXTCLOUD,\n    ) -> OIDCTokens:\n        \"\"\"\n        Refresh access token using refresh token.\n\n        Args:\n            refresh_token: Refresh token\n            provider: OIDC provider\n\n        Returns:\n            New OIDCTokens\n        \"\"\"\n        config = self.providers.get(provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {provider}\")\n\n        data = {\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": refresh_token,\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n        }\n\n        endpoint = config.token_endpoint\n        if not endpoint:\n            discovery = await self.discover_configuration(config.issuer)\n            endpoint = discovery[\"token_endpoint\"]\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                endpoint,\n                data=data,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n            token_data = response.json()\n\n        return OIDCTokens(\n            access_token=token_data[\"access_token\"],\n            token_type=token_data.get(\"token_type\", \"Bearer\"),\n            id_token=token_data.get(\"id_token\"),\n            refresh_token=token_data.get(\"refresh_token\", refresh_token),\n            expires_in=token_data.get(\"expires_in\", 3600),\n            scope=token_data.get(\"scope\"),\n        )\n\n    async def _get_jwks(self, provider: OIDCProvider) -> Dict:\n        \"\"\"Fetch and cache JWKS for provider.\"\"\"\n        config = self.providers.get(provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {provider}\")\n\n        cache_key = config.issuer\n\n        # Check cache (valid for 1 hour)\n        if cache_key in self._jwks_cache:\n            cache_time = self._jwks_cache_time.get(cache_key)\n            if cache_time and datetime.utcnow() - cache_time < timedelta(hours=1):\n                return self._jwks_cache[cache_key]\n\n        jwks_uri = config.jwks_uri\n        if not jwks_uri:\n            discovery = await self.discover_configuration(config.issuer)\n            jwks_uri = discovery[\"jwks_uri\"]\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(jwks_uri, timeout=10.0)\n            response.raise_for_status()\n            jwks = response.json()\n\n        self._jwks_cache[cache_key] = jwks\n        self._jwks_cache_time[cache_key] = datetime.utcnow()\n\n        return jwks\n\n    async def validate_id_token(\n        self,\n        id_token: str,\n        nonce: str,\n        provider: OIDCProvider = OIDCProvider.NEXTCLOUD,\n    ) -> OIDCClaims:\n        \"\"\"\n        Validate and decode ID token.\n\n        Args:\n            id_token: JWT ID token\n            nonce: Expected nonce value\n            provider: OIDC provider\n\n        Returns:\n            Validated OIDCClaims\n\n        Raises:\n            ValueError: If token is invalid\n        \"\"\"\n        config = self.providers.get(provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {provider}\")\n\n        # Get JWKS\n        jwks = await self._get_jwks(provider)\n\n        try:\n            # Decode and validate\n            claims = jwt.decode(\n                id_token,\n                jwks,\n                algorithms=[\"RS256\", \"ES256\"],\n                audience=config.client_id,\n                issuer=config.issuer,\n            )\n        except JWTError as e:\n            logger.error(f\"ID token validation failed: {e}\")\n            raise ValueError(f\"Invalid ID token: {e}\")\n\n        # Verify nonce\n        if claims.get(\"nonce\") != nonce:\n            raise ValueError(\"Invalid nonce - possible replay attack\")\n\n        return OIDCClaims(\n            sub=claims[\"sub\"],\n            iss=claims[\"iss\"],\n            aud=claims[\"aud\"] if isinstance(claims[\"aud\"], str) else claims[\"aud\"][0],\n            exp=claims[\"exp\"],\n            iat=claims[\"iat\"],\n            nonce=claims.get(\"nonce\"),\n            email=claims.get(\"email\"),\n            email_verified=claims.get(\"email_verified\"),\n            name=claims.get(\"name\"),\n            given_name=claims.get(\"given_name\"),\n            family_name=claims.get(\"family_name\"),\n            preferred_username=claims.get(\"preferred_username\"),\n            picture=claims.get(\"picture\"),\n            locale=claims.get(\"locale\"),\n            extra_claims={\n                k: v\n                for k, v in claims.items()\n                if k\n                not in [\n                    \"sub\",\n                    \"iss\",\n                    \"aud\",\n                    \"exp\",\n                    \"iat\",\n                    \"nonce\",\n                    \"email\",\n                    \"email_verified\",\n                    \"name\",\n                    \"given_name\",\n                    \"family_name\",\n                    \"preferred_username\",\n                    \"picture\",\n                    \"locale\",\n                ]\n            },\n        )\n\n    async def get_user_info(\n        self,\n        access_token: str,\n        provider: OIDCProvider = OIDCProvider.NEXTCLOUD,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get user info from provider's userinfo endpoint.\n\n        Args:\n            access_token: Valid access token\n            provider: OIDC provider\n\n        Returns:\n            User info dictionary\n        \"\"\"\n        config = self.providers.get(provider)\n        if not config:\n            raise ValueError(f\"Provider not registered: {provider}\")\n\n        endpoint = config.userinfo_endpoint\n        if not endpoint:\n            discovery = await self.discover_configuration(config.issuer)\n            endpoint = discovery[\"userinfo_endpoint\"]\n\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n        # Nextcloud requires OCS-APIRequest header\n        if provider == OIDCProvider.NEXTCLOUD:\n            headers[\"OCS-APIRequest\"] = \"true\"\n            headers[\"Accept\"] = \"application/json\"\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                endpoint,\n                headers=headers,\n                timeout=10.0,\n            )\n            response.raise_for_status()\n            return response.json()\n\n    async def get_nextcloud_user(\n        self,\n        access_token: str,\n    ) -> NextcloudUser:\n        \"\"\"\n        Get Nextcloud user info from OCS API.\n\n        Args:\n            access_token: Valid Nextcloud access token\n\n        Returns:\n            NextcloudUser object\n        \"\"\"\n        user_info = await self.get_user_info(access_token, OIDCProvider.NEXTCLOUD)\n\n        # Nextcloud OCS API wraps data in ocs.data\n        if \"ocs\" in user_info:\n            user_data = user_info[\"ocs\"][\"data\"]\n        else:\n            user_data = user_info\n\n        return NextcloudUser(\n            id=user_data.get(\"id\", \"\"),\n            display_name=user_data.get(\"displayname\", user_data.get(\"display-name\", \"\")),\n            email=user_data.get(\"email\"),\n            groups=user_data.get(\"groups\", []),\n            quota=user_data.get(\"quota\"),\n            phone=user_data.get(\"phone\"),\n            address=user_data.get(\"address\"),\n            website=user_data.get(\"website\"),\n            twitter=user_data.get(\"twitter\"),\n            language=user_data.get(\"language\"),\n            backend=user_data.get(\"backend\"),\n            enabled=user_data.get(\"enabled\", True),\n        )\n\n    async def logout(\n        self,\n        id_token: str,\n        provider: OIDCProvider = OIDCProvider.NEXTCLOUD,\n        post_logout_redirect_uri: Optional[str] = None,\n    ) -> Optional[str]:\n        \"\"\"\n        Get logout URL for provider (if supported).\n\n        Args:\n            id_token: ID token hint\n            provider: OIDC provider\n            post_logout_redirect_uri: Where to redirect after logout\n\n        Returns:\n            Logout URL or None if not supported\n        \"\"\"\n        config = self.providers.get(provider)\n        if not config:\n            return None\n\n        endpoint = config.end_session_endpoint\n        if not endpoint:\n            try:\n                discovery = await self.discover_configuration(config.issuer)\n                endpoint = discovery.get(\"end_session_endpoint\")\n            except Exception:\n                return None\n\n        if not endpoint:\n            return None\n\n        params = {\"id_token_hint\": id_token}\n        if post_logout_redirect_uri:\n            params[\"post_logout_redirect_uri\"] = post_logout_redirect_uri\n\n        return f\"{endpoint}?{urlencode(params)}\"\n\n\n# Singleton instance\noidc_service = OIDCService()\n\n\ndef get_oidc_service() -> OIDCService:\n    \"\"\"Get the OIDC service singleton.\"\"\"\n    return oidc_service\n\n\ndef configure_oidc_from_settings() -> OIDCService:\n    \"\"\"Configure OIDC service from application settings.\"\"\"\n    service = get_oidc_service()\n\n    # Register Nextcloud if configured\n    if hasattr(settings, \"NEXTCLOUD_URL\") and settings.NEXTCLOUD_URL:\n        service.register_nextcloud(\n            base_url=settings.NEXTCLOUD_URL,\n            client_id=getattr(settings, \"NEXTCLOUD_OAUTH_CLIENT_ID\", \"\"),\n            client_secret=getattr(settings, \"NEXTCLOUD_OAUTH_CLIENT_SECRET\", \"\"),\n            redirect_uri=getattr(\n                settings,\n                \"NEXTCLOUD_OAUTH_REDIRECT_URI\",\n                f\"{settings.API_BASE_URL}/api/auth/oidc/callback\",\n            ),\n        )\n\n    # Register Google if configured\n    if hasattr(settings, \"GOOGLE_OAUTH_CLIENT_ID\") and settings.GOOGLE_OAUTH_CLIENT_ID:\n        service.register_google(\n            client_id=settings.GOOGLE_OAUTH_CLIENT_ID,\n            client_secret=getattr(settings, \"GOOGLE_OAUTH_CLIENT_SECRET\", \"\"),\n            redirect_uri=getattr(\n                settings,\n                \"GOOGLE_OAUTH_REDIRECT_URI\",\n                f\"{settings.API_BASE_URL}/api/auth/google/callback\",\n            ),\n        )\n\n    # Register Microsoft if configured\n    if hasattr(settings, \"MICROSOFT_TENANT_ID\") and settings.MICROSOFT_TENANT_ID:\n        service.register_microsoft(\n            tenant_id=settings.MICROSOFT_TENANT_ID,\n            client_id=getattr(settings, \"MICROSOFT_CLIENT_ID\", \"\"),\n            client_secret=getattr(settings, \"MICROSOFT_CLIENT_SECRET\", \"\"),\n            redirect_uri=getattr(\n                settings,\n                \"MICROSOFT_REDIRECT_URI\",\n                f\"{settings.API_BASE_URL}/api/auth/microsoft/callback\",\n            ),\n        )\n\n    return service\n"
}
