{
  "path": "services/api-gateway/app/services/patient_context_service.py",
  "language": "python",
  "size": 20277,
  "last_modified": "2025-12-05T03:07:13.134Z",
  "lines": 592,
  "content": "\"\"\"\nPatient Context Service - Context-Aware Clinical Assistance\n\nPhase 9: Patient Context Integration for Medical Dictation.\n\nFeatures:\n- Retrieve patient demographics and history for dictation context\n- Generate contextual prompts based on patient data\n- Support condition-aware knowledge retrieval\n- Integrate with RAG for medication interaction queries\n- HIPAA-compliant data access with audit logging\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Enums and Types\n# ==============================================================================\n\n\nclass PatientDataCategory(str, Enum):\n    \"\"\"Categories of patient data for context.\"\"\"\n\n    DEMOGRAPHICS = \"demographics\"\n    MEDICATIONS = \"medications\"\n    ALLERGIES = \"allergies\"\n    CONDITIONS = \"conditions\"\n    VITALS = \"vitals\"\n    LABS = \"labs\"\n    PROCEDURES = \"procedures\"\n    NOTES = \"notes\"\n\n\nclass ContextRelevance(str, Enum):\n    \"\"\"Relevance level for context items.\"\"\"\n\n    HIGH = \"high\"  # Current medications, active conditions\n    MEDIUM = \"medium\"  # Recent labs, recent visits\n    LOW = \"low\"  # Historical data\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\n@dataclass\nclass Medication:\n    \"\"\"Patient medication record.\"\"\"\n\n    name: str\n    dosage: str\n    frequency: str\n    route: str = \"PO\"\n    start_date: Optional[datetime] = None\n    prescriber: Optional[str] = None\n    is_active: bool = True\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"dosage\": self.dosage,\n            \"frequency\": self.frequency,\n            \"route\": self.route,\n            \"start_date\": self.start_date.isoformat() if self.start_date else None,\n            \"prescriber\": self.prescriber,\n            \"is_active\": self.is_active,\n        }\n\n\n@dataclass\nclass Allergy:\n    \"\"\"Patient allergy record.\"\"\"\n\n    allergen: str\n    reaction: str\n    severity: str = \"moderate\"  # mild, moderate, severe\n    verified: bool = True\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"allergen\": self.allergen,\n            \"reaction\": self.reaction,\n            \"severity\": self.severity,\n            \"verified\": self.verified,\n        }\n\n\n@dataclass\nclass Condition:\n    \"\"\"Patient condition/diagnosis record.\"\"\"\n\n    name: str\n    icd10_code: Optional[str] = None\n    onset_date: Optional[datetime] = None\n    status: str = \"active\"  # active, resolved, chronic\n    notes: Optional[str] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"icd10_code\": self.icd10_code,\n            \"onset_date\": self.onset_date.isoformat() if self.onset_date else None,\n            \"status\": self.status,\n            \"notes\": self.notes,\n        }\n\n\n@dataclass\nclass VitalSign:\n    \"\"\"Patient vital sign record.\"\"\"\n\n    type: str  # BP, HR, RR, Temp, SpO2, Weight, Height\n    value: str\n    unit: str\n    recorded_at: datetime\n    is_abnormal: bool = False\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"type\": self.type,\n            \"value\": self.value,\n            \"unit\": self.unit,\n            \"recorded_at\": self.recorded_at.isoformat(),\n            \"is_abnormal\": self.is_abnormal,\n        }\n\n\n@dataclass\nclass LabResult:\n    \"\"\"Patient lab result record.\"\"\"\n\n    test_name: str\n    value: str\n    unit: str\n    reference_range: str\n    collected_at: datetime\n    is_abnormal: bool = False\n    category: str = \"general\"  # CBC, BMP, CMP, etc.\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"test_name\": self.test_name,\n            \"value\": self.value,\n            \"unit\": self.unit,\n            \"reference_range\": self.reference_range,\n            \"collected_at\": self.collected_at.isoformat(),\n            \"is_abnormal\": self.is_abnormal,\n            \"category\": self.category,\n        }\n\n\n@dataclass\nclass PatientDemographics:\n    \"\"\"Patient demographic information.\"\"\"\n\n    patient_id: str\n    age: int\n    sex: str  # M, F, O\n    preferred_language: str = \"en\"\n    # Note: Name, DOB, MRN are PHI - only used when explicitly needed\n    mrn: Optional[str] = None\n    name: Optional[str] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"patient_id\": self.patient_id,\n            \"age\": self.age,\n            \"sex\": self.sex,\n            \"preferred_language\": self.preferred_language,\n            # Only include PHI if set\n            \"mrn\": self.mrn,\n            \"name\": self.name,\n        }\n\n\n@dataclass\nclass DictationContext:\n    \"\"\"\n    Full patient context for dictation sessions.\n\n    Contains all relevant patient information to provide\n    context-aware assistance during clinical documentation.\n    \"\"\"\n\n    demographics: PatientDemographics\n    medications: List[Medication] = field(default_factory=list)\n    allergies: List[Allergy] = field(default_factory=list)\n    conditions: List[Condition] = field(default_factory=list)\n    recent_vitals: List[VitalSign] = field(default_factory=list)\n    recent_labs: List[LabResult] = field(default_factory=list)\n\n    # Computed summaries\n    medication_summary: str = \"\"\n    allergy_summary: str = \"\"\n    condition_summary: str = \"\"\n\n    # Context metadata\n    context_generated_at: datetime = field(default_factory=datetime.utcnow)\n    data_freshness_hours: int = 24\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"demographics\": self.demographics.to_dict(),\n            \"medications\": [m.to_dict() for m in self.medications],\n            \"allergies\": [a.to_dict() for a in self.allergies],\n            \"conditions\": [c.to_dict() for c in self.conditions],\n            \"recent_vitals\": [v.to_dict() for v in self.recent_vitals],\n            \"recent_labs\": [l.to_dict() for l in self.recent_labs],\n            \"medication_summary\": self.medication_summary,\n            \"allergy_summary\": self.allergy_summary,\n            \"condition_summary\": self.condition_summary,\n            \"context_generated_at\": self.context_generated_at.isoformat(),\n            \"data_freshness_hours\": self.data_freshness_hours,\n        }\n\n\n@dataclass\nclass ContextPrompt:\n    \"\"\"A contextual prompt or suggestion based on patient data.\"\"\"\n\n    prompt_type: str  # info, alert, suggestion, question\n    category: PatientDataCategory\n    message: str\n    priority: int = 0  # Higher = more important\n    data_reference: Optional[Dict[str, Any]] = None\n\n\n# ==============================================================================\n# Patient Context Service\n# ==============================================================================\n\n\nclass PatientContextService:\n    \"\"\"\n    Service for managing patient context during dictation.\n\n    Provides context-aware clinical assistance by:\n    - Retrieving relevant patient data for dictation sessions\n    - Generating contextual prompts and suggestions\n    - Supporting medication interaction queries\n    - Integrating with RAG for condition-aware knowledge retrieval\n\n    Usage:\n        service = PatientContextService()\n\n        # Get context for dictation\n        context = await service.get_context_for_dictation(\n            user_id=\"clinician_123\",\n            patient_id=\"patient_456\"\n        )\n\n        # Generate prompts\n        prompts = service.generate_context_prompts(context)\n        for prompt in prompts:\n            print(f\"[{prompt.prompt_type}] {prompt.message}\")\n    \"\"\"\n\n    def __init__(self):\n        self._context_cache: Dict[str, DictationContext] = {}\n        self._cache_ttl_minutes = 15\n\n    async def get_context_for_dictation(\n        self,\n        user_id: str,\n        patient_id: str,\n        include_categories: Optional[List[PatientDataCategory]] = None,\n    ) -> DictationContext:\n        \"\"\"\n        Retrieve patient context for dictation.\n\n        Args:\n            user_id: ID of the clinician (for audit logging)\n            patient_id: ID of the patient\n            include_categories: Optional list of categories to include.\n                If None, includes all categories.\n\n        Returns:\n            DictationContext with patient data\n        \"\"\"\n        # Check cache first\n        cache_key = f\"{user_id}:{patient_id}\"\n        if cache_key in self._context_cache:\n            cached = self._context_cache[cache_key]\n            cache_age = datetime.utcnow() - cached.context_generated_at\n            if cache_age < timedelta(minutes=self._cache_ttl_minutes):\n                logger.debug(f\"Using cached context for patient {patient_id}\")\n                return cached\n\n        logger.info(f\"Building context for patient {patient_id} by user {user_id}\")\n\n        # In a real implementation, this would query EHR/database\n        # For now, return a mock context structure\n        context = await self._build_context(patient_id, include_categories)\n\n        # Generate summaries\n        context.medication_summary = self._summarize_medications(context.medications)\n        context.allergy_summary = self._summarize_allergies(context.allergies)\n        context.condition_summary = self._summarize_conditions(context.conditions)\n\n        # Cache the context\n        self._context_cache[cache_key] = context\n\n        return context\n\n    async def _build_context(\n        self,\n        patient_id: str,\n        include_categories: Optional[List[PatientDataCategory]] = None,\n    ) -> DictationContext:\n        \"\"\"\n        Build patient context from data sources.\n\n        In production, this would integrate with:\n        - EHR systems (Epic, Cerner, etc.)\n        - FHIR APIs\n        - Local patient databases\n        \"\"\"\n        # Default to all categories\n        if include_categories is None:\n            include_categories = list(PatientDataCategory)\n\n        # Create base context with demographics\n        context = DictationContext(\n            demographics=PatientDemographics(\n                patient_id=patient_id,\n                age=0,  # Would be populated from EHR\n                sex=\"\",\n            )\n        )\n\n        # Populate based on requested categories\n        # In production, these would be database/API calls\n        if PatientDataCategory.MEDICATIONS in include_categories:\n            context.medications = await self._fetch_medications(patient_id)\n\n        if PatientDataCategory.ALLERGIES in include_categories:\n            context.allergies = await self._fetch_allergies(patient_id)\n\n        if PatientDataCategory.CONDITIONS in include_categories:\n            context.conditions = await self._fetch_conditions(patient_id)\n\n        if PatientDataCategory.VITALS in include_categories:\n            context.recent_vitals = await self._fetch_recent_vitals(patient_id)\n\n        if PatientDataCategory.LABS in include_categories:\n            context.recent_labs = await self._fetch_recent_labs(patient_id)\n\n        return context\n\n    async def _fetch_medications(self, patient_id: str) -> List[Medication]:\n        \"\"\"Fetch patient medications from data source.\"\"\"\n        # Placeholder - would integrate with EHR\n        logger.debug(f\"Fetching medications for patient {patient_id}\")\n        return []\n\n    async def _fetch_allergies(self, patient_id: str) -> List[Allergy]:\n        \"\"\"Fetch patient allergies from data source.\"\"\"\n        logger.debug(f\"Fetching allergies for patient {patient_id}\")\n        return []\n\n    async def _fetch_conditions(self, patient_id: str) -> List[Condition]:\n        \"\"\"Fetch patient conditions from data source.\"\"\"\n        logger.debug(f\"Fetching conditions for patient {patient_id}\")\n        return []\n\n    async def _fetch_recent_vitals(self, patient_id: str) -> List[VitalSign]:\n        \"\"\"Fetch recent vital signs from data source.\"\"\"\n        logger.debug(f\"Fetching recent vitals for patient {patient_id}\")\n        return []\n\n    async def _fetch_recent_labs(self, patient_id: str) -> List[LabResult]:\n        \"\"\"Fetch recent lab results from data source.\"\"\"\n        logger.debug(f\"Fetching recent labs for patient {patient_id}\")\n        return []\n\n    def _summarize_medications(self, medications: List[Medication]) -> str:\n        \"\"\"Generate a text summary of medications.\"\"\"\n        if not medications:\n            return \"No current medications on file.\"\n\n        active = [m for m in medications if m.is_active]\n        if not active:\n            return \"No active medications.\"\n\n        summary_parts = []\n        for med in active[:5]:  # Limit to top 5\n            summary_parts.append(f\"{med.name} {med.dosage} {med.frequency}\")\n\n        if len(active) > 5:\n            summary_parts.append(f\"...and {len(active) - 5} more\")\n\n        return \"Current medications: \" + \", \".join(summary_parts)\n\n    def _summarize_allergies(self, allergies: List[Allergy]) -> str:\n        \"\"\"Generate a text summary of allergies.\"\"\"\n        if not allergies:\n            return \"No known allergies (NKDA).\"\n\n        severe = [a for a in allergies if a.severity == \"severe\"]\n        if severe:\n            severe_list = \", \".join([a.allergen for a in severe])\n            return f\"ALLERGIES (SEVERE): {severe_list}\"\n\n        allergen_list = \", \".join([a.allergen for a in allergies[:5]])\n        return f\"Allergies: {allergen_list}\"\n\n    def _summarize_conditions(self, conditions: List[Condition]) -> str:\n        \"\"\"Generate a text summary of conditions.\"\"\"\n        if not conditions:\n            return \"No documented conditions.\"\n\n        active = [c for c in conditions if c.status in (\"active\", \"chronic\")]\n        if not active:\n            return \"No active conditions.\"\n\n        condition_list = \", \".join([c.name for c in active[:5]])\n        if len(active) > 5:\n            condition_list += f\" (+{len(active) - 5} more)\"\n\n        return f\"Active conditions: {condition_list}\"\n\n    def generate_context_prompts(self, context: DictationContext) -> List[ContextPrompt]:\n        \"\"\"\n        Generate contextual prompts based on patient data.\n\n        Returns a list of prompts/suggestions that can help the clinician\n        during dictation.\n\n        Args:\n            context: Patient context\n\n        Returns:\n            List of ContextPrompt objects\n        \"\"\"\n        prompts = []\n\n        # Allergy alerts (highest priority)\n        severe_allergies = [a for a in context.allergies if a.severity == \"severe\"]\n        if severe_allergies:\n            allergens = \", \".join([a.allergen for a in severe_allergies])\n            prompts.append(\n                ContextPrompt(\n                    prompt_type=\"alert\",\n                    category=PatientDataCategory.ALLERGIES,\n                    message=f\"Alert: Patient has severe allergies to {allergens}\",\n                    priority=100,\n                    data_reference={\"allergies\": [a.to_dict() for a in severe_allergies]},\n                )\n            )\n\n        # Lab result prompts\n        abnormal_labs = [lab for lab in context.recent_labs if lab.is_abnormal]\n        if abnormal_labs:\n            lab_count = len(abnormal_labs)\n            prompts.append(\n                ContextPrompt(\n                    prompt_type=\"info\",\n                    category=PatientDataCategory.LABS,\n                    message=f\"I see {lab_count} abnormal lab result(s). Would you like me to summarize them?\",\n                    priority=50,\n                    data_reference={\"labs\": [l.to_dict() for l in abnormal_labs]},\n                )\n            )\n\n        # Vital sign prompts\n        abnormal_vitals = [v for v in context.recent_vitals if v.is_abnormal]\n        if abnormal_vitals:\n            vital_types = \", \".join(set([v.type for v in abnormal_vitals]))\n            prompts.append(\n                ContextPrompt(\n                    prompt_type=\"info\",\n                    category=PatientDataCategory.VITALS,\n                    message=f\"Note: Abnormal vitals recorded for {vital_types}\",\n                    priority=40,\n                    data_reference={\"vitals\": [v.to_dict() for v in abnormal_vitals]},\n                )\n            )\n\n        # Medication count info\n        active_meds = [m for m in context.medications if m.is_active]\n        if len(active_meds) > 5:\n            prompts.append(\n                ContextPrompt(\n                    prompt_type=\"info\",\n                    category=PatientDataCategory.MEDICATIONS,\n                    message=f\"Patient is on {len(active_meds)} active medications. Would you like to review them?\",\n                    priority=30,\n                )\n            )\n\n        # Chronic condition reminder\n        chronic = [c for c in context.conditions if c.status == \"chronic\"]\n        if chronic:\n            condition_names = \", \".join([c.name for c in chronic[:3]])\n            prompts.append(\n                ContextPrompt(\n                    prompt_type=\"suggestion\",\n                    category=PatientDataCategory.CONDITIONS,\n                    message=f\"Patient has chronic conditions: {condition_names}. Consider addressing in assessment.\",\n                    priority=20,\n                )\n            )\n\n        # Sort by priority (highest first)\n        prompts.sort(key=lambda p: p.priority, reverse=True)\n\n        return prompts\n\n    def get_medication_context_for_rag(self, context: DictationContext) -> Dict[str, Any]:\n        \"\"\"\n        Extract medication data for RAG queries.\n\n        Returns context suitable for drug interaction checks\n        and medication-related knowledge retrieval.\n        \"\"\"\n        return {\n            \"current_medications\": [m.name for m in context.medications if m.is_active],\n            \"medication_details\": [m.to_dict() for m in context.medications if m.is_active],\n            \"allergies\": [a.allergen for a in context.allergies],\n            \"conditions\": [c.name for c in context.conditions if c.status != \"resolved\"],\n        }\n\n    def get_condition_context_for_rag(self, context: DictationContext) -> Dict[str, Any]:\n        \"\"\"\n        Extract condition data for RAG queries.\n\n        Returns context suitable for condition-aware\n        knowledge retrieval.\n        \"\"\"\n        active_conditions = [c for c in context.conditions if c.status != \"resolved\"]\n        return {\n            \"active_conditions\": [c.name for c in active_conditions],\n            \"icd10_codes\": [c.icd10_code for c in active_conditions if c.icd10_code],\n            \"chronic_conditions\": [c.name for c in active_conditions if c.status == \"chronic\"],\n        }\n\n    async def check_medication_interactions(\n        self,\n        context: DictationContext,\n        new_medication: str,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Check for interactions between a new medication and current meds.\n\n        This would integrate with a drug interaction database in production.\n\n        Args:\n            context: Patient context with current medications\n            new_medication: Name of medication being considered\n\n        Returns:\n            List of potential interactions\n        \"\"\"\n        logger.info(\n            f\"Checking interactions for {new_medication} against \" f\"{len(context.medications)} current medications\"\n        )\n\n        # Placeholder - would integrate with drug interaction API\n        # Examples: DrugBank, RxNorm, OpenFDA\n        interactions = []\n\n        # In production, query drug interaction database here\n        # For now, return empty list\n\n        return interactions\n\n    def clear_cache(self, patient_id: Optional[str] = None) -> None:\n        \"\"\"Clear cached context.\"\"\"\n        if patient_id:\n            # Clear specific patient\n            keys_to_remove = [k for k in self._context_cache.keys() if k.endswith(f\":{patient_id}\")]\n            for key in keys_to_remove:\n                del self._context_cache[key]\n            logger.info(f\"Cleared cache for patient {patient_id}\")\n        else:\n            # Clear all\n            self._context_cache.clear()\n            logger.info(\"Cleared all patient context cache\")\n\n\n# Global service instance\npatient_context_service = PatientContextService()\n"
}
