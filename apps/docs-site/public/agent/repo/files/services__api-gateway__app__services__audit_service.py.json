{
  "path": "services/api-gateway/app/services/audit_service.py",
  "language": "python",
  "size": 18257,
  "last_modified": "2025-12-04T11:26:55.610Z",
  "lines": 567,
  "content": "\"\"\"\nAudit logging service for tracking user actions and system events.\n\nHIPAA Compliance: All access to PHI and authentication events must be logged.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional\n\nfrom app.core.request_id import get_request_id\nfrom app.models.audit_log import AuditLog\nfrom app.models.user import User\nfrom fastapi import Request\nfrom sqlalchemy.orm import Session\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuditService:\n    \"\"\"\n    Service for creating and managing audit logs.\n\n    Audit logs are immutable and include integrity verification.\n    \"\"\"\n\n    @staticmethod\n    async def log_event(\n        db: Session,\n        action: str,\n        success: bool,\n        user: Optional[User] = None,\n        user_id: Optional[str] = None,\n        user_email: Optional[str] = None,\n        user_role: Optional[str] = None,\n        resource_type: Optional[str] = None,\n        resource_id: Optional[str] = None,\n        request: Optional[Request] = None,\n        request_id: Optional[str] = None,\n        ip_address: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        endpoint: Optional[str] = None,\n        status_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        service_name: str = \"api-gateway\",\n    ) -> AuditLog:\n        \"\"\"\n        Create an audit log entry.\n\n        Args:\n            db: Database session\n            action: Action performed (e.g., \"login\", \"create_user\", \"delete_document\")\n            success: Whether the action succeeded\n            user: User object (if available, will extract user_id, email, role)\n            user_id: User ID (if user not provided)\n            user_email: User email (if user not provided)\n            user_role: User role (if user not provided)\n            resource_type: Type of resource accessed (e.g., \"user\", \"document\")\n            resource_id: ID of the resource\n            request: FastAPI Request object (will extract request_id, ip, user_agent, endpoint)\n            request_id: Request correlation ID (if request not provided)\n            ip_address: Client IP address (if request not provided)\n            user_agent: Client user agent (if request not provided)\n            endpoint: API endpoint (if request not provided)\n            status_code: HTTP status code\n            error_message: Error message if action failed\n            metadata: Additional context as JSON\n            service_name: Name of the service generating the log\n\n        Returns:\n            Created AuditLog entry\n        \"\"\"\n        # Extract user info from User object if provided\n        if user:\n            user_id = str(user.id)\n            user_email = user.email\n            user_role = getattr(user, \"admin_role\", None) or (\"admin\" if user.is_admin else \"user\")\n\n        # Extract request info from Request object if provided\n        if request:\n            request_id = get_request_id(request)\n            ip_address = request.client.host if request.client else None\n            user_agent = request.headers.get(\"user-agent\")\n            endpoint = f\"{request.method} {request.url.path}\"\n\n        # Create audit log entry\n        audit_log = AuditLog(\n            user_id=user_id,\n            user_email=user_email,\n            user_role=user_role,\n            action=action,\n            resource_type=resource_type,\n            resource_id=resource_id,\n            request_id=request_id,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            service_name=service_name,\n            endpoint=endpoint,\n            success=success,\n            status_code=status_code,\n            error_message=error_message,\n            metadata=metadata,\n        )\n\n        # Calculate integrity hash\n        audit_log.hash = audit_log.calculate_hash()\n\n        # Save to database\n        try:\n            db.add(audit_log)\n            db.commit()\n            db.refresh(audit_log)\n\n            # Also log to application logs\n            log_level = logging.INFO if success else logging.WARNING\n            logger.log(\n                log_level,\n                f\"Audit: {action} by {user_email or 'system'} - \" f\"{'success' if success else 'failed'}\",\n                extra={\n                    \"audit_log_id\": str(audit_log.id),\n                    \"request_id\": request_id,\n                    \"user_id\": user_id,\n                    \"action\": action,\n                    \"resource_type\": resource_type,\n                    \"success\": success,\n                },\n            )\n\n            return audit_log\n\n        except Exception as e:\n            logger.error(f\"Failed to create audit log: {e}\", exc_info=True)\n            db.rollback()\n            raise\n\n    @staticmethod\n    async def log_authentication(\n        db: Session,\n        action: str,  # \"login\", \"logout\", \"register\", \"password_change\"\n        user: Optional[User],\n        request: Request,\n        success: bool,\n        error_message: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log authentication-related events.\n\n        This is a convenience method for the most common audit log use case.\n        \"\"\"\n        return await AuditService.log_event(\n            db=db,\n            action=action,\n            success=success,\n            user=user,\n            resource_type=\"authentication\",\n            request=request,\n            error_message=error_message,\n            metadata=metadata,\n        )\n\n    @staticmethod\n    def verify_audit_log_integrity(db: Session, audit_log_id: str) -> bool:\n        \"\"\"\n        Verify that an audit log entry has not been tampered with.\n\n        Args:\n            db: Database session\n            audit_log_id: ID of the audit log to verify\n\n        Returns:\n            True if hash matches, False if tampered\n        \"\"\"\n        audit_log = db.query(AuditLog).filter(AuditLog.id == audit_log_id).first()\n        if not audit_log:\n            return False\n\n        return audit_log.verify_integrity()\n\n    @staticmethod\n    def get_user_audit_trail(db: Session, user_id: str, limit: int = 100, offset: int = 0) -> list[AuditLog]:\n        \"\"\"\n        Get audit trail for a specific user.\n\n        Args:\n            db: Database session\n            user_id: User ID to get audit trail for\n            limit: Maximum number of entries to return\n            offset: Number of entries to skip\n\n        Returns:\n            List of AuditLog entries\n        \"\"\"\n        return (\n            db.query(AuditLog)\n            .filter(AuditLog.user_id == user_id)\n            .order_by(AuditLog.timestamp.desc())\n            .limit(limit)\n            .offset(offset)\n            .all()\n        )\n\n    @staticmethod\n    def get_recent_failed_logins(db: Session, minutes: int = 30, limit: int = 100) -> list[AuditLog]:\n        \"\"\"\n        Get recent failed login attempts for security monitoring.\n\n        Args:\n            db: Database session\n            minutes: How many minutes back to look\n            limit: Maximum number of entries to return\n\n        Returns:\n            List of failed login audit logs\n        \"\"\"\n        cutoff_time = datetime.now(timezone.utc) - timedelta(minutes=minutes)\n\n        return (\n            db.query(AuditLog)\n            .filter(\n                AuditLog.action == \"login\",\n                AuditLog.success.is_(False),\n                AuditLog.timestamp >= cutoff_time,\n            )\n            .order_by(AuditLog.timestamp.desc())\n            .limit(limit)\n            .all()\n        )\n\n    # =========================================================================\n    # HIPAA Dictation Audit Events (Phase 9)\n    # =========================================================================\n\n    @staticmethod\n    async def log_dictation_started(\n        db: Session,\n        user: Optional[User],\n        session_id: str,\n        patient_id: Optional[str] = None,\n        note_type: Optional[str] = None,\n        specialty: Optional[str] = None,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log dictation session start (HIPAA required).\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            session_id: Dictation session ID\n            patient_id: Patient ID if in patient context\n            note_type: Type of note being dictated (SOAP, H&P, etc.)\n            specialty: Medical specialty if set\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"note_type\": note_type,\n            \"specialty\": specialty,\n            **(metadata or {}),\n        }\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"DICTATION_STARTED\",\n            success=True,\n            user=user,\n            resource_type=\"dictation_session\",\n            resource_id=session_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    async def log_dictation_ended(\n        db: Session,\n        user: Optional[User],\n        session_id: str,\n        duration_seconds: Optional[float] = None,\n        word_count: Optional[int] = None,\n        was_saved: bool = False,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log dictation session end (HIPAA required).\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            session_id: Dictation session ID\n            duration_seconds: Total session duration\n            word_count: Number of words dictated\n            was_saved: Whether the note was saved\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"duration_seconds\": duration_seconds,\n            \"word_count\": word_count,\n            \"was_saved\": was_saved,\n            **(metadata or {}),\n        }\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"DICTATION_ENDED\",\n            success=True,\n            user=user,\n            resource_type=\"dictation_session\",\n            resource_id=session_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    async def log_patient_context_accessed(\n        db: Session,\n        user: Optional[User],\n        patient_id: str,\n        session_id: Optional[str] = None,\n        data_categories: Optional[list[str]] = None,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log patient context access during dictation (HIPAA required).\n\n        This event is logged whenever patient data is retrieved for\n        context-aware dictation assistance.\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            patient_id: Patient whose data was accessed\n            session_id: Dictation session ID\n            data_categories: Categories of data accessed (meds, labs, etc.)\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"data_categories\": data_categories or [],\n            **(metadata or {}),\n        }\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"PATIENT_CONTEXT_ACCESSED\",\n            success=True,\n            user=user,\n            resource_type=\"patient\",\n            resource_id=patient_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    async def log_note_saved(\n        db: Session,\n        user: Optional[User],\n        session_id: str,\n        note_id: str,\n        patient_id: Optional[str] = None,\n        note_type: Optional[str] = None,\n        word_count: Optional[int] = None,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log clinical note save (HIPAA required).\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            session_id: Dictation session ID\n            note_id: ID of the saved note\n            patient_id: Patient ID if in patient context\n            note_type: Type of note saved\n            word_count: Number of words in note\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"patient_id\": patient_id,\n            \"note_type\": note_type,\n            \"word_count\": word_count,\n            **(metadata or {}),\n        }\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"NOTE_SAVED\",\n            success=True,\n            user=user,\n            resource_type=\"clinical_note\",\n            resource_id=note_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    async def log_phi_detected(\n        db: Session,\n        user: Optional[User],\n        session_id: str,\n        phi_type: str,\n        alert_level: str,\n        was_expected: bool,\n        action_taken: str,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log PHI detection during dictation (HIPAA required for unexpected PHI).\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            session_id: Dictation session ID\n            phi_type: Type of PHI detected (name, SSN, MRN, etc.)\n            alert_level: info, warning, or critical\n            was_expected: Whether PHI matched current patient context\n            action_taken: Action taken (allow, mask, redact, alert)\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"phi_type\": phi_type,\n            \"alert_level\": alert_level,\n            \"was_expected\": was_expected,\n            \"action_taken\": action_taken,\n            **(metadata or {}),\n        }\n\n        # Unexpected PHI is a potential security event\n        success = was_expected or alert_level == \"info\"\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"PHI_DETECTED\",\n            success=success,\n            user=user,\n            resource_type=\"dictation_session\",\n            resource_id=session_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    async def log_medication_interaction_check(\n        db: Session,\n        user: Optional[User],\n        patient_id: str,\n        medication_checked: str,\n        interactions_found: int,\n        session_id: Optional[str] = None,\n        request: Optional[Request] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> AuditLog:\n        \"\"\"\n        Log medication interaction check (HIPAA recommended for clinical decision support).\n\n        Args:\n            db: Database session\n            user: Clinician user object\n            patient_id: Patient whose medications were checked\n            medication_checked: Name of medication being evaluated\n            interactions_found: Number of interactions found\n            session_id: Dictation session ID if during dictation\n            request: FastAPI request object\n            metadata: Additional context\n        \"\"\"\n        event_metadata = {\n            \"session_id\": session_id,\n            \"medication_checked\": medication_checked,\n            \"interactions_found\": interactions_found,\n            **(metadata or {}),\n        }\n\n        return await AuditService.log_event(\n            db=db,\n            action=\"MEDICATION_INTERACTION_CHECK\",\n            success=True,\n            user=user,\n            resource_type=\"patient\",\n            resource_id=patient_id,\n            request=request,\n            metadata=event_metadata,\n        )\n\n    @staticmethod\n    def get_dictation_audit_trail(\n        db: Session,\n        session_id: str,\n        limit: int = 100,\n    ) -> list[AuditLog]:\n        \"\"\"\n        Get all audit events for a dictation session.\n\n        Args:\n            db: Database session\n            session_id: Dictation session ID\n            limit: Maximum number of entries\n\n        Returns:\n            List of audit events for the session\n        \"\"\"\n        dictation_actions = [\n            \"DICTATION_STARTED\",\n            \"DICTATION_ENDED\",\n            \"PATIENT_CONTEXT_ACCESSED\",\n            \"NOTE_SAVED\",\n            \"PHI_DETECTED\",\n            \"MEDICATION_INTERACTION_CHECK\",\n        ]\n\n        return (\n            db.query(AuditLog)\n            .filter(\n                AuditLog.action.in_(dictation_actions),\n                AuditLog.resource_id == session_id,\n            )\n            .order_by(AuditLog.timestamp.asc())\n            .limit(limit)\n            .all()\n        )\n\n    @staticmethod\n    def get_patient_access_log(\n        db: Session,\n        patient_id: str,\n        days: int = 30,\n        limit: int = 500,\n    ) -> list[AuditLog]:\n        \"\"\"\n        Get all access events for a patient (HIPAA accounting of disclosures).\n\n        Args:\n            db: Database session\n            patient_id: Patient ID\n            days: Number of days to look back\n            limit: Maximum number of entries\n\n        Returns:\n            List of audit events involving the patient\n        \"\"\"\n        cutoff_time = datetime.now(timezone.utc) - timedelta(days=days)\n\n        return (\n            db.query(AuditLog)\n            .filter(\n                AuditLog.resource_type == \"patient\",\n                AuditLog.resource_id == patient_id,\n                AuditLog.timestamp >= cutoff_time,\n            )\n            .order_by(AuditLog.timestamp.desc())\n            .limit(limit)\n            .all()\n        )\n"
}
