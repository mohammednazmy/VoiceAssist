{
  "path": "services/api-gateway/app/services/pubmed_enhanced_service.py",
  "language": "python",
  "size": 27196,
  "last_modified": "2025-12-04T11:26:59.690Z",
  "lines": 874,
  "content": "\"\"\"\nEnhanced PubMed Service\n\nAdvanced PubMed integration with additional features:\n- Full-text access via PubMed Central (PMC)\n- Citation network analysis\n- Similar articles discovery\n- Clinical trial matching\n- MeSH term expansion\n- Systematic review support\n\nUses NCBI E-utilities API (free, requires API key for higher rate limits).\n\"\"\"\n\nimport asyncio\nimport xml.etree.ElementTree as ET  # nosec B405 - parsing from trusted NCBI API\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport httpx\nfrom app.core.config import settings\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass PublicationType(Enum):\n    \"\"\"PubMed publication types\"\"\"\n\n    CLINICAL_TRIAL = \"Clinical Trial\"\n    META_ANALYSIS = \"Meta-Analysis\"\n    RANDOMIZED_CONTROLLED_TRIAL = \"Randomized Controlled Trial\"\n    REVIEW = \"Review\"\n    SYSTEMATIC_REVIEW = \"Systematic Review\"\n    CASE_REPORTS = \"Case Reports\"\n    GUIDELINE = \"Guideline\"\n    PRACTICE_GUIDELINE = \"Practice Guideline\"\n    OBSERVATIONAL_STUDY = \"Observational Study\"\n    COMPARATIVE_STUDY = \"Comparative Study\"\n\n\nclass ArticleStatus(Enum):\n    \"\"\"Article availability status\"\"\"\n\n    AVAILABLE = \"available\"\n    ABSTRACT_ONLY = \"abstract_only\"\n    FULL_TEXT_PMC = \"full_text_pmc\"\n    FULL_TEXT_PUBLISHER = \"full_text_publisher\"\n    UNAVAILABLE = \"unavailable\"\n\n\nclass ArticleType(Enum):\n    \"\"\"Article type filter for PubMed search\"\"\"\n\n    clinical_trial = \"Clinical Trial\"\n    meta_analysis = \"Meta-Analysis\"\n    randomized_controlled_trial = \"Randomized Controlled Trial\"\n    review = \"Review\"\n    systematic_review = \"Systematic Review\"\n    case_reports = \"Case Reports\"\n    guideline = \"Guideline\"\n    practice_guideline = \"Practice Guideline\"\n    observational_study = \"Observational Study\"\n    comparative_study = \"Comparative Study\"\n\n\n@dataclass\nclass DateRange:\n    \"\"\"Date range filter for PubMed search\"\"\"\n\n    start: Optional[str] = None  # Format: YYYY/MM/DD or YYYY\n    end: Optional[str] = None\n\n\n@dataclass\nclass Author:\n    \"\"\"Article author information\"\"\"\n\n    last_name: str\n    first_name: Optional[str] = None\n    initials: Optional[str] = None\n    affiliation: Optional[str] = None\n    orcid: Optional[str] = None\n\n    @property\n    def full_name(self) -> str:\n        \"\"\"Get full author name.\"\"\"\n        if self.first_name:\n            return f\"{self.first_name} {self.last_name}\"\n        elif self.initials:\n            return f\"{self.initials} {self.last_name}\"\n        return self.last_name\n\n\n@dataclass\nclass Journal:\n    \"\"\"Journal information\"\"\"\n\n    title: str\n    iso_abbreviation: Optional[str] = None\n    issn: Optional[str] = None\n    volume: Optional[str] = None\n    issue: Optional[str] = None\n    pub_date: Optional[str] = None\n\n\n@dataclass\nclass MeSHTerm:\n    \"\"\"MeSH (Medical Subject Headings) term\"\"\"\n\n    descriptor: str\n    qualifier: Optional[str] = None\n    is_major_topic: bool = False\n    tree_numbers: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass PubMedArticle:\n    \"\"\"Complete PubMed article record\"\"\"\n\n    pmid: str\n    title: str\n    abstract: Optional[str] = None\n    authors: List[Author] = field(default_factory=list)\n    journal: Optional[Journal] = None\n    pub_date: Optional[str] = None\n    doi: Optional[str] = None\n    pmc_id: Optional[str] = None\n    publication_types: List[str] = field(default_factory=list)\n    mesh_terms: List[MeSHTerm] = field(default_factory=list)\n    keywords: List[str] = field(default_factory=list)\n    status: ArticleStatus = ArticleStatus.ABSTRACT_ONLY\n\n    @property\n    def has_full_text(self) -> bool:\n        \"\"\"Check if full text is available.\"\"\"\n        return self.status in [\n            ArticleStatus.FULL_TEXT_PMC,\n            ArticleStatus.FULL_TEXT_PUBLISHER,\n        ]\n\n    @property\n    def citation(self) -> str:\n        \"\"\"Generate citation string.\"\"\"\n        authors_str = \"\"\n        if self.authors:\n            if len(self.authors) <= 3:\n                authors_str = \", \".join(a.full_name for a in self.authors)\n            else:\n                authors_str = f\"{self.authors[0].full_name} et al.\"\n\n        journal_str = \"\"\n        if self.journal:\n            journal_str = self.journal.iso_abbreviation or self.journal.title\n            if self.journal.pub_date:\n                journal_str += f\" ({self.journal.pub_date})\"\n\n        return f\"{authors_str}. {self.title}. {journal_str}\"\n\n\n@dataclass\nclass CitationNetwork:\n    \"\"\"Citation network for an article\"\"\"\n\n    article_pmid: str\n    citing_articles: List[str] = field(default_factory=list)\n    cited_articles: List[str] = field(default_factory=list)\n    citation_count: int = 0\n\n\n@dataclass\nclass ClinicalTrial:\n    \"\"\"Clinical trial information\"\"\"\n\n    nct_id: str\n    title: str\n    status: str\n    condition: str\n    intervention: Optional[str] = None\n    phase: Optional[str] = None\n    enrollment: Optional[int] = None\n    start_date: Optional[str] = None\n    completion_date: Optional[str] = None\n    locations: List[str] = field(default_factory=list)\n    url: Optional[str] = None\n\n\n@dataclass\nclass SearchResult:\n    \"\"\"PubMed search result\"\"\"\n\n    query: str\n    total_count: int\n    articles: List[PubMedArticle]\n    query_translation: Optional[str] = None\n    search_time_ms: float = 0.0\n\n\nclass EnhancedPubMedService:\n    \"\"\"\n    Enhanced PubMed integration with advanced features.\n\n    Features:\n    - Full-text access via PMC\n    - Citation network analysis\n    - Similar articles discovery\n    - Clinical trial matching\n    - MeSH term expansion\n    - Systematic review support\n\n    API: NCBI E-utilities (https://www.ncbi.nlm.nih.gov/books/NBK25500/)\n    Rate limits: 3 requests/second without API key, 10/second with key\n    \"\"\"\n\n    EUTILS_BASE = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils\"\n    PMC_BASE = \"https://www.ncbi.nlm.nih.gov/pmc/oai/oai.cgi\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        cache_service: Optional[Any] = None,\n    ):\n        \"\"\"\n        Initialize Enhanced PubMed service.\n\n        Args:\n            api_key: NCBI API key (for higher rate limits)\n            email: Contact email (required by NCBI)\n            cache_service: Optional cache service\n        \"\"\"\n        self.api_key = api_key or getattr(settings, \"NCBI_API_KEY\", \"\")\n        self.email = email or getattr(settings, \"NCBI_EMAIL\", \"voiceassist@localhost\")\n        self.cache = cache_service\n        self._client: Optional[httpx.AsyncClient] = None\n        self._request_semaphore = asyncio.Semaphore(10 if self.api_key else 3)\n\n        logger.info(\n            \"EnhancedPubMedService initialized\",\n            extra={\"has_api_key\": bool(self.api_key)},\n        )\n\n    async def _get_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._client is None:\n            self._client = httpx.AsyncClient(\n                timeout=30.0,\n                headers={\"User-Agent\": \"VoiceAssist/1.0\"},\n            )\n        return self._client\n\n    async def close(self):\n        \"\"\"Close HTTP client.\"\"\"\n        if self._client:\n            await self._client.aclose()\n            self._client = None\n\n    def _get_base_params(self) -> Dict[str, str]:\n        \"\"\"Get base parameters for E-utilities requests.\"\"\"\n        params = {\"email\": self.email, \"tool\": \"voiceassist\"}\n        if self.api_key:\n            params[\"api_key\"] = self.api_key\n        return params\n\n    async def _esearch(\n        self,\n        query: str,\n        max_results: int = 20,\n        retstart: int = 0,\n        sort: str = \"relevance\",\n    ) -> Tuple[List[str], int, Optional[str]]:\n        \"\"\"\n        Execute ESearch to get PMIDs.\n\n        Args:\n            query: Search query\n            max_results: Maximum results\n            retstart: Starting index\n            sort: Sort order (relevance, pub_date)\n\n        Returns:\n            Tuple of (pmid_list, total_count, query_translation)\n        \"\"\"\n        async with self._request_semaphore:\n            client = await self._get_client()\n            params = {\n                **self._get_base_params(),\n                \"db\": \"pubmed\",\n                \"term\": query,\n                \"retmax\": max_results,\n                \"retstart\": retstart,\n                \"sort\": sort,\n                \"retmode\": \"json\",\n                \"usehistory\": \"n\",\n            }\n\n            response = await client.get(f\"{self.EUTILS_BASE}/esearch.fcgi\", params=params)\n            response.raise_for_status()\n            data = response.json()\n\n            result = data.get(\"esearchresult\", {})\n            pmids = result.get(\"idlist\", [])\n            total = int(result.get(\"count\", 0))\n            translation = result.get(\"querytranslation\")\n\n            return pmids, total, translation\n\n    async def _efetch(\n        self,\n        pmids: List[str],\n        rettype: str = \"xml\",\n    ) -> List[PubMedArticle]:\n        \"\"\"\n        Fetch article details for PMIDs.\n\n        Args:\n            pmids: List of PubMed IDs\n            rettype: Return type (xml, abstract)\n\n        Returns:\n            List of PubMedArticle objects\n        \"\"\"\n        if not pmids:\n            return []\n\n        async with self._request_semaphore:\n            client = await self._get_client()\n            params = {\n                **self._get_base_params(),\n                \"db\": \"pubmed\",\n                \"id\": \",\".join(pmids),\n                \"rettype\": rettype,\n                \"retmode\": \"xml\",\n            }\n\n            response = await client.get(f\"{self.EUTILS_BASE}/efetch.fcgi\", params=params)\n            response.raise_for_status()\n\n            return self._parse_pubmed_xml(response.text)\n\n    async def _elink(\n        self,\n        pmid: str,\n        linkname: str,\n    ) -> List[str]:\n        \"\"\"\n        Get linked articles using ELink.\n\n        Args:\n            pmid: Source PubMed ID\n            linkname: Link type (pubmed_pubmed, pubmed_pubmed_citedin, etc.)\n\n        Returns:\n            List of linked PMIDs\n        \"\"\"\n        async with self._request_semaphore:\n            client = await self._get_client()\n            params = {\n                **self._get_base_params(),\n                \"dbfrom\": \"pubmed\",\n                \"db\": \"pubmed\",\n                \"id\": pmid,\n                \"linkname\": linkname,\n                \"retmode\": \"json\",\n            }\n\n            response = await client.get(f\"{self.EUTILS_BASE}/elink.fcgi\", params=params)\n            response.raise_for_status()\n            data = response.json()\n\n            linksets = data.get(\"linksets\", [{}])\n            if linksets:\n                linksetdbs = linksets[0].get(\"linksetdbs\", [])\n                if linksetdbs:\n                    return [str(lid) for lid in linksetdbs[0].get(\"links\", [])]\n\n            return []\n\n    def _parse_pubmed_xml(self, xml_text: str) -> List[PubMedArticle]:\n        \"\"\"Parse PubMed XML response into articles.\"\"\"\n        articles = []\n\n        try:\n            root = ET.fromstring(xml_text)  # nosec B314 - trusted NCBI API\n\n            for article_elem in root.findall(\".//PubmedArticle\"):\n                article = self._parse_article_element(article_elem)\n                if article:\n                    articles.append(article)\n\n        except ET.ParseError as e:\n            logger.error(f\"Failed to parse PubMed XML: {e}\")\n\n        return articles\n\n    def _parse_article_element(self, elem: ET.Element) -> Optional[PubMedArticle]:\n        \"\"\"Parse single article element.\"\"\"\n        try:\n            # Get PMID\n            pmid_elem = elem.find(\".//PMID\")\n            if pmid_elem is None or pmid_elem.text is None:\n                return None\n            pmid = pmid_elem.text\n\n            # Get title\n            title_elem = elem.find(\".//ArticleTitle\")\n            title = title_elem.text if title_elem is not None else \"\"\n\n            # Get abstract\n            abstract_parts = []\n            for abs_elem in elem.findall(\".//AbstractText\"):\n                label = abs_elem.get(\"Label\", \"\")\n                text = abs_elem.text or \"\"\n                if label:\n                    abstract_parts.append(f\"{label}: {text}\")\n                else:\n                    abstract_parts.append(text)\n            abstract = \" \".join(abstract_parts) if abstract_parts else None\n\n            # Get authors\n            authors = []\n            for author_elem in elem.findall(\".//Author\"):\n                last_name = author_elem.findtext(\"LastName\", \"\")\n                if last_name:\n                    authors.append(\n                        Author(\n                            last_name=last_name,\n                            first_name=author_elem.findtext(\"ForeName\"),\n                            initials=author_elem.findtext(\"Initials\"),\n                            affiliation=author_elem.findtext(\".//AffiliationInfo/Affiliation\"),\n                        )\n                    )\n\n            # Get journal info\n            journal = None\n            journal_elem = elem.find(\".//Journal\")\n            if journal_elem is not None:\n                journal = Journal(\n                    title=journal_elem.findtext(\"Title\", \"\"),\n                    iso_abbreviation=journal_elem.findtext(\"ISOAbbreviation\"),\n                    issn=journal_elem.findtext(\"ISSN\"),\n                    volume=elem.findtext(\".//JournalIssue/Volume\"),\n                    issue=elem.findtext(\".//JournalIssue/Issue\"),\n                    pub_date=self._parse_pub_date(elem.find(\".//JournalIssue/PubDate\")),\n                )\n\n            # Get DOI\n            doi = None\n            for id_elem in elem.findall(\".//ArticleId\"):\n                if id_elem.get(\"IdType\") == \"doi\":\n                    doi = id_elem.text\n\n            # Get PMC ID\n            pmc_id = None\n            for id_elem in elem.findall(\".//ArticleId\"):\n                if id_elem.get(\"IdType\") == \"pmc\":\n                    pmc_id = id_elem.text\n\n            # Get publication types\n            pub_types = [pt.text for pt in elem.findall(\".//PublicationType\") if pt.text]\n\n            # Get MeSH terms\n            mesh_terms = []\n            for mesh_elem in elem.findall(\".//MeshHeading\"):\n                descriptor = mesh_elem.findtext(\"DescriptorName\")\n                if descriptor:\n                    mesh_terms.append(\n                        MeSHTerm(\n                            descriptor=descriptor,\n                            qualifier=mesh_elem.findtext(\"QualifierName\"),\n                            is_major_topic=(\n                                (mesh_elem.find(\"DescriptorName\").get(\"MajorTopicYN\") == \"Y\")\n                                if mesh_elem.find(\"DescriptorName\") is not None\n                                else False\n                            ),\n                        )\n                    )\n\n            # Get keywords\n            keywords = [kw.text for kw in elem.findall(\".//Keyword\") if kw.text]\n\n            # Determine status\n            status = ArticleStatus.ABSTRACT_ONLY\n            if pmc_id:\n                status = ArticleStatus.FULL_TEXT_PMC\n\n            return PubMedArticle(\n                pmid=pmid,\n                title=title,\n                abstract=abstract,\n                authors=authors,\n                journal=journal,\n                pub_date=journal.pub_date if journal else None,\n                doi=doi,\n                pmc_id=pmc_id,\n                publication_types=pub_types,\n                mesh_terms=mesh_terms,\n                keywords=keywords,\n                status=status,\n            )\n\n        except Exception as e:\n            logger.warning(f\"Failed to parse article: {e}\")\n            return None\n\n    def _parse_pub_date(self, date_elem: Optional[ET.Element]) -> Optional[str]:\n        \"\"\"Parse publication date from XML element.\"\"\"\n        if date_elem is None:\n            return None\n\n        year = date_elem.findtext(\"Year\", \"\")\n        month = date_elem.findtext(\"Month\", \"\")\n        day = date_elem.findtext(\"Day\", \"\")\n\n        if year:\n            if month:\n                if day:\n                    return f\"{year}-{month}-{day}\"\n                return f\"{year}-{month}\"\n            return year\n\n        medline_date = date_elem.findtext(\"MedlineDate\")\n        return medline_date\n\n    async def search(\n        self,\n        query: str,\n        max_results: int = 20,\n        publication_types: Optional[List[PublicationType]] = None,\n        date_from: Optional[str] = None,\n        date_to: Optional[str] = None,\n        sort: str = \"relevance\",\n    ) -> SearchResult:\n        \"\"\"\n        Search PubMed articles.\n\n        Args:\n            query: Search query\n            max_results: Maximum results (1-100)\n            publication_types: Filter by publication types\n            date_from: Start date (YYYY/MM/DD)\n            date_to: End date (YYYY/MM/DD)\n            sort: Sort order (relevance, pub_date)\n\n        Returns:\n            SearchResult with articles\n        \"\"\"\n        import time\n\n        start_time = time.time()\n\n        # Build query with filters\n        full_query = query\n\n        if publication_types:\n            type_filter = \" OR \".join(f'\"{pt.value}\"[Publication Type]' for pt in publication_types)\n            full_query = f\"({full_query}) AND ({type_filter})\"\n\n        if date_from or date_to:\n            date_filter = f\"{date_from or '1900/01/01'}:{date_to or '3000'}\"\n            full_query = f\"({full_query}) AND ({date_filter}[Date - Publication])\"\n\n        # Search\n        pmids, total, translation = await self._esearch(full_query, max_results=max_results, sort=sort)\n\n        # Fetch articles\n        articles = await self._efetch(pmids) if pmids else []\n\n        search_time = (time.time() - start_time) * 1000\n\n        logger.info(\n            \"PubMed search completed\",\n            extra={\n                \"query\": query[:50],\n                \"total\": total,\n                \"returned\": len(articles),\n                \"time_ms\": search_time,\n            },\n        )\n\n        return SearchResult(\n            query=query,\n            total_count=total,\n            articles=articles,\n            query_translation=translation,\n            search_time_ms=search_time,\n        )\n\n    async def search_with_mesh(\n        self,\n        query: str,\n        mesh_terms: Optional[List[str]] = None,\n        publication_types: Optional[List[PublicationType]] = None,\n        max_results: int = 20,\n    ) -> SearchResult:\n        \"\"\"\n        Search with MeSH term expansion.\n\n        Args:\n            query: Base search query\n            mesh_terms: Additional MeSH terms to include\n            publication_types: Publication type filters\n            max_results: Maximum results\n\n        Returns:\n            SearchResult\n        \"\"\"\n        full_query = query\n\n        if mesh_terms:\n            mesh_query = \" OR \".join(f'\"{term}\"[MeSH]' for term in mesh_terms)\n            full_query = f\"({full_query}) AND ({mesh_query})\"\n\n        return await self.search(\n            full_query,\n            max_results=max_results,\n            publication_types=publication_types,\n        )\n\n    async def get_article(self, pmid: str) -> Optional[PubMedArticle]:\n        \"\"\"\n        Get single article by PMID.\n\n        Args:\n            pmid: PubMed ID\n\n        Returns:\n            PubMedArticle or None\n        \"\"\"\n        articles = await self._efetch([pmid])\n        return articles[0] if articles else None\n\n    async def get_full_text(self, pmid: str) -> Optional[str]:\n        \"\"\"\n        Get full text from PMC if available.\n\n        Args:\n            pmid: PubMed ID\n\n        Returns:\n            Full text content or None\n        \"\"\"\n        # First, get the PMC ID\n        article = await self.get_article(pmid)\n        if not article or not article.pmc_id:\n            return None\n\n        try:\n            async with self._request_semaphore:\n                client = await self._get_client()\n\n                # Fetch from PMC OAI\n                params = {\n                    \"verb\": \"GetRecord\",\n                    \"identifier\": f\"oai:pubmedcentral.nih.gov:{article.pmc_id}\",\n                    \"metadataPrefix\": \"pmc\",\n                }\n\n                response = await client.get(self.PMC_BASE, params=params)\n                response.raise_for_status()\n\n                # Parse and extract text\n                return self._extract_pmc_text(response.text)\n\n        except Exception as e:\n            logger.warning(f\"Failed to get PMC full text: {e}\")\n            return None\n\n    def _extract_pmc_text(self, xml_text: str) -> Optional[str]:\n        \"\"\"Extract text from PMC XML.\"\"\"\n        try:\n            root = ET.fromstring(xml_text)  # nosec B314 - trusted PMC API\n            body = root.find(\".//{http://jats.nlm.nih.gov}body\")\n            if body is None:\n                body = root.find(\".//body\")\n\n            if body is not None:\n                return ET.tostring(body, encoding=\"unicode\", method=\"text\")\n\n            return None\n        except Exception as e:\n            logger.warning(f\"Failed to extract PMC text: {e}\")\n            return None\n\n    async def find_similar_articles(\n        self,\n        pmid: str,\n        max_results: int = 10,\n    ) -> List[PubMedArticle]:\n        \"\"\"\n        Find similar articles using NCBI's Related Articles.\n\n        Args:\n            pmid: Source PubMed ID\n            max_results: Maximum similar articles\n\n        Returns:\n            List of similar articles\n        \"\"\"\n        related_pmids = await self._elink(pmid, \"pubmed_pubmed\")\n\n        if related_pmids:\n            return await self._efetch(related_pmids[:max_results])\n\n        return []\n\n    async def get_citation_network(\n        self,\n        pmid: str,\n    ) -> CitationNetwork:\n        \"\"\"\n        Build citation network for an article.\n\n        Args:\n            pmid: PubMed ID\n\n        Returns:\n            CitationNetwork with citing and cited articles\n        \"\"\"\n        # Get articles citing this one\n        citing_task = self._elink(pmid, \"pubmed_pubmed_citedin\")\n\n        # Get articles this one cites\n        cited_task = self._elink(pmid, \"pubmed_pubmed_refs\")\n\n        citing, cited = await asyncio.gather(citing_task, cited_task)\n\n        return CitationNetwork(\n            article_pmid=pmid,\n            citing_articles=citing,\n            cited_articles=cited,\n            citation_count=len(citing),\n        )\n\n    async def search_clinical_trials(\n        self,\n        condition: str,\n        intervention: Optional[str] = None,\n        status: Optional[str] = None,\n        max_results: int = 20,\n    ) -> List[ClinicalTrial]:\n        \"\"\"\n        Search clinical trials via PubMed/ClinicalTrials.gov.\n\n        Args:\n            condition: Medical condition\n            intervention: Treatment/intervention\n            status: Trial status (recruiting, completed, etc.)\n            max_results: Maximum results\n\n        Returns:\n            List of clinical trials\n        \"\"\"\n        # Build query for clinical trials\n        query_parts = [f\"{condition}[Condition]\"]\n\n        if intervention:\n            query_parts.append(f\"{intervention}[Intervention]\")\n\n        # Add clinical trial filter\n        query_parts.append('\"Clinical Trial\"[Publication Type]')\n\n        full_query = \" AND \".join(query_parts)\n\n        result = await self.search(full_query, max_results=max_results)\n\n        # Convert to clinical trial format\n        trials = []\n        for article in result.articles:\n            if \"Clinical Trial\" in article.publication_types:\n                trials.append(\n                    ClinicalTrial(\n                        nct_id=article.pmid,  # Will be replaced if NCT found\n                        title=article.title,\n                        status=status or \"unknown\",\n                        condition=condition,\n                        intervention=intervention,\n                        url=f\"https://pubmed.ncbi.nlm.nih.gov/{article.pmid}/\",\n                    )\n                )\n\n        return trials\n\n    async def get_mesh_terms(self, query: str) -> List[str]:\n        \"\"\"\n        Get MeSH terms related to a query.\n\n        Args:\n            query: Search term\n\n        Returns:\n            List of related MeSH terms\n        \"\"\"\n        async with self._request_semaphore:\n            client = await self._get_client()\n            params = {\n                **self._get_base_params(),\n                \"db\": \"mesh\",\n                \"term\": query,\n                \"retmode\": \"json\",\n                \"retmax\": 10,\n            }\n\n            response = await client.get(f\"{self.EUTILS_BASE}/esearch.fcgi\", params=params)\n            response.raise_for_status()\n            data = response.json()\n\n            # Get MeSH UIDs\n            uids = data.get(\"esearchresult\", {}).get(\"idlist\", [])\n            if not uids:\n                return []\n\n            # Fetch MeSH term details\n            fetch_params = {\n                **self._get_base_params(),\n                \"db\": \"mesh\",\n                \"id\": \",\".join(uids),\n                \"retmode\": \"xml\",\n            }\n\n            fetch_response = await client.get(f\"{self.EUTILS_BASE}/efetch.fcgi\", params=fetch_params)\n            fetch_response.raise_for_status()\n\n            # Parse MeSH terms\n            terms = []\n            try:\n                root = ET.fromstring(fetch_response.text)  # nosec B314 - trusted NCBI API\n                for desc in root.findall(\".//DescriptorName/String\"):\n                    if desc.text:\n                        terms.append(desc.text)\n            except Exception:\n                pass\n\n            return terms\n\n    def article_to_dict(self, article: PubMedArticle) -> Dict[str, Any]:\n        \"\"\"Convert article to dictionary for API response.\"\"\"\n        return {\n            \"pmid\": article.pmid,\n            \"title\": article.title,\n            \"abstract\": article.abstract,\n            \"authors\": [\n                {\n                    \"name\": a.full_name,\n                    \"affiliation\": a.affiliation,\n                }\n                for a in article.authors\n            ],\n            \"journal\": (\n                {\n                    \"title\": article.journal.title if article.journal else None,\n                    \"abbreviation\": (article.journal.iso_abbreviation if article.journal else None),\n                    \"volume\": article.journal.volume if article.journal else None,\n                    \"issue\": article.journal.issue if article.journal else None,\n                }\n                if article.journal\n                else None\n            ),\n            \"pub_date\": article.pub_date,\n            \"doi\": article.doi,\n            \"pmc_id\": article.pmc_id,\n            \"publication_types\": article.publication_types,\n            \"mesh_terms\": [{\"descriptor\": m.descriptor, \"is_major\": m.is_major_topic} for m in article.mesh_terms],\n            \"keywords\": article.keywords,\n            \"has_full_text\": article.has_full_text,\n            \"citation\": article.citation,\n            \"url\": f\"https://pubmed.ncbi.nlm.nih.gov/{article.pmid}/\",\n        }\n\n\n# Global service instance\npubmed_service = EnhancedPubMedService()\n"
}
