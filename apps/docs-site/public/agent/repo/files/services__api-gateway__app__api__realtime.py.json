{
  "path": "services/api-gateway/app/api/realtime.py",
  "language": "python",
  "size": 26525,
  "last_modified": "2025-12-04T11:26:48.947Z",
  "lines": 720,
  "content": "\"\"\"\nRealtime WebSocket API for streaming chat and future voice integration.\n\nThis module provides WebSocket endpoints for real-time communication between\nthe client and the backend. In Phase 4 MVP, it supports text-based streaming.\n\nVoice/TTS integration plan (to be implemented):\n- Add authenticated WS path for audio: accept PCM/Opus chunks, forward to ASR (OpenAI Realtime/local ASR)\n- Emit interim transcripts as `transcript.partial` and final as `transcript.final`\n- Support TTS responses via REST/WS: synthesize assistant replies and stream audio chunks\n- Heartbeats + backpressure: ping/pong and max in-flight frames to avoid buffer bloat\n- Metrics: connection counts, audio duration, ASR/TTS latency, error rates\nFuture phases will add voice streaming, VAD, and OpenAI Realtime API integration.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict\n\nfrom app.core.business_metrics import rag_citations_per_query, rag_queries_total\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.core.logging import get_logger\nfrom app.core.security import verify_token\nfrom app.models.message import Message\nfrom app.models.session import Session as ChatSession\nfrom app.models.user import User\nfrom app.schemas.websocket import (\n    create_chunk_event,\n    create_connected_event,\n    create_error_event,\n    create_message_done_event,\n    create_pong_event,\n)\nfrom app.services.rag_service import QueryOrchestrator, QueryRequest\nfrom app.services.webrtc_signaling import signaling_service\nfrom fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\nfrom starlette.websockets import WebSocketState\n\nrouter = APIRouter(prefix=\"/api/realtime\", tags=[\"realtime\"])\nlogger = get_logger(__name__)\n\n\ndef is_websocket_connected(websocket: WebSocket) -> bool:\n    \"\"\"Check if WebSocket is still in a connected state and can receive messages.\"\"\"\n    try:\n        return (\n            websocket.client_state == WebSocketState.CONNECTED\n            and websocket.application_state == WebSocketState.CONNECTED\n        )\n    except Exception:\n        return False\n\n\nasync def safe_send_json(websocket: WebSocket, data: Dict[str, Any]) -> bool:\n    \"\"\"Safely send JSON to WebSocket, returning False if the socket is closed.\n\n    Args:\n        websocket: The WebSocket connection\n        data: The data to send as JSON\n\n    Returns:\n        True if send succeeded, False if socket was closed or error occurred\n    \"\"\"\n    if not is_websocket_connected(websocket):\n        logger.warning(\"Attempted to send on closed WebSocket, skipping\")\n        return False\n\n    try:\n        await websocket.send_json(data)\n        return True\n    except RuntimeError as e:\n        if \"close message has been sent\" in str(e).lower():\n            logger.warning(\"WebSocket already closed, cannot send message\")\n        else:\n            logger.error(f\"RuntimeError sending WebSocket message: {e}\")\n        return False\n    except WebSocketDisconnect:\n        logger.warning(\"WebSocket disconnected during send\")\n        return False\n    except Exception as e:\n        logger.error(f\"Unexpected error sending WebSocket message: {e}\")\n        return False\n\n\n# Global QueryOrchestrator instance\nquery_orchestrator = QueryOrchestrator()\n\n\nclass ConnectionManager:\n    \"\"\"\n    Manages active WebSocket connections.\n\n    Handles connection lifecycle, message broadcasting, and connection cleanup.\n    \"\"\"\n\n    def __init__(self):\n        self.active_connections: Dict[str, WebSocket] = {}\n\n    async def connect(self, websocket: WebSocket, client_id: str):\n        \"\"\"Accept and register a new WebSocket connection.\"\"\"\n        await websocket.accept()\n        self.active_connections[client_id] = websocket\n        logger.info(f\"WebSocket connected: {client_id}\")\n\n    def disconnect(self, client_id: str):\n        \"\"\"Remove a WebSocket connection.\"\"\"\n        if client_id in self.active_connections:\n            del self.active_connections[client_id]\n            logger.info(f\"WebSocket disconnected: {client_id}\")\n\n    async def send_personal_message(self, message: Dict[str, Any], client_id: str) -> bool:\n        \"\"\"Send a message to a specific client.\n\n        Returns:\n            True if send succeeded, False if client not found or socket closed\n        \"\"\"\n        if client_id not in self.active_connections:\n            logger.warning(f\"Client {client_id} not found in active connections\")\n            return False\n\n        websocket = self.active_connections[client_id]\n        return await safe_send_json(websocket, message)\n\n    async def send_error(self, client_id: str, error_code: str, error_message: str) -> bool:\n        \"\"\"Send an error message to a client.\n\n        Returns:\n            True if send succeeded, False if client not found or socket closed\n        \"\"\"\n        error_msg = {\n            \"type\": \"error\",\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            \"error\": {\"code\": error_code, \"message\": error_message},\n        }\n        return await self.send_personal_message(error_msg, client_id)\n\n\n# Global connection manager instance\nmanager = ConnectionManager()\n\n\nclass WebRTCOffer(BaseModel):\n    session_id: str\n    sdp: str\n\n\nclass WebRTCAnswer(BaseModel):\n    session_id: str\n    sdp: str\n\n\nclass ICECandidatePayload(BaseModel):\n    session_id: str\n    candidate: dict\n\n\nclass WebRTCSessionResponse(BaseModel):\n    session_id: str\n    offer: str | None = None\n    answer: str | None = None\n    ice_candidates: list[dict]\n    processing: dict\n\n\n@router.post(\"/webrtc/offer\", response_model=WebRTCSessionResponse)\nasync def post_webrtc_offer(payload: WebRTCOffer, current_user: User = Depends(get_current_user)):\n    session = signaling_service.register_offer(\n        session_id=payload.session_id, user_id=str(current_user.id), sdp=payload.sdp\n    )\n    return WebRTCSessionResponse(\n        session_id=session.session_id,\n        offer=session.offer_sdp,\n        answer=session.answer_sdp,\n        ice_candidates=session.ice_candidates,\n        processing={\n            \"vad_threshold\": session.vad_threshold,\n            \"noise_suppression\": session.noise_suppression,\n        },\n    )\n\n\n@router.post(\"/webrtc/answer\", response_model=WebRTCSessionResponse)\nasync def post_webrtc_answer(payload: WebRTCAnswer, current_user: User = Depends(get_current_user)):\n    session = signaling_service.register_answer(\n        session_id=payload.session_id, user_id=str(current_user.id), sdp=payload.sdp\n    )\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Unknown WebRTC session\")\n\n    return WebRTCSessionResponse(\n        session_id=session.session_id,\n        offer=session.offer_sdp,\n        answer=session.answer_sdp,\n        ice_candidates=session.ice_candidates,\n        processing={\n            \"vad_threshold\": session.vad_threshold,\n            \"noise_suppression\": session.noise_suppression,\n        },\n    )\n\n\n@router.post(\"/webrtc/candidate\", response_model=WebRTCSessionResponse)\nasync def post_webrtc_candidate(payload: ICECandidatePayload, current_user: User = Depends(get_current_user)):\n    session = signaling_service.add_ice_candidate(\n        session_id=payload.session_id,\n        user_id=str(current_user.id),\n        candidate=payload.candidate,\n    )\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Unknown WebRTC session\")\n\n    return WebRTCSessionResponse(\n        session_id=session.session_id,\n        offer=session.offer_sdp,\n        answer=session.answer_sdp,\n        ice_candidates=session.ice_candidates,\n        processing={\n            \"vad_threshold\": session.vad_threshold,\n            \"noise_suppression\": session.noise_suppression,\n        },\n    )\n\n\n@router.get(\"/webrtc/{session_id}\", response_model=WebRTCSessionResponse)\nasync def get_webrtc_state(session_id: str, current_user: User = Depends(get_current_user)):\n    session = signaling_service.get_session(session_id)\n    if not session:\n        raise HTTPException(status_code=404, detail=\"WebRTC session not found\")\n\n    return WebRTCSessionResponse(\n        session_id=session.session_id,\n        offer=session.offer_sdp,\n        answer=session.answer_sdp,\n        ice_candidates=session.ice_candidates,\n        processing={\n            \"vad_threshold\": session.vad_threshold,\n            \"noise_suppression\": session.noise_suppression,\n        },\n    )\n\n\n@router.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket, db: Session = Depends(get_db)):\n    \"\"\"\n    WebSocket endpoint for realtime chat communication.\n\n    Query Parameters:\n    - token: JWT access token for authentication (required)\n    - conversationId: Conversation/session ID to connect to (optional)\n\n    Message Protocol (Updated to match frontend expectations):\n    ----------------------------------------------------------\n\n    Client -> Server:\n    {\n        \"type\": \"message\",\n        \"content\": \"User's message text\",\n        \"session_id\": \"optional-session-uuid\",\n        \"clinical_context\": {...}  // optional\n    }\n\n    {\n        \"type\": \"ping\"\n    }\n\n    Server -> Client:\n    {\n        \"type\": \"connected\",\n        \"client_id\": \"uuid\",\n        \"timestamp\": \"2025-11-22T00:00:00.000Z\",\n        \"protocol_version\": \"1.0\",\n        \"capabilities\": [\"text_streaming\"]\n    }\n\n    {\n        \"type\": \"history\",\n        \"messages\": [...]  // Previous messages if conversationId provided\n    }\n\n    {\n        \"type\": \"chunk\",\n        \"messageId\": \"uuid\",\n        \"content\": \"Partial response text...\"\n    }\n\n    {\n        \"type\": \"message.done\",\n        \"messageId\": \"uuid\",\n        \"message\": {\n            \"id\": \"uuid\",\n            \"role\": \"assistant\",\n            \"content\": \"Complete response text\",\n            \"citations\": [...],\n            \"timestamp\": 1700000000000  // Unix timestamp in milliseconds\n        },\n        \"timestamp\": \"2025-11-22T00:00:05.000Z\"\n    }\n\n    {\n        \"type\": \"error\",\n        \"messageId\": \"uuid\",\n        \"error\": {\n            \"code\": \"BACKEND_ERROR\",\n            \"message\": \"Error description\"\n        }\n    }\n\n    {\n        \"type\": \"pong\",\n        \"timestamp\": \"2025-11-22T00:00:00.000Z\"\n    }\n\n    Future phases will add:\n    - Voice streaming events (audio_start, audio_chunk, audio_end)\n    - VAD events (speech_start, speech_end)\n    - Turn-taking events (interrupt, resume)\n    \"\"\"\n    import uuid as uuid_module\n\n    # Authenticate via query param token\n    token = websocket.query_params.get(\"token\")\n    conversation_id = websocket.query_params.get(\"conversationId\")\n\n    if not token:\n        await websocket.accept()\n        error_event = create_error_event(\n            error_code=\"UNAUTHORIZED\",\n            error_message=\"Missing authentication token\",\n            timestamp=datetime.now(timezone.utc),\n        )\n        await websocket.send_json(error_event)\n        await websocket.close(code=1008)  # Policy Violation\n        return\n\n    # Verify JWT token\n    payload = verify_token(token)\n    if not payload or payload.get(\"type\") != \"access\":\n        await websocket.accept()\n        error_event = create_error_event(\n            error_code=\"UNAUTHORIZED\",\n            error_message=\"Invalid or expired token\",\n            timestamp=datetime.now(timezone.utc),\n        )\n        await websocket.send_json(error_event)\n        await websocket.close(code=1008)\n        return\n\n    user_id = payload.get(\"sub\")\n    if not user_id:\n        await websocket.accept()\n        error_event = create_error_event(\n            error_code=\"UNAUTHORIZED\",\n            error_message=\"Invalid token payload\",\n            timestamp=datetime.now(timezone.utc),\n        )\n        await websocket.send_json(error_event)\n        await websocket.close(code=1008)\n        return\n\n    # Verify user exists and is active\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        await websocket.accept()\n        error_event = create_error_event(\n            error_code=\"UNAUTHORIZED\",\n            error_message=\"User not found\",\n            timestamp=datetime.now(timezone.utc),\n        )\n        await websocket.send_json(error_event)\n        await websocket.close(code=1008)\n        return\n\n    # Check if user is active\n    if not user.is_active:\n        await websocket.accept()\n        error_event = create_error_event(\n            error_code=\"FORBIDDEN\",\n            error_message=\"User account is deactivated\",\n            timestamp=datetime.now(timezone.utc),\n        )\n        await websocket.send_json(error_event)\n        await websocket.close(code=1008)\n        return\n\n    # Use user ID as client ID for authenticated sessions\n    client_id = str(user_id)\n\n    # Verify conversation ownership if conversationId provided\n    session_obj: ChatSession | None = None\n    if conversation_id:\n        try:\n            session_uuid = uuid_module.UUID(conversation_id)\n            session_obj = db.query(ChatSession).filter(ChatSession.id == session_uuid).first()\n            if session_obj and str(session_obj.user_id) != str(user_id):\n                await websocket.accept()\n                error_event = create_error_event(\n                    error_code=\"FORBIDDEN\",\n                    error_message=\"Access denied to conversation\",\n                    timestamp=datetime.now(timezone.utc),\n                )\n                await websocket.send_json(error_event)\n                await websocket.close(code=1008)\n                return\n        except ValueError:\n            # Invalid UUID format, ignore and proceed without session\n            logger.warning(f\"Invalid conversation ID format: {conversation_id}\")\n\n    await manager.connect(websocket, client_id)\n\n    try:\n        # Send welcome message using schema\n        connected_event = create_connected_event(client_id=client_id, timestamp=datetime.now(timezone.utc))\n        await websocket.send_json(connected_event)\n\n        # Send message history if conversation exists\n        if session_obj:\n            messages = (\n                db.query(Message)\n                .filter(Message.session_id == session_obj.id)\n                .order_by(Message.created_at.asc())\n                .limit(100)  # Limit history to last 100 messages\n                .all()\n            )\n            if messages:\n                history_messages = []\n                for msg in messages:\n                    msg_dict = {\n                        \"id\": str(msg.id),\n                        \"role\": msg.role,\n                        \"content\": msg.content,\n                        \"timestamp\": (int(msg.created_at.timestamp() * 1000) if msg.created_at else 0),\n                    }\n                    # Include citations from metadata if present\n                    if msg.message_metadata and \"citations\" in msg.message_metadata:\n                        msg_dict[\"citations\"] = msg.message_metadata[\"citations\"]\n                    history_messages.append(msg_dict)\n\n                history_event = {\n                    \"type\": \"history\",\n                    \"messages\": history_messages,\n                    \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n                }\n                await websocket.send_json(history_event)\n\n        logger.info(\n            \"WebSocket authenticated and connected\",\n            extra={\n                \"client_id\": client_id,\n                \"user_id\": user_id,\n                \"conversation_id\": conversation_id,\n                \"history_loaded\": session_obj is not None,\n            },\n        )\n\n        while True:\n            # Receive message from client\n            data = await websocket.receive_json()\n            message_type = data.get(\"type\")\n\n            logger.info(\n                \"Received WebSocket message\",\n                extra={\n                    \"client_id\": client_id,\n                    \"message_type\": message_type,\n                    \"user_id\": user_id,\n                },\n            )\n\n            if message_type == \"message\":\n                # Override session_id with the authenticated conversation if not provided\n                if session_obj and not data.get(\"session_id\"):\n                    data[\"session_id\"] = str(session_obj.id)\n                # Pass user_id for ownership validation\n                data[\"_user_id\"] = user_id\n                # Process chat message\n                await handle_chat_message(websocket, client_id, data, db)\n\n            elif message_type == \"ping\":\n                # Respond to ping for connection keepalive using schema\n                pong_event = create_pong_event(timestamp=datetime.now(timezone.utc))\n                await websocket.send_json(pong_event)\n\n            else:\n                # Unknown message type\n                await manager.send_error(\n                    client_id,\n                    \"UNKNOWN_MESSAGE_TYPE\",\n                    f\"Unknown message type: {message_type}\",\n                )\n\n    except WebSocketDisconnect:\n        manager.disconnect(client_id)\n        logger.info(f\"Client disconnected: {client_id}\", extra={\"user_id\": user_id})\n\n    except Exception as e:\n        logger.error(f\"WebSocket error: {str(e)}\", exc_info=True, extra={\"user_id\": user_id})\n        # Try to send error, but don't fail if socket is already closed\n        await manager.send_error(client_id, \"INTERNAL_ERROR\", str(e))\n        manager.disconnect(client_id)\n\n\nasync def handle_chat_message(websocket: WebSocket, client_id: str, data: Dict[str, Any], db: Session):\n    \"\"\"\n    Handle incoming chat message and stream response using QueryOrchestrator.\n\n    Integrates with the QueryOrchestrator to process clinical queries and\n    stream responses back to the client in chunks.\n    \"\"\"\n    import uuid\n\n    message_id = str(uuid.uuid4())\n    user_message = data.get(\"content\", \"\")\n    session_id = data.get(\"session_id\")\n    clinical_context_id = data.get(\"clinical_context_id\")\n    attachments = data.get(\"attachments\") or []\n    # Client-provided message ID for idempotency and attachment sync\n    client_message_id = data.get(\"client_message_id\")\n    # User ID passed from authenticated WebSocket handler\n    user_id = data.get(\"_user_id\")\n\n    logger.info(\n        \"Processing chat message\",\n        extra={\n            \"client_id\": client_id,\n            \"message_id\": message_id,\n            \"has_session\": bool(session_id),\n            \"has_context\": bool(clinical_context_id),\n            \"user_id\": user_id,\n        },\n    )\n\n    # Note: Frontend expects specific event types and camelCase field names\n    # Changed to match frontend protocol in useChatSession.ts\n\n    try:\n        # Validate session if provided\n        session_obj: ChatSession | None = None\n        if session_id:\n            try:\n                session_uuid = uuid.UUID(session_id)\n                session_obj = db.query(ChatSession).filter(ChatSession.id == session_uuid).first()\n                if not session_obj:\n                    await manager.send_error(\n                        client_id,\n                        \"INVALID_SESSION\",\n                        f\"Session {session_id} not found\",\n                    )\n                    return\n                # Verify session ownership if user_id is available\n                if user_id and str(session_obj.user_id) != str(user_id):\n                    await manager.send_error(\n                        client_id,\n                        \"FORBIDDEN\",\n                        \"Access denied to this conversation\",\n                    )\n                    return\n            except ValueError:\n                await manager.send_error(\n                    client_id,\n                    \"INVALID_SESSION_ID\",\n                    f\"Session id {session_id} is not a valid UUID\",\n                )\n                return\n\n        # Persist user message for history\n        user_db_message_id = None\n        if session_obj:\n            user_message_row = Message(\n                session_id=session_obj.id,\n                role=\"user\",\n                content=user_message,\n                client_message_id=client_message_id,  # Store client ID for attachment sync\n                message_metadata={\n                    \"source\": \"realtime_ws\",\n                    \"clinical_context_id\": clinical_context_id,\n                    \"attachments\": attachments,\n                },\n            )\n            db.add(user_message_row)\n            session_obj.message_count = (session_obj.message_count or 0) + 1\n            db.commit()\n            db.refresh(user_message_row)\n            user_db_message_id = str(user_message_row.id)\n            logger.info(\n                \"Persisted realtime user message\",\n                extra={\n                    \"session_id\": session_id,\n                    \"message_id\": user_db_message_id,\n                    \"client_message_id\": client_message_id,\n                },\n            )\n\n            # Send user_message.created event so frontend can sync message ID for attachments\n            user_created_event = {\n                \"type\": \"user_message.created\",\n                \"messageId\": user_db_message_id,\n                \"clientMessageId\": client_message_id,\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            }\n            await safe_send_json(websocket, user_created_event)\n\n        # Create query request for orchestrator\n        query_request = QueryRequest(\n            session_id=session_id,\n            query=user_message,\n            clinical_context_id=clinical_context_id,\n        )\n\n        async def stream_chunk(chunk: str):\n            chunk_event = create_chunk_event(message_id=message_id, content=chunk)\n            await safe_send_json(websocket, chunk_event)\n\n        # Stream LLM response with real-time chunks\n        query_response = await query_orchestrator.stream_query(\n            query_request, trace_id=message_id, on_chunk=stream_chunk\n        )\n\n        # Prepare citations for response with full structured data\n        # Use both snake_case (for schema) and camelCase (for frontend) field names\n        citations = []\n        for cite in query_response.citations:\n            citation_dict = {\n                \"id\": cite.id,\n                \"sourceId\": cite.source_id,\n                \"source_id\": cite.source_id,  # Also include snake_case\n                \"sourceType\": cite.source_type,\n                \"source_type\": cite.source_type,  # Also include snake_case\n                \"title\": cite.title,\n                \"url\": cite.url if cite.url else None,\n                \"authors\": cite.authors if hasattr(cite, \"authors\") else None,\n                \"publicationYear\": (cite.publication_date if hasattr(cite, \"publication_date\") else None),\n                \"publication_date\": (cite.publication_date if hasattr(cite, \"publication_date\") else None),\n                \"journal\": cite.journal if hasattr(cite, \"journal\") else None,\n                \"doi\": cite.doi if hasattr(cite, \"doi\") else None,\n                \"pubmedId\": cite.pmid if hasattr(cite, \"pmid\") else None,\n                \"pmid\": cite.pmid if hasattr(cite, \"pmid\") else None,\n                \"relevanceScore\": (cite.relevance_score if hasattr(cite, \"relevance_score\") else None),\n                \"relevance_score\": (cite.relevance_score if hasattr(cite, \"relevance_score\") else None),\n                \"snippet\": cite.quoted_text if hasattr(cite, \"quoted_text\") else None,\n                \"quoted_text\": (cite.quoted_text if hasattr(cite, \"quoted_text\") else None),\n                # Backward compatibility fields for older frontend code\n                \"source\": cite.source_type,\n                \"reference\": cite.title,\n            }\n            citations.append(citation_dict)\n\n        # Use schema to create message.done event\n        now = datetime.now(timezone.utc)\n        message_done_event = create_message_done_event(\n            message_id=message_id,\n            role=\"assistant\",\n            content=query_response.answer,\n            citations=citations,\n            timestamp=now,\n        )\n\n        # Use safe send for the final message.done event\n        await safe_send_json(websocket, message_done_event)\n\n        # Persist assistant message for history\n        if session_obj:\n            assistant_metadata = {\n                \"source\": \"realtime_ws\",\n                \"citations\": citations,\n                \"clinical_context_id\": clinical_context_id,\n                \"user_message_id\": user_db_message_id,\n                \"finish_reason\": query_response.finish_reason,\n            }\n            assistant_message_row = Message(\n                session_id=session_obj.id,\n                role=\"assistant\",\n                content=query_response.answer,\n                tokens=query_response.tokens,\n                model=query_response.model,\n                message_metadata=assistant_metadata,\n            )\n            db.add(assistant_message_row)\n            session_obj.message_count = (session_obj.message_count or 0) + 1\n            db.commit()\n            logger.info(\n                \"Persisted realtime assistant message\",\n                extra={\n                    \"session_id\": session_id,\n                    \"message_id\": str(assistant_message_row.id),\n                },\n            )\n\n        # Track RAG query metrics (P3.3 - Business Metrics)\n        has_citations = len(citations) > 0\n        rag_queries_total.labels(success=\"true\", has_citations=str(has_citations).lower()).inc()\n        rag_citations_per_query.observe(len(citations))\n\n        logger.info(\n            \"Completed streaming response\",\n            extra={\n                \"client_id\": client_id,\n                \"message_id\": message_id,\n                \"response_length\": len(query_response.answer),\n                \"citation_count\": len(citations),\n            },\n        )\n\n    except Exception as e:\n        # Track failed RAG query (P3.3 - Business Metrics)\n        rag_queries_total.labels(success=\"false\", has_citations=\"false\").inc()\n\n        logger.error(f\"Error processing chat message: {str(e)}\", exc_info=True)\n\n        # Use schema to create error event\n        error_event = create_error_event(\n            error_code=\"BACKEND_ERROR\",\n            error_message=f\"Failed to process query: {str(e)}\",\n            message_id=message_id,\n            timestamp=datetime.now(timezone.utc),\n        )\n        # Use safe send to avoid RuntimeError if socket is already closed\n        await safe_send_json(websocket, error_event)\n"
}
