{
  "path": "services/api-gateway/app/services/translation_service.py",
  "language": "python",
  "size": 15870,
  "last_modified": "2025-12-04T18:47:50.955Z",
  "lines": 425,
  "content": "\"\"\"\nTranslation Service with Graceful Fallback\nProvides translation capabilities with caching and multi-provider fallback.\n\nPart of Voice Mode Enhancement Plan v4.1\nReference: /home/asimo/.claude/plans/noble-bubbling-trinket.md#translation-fallback--error-handling\n\"\"\"\n\nimport asyncio\nimport hashlib\nimport logging\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom app.core.config import settings\nfrom app.services.cache_service import CacheService\nfrom redis.asyncio import Redis\n\nlogger = logging.getLogger(__name__)\n\n\nclass LanguageCode(str, Enum):\n    \"\"\"Supported language codes.\"\"\"\n\n    EN = \"en\"\n    ES = \"es\"\n    FR = \"fr\"\n    DE = \"de\"\n    IT = \"it\"\n    PT = \"pt\"\n    AR = \"ar\"\n    ZH = \"zh\"\n    HI = \"hi\"\n    UR = \"ur\"\n\n\n@dataclass\nclass TranslationResult:\n    \"\"\"Result of a translation operation.\"\"\"\n\n    text: str\n    source_language: str\n    target_language: str\n    from_cache: bool = False\n    used_fallback: bool = False\n    failed: bool = False\n    error_message: Optional[str] = None\n    latency_ms: float = 0.0\n    provider: Optional[str] = None\n\n\n@dataclass\nclass TranslationMetrics:\n    \"\"\"Metrics for translation operations.\"\"\"\n\n    total_requests: int = 0\n    cache_hits: int = 0\n    primary_successes: int = 0\n    fallback_successes: int = 0\n    total_failures: int = 0\n    avg_latency_ms: float = 0.0\n\n\nclass TranslationProvider:\n    \"\"\"Base class for translation providers.\"\"\"\n\n    async def translate(self, text: str, source: str, target: str) -> str:\n        \"\"\"Translate text from source to target language.\"\"\"\n        raise NotImplementedError\n\n\nclass GoogleTranslateProvider(TranslationProvider):\n    \"\"\"Google Cloud Translation API provider.\"\"\"\n\n    def __init__(self, api_key: Optional[str] = None):\n        self.api_key = api_key or settings.google_translate_api_key\n        self.base_url = \"https://translation.googleapis.com/language/translate/v2\"\n\n    async def translate(self, text: str, source: str, target: str) -> str:\n        \"\"\"Translate using Google Cloud Translation API.\"\"\"\n        if not self.api_key:\n            raise TranslationError(\"Google Translate API key not configured\")\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                self.base_url,\n                params={\"key\": self.api_key},\n                json={\"q\": text, \"source\": source, \"target\": target, \"format\": \"text\"},\n                timeout=5.0,\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data[\"data\"][\"translations\"][0][\"translatedText\"]\n\n\nclass DeepLTranslateProvider(TranslationProvider):\n    \"\"\"DeepL Translation API provider.\"\"\"\n\n    # DeepL language code mapping\n    LANGUAGE_MAP = {\n        \"en\": \"EN\",\n        \"es\": \"ES\",\n        \"fr\": \"FR\",\n        \"de\": \"DE\",\n        \"it\": \"IT\",\n        \"pt\": \"PT-PT\",\n        \"ar\": \"AR\",  # Note: DeepL has limited Arabic support\n        \"zh\": \"ZH\",\n        \"hi\": \"HI\",  # Note: DeepL may not support Hindi\n        \"ur\": \"UR\",  # Note: DeepL may not support Urdu\n    }\n\n    def __init__(self, api_key: Optional[str] = None):\n        self.api_key = api_key or settings.deepl_api_key\n        self.base_url = \"https://api-free.deepl.com/v2/translate\"\n\n    async def translate(self, text: str, source: str, target: str) -> str:\n        \"\"\"Translate using DeepL API.\"\"\"\n        if not self.api_key:\n            raise TranslationError(\"DeepL API key not configured\")\n\n        source_lang = self.LANGUAGE_MAP.get(source, source.upper())\n        target_lang = self.LANGUAGE_MAP.get(target, target.upper())\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                self.base_url,\n                headers={\"Authorization\": f\"DeepL-Auth-Key {self.api_key}\"},\n                data={\"text\": text, \"source_lang\": source_lang, \"target_lang\": target_lang},\n                timeout=5.0,\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data[\"translations\"][0][\"text\"]\n\n\nclass TranslationError(Exception):\n    \"\"\"Exception raised when translation fails.\"\"\"\n\n    pass\n\n\nclass TranslationService:\n    \"\"\"\n    Translation service with caching and graceful fallback.\n\n    Features:\n    - Multi-provider support with automatic fallback\n    - Redis caching for common translations (7-day TTL)\n    - Graceful degradation with user-friendly error messages\n    - Latency tracking and metrics\n    \"\"\"\n\n    COMMON_TRANSLATIONS_CACHE_TTL = 86400 * 7  # 7 days\n\n    # Fallback messages for when all translation providers fail\n    FALLBACK_MESSAGES: Dict[str, str] = {\n        \"en\": \"Translation temporarily unavailable. Please try again.\",\n        \"es\": \"Traducción no disponible temporalmente. Por favor, inténtelo de nuevo.\",\n        \"fr\": \"Traduction temporairement indisponible. Veuillez réessayer.\",\n        \"de\": \"Übersetzung vorübergehend nicht verfügbar. Bitte versuchen Sie es erneut.\",\n        \"it\": \"Traduzione temporaneamente non disponibile. Per favore riprova.\",\n        \"pt\": \"Tradução temporariamente indisponível. Por favor, tente novamente.\",\n        \"ar\": \"الترجمة غير متوفرة مؤقتاً. يرجى المحاولة مرة أخرى.\",\n        \"zh\": \"翻译暂时不可用。请重试。\",\n        \"hi\": \"अनुवाद अस्थायी रूप से अनुपलब्ध है। कृपया पुनः प्रयास करें।\",\n        \"ur\": \"ترجمہ عارضی طور پر دستیاب نہیں ہے۔ براہ کرم دوبارہ کوشش کریں۔\",\n    }\n\n    # Common medical phrases to pre-cache\n    COMMON_PHRASES: List[str] = [\n        \"How can I help you today?\",\n        \"Please describe your symptoms.\",\n        \"Do you have any allergies?\",\n        \"Are you currently taking any medications?\",\n        \"When did the symptoms start?\",\n        \"On a scale of 1 to 10, how would you rate your pain?\",\n        \"I understand. Let me help you with that.\",\n        \"Please wait while I process your request.\",\n        \"Thank you for your patience.\",\n        \"Is there anything else I can help you with?\",\n    ]\n\n    def __init__(\n        self,\n        cache_service: Optional[CacheService] = None,\n        redis_client: Optional[Redis] = None,\n        primary_provider: Optional[TranslationProvider] = None,\n        fallback_provider: Optional[TranslationProvider] = None,\n    ):\n        self.cache = cache_service\n        self.redis = redis_client\n        self.providers = {\n            \"primary\": primary_provider or GoogleTranslateProvider(),\n            \"fallback\": fallback_provider or DeepLTranslateProvider(),\n        }\n        self.metrics = TranslationMetrics()\n\n    def _generate_cache_key(self, text: str, source: str, target: str) -> str:\n        \"\"\"Generate a cache key for a translation.\"\"\"\n        # Use first 100 chars of text for hash to keep keys manageable\n        text_hash = hashlib.sha256(text[:100].encode()).hexdigest()[:16]\n        return f\"translation:{source}:{target}:{text_hash}\"\n\n    async def translate(\n        self, text: str, source: LanguageCode | str, target: LanguageCode | str, timeout_seconds: float = 2.0\n    ) -> TranslationResult:\n        \"\"\"\n        Translate text with fallback handling.\n\n        Args:\n            text: Text to translate\n            source: Source language code\n            target: Target language code\n            timeout_seconds: Timeout for each provider attempt\n\n        Returns:\n            TranslationResult with translated text or error info\n        \"\"\"\n        import time\n\n        start_time = time.monotonic()\n        self.metrics.total_requests += 1\n\n        # Convert enum to string if needed\n        source_str = source.value if isinstance(source, LanguageCode) else source\n        target_str = target.value if isinstance(target, LanguageCode) else target\n\n        # 1. Check cache first\n        cache_key = self._generate_cache_key(text, source_str, target_str)\n        if self.redis:\n            try:\n                cached = await self.redis.get(cache_key)\n                if cached:\n                    self.metrics.cache_hits += 1\n                    logger.debug(f\"Translation cache hit for {cache_key}\")\n                    return TranslationResult(\n                        text=cached.decode() if isinstance(cached, bytes) else cached,\n                        source_language=source_str,\n                        target_language=target_str,\n                        from_cache=True,\n                        latency_ms=(time.monotonic() - start_time) * 1000,\n                    )\n            except Exception as e:\n                logger.warning(f\"Cache lookup failed: {e}\")\n\n        # 2. Try primary provider\n        try:\n            result = await asyncio.wait_for(\n                self.providers[\"primary\"].translate(text, source_str, target_str), timeout=timeout_seconds\n            )\n            self.metrics.primary_successes += 1\n\n            # Cache the result\n            await self._cache_translation(cache_key, result, text)\n\n            return TranslationResult(\n                text=result,\n                source_language=source_str,\n                target_language=target_str,\n                from_cache=False,\n                latency_ms=(time.monotonic() - start_time) * 1000,\n                provider=\"primary\",\n            )\n\n        except (TranslationError, asyncio.TimeoutError, httpx.HTTPError) as e:\n            logger.warning(f\"Primary translation provider failed: {e}\")\n\n            # 3. Try fallback provider\n            try:\n                result = await asyncio.wait_for(\n                    self.providers[\"fallback\"].translate(text, source_str, target_str),\n                    timeout=timeout_seconds + 1.0,  # Slightly longer timeout for fallback\n                )\n                self.metrics.fallback_successes += 1\n\n                # Cache the result\n                await self._cache_translation(cache_key, result, text)\n\n                return TranslationResult(\n                    text=result,\n                    source_language=source_str,\n                    target_language=target_str,\n                    from_cache=False,\n                    used_fallback=True,\n                    latency_ms=(time.monotonic() - start_time) * 1000,\n                    provider=\"fallback\",\n                )\n\n            except Exception as fallback_error:\n                logger.error(f\"All translation providers failed: {fallback_error}\")\n                self.metrics.total_failures += 1\n\n                # 4. Return original text with error message\n                return TranslationResult(\n                    text=text,  # Return original text\n                    source_language=source_str,\n                    target_language=target_str,\n                    failed=True,\n                    error_message=self.FALLBACK_MESSAGES.get(target_str, self.FALLBACK_MESSAGES[\"en\"]),\n                    latency_ms=(time.monotonic() - start_time) * 1000,\n                )\n\n    async def translate_with_fallback(\n        self, text: str, source: LanguageCode | str, target: LanguageCode | str\n    ) -> TranslationResult:\n        \"\"\"\n        Convenience method matching the plan API.\n        Alias for translate() with default timeout.\n        \"\"\"\n        return await self.translate(text, source, target)\n\n    async def _cache_translation(self, cache_key: str, result: str, original_text: str) -> None:\n        \"\"\"Cache translation if appropriate (short common phrases).\"\"\"\n        if not self.redis:\n            return\n\n        try:\n            # Cache short phrases (likely to be reused)\n            if len(original_text) < 200:\n                await self.redis.setex(cache_key, self.COMMON_TRANSLATIONS_CACHE_TTL, result)\n                logger.debug(f\"Cached translation: {cache_key}\")\n        except Exception as e:\n            logger.warning(f\"Failed to cache translation: {e}\")\n\n    async def pre_cache_common_phrases(self, languages: List[str] = None) -> Dict[str, int]:\n        \"\"\"\n        Pre-cache common medical phrases for specified languages.\n\n        Args:\n            languages: List of target language codes (default: all supported)\n\n        Returns:\n            Dict with language codes and number of phrases cached\n        \"\"\"\n        if languages is None:\n            languages = [lang.value for lang in LanguageCode if lang != LanguageCode.EN]\n\n        cached_counts = {}\n\n        for lang in languages:\n            count = 0\n            for phrase in self.COMMON_PHRASES:\n                try:\n                    result = await self.translate(phrase, \"en\", lang, timeout_seconds=5.0)\n                    if not result.failed:\n                        count += 1\n                except Exception as e:\n                    logger.warning(f\"Failed to pre-cache '{phrase}' for {lang}: {e}\")\n\n            cached_counts[lang] = count\n            logger.info(f\"Pre-cached {count} phrases for {lang}\")\n\n        return cached_counts\n\n    async def detect_language(self, text: str) -> str:\n        \"\"\"\n        Detect the language of input text.\n        Uses Google Translate detection API.\n\n        Returns:\n            ISO 639-1 language code\n        \"\"\"\n        if not hasattr(self.providers[\"primary\"], \"api_key\"):\n            return \"en\"  # Default to English\n\n        api_key = getattr(self.providers[\"primary\"], \"api_key\", None)\n        if not api_key:\n            return \"en\"\n\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.post(\n                    \"https://translation.googleapis.com/language/translate/v2/detect\",\n                    params={\"key\": api_key},\n                    json={\"q\": text[:500]},  # Limit text length\n                    timeout=2.0,\n                )\n                response.raise_for_status()\n                data = response.json()\n                return data[\"data\"][\"detections\"][0][0][\"language\"]\n        except Exception as e:\n            logger.warning(f\"Language detection failed: {e}\")\n            return \"en\"\n\n    def get_metrics(self) -> TranslationMetrics:\n        \"\"\"Get current translation metrics.\"\"\"\n        if self.metrics.total_requests > 0:\n            self.metrics.avg_latency_ms = (\n                self.metrics.primary_successes + self.metrics.fallback_successes\n            ) / self.metrics.total_requests\n        return self.metrics\n\n    def get_supported_languages(self) -> List[Dict[str, str]]:\n        \"\"\"Get list of supported languages with their codes and names.\"\"\"\n        return [\n            {\"code\": \"en\", \"name\": \"English\", \"native\": \"English\"},\n            {\"code\": \"es\", \"name\": \"Spanish\", \"native\": \"Español\"},\n            {\"code\": \"fr\", \"name\": \"French\", \"native\": \"Français\"},\n            {\"code\": \"de\", \"name\": \"German\", \"native\": \"Deutsch\"},\n            {\"code\": \"it\", \"name\": \"Italian\", \"native\": \"Italiano\"},\n            {\"code\": \"pt\", \"name\": \"Portuguese\", \"native\": \"Português\"},\n            {\"code\": \"ar\", \"name\": \"Arabic\", \"native\": \"العربية\", \"rtl\": True},\n            {\"code\": \"zh\", \"name\": \"Chinese (Mandarin)\", \"native\": \"中文\"},\n            {\"code\": \"hi\", \"name\": \"Hindi\", \"native\": \"हिन्दी\"},\n            {\"code\": \"ur\", \"name\": \"Urdu\", \"native\": \"اردو\", \"rtl\": True},\n        ]\n\n\n# Singleton instance for dependency injection\n_translation_service: Optional[TranslationService] = None\n\n\nasync def get_translation_service() -> TranslationService:\n    \"\"\"Get or create translation service instance.\"\"\"\n    global _translation_service\n    if _translation_service is None:\n        from app.core.redis import get_redis_client\n\n        redis = await get_redis_client()\n        _translation_service = TranslationService(redis_client=redis)\n    return _translation_service\n"
}
