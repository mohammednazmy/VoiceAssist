{
  "path": "services/api-gateway/app/api/integrations.py",
  "language": "python",
  "size": 46773,
  "last_modified": "2025-12-04T11:26:49.667Z",
  "lines": 1462,
  "content": "\"\"\"\nIntegrations API Endpoints (Phase 4 - Nextcloud Integration)\n\nProvides API endpoints for Nextcloud integrations:\n- OIDC authentication (SSO with Nextcloud)\n- Calendar operations (CalDAV)\n- Contact operations (CardDAV)\n- Email operations (IMAP/SMTP)\n- File auto-indexing (WebDAV)\n\nAll endpoints require authentication and return standardized API envelopes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport secrets\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.api_envelope import ErrorCodes, error_response, success_response\nfrom app.core.config import settings\nfrom app.core.dependencies import get_current_admin_user, get_current_user\nfrom app.services.caldav_service import CalDAVService\nfrom app.services.carddav_service import AddressType, CardDAVService, Contact, ContactSearchQuery\nfrom app.services.carddav_service import EmailAddress as CardEmailAddress\nfrom app.services.carddav_service import EmailType, PhoneNumber, PhoneType, PostalAddress\nfrom app.services.email_service import Email, EmailService\nfrom app.services.nextcloud_file_indexer import NextcloudFileIndexer\nfrom app.services.oidc_service import AuthorizationRequest, OIDCProvider, OIDCService\nfrom fastapi import APIRouter, Depends, Query\nfrom pydantic import BaseModel, EmailStr, Field\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/integrations\", tags=[\"integrations\"])\n\n\n# ===================================\n# OIDC Request/Response Models\n# ===================================\n\n\nclass OIDCAuthStartRequest(BaseModel):\n    \"\"\"Request to start OIDC authentication flow.\"\"\"\n\n    provider: str = Field(..., description=\"OIDC provider (nextcloud, google, microsoft)\")\n    redirect_uri: str = Field(..., description=\"Where to redirect after auth\")\n\n\nclass OIDCAuthStartResponse(BaseModel):\n    \"\"\"Response with authorization URL.\"\"\"\n\n    authorization_url: str\n    state: str\n    nonce: str\n\n\nclass OIDCCallbackRequest(BaseModel):\n    \"\"\"OIDC callback request.\"\"\"\n\n    code: str = Field(..., description=\"Authorization code from provider\")\n    state: str = Field(..., description=\"State parameter for CSRF validation\")\n\n\nclass OIDCUserInfo(BaseModel):\n    \"\"\"OIDC user information.\"\"\"\n\n    sub: str\n    email: Optional[str] = None\n    name: Optional[str] = None\n    preferred_username: Optional[str] = None\n    picture: Optional[str] = None\n\n\n# ===================================\n# Calendar Request/Response Models\n# ===================================\n\n\nclass CreateEventRequest(BaseModel):\n    \"\"\"Request model for creating a calendar event.\"\"\"\n\n    summary: str = Field(..., description=\"Event title\")\n    start: datetime = Field(..., description=\"Event start time\")\n    end: datetime = Field(..., description=\"Event end time\")\n    description: Optional[str] = Field(None, description=\"Event description\")\n    location: Optional[str] = Field(None, description=\"Event location\")\n    calendar_id: Optional[str] = Field(None, description=\"Target calendar ID\")\n\n\nclass UpdateEventRequest(BaseModel):\n    \"\"\"Request model for updating a calendar event.\"\"\"\n\n    summary: Optional[str] = Field(None, description=\"New event title\")\n    start: Optional[datetime] = Field(None, description=\"New start time\")\n    end: Optional[datetime] = Field(None, description=\"New end time\")\n    description: Optional[str] = Field(None, description=\"New description\")\n    location: Optional[str] = Field(None, description=\"New location\")\n\n\n# ===================================\n# Contact Request/Response Models\n# ===================================\n\n\nclass PhoneNumberRequest(BaseModel):\n    \"\"\"Phone number input.\"\"\"\n\n    number: str\n    type: str = \"OTHER\"\n    is_primary: bool = False\n\n\nclass EmailAddressRequest(BaseModel):\n    \"\"\"Email address input.\"\"\"\n\n    email: EmailStr\n    type: str = \"OTHER\"\n    is_primary: bool = False\n\n\nclass PostalAddressRequest(BaseModel):\n    \"\"\"Postal address input.\"\"\"\n\n    street: Optional[str] = None\n    city: Optional[str] = None\n    state: Optional[str] = None\n    postal_code: Optional[str] = None\n    country: Optional[str] = None\n    type: str = \"OTHER\"\n\n\nclass CreateContactRequest(BaseModel):\n    \"\"\"Request to create a contact.\"\"\"\n\n    display_name: str = Field(..., description=\"Contact display name\")\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    middle_name: Optional[str] = None\n    nickname: Optional[str] = None\n    emails: List[EmailAddressRequest] = Field(default_factory=list)\n    phones: List[PhoneNumberRequest] = Field(default_factory=list)\n    addresses: List[PostalAddressRequest] = Field(default_factory=list)\n    organization: Optional[str] = None\n    title: Optional[str] = None\n    notes: Optional[str] = None\n    website: Optional[str] = None\n    categories: List[str] = Field(default_factory=list)\n\n\nclass UpdateContactRequest(BaseModel):\n    \"\"\"Request to update a contact.\"\"\"\n\n    display_name: Optional[str] = None\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    middle_name: Optional[str] = None\n    nickname: Optional[str] = None\n    emails: Optional[List[EmailAddressRequest]] = None\n    phones: Optional[List[PhoneNumberRequest]] = None\n    addresses: Optional[List[PostalAddressRequest]] = None\n    organization: Optional[str] = None\n    title: Optional[str] = None\n    notes: Optional[str] = None\n    website: Optional[str] = None\n    categories: Optional[List[str]] = None\n\n\n# ===================================\n# Email Request/Response Models\n# ===================================\n\n\nclass SendEmailRequest(BaseModel):\n    \"\"\"Request model for sending an email.\"\"\"\n\n    to_addresses: List[EmailStr] = Field(..., description=\"Recipient email addresses\")\n    subject: str = Field(..., description=\"Email subject\")\n    body: str = Field(..., description=\"Email body\")\n    cc_addresses: Optional[List[EmailStr]] = Field(None, description=\"CC recipients\")\n    bcc_addresses: Optional[List[EmailStr]] = Field(None, description=\"BCC recipients\")\n    is_html: bool = Field(False, description=\"Whether body is HTML\")\n    reply_to: Optional[str] = Field(None, description=\"Message-ID to reply to\")\n\n\nclass EmailSearchRequest(BaseModel):\n    \"\"\"Request model for searching emails.\"\"\"\n\n    query: str = Field(..., description=\"Search query\")\n    folder: str = Field(\"INBOX\", description=\"Folder to search in\")\n    limit: int = Field(50, le=200, description=\"Maximum results\")\n\n\n# ===================================\n# File Indexing Request Models\n# ===================================\n\n\nclass IndexFileRequest(BaseModel):\n    \"\"\"Request model for indexing a specific file.\"\"\"\n\n    file_path: str = Field(..., description=\"Nextcloud file path\")\n    source_type: str = Field(\"note\", description=\"Document source type\")\n\n\n# ===================================\n# Helper Functions\n# ===================================\n\n\ndef get_oidc_service() -> OIDCService:\n    \"\"\"Get OIDC service instance.\"\"\"\n    return OIDCService()\n\n\ndef get_caldav_service() -> CalDAVService:\n    \"\"\"Get CalDAV service instance with Nextcloud credentials.\"\"\"\n    return CalDAVService(\n        caldav_url=settings.NEXTCLOUD_URL + \"/remote.php/dav/\",\n        username=settings.NEXTCLOUD_ADMIN_USER,\n        password=settings.NEXTCLOUD_ADMIN_PASSWORD,\n    )\n\n\ndef get_carddav_service() -> CardDAVService:\n    \"\"\"Get CardDAV service instance with Nextcloud credentials.\"\"\"\n    return CardDAVService(\n        base_url=settings.NEXTCLOUD_URL,\n        username=settings.NEXTCLOUD_ADMIN_USER,\n        password=settings.NEXTCLOUD_ADMIN_PASSWORD,\n    )\n\n\ndef get_email_service() -> EmailService:\n    \"\"\"Get email service instance.\"\"\"\n    return EmailService(\n        imap_host=getattr(settings, \"IMAP_HOST\", \"\"),\n        imap_port=getattr(settings, \"IMAP_PORT\", 993),\n        smtp_host=getattr(settings, \"SMTP_HOST\", \"\"),\n        smtp_port=getattr(settings, \"SMTP_PORT\", 587),\n        username=getattr(settings, \"EMAIL_USERNAME\", \"\"),\n        password=getattr(settings, \"EMAIL_PASSWORD\", \"\"),\n        use_ssl=getattr(settings, \"EMAIL_USE_SSL\", True),\n    )\n\n\ndef contact_to_dict(contact: Contact) -> Dict[str, Any]:\n    \"\"\"Convert Contact dataclass to dict for JSON serialization.\"\"\"\n    return {\n        \"uid\": contact.uid,\n        \"display_name\": contact.display_name,\n        \"first_name\": contact.first_name,\n        \"last_name\": contact.last_name,\n        \"middle_name\": contact.middle_name,\n        \"nickname\": contact.nickname,\n        \"emails\": [{\"email\": e.email, \"type\": e.type.value, \"is_primary\": e.is_primary} for e in contact.emails],\n        \"phones\": [{\"number\": p.number, \"type\": p.type.value, \"is_primary\": p.is_primary} for p in contact.phones],\n        \"addresses\": [\n            {\n                \"street\": a.street,\n                \"city\": a.city,\n                \"state\": a.state,\n                \"postal_code\": a.postal_code,\n                \"country\": a.country,\n                \"type\": a.type.value,\n            }\n            for a in contact.addresses\n        ],\n        \"organization\": contact.organization,\n        \"title\": contact.title,\n        \"notes\": contact.notes,\n        \"website\": contact.website,\n        \"categories\": contact.categories,\n        \"birthday\": contact.birthday.isoformat() if contact.birthday else None,\n        \"created\": contact.created.isoformat() if contact.created else None,\n        \"modified\": contact.modified.isoformat() if contact.modified else None,\n    }\n\n\ndef email_to_dict(email: Email) -> Dict[str, Any]:\n    \"\"\"Convert Email dataclass to dict for JSON serialization.\"\"\"\n    return {\n        \"id\": email.id,\n        \"message_id\": email.message_id,\n        \"uid\": email.uid,\n        \"subject\": email.subject,\n        \"from_addr\": str(email.from_addr) if email.from_addr else None,\n        \"to_addrs\": [str(a) for a in email.to_addrs],\n        \"cc_addrs\": [str(a) for a in email.cc_addrs] if email.cc_addrs else [],\n        \"date\": email.date.isoformat() if email.date else None,\n        \"preview\": email.preview,\n        \"is_read\": email.is_read,\n        \"is_flagged\": email.is_flagged,\n        \"has_attachments\": email.has_attachments,\n        \"folder\": email.folder,\n        \"thread_id\": email.thread_id,\n    }\n\n\n# ===================================\n# OIDC Authentication Endpoints\n# ===================================\n\n\n# Store for OIDC state/nonce (in production, use Redis)\n_oidc_states: Dict[str, Dict[str, str]] = {}\n\n\n@router.post(\"/oidc/auth/start\")\nasync def start_oidc_auth(request: OIDCAuthStartRequest):\n    \"\"\"\n    Start OIDC authentication flow.\n\n    Returns an authorization URL to redirect the user to.\n    \"\"\"\n    try:\n        # Validate provider\n        provider_str = request.provider.lower()\n        if provider_str == \"nextcloud\":\n            provider = OIDCProvider.NEXTCLOUD\n        elif provider_str == \"google\":\n            provider = OIDCProvider.GOOGLE\n        elif provider_str == \"microsoft\":\n            provider = OIDCProvider.MICROSOFT\n        else:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=f\"Unknown provider: {request.provider}\",\n            )\n\n        # Generate state and nonce\n        state = secrets.token_urlsafe(32)\n        nonce = secrets.token_urlsafe(32)\n\n        # Store for validation\n        _oidc_states[state] = {\n            \"nonce\": nonce,\n            \"redirect_uri\": request.redirect_uri,\n            \"provider\": provider_str,\n        }\n\n        # Build authorization URL\n        service = get_oidc_service()\n        auth_request = AuthorizationRequest(\n            provider=provider,\n            redirect_uri=request.redirect_uri,\n            state=state,\n            nonce=nonce,\n        )\n\n        auth_url = await service.get_authorization_url(auth_request)\n\n        return success_response(\n            data={\n                \"authorization_url\": auth_url,\n                \"state\": state,\n                \"nonce\": nonce,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error starting OIDC auth: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to start authentication\",\n        )\n\n\n@router.post(\"/oidc/auth/callback\")\nasync def handle_oidc_callback(request: OIDCCallbackRequest):\n    \"\"\"\n    Handle OIDC callback after provider authentication.\n\n    Exchanges authorization code for tokens and returns user info.\n    \"\"\"\n    try:\n        # Validate state\n        if request.state not in _oidc_states:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=\"Invalid or expired state parameter\",\n            )\n\n        state_data = _oidc_states.pop(request.state)\n        nonce = state_data[\"nonce\"]\n        redirect_uri = state_data[\"redirect_uri\"]\n        provider_str = state_data[\"provider\"]\n\n        # Map provider\n        provider_map = {\n            \"nextcloud\": OIDCProvider.NEXTCLOUD,\n            \"google\": OIDCProvider.GOOGLE,\n            \"microsoft\": OIDCProvider.MICROSOFT,\n        }\n        provider = provider_map.get(provider_str, OIDCProvider.NEXTCLOUD)\n\n        # Exchange code for tokens\n        service = get_oidc_service()\n        auth_request = AuthorizationRequest(\n            provider=provider,\n            redirect_uri=redirect_uri,\n            state=request.state,\n            nonce=nonce,\n        )\n\n        tokens = await service.exchange_code(request.code, auth_request)\n\n        # Validate ID token\n        claims = await service.validate_id_token(tokens.id_token, nonce, provider)\n\n        return success_response(\n            data={\n                \"access_token\": tokens.access_token,\n                \"id_token\": tokens.id_token,\n                \"refresh_token\": tokens.refresh_token,\n                \"expires_in\": tokens.expires_in,\n                \"user\": {\n                    \"sub\": claims.sub,\n                    \"email\": claims.email,\n                    \"name\": claims.name,\n                    \"preferred_username\": claims.preferred_username,\n                },\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error handling OIDC callback: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Authentication failed\",\n        )\n\n\n@router.get(\"/oidc/userinfo\")\nasync def get_oidc_userinfo(\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Get user info from OIDC provider.\n\n    Requires authentication via access token.\n    \"\"\"\n    try:\n        # Get access token from session/request\n        access_token = current_user.get(\"oidc_access_token\")\n        if not access_token:\n            return error_response(\n                code=ErrorCodes.UNAUTHORIZED,\n                message=\"No OIDC access token found\",\n            )\n\n        service = get_oidc_service()\n        user_info = await service.get_nextcloud_user(access_token)\n\n        return success_response(\n            data={\n                \"user_id\": user_info.user_id,\n                \"display_name\": user_info.display_name,\n                \"email\": user_info.email,\n                \"groups\": user_info.groups,\n                \"quota_used\": user_info.quota_used,\n                \"quota_total\": user_info.quota_total,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error getting user info: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to get user info\",\n        )\n\n\n# ===================================\n# Calendar Endpoints\n# ===================================\n\n\n@router.get(\"/calendar/calendars\")\nasync def list_calendars(current_admin_user: dict = Depends(get_current_admin_user)):\n    \"\"\"\n    List all available calendars for the authenticated user.\n\n    Requires authentication.\n    \"\"\"\n    try:\n        caldav_service = get_caldav_service()\n\n        if not caldav_service.connect():\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to connect to calendar service\",\n            )\n\n        calendars = caldav_service.list_calendars()\n\n        return success_response(data={\"calendars\": calendars})\n\n    except Exception as e:\n        logger.error(f\"Error listing calendars: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to list calendars\",\n        )\n\n\n@router.get(\"/calendar/events\")\nasync def list_events(\n    start_date: Optional[datetime] = Query(None),\n    end_date: Optional[datetime] = Query(None),\n    calendar_id: Optional[str] = Query(None),\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    List calendar events within a date range.\n\n    Requires authentication.\n    \"\"\"\n    try:\n        caldav_service = get_caldav_service()\n\n        events = caldav_service.get_events(\n            calendar_id=calendar_id,\n            start_date=start_date,\n            end_date=end_date,\n        )\n\n        # Convert to dict for JSON serialization\n        events_data = [\n            {\n                \"uid\": event.uid,\n                \"summary\": event.summary,\n                \"description\": event.description,\n                \"start\": (event.start.isoformat() if hasattr(event.start, \"isoformat\") else str(event.start)),\n                \"end\": (event.end.isoformat() if hasattr(event.end, \"isoformat\") else str(event.end)),\n                \"location\": event.location,\n                \"organizer\": event.organizer,\n                \"attendees\": event.attendees,\n            }\n            for event in events\n        ]\n\n        return success_response(data={\"events\": events_data, \"count\": len(events_data)})\n\n    except Exception as e:\n        logger.error(f\"Error listing events: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to list events\",\n        )\n\n\n@router.post(\"/calendar/events\")\nasync def create_event(\n    request: CreateEventRequest,\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    Create a new calendar event.\n\n    Requires authentication.\n    \"\"\"\n    try:\n        caldav_service = get_caldav_service()\n\n        event_uid = caldav_service.create_event(\n            summary=request.summary,\n            start=request.start,\n            end=request.end,\n            description=request.description,\n            location=request.location,\n            calendar_id=request.calendar_id,\n        )\n\n        if event_uid:\n            return success_response(data={\"event_uid\": event_uid, \"status\": \"created\"})\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to create event\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error creating event: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to create event\",\n        )\n\n\n@router.put(\"/calendar/events/{event_uid}\")\nasync def update_event(\n    event_uid: str,\n    request: UpdateEventRequest,\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    Update an existing calendar event.\n\n    Requires authentication.\n    \"\"\"\n    try:\n        caldav_service = get_caldav_service()\n\n        success = caldav_service.update_event(\n            event_uid=event_uid,\n            summary=request.summary,\n            start=request.start,\n            end=request.end,\n            description=request.description,\n            location=request.location,\n        )\n\n        if success:\n            return success_response(data={\"event_uid\": event_uid, \"status\": \"updated\"})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Event not found: {event_uid}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error updating event: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to update event\",\n        )\n\n\n@router.delete(\"/calendar/events/{event_uid}\")\nasync def delete_event(\n    event_uid: str,\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    Delete a calendar event.\n\n    Requires authentication.\n    \"\"\"\n    try:\n        caldav_service = get_caldav_service()\n\n        success = caldav_service.delete_event(event_uid=event_uid)\n\n        if success:\n            return success_response(data={\"event_uid\": event_uid, \"status\": \"deleted\"})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Event not found: {event_uid}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error deleting event: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to delete event\",\n        )\n\n\n# ===================================\n# Contact Endpoints (CardDAV)\n# ===================================\n\n\n@router.get(\"/contacts/addressbooks\")\nasync def list_address_books(current_user: dict = Depends(get_current_user)):\n    \"\"\"\n    List all address books for the authenticated user.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n        address_books = await service.list_address_books()\n\n        return success_response(\n            data={\n                \"address_books\": [\n                    {\n                        \"name\": ab.name,\n                        \"display_name\": ab.display_name,\n                        \"url\": ab.url,\n                        \"description\": ab.description,\n                        \"contact_count\": ab.contact_count,\n                    }\n                    for ab in address_books\n                ]\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error listing address books: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n            message=\"Failed to list address books\",\n        )\n\n\n@router.get(\"/contacts\")\nasync def list_contacts(\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    search: Optional[str] = Query(None, description=\"Search query\"),\n    limit: int = Query(100, le=500, description=\"Maximum results\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    List contacts in an address book.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n\n        query = None\n        if search:\n            query = ContactSearchQuery(text=search, limit=limit)\n\n        contacts = await service.list_contacts(address_book=address_book, query=query)\n\n        return success_response(\n            data={\n                \"contacts\": [contact_to_dict(c) for c in contacts[:limit]],\n                \"count\": len(contacts),\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error listing contacts: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n            message=\"Failed to list contacts\",\n        )\n\n\n@router.get(\"/contacts/{uid}\")\nasync def get_contact(\n    uid: str,\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Get a specific contact by UID.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n        contact = await service.get_contact(uid=uid, address_book=address_book)\n\n        if contact:\n            return success_response(data={\"contact\": contact_to_dict(contact)})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Contact not found: {uid}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error getting contact: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to get contact\",\n        )\n\n\n@router.post(\"/contacts\")\nasync def create_contact(\n    request: CreateContactRequest,\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Create a new contact.\n    \"\"\"\n    try:\n        import uuid\n\n        service = get_carddav_service()\n\n        # Build Contact object\n        contact = Contact(\n            uid=str(uuid.uuid4()),\n            display_name=request.display_name,\n            first_name=request.first_name,\n            last_name=request.last_name,\n            middle_name=request.middle_name,\n            nickname=request.nickname,\n            organization=request.organization,\n            title=request.title,\n            notes=request.notes,\n            website=request.website,\n            categories=request.categories,\n            emails=[\n                CardEmailAddress(\n                    email=e.email,\n                    type=(EmailType[e.type.upper()] if e.type.upper() in EmailType.__members__ else EmailType.OTHER),\n                    is_primary=e.is_primary,\n                )\n                for e in request.emails\n            ],\n            phones=[\n                PhoneNumber(\n                    number=p.number,\n                    type=(PhoneType[p.type.upper()] if p.type.upper() in PhoneType.__members__ else PhoneType.OTHER),\n                    is_primary=p.is_primary,\n                )\n                for p in request.phones\n            ],\n            addresses=[\n                PostalAddress(\n                    street=a.street,\n                    city=a.city,\n                    state=a.state,\n                    postal_code=a.postal_code,\n                    country=a.country,\n                    type=(\n                        AddressType[a.type.upper()] if a.type.upper() in AddressType.__members__ else AddressType.OTHER\n                    ),\n                )\n                for a in request.addresses\n            ],\n        )\n\n        new_uid = await service.create_contact(contact=contact, address_book=address_book)\n\n        return success_response(\n            data={\n                \"uid\": new_uid,\n                \"status\": \"created\",\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error creating contact: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to create contact\",\n        )\n\n\n@router.put(\"/contacts/{uid}\")\nasync def update_contact(\n    uid: str,\n    request: UpdateContactRequest,\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Update an existing contact.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n\n        # Get existing contact\n        existing = await service.get_contact(uid=uid, address_book=address_book)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Contact not found: {uid}\",\n            )\n\n        # Update fields\n        if request.display_name is not None:\n            existing.display_name = request.display_name\n        if request.first_name is not None:\n            existing.first_name = request.first_name\n        if request.last_name is not None:\n            existing.last_name = request.last_name\n        if request.middle_name is not None:\n            existing.middle_name = request.middle_name\n        if request.nickname is not None:\n            existing.nickname = request.nickname\n        if request.organization is not None:\n            existing.organization = request.organization\n        if request.title is not None:\n            existing.title = request.title\n        if request.notes is not None:\n            existing.notes = request.notes\n        if request.website is not None:\n            existing.website = request.website\n        if request.categories is not None:\n            existing.categories = request.categories\n\n        if request.emails is not None:\n            existing.emails = [\n                CardEmailAddress(\n                    email=e.email,\n                    type=(EmailType[e.type.upper()] if e.type.upper() in EmailType.__members__ else EmailType.OTHER),\n                    is_primary=e.is_primary,\n                )\n                for e in request.emails\n            ]\n\n        if request.phones is not None:\n            existing.phones = [\n                PhoneNumber(\n                    number=p.number,\n                    type=(PhoneType[p.type.upper()] if p.type.upper() in PhoneType.__members__ else PhoneType.OTHER),\n                    is_primary=p.is_primary,\n                )\n                for p in request.phones\n            ]\n\n        if request.addresses is not None:\n            existing.addresses = [\n                PostalAddress(\n                    street=a.street,\n                    city=a.city,\n                    state=a.state,\n                    postal_code=a.postal_code,\n                    country=a.country,\n                    type=(\n                        AddressType[a.type.upper()] if a.type.upper() in AddressType.__members__ else AddressType.OTHER\n                    ),\n                )\n                for a in request.addresses\n            ]\n\n        success = await service.update_contact(contact=existing, address_book=address_book)\n\n        if success:\n            return success_response(data={\"uid\": uid, \"status\": \"updated\"})\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to update contact\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error updating contact: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to update contact\",\n        )\n\n\n@router.delete(\"/contacts/{uid}\")\nasync def delete_contact(\n    uid: str,\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Delete a contact.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n        success = await service.delete_contact(uid=uid, address_book=address_book)\n\n        if success:\n            return success_response(data={\"uid\": uid, \"status\": \"deleted\"})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Contact not found: {uid}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error deleting contact: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to delete contact\",\n        )\n\n\n@router.get(\"/contacts/search\")\nasync def search_contacts(\n    query: str = Query(..., description=\"Search query\"),\n    address_book: str = Query(\"contacts\", description=\"Address book name\"),\n    limit: int = Query(50, le=200, description=\"Maximum results\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Search contacts by name, email, phone, or organization.\n    \"\"\"\n    try:\n        service = get_carddav_service()\n        contacts = await service.search_contacts(query=query, address_book=address_book)\n\n        return success_response(\n            data={\n                \"contacts\": [contact_to_dict(c) for c in contacts[:limit]],\n                \"count\": len(contacts),\n                \"query\": query,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error searching contacts: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n            message=\"Failed to search contacts\",\n        )\n\n\n# ===================================\n# Email Endpoints\n# ===================================\n\n\n@router.get(\"/email/folders\")\nasync def list_email_folders(current_user: dict = Depends(get_current_user)):\n    \"\"\"\n    List email folders/mailboxes.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        # Check if email is configured\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured. Set IMAP_HOST, SMTP_HOST, and EMAIL_* settings.\",\n            )\n\n        folders = await service.list_folders()\n\n        return success_response(\n            data={\n                \"folders\": [\n                    {\n                        \"name\": f.name,\n                        \"total_messages\": f.total_messages,\n                        \"unread_messages\": f.unread_messages,\n                        \"is_inbox\": f.is_inbox,\n                        \"is_sent\": f.is_sent,\n                        \"is_drafts\": f.is_drafts,\n                    }\n                    for f in folders\n                ]\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error listing email folders: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n            message=\"Failed to list email folders\",\n        )\n\n\n@router.get(\"/email/messages\")\nasync def list_email_messages(\n    folder: str = Query(\"INBOX\", description=\"Folder name\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(50, le=200, description=\"Messages per page\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    List email messages in a folder.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        result = await service.list_messages(\n            folder=folder,\n            page=page,\n            page_size=page_size,\n        )\n\n        return success_response(\n            data={\n                \"messages\": [email_to_dict(e) for e in result.messages],\n                \"total\": result.total,\n                \"page\": result.page,\n                \"page_size\": result.page_size,\n                \"has_more\": result.has_more,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Error listing email messages: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n            message=\"Failed to list email messages\",\n        )\n\n\n@router.get(\"/email/messages/{message_id}\")\nasync def get_email_message(\n    message_id: str,\n    folder: str = Query(\"INBOX\", description=\"Folder name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Get a specific email message with full content.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        email = await service.get_message(message_id=message_id, folder=folder)\n\n        if email:\n            result = email_to_dict(email)\n            result[\"body_text\"] = email.body_text\n            result[\"body_html\"] = email.body_html\n            result[\"attachments\"] = [\n                {\n                    \"filename\": a.filename,\n                    \"content_type\": a.content_type,\n                    \"size\": a.size,\n                }\n                for a in email.attachments\n            ]\n            return success_response(data={\"message\": result})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Message not found: {message_id}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error getting email message: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to get email message\",\n        )\n\n\n@router.post(\"/email/send\")\nasync def send_email(\n    request: SendEmailRequest,\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Send an email.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.smtp_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured. Set SMTP_HOST and EMAIL_* settings.\",\n            )\n\n        success = await service.send_email(\n            to=request.to_addresses,\n            subject=request.subject,\n            body=request.body,\n            cc=request.cc_addresses,\n            bcc=request.bcc_addresses,\n            html=request.is_html,\n        )\n\n        if success:\n            return success_response(data={\"status\": \"sent\"})\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to send email\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error sending email: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to send email\",\n        )\n\n\n@router.post(\"/email/messages/{message_id}/reply\")\nasync def reply_to_email(\n    message_id: str,\n    body: str = Query(..., description=\"Reply body\"),\n    reply_all: bool = Query(False, description=\"Reply to all recipients\"),\n    folder: str = Query(\"INBOX\", description=\"Folder containing original\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Reply to an email message.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.smtp_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        # Get original message\n        original = await service.get_message(message_id=message_id, folder=folder)\n        if not original:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Original message not found: {message_id}\",\n            )\n\n        success = await service.reply_to(\n            original_message=original,\n            body=body,\n            reply_all=reply_all,\n        )\n\n        if success:\n            return success_response(data={\"status\": \"sent\"})\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to send reply\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error replying to email: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to reply to email\",\n        )\n\n\n@router.get(\"/email/threads/{thread_id}\")\nasync def get_email_thread(\n    thread_id: str,\n    folder: str = Query(\"INBOX\", description=\"Folder name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Get an email thread (conversation).\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        thread = await service.get_thread(message_id=thread_id, folder=folder)\n\n        if thread:\n            return success_response(\n                data={\n                    \"thread\": {\n                        \"thread_id\": thread.thread_id,\n                        \"subject\": thread.subject,\n                        \"participants\": [str(p) for p in thread.participants],\n                        \"total_count\": thread.total_count,\n                        \"unread_count\": thread.unread_count,\n                        \"last_message_date\": (\n                            thread.last_message_date.isoformat() if thread.last_message_date else None\n                        ),\n                        \"messages\": [email_to_dict(m) for m in thread.messages],\n                    }\n                }\n            )\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Thread not found: {thread_id}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error getting email thread: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to get email thread\",\n        )\n\n\n@router.put(\"/email/messages/{message_id}/flags\")\nasync def update_email_flags(\n    message_id: str,\n    mark_read: Optional[bool] = Query(None, description=\"Mark as read/unread\"),\n    mark_flagged: Optional[bool] = Query(None, description=\"Mark as flagged/unflagged\"),\n    folder: str = Query(\"INBOX\", description=\"Folder name\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Update email message flags (read, flagged).\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        success = True\n\n        if mark_read is not None:\n            success = success and await service.mark_read(\n                message_id=message_id,\n                folder=folder,\n                read=mark_read,\n            )\n\n        if mark_flagged is not None:\n            success = success and await service.mark_flagged(\n                message_id=message_id,\n                folder=folder,\n                flagged=mark_flagged,\n            )\n\n        if success:\n            return success_response(data={\"message_id\": message_id, \"status\": \"updated\"})\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to update message flags\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error updating email flags: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to update email flags\",\n        )\n\n\n@router.delete(\"/email/messages/{message_id}\")\nasync def delete_email(\n    message_id: str,\n    folder: str = Query(\"INBOX\", description=\"Folder name\"),\n    permanent: bool = Query(False, description=\"Permanently delete\"),\n    current_user: dict = Depends(get_current_user),\n):\n    \"\"\"\n    Delete an email message.\n    \"\"\"\n    try:\n        service = get_email_service()\n\n        if not service.imap_host:\n            return error_response(\n                code=\"NOT_CONFIGURED\",\n                message=\"Email integration is not configured.\",\n            )\n\n        success = await service.delete_message(\n            message_id=message_id,\n            folder=folder,\n            permanent=permanent,\n        )\n\n        if success:\n            return success_response(data={\"message_id\": message_id, \"status\": \"deleted\"})\n        else:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Message not found: {message_id}\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error deleting email: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to delete email\",\n        )\n\n\n# ===================================\n# File Indexing Endpoints\n# ===================================\n\n\n@router.post(\"/files/scan-and-index\")\nasync def scan_and_index_files(\n    source_type: str = Query(\"note\", description=\"Default source type for indexed documents\"),\n    force_reindex: bool = Query(False, description=\"Force re-indexing of all files\"),\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    Scan Nextcloud directories and auto-index medical documents.\n\n    This endpoint triggers a full scan of configured watch directories\n    and indexes all supported medical documents into the knowledge base.\n\n    Requires authentication (admin role recommended).\n    \"\"\"\n    try:\n        indexer = NextcloudFileIndexer(\n            webdav_url=settings.NEXTCLOUD_URL + \"/remote.php/dav/files/\" + settings.NEXTCLOUD_ADMIN_USER + \"/\",\n            username=settings.NEXTCLOUD_ADMIN_USER,\n            password=settings.NEXTCLOUD_ADMIN_PASSWORD,\n            watch_directories=[\"Medical Documents\", \"Guidelines\", \"Textbooks\"],\n        )\n\n        if not indexer.connect():\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to connect to Nextcloud\",\n            )\n\n        summary = await indexer.scan_and_index(\n            source_type=source_type,\n            force_reindex=force_reindex,\n        )\n\n        return success_response(data=summary)\n\n    except Exception as e:\n        logger.error(f\"Error scanning and indexing files: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to scan and index files\",\n        )\n\n\n@router.post(\"/files/index\")\nasync def index_specific_file(\n    request: IndexFileRequest,\n    current_admin_user: dict = Depends(get_current_admin_user),\n):\n    \"\"\"\n    Index a specific Nextcloud file into the knowledge base.\n\n    Useful for manually triggering indexing of a single document.\n\n    Requires authentication (admin role recommended).\n    \"\"\"\n    try:\n        indexer = NextcloudFileIndexer(\n            webdav_url=settings.NEXTCLOUD_URL + \"/remote.php/dav/files/\" + settings.NEXTCLOUD_ADMIN_USER + \"/\",\n            username=settings.NEXTCLOUD_ADMIN_USER,\n            password=settings.NEXTCLOUD_ADMIN_PASSWORD,\n        )\n\n        if not indexer.connect():\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to connect to Nextcloud\",\n            )\n\n        result = await indexer.index_specific_file(\n            file_path=request.file_path,\n            source_type=request.source_type,\n        )\n\n        if result and result.success:\n            return success_response(\n                data={\n                    \"document_id\": result.document_id,\n                    \"chunks_indexed\": result.chunks_indexed,\n                    \"processing_time_ms\": result.processing_time_ms,\n                    \"status\": \"indexed\",\n                }\n            )\n        else:\n            return error_response(\n                code=ErrorCodes.EXTERNAL_SERVICE_ERROR,\n                message=\"Failed to index file\",\n            )\n\n    except Exception as e:\n        logger.error(f\"Error indexing file: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to index file\",\n        )\n"
}
