{
  "path": "services/api-gateway/app/services/memory_context_service.py",
  "language": "python",
  "size": 18401,
  "last_modified": "2025-12-04T12:32:40.271Z",
  "lines": 559,
  "content": "\"\"\"\nMemory Context Service - Conversational Memory Management\n\nProvides multi-tier memory for natural voice conversations:\n- Short-term: Active conversation context (topics, entities, emotions)\n- Medium-term: User preferences and patterns\n- Long-term: Speech profile for personalized timing\n\nThis service integrates with the voice pipeline to:\n1. Track conversation context for coherent responses\n2. Learn user preferences over time\n3. Optimize response timing based on speech patterns\n\nPhase: Voice Mode Intelligence Enhancement - Phase 4\n\"\"\"\n\nimport uuid\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.logging import get_logger\nfrom app.models.conversation_memory import ConversationMemory, UserContext, UserSpeechProfile\nfrom sqlalchemy import and_, select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import Session\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Memory Types and Constants\n# ==============================================================================\n\n\nclass MemoryType:\n    \"\"\"Memory type categories for conversation memory.\"\"\"\n\n    TOPIC = \"topic\"  # Current/recent topics\n    ENTITY = \"entity\"  # People, places, medical terms\n    EMOTION = \"emotion\"  # Detected emotional states\n    REFERENCE = \"reference\"  # \"it\", \"that\", etc. resolution\n    CONTEXT = \"context\"  # General conversational context\n\n\nclass ContextCategory:\n    \"\"\"Categories for user context.\"\"\"\n\n    INTEREST = \"interest\"  # Topics they care about\n    KNOWLEDGE = \"knowledge\"  # Their expertise level\n    PREFERENCE = \"preference\"  # Communication preferences\n    CONCERN = \"concern\"  # Recurring worries\n    HISTORY = \"history\"  # Interaction history\n\n\n# Memory TTL settings\nSHORT_TERM_TTL_HOURS = 24  # Conversation memory expires after 24h\nRELEVANCE_DECAY_RATE = 0.05  # Per-access decay\n\n\n# ==============================================================================\n# Short-Term Memory Manager\n# ==============================================================================\n\n\nclass ConversationMemoryManager:\n    \"\"\"\n    Manages short-term conversation memory for a session.\n\n    Tracks:\n    - Current topic\n    - Recently mentioned entities\n    - Emotional state progression\n    - Reference resolution context\n    \"\"\"\n\n    def __init__(self, session_id: uuid.UUID, user_id: uuid.UUID):\n        self.session_id = session_id\n        self.user_id = user_id\n        self._local_cache: Dict[str, Any] = {}\n\n    async def remember(\n        self,\n        memory_type: str,\n        key: str,\n        value: str,\n        metadata: Optional[Dict] = None,\n        db: Optional[AsyncSession] = None,\n    ) -> None:\n        \"\"\"\n        Store a memory for this conversation.\n\n        Args:\n            memory_type: Type of memory (topic, entity, emotion, etc.)\n            key: Memory identifier\n            value: Memory content\n            metadata: Additional context\n            db: Optional database session\n        \"\"\"\n        # Store in local cache for quick access\n        cache_key = f\"{memory_type}:{key}\"\n        self._local_cache[cache_key] = {\n            \"value\": value,\n            \"metadata\": metadata or {},\n            \"timestamp\": datetime.now(timezone.utc),\n        }\n\n        # Persist to database\n        if db:\n            try:\n                # Check if exists\n                result = await db.execute(\n                    select(ConversationMemory).where(\n                        and_(\n                            ConversationMemory.session_id == self.session_id,\n                            ConversationMemory.memory_type == memory_type,\n                            ConversationMemory.key == key,\n                        )\n                    )\n                )\n                existing = result.scalar_one_or_none()\n\n                if existing:\n                    # Update existing\n                    existing.value = value\n                    existing.metadata = metadata or {}\n                    existing.access()\n                else:\n                    # Create new\n                    memory = ConversationMemory(\n                        session_id=self.session_id,\n                        user_id=self.user_id,\n                        memory_type=memory_type,\n                        key=key,\n                        value=value,\n                        metadata=metadata or {},\n                        expires_at=datetime.now(timezone.utc) + timedelta(hours=SHORT_TERM_TTL_HOURS),\n                    )\n                    db.add(memory)\n\n                await db.commit()\n            except Exception as e:\n                logger.error(f\"Failed to persist memory: {e}\")\n                await db.rollback()\n\n    async def recall(\n        self,\n        memory_type: str,\n        key: Optional[str] = None,\n        db: Optional[AsyncSession] = None,\n    ) -> Optional[Dict]:\n        \"\"\"\n        Recall memories from this conversation.\n\n        Args:\n            memory_type: Type of memory to recall\n            key: Optional specific key to recall\n            db: Optional database session\n\n        Returns:\n            Memory value or list of memories\n        \"\"\"\n        # Check local cache first\n        if key:\n            cache_key = f\"{memory_type}:{key}\"\n            if cache_key in self._local_cache:\n                return self._local_cache[cache_key]\n\n        # Query database\n        if db:\n            try:\n                if key:\n                    result = await db.execute(\n                        select(ConversationMemory).where(\n                            and_(\n                                ConversationMemory.session_id == self.session_id,\n                                ConversationMemory.memory_type == memory_type,\n                                ConversationMemory.key == key,\n                            )\n                        )\n                    )\n                    memory = result.scalar_one_or_none()\n                    if memory:\n                        memory.access()\n                        await db.commit()\n                        return {\n                            \"value\": memory.value,\n                            \"metadata\": memory.metadata,\n                            \"relevance\": memory.relevance_score,\n                        }\n                else:\n                    # Get all memories of this type\n                    result = await db.execute(\n                        select(ConversationMemory)\n                        .where(\n                            and_(\n                                ConversationMemory.session_id == self.session_id,\n                                ConversationMemory.memory_type == memory_type,\n                            )\n                        )\n                        .order_by(ConversationMemory.relevance_score.desc())\n                    )\n                    memories = result.scalars().all()\n                    return [\n                        {\n                            \"key\": m.key,\n                            \"value\": m.value,\n                            \"metadata\": m.metadata,\n                            \"relevance\": m.relevance_score,\n                        }\n                        for m in memories\n                    ]\n            except Exception as e:\n                logger.error(f\"Failed to recall memory: {e}\")\n\n        return None\n\n    async def get_context_summary(self, db: Optional[AsyncSession] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of current conversation context.\n\n        Returns dict with:\n        - current_topic: The main topic being discussed\n        - recent_entities: Entities mentioned recently\n        - emotional_state: Detected user emotion\n        - context_items: Other relevant context\n        \"\"\"\n        summary = {\n            \"current_topic\": None,\n            \"recent_entities\": [],\n            \"emotional_state\": None,\n            \"context_items\": [],\n        }\n\n        # Get from local cache first\n        for cache_key, data in self._local_cache.items():\n            memory_type, key = cache_key.split(\":\", 1)\n            if memory_type == MemoryType.TOPIC:\n                summary[\"current_topic\"] = data[\"value\"]\n            elif memory_type == MemoryType.ENTITY:\n                summary[\"recent_entities\"].append(data[\"value\"])\n            elif memory_type == MemoryType.EMOTION:\n                summary[\"emotional_state\"] = data[\"value\"]\n            else:\n                summary[\"context_items\"].append({key: data[\"value\"]})\n\n        return summary\n\n    def clear_cache(self) -> None:\n        \"\"\"Clear local cache (session ended).\"\"\"\n        self._local_cache.clear()\n\n\n# ==============================================================================\n# Medium-Term Context Manager\n# ==============================================================================\n\n\nclass UserContextManager:\n    \"\"\"\n    Manages medium-term user context across sessions.\n\n    Learns and tracks:\n    - Topics of interest\n    - Knowledge levels\n    - Communication preferences\n    - Recurring concerns\n    \"\"\"\n\n    def __init__(self, user_id: uuid.UUID):\n        self.user_id = user_id\n\n    async def learn(\n        self,\n        category: str,\n        key: str,\n        value: str,\n        confidence: float = 0.5,\n        metadata: Optional[Dict] = None,\n        db: Optional[AsyncSession] = None,\n    ) -> None:\n        \"\"\"\n        Learn a new piece of user context.\n\n        If context already exists, reinforce or update it.\n        \"\"\"\n        if not db:\n            return\n\n        try:\n            result = await db.execute(\n                select(UserContext).where(\n                    and_(\n                        UserContext.user_id == self.user_id,\n                        UserContext.category == category,\n                        UserContext.key == key,\n                    )\n                )\n            )\n            existing = result.scalar_one_or_none()\n\n            if existing:\n                # Reinforce if same value\n                if existing.value == value:\n                    existing.reinforce()\n                else:\n                    # Update with new value\n                    existing.value = value\n                    existing.confidence = confidence\n                    existing.metadata = metadata or {}\n            else:\n                # Create new context\n                context = UserContext(\n                    user_id=self.user_id,\n                    category=category,\n                    key=key,\n                    value=value,\n                    confidence=confidence,\n                    metadata=metadata or {},\n                )\n                db.add(context)\n\n            await db.commit()\n        except Exception as e:\n            logger.error(f\"Failed to learn user context: {e}\")\n            await db.rollback()\n\n    async def query(\n        self,\n        category: Optional[str] = None,\n        min_confidence: float = 0.3,\n        db: Optional[AsyncSession] = None,\n    ) -> List[Dict]:\n        \"\"\"\n        Query user context.\n\n        Args:\n            category: Optional category filter\n            min_confidence: Minimum confidence threshold\n            db: Database session\n\n        Returns:\n            List of context items\n        \"\"\"\n        if not db:\n            return []\n\n        try:\n            query = select(UserContext).where(\n                and_(\n                    UserContext.user_id == self.user_id,\n                    UserContext.confidence >= min_confidence,\n                    UserContext.contradicted == False,\n                )\n            )\n\n            if category:\n                query = query.where(UserContext.category == category)\n\n            result = await db.execute(query.order_by(UserContext.confidence.desc()))\n            contexts = result.scalars().all()\n\n            return [\n                {\n                    \"category\": c.category,\n                    \"key\": c.key,\n                    \"value\": c.value,\n                    \"confidence\": c.confidence,\n                    \"observations\": c.observation_count,\n                }\n                for c in contexts\n            ]\n        except Exception as e:\n            logger.error(f\"Failed to query user context: {e}\")\n            return []\n\n    async def get_preferences(self, db: Optional[AsyncSession] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get user's communication preferences.\n\n        Returns dict with:\n        - detail_level: \"brief\" | \"detailed\" | \"balanced\"\n        - formality: \"formal\" | \"casual\" | \"adaptive\"\n        - response_style: Preferred response characteristics\n        \"\"\"\n        defaults = {\n            \"detail_level\": \"balanced\",\n            \"formality\": \"adaptive\",\n            \"response_style\": \"informative\",\n            \"topics_of_interest\": [],\n        }\n\n        if not db:\n            return defaults\n\n        preferences = await self.query(\n            category=ContextCategory.PREFERENCE,\n            db=db,\n        )\n\n        for pref in preferences:\n            if pref[\"key\"] in defaults:\n                defaults[pref[\"key\"]] = pref[\"value\"]\n\n        # Get topics of interest\n        interests = await self.query(\n            category=ContextCategory.INTEREST,\n            db=db,\n        )\n        defaults[\"topics_of_interest\"] = [i[\"value\"] for i in interests[:5]]\n\n        return defaults\n\n\n# ==============================================================================\n# Speech Profile Manager\n# ==============================================================================\n\n\nclass SpeechProfileManager:\n    \"\"\"\n    Manages long-term speech profile for a user.\n\n    Provides personalized timing parameters for:\n    - Response delay\n    - Backchannel frequency\n    - Barge-in sensitivity\n    \"\"\"\n\n    def __init__(self, user_id: uuid.UUID):\n        self.user_id = user_id\n        self._profile: Optional[UserSpeechProfile] = None\n\n    async def load(self, db: Session) -> Optional[UserSpeechProfile]:\n        \"\"\"Load user's speech profile from database.\"\"\"\n        try:\n            self._profile = UserSpeechProfile.get_or_create(db, self.user_id)\n            return self._profile\n        except Exception as e:\n            logger.error(f\"Failed to load speech profile: {e}\")\n            return None\n\n    async def update_from_session(\n        self,\n        wpm: float,\n        avg_pause_ms: float,\n        utterance_count: int,\n        session_duration_min: float,\n        db: Session,\n    ) -> None:\n        \"\"\"Update profile after a voice session.\"\"\"\n        if not self._profile:\n            await self.load(db)\n\n        if self._profile:\n            self._profile.update_from_session(\n                wpm=wpm,\n                avg_pause_ms=avg_pause_ms,\n                utterance_count=utterance_count,\n                session_duration_min=session_duration_min,\n            )\n            db.commit()\n\n    def get_optimal_timing(self) -> Dict[str, Any]:\n        \"\"\"Get optimal response timing for this user.\"\"\"\n        if self._profile:\n            return self._profile.get_optimal_response_timing()\n\n        # Defaults for new users\n        return {\n            \"response_delay_ms\": 200,\n            \"backchannel_interval_s\": 7,\n            \"barge_in_threshold\": 0.5,\n            \"turn_yield_ms\": 1500,\n        }\n\n\n# ==============================================================================\n# Memory Context Service\n# ==============================================================================\n\n\nclass MemoryContextService:\n    \"\"\"\n    Unified service for conversation memory and user context.\n\n    Provides:\n    - Session-scoped conversation memory\n    - User-scoped context learning\n    - Speech profile management\n    \"\"\"\n\n    def __init__(self):\n        self._conversation_managers: Dict[str, ConversationMemoryManager] = {}\n        self._context_managers: Dict[str, UserContextManager] = {}\n        self._profile_managers: Dict[str, SpeechProfileManager] = {}\n\n    def get_conversation_memory(\n        self,\n        session_id: uuid.UUID,\n        user_id: uuid.UUID,\n    ) -> ConversationMemoryManager:\n        \"\"\"Get or create conversation memory manager for a session.\"\"\"\n        key = str(session_id)\n        if key not in self._conversation_managers:\n            self._conversation_managers[key] = ConversationMemoryManager(\n                session_id=session_id,\n                user_id=user_id,\n            )\n        return self._conversation_managers[key]\n\n    def get_user_context(self, user_id: uuid.UUID) -> UserContextManager:\n        \"\"\"Get or create user context manager.\"\"\"\n        key = str(user_id)\n        if key not in self._context_managers:\n            self._context_managers[key] = UserContextManager(user_id=user_id)\n        return self._context_managers[key]\n\n    def get_speech_profile(self, user_id: uuid.UUID) -> SpeechProfileManager:\n        \"\"\"Get or create speech profile manager.\"\"\"\n        key = str(user_id)\n        if key not in self._profile_managers:\n            self._profile_managers[key] = SpeechProfileManager(user_id=user_id)\n        return self._profile_managers[key]\n\n    def end_session(self, session_id: uuid.UUID) -> None:\n        \"\"\"Clean up session-scoped resources.\"\"\"\n        key = str(session_id)\n        if key in self._conversation_managers:\n            self._conversation_managers[key].clear_cache()\n            del self._conversation_managers[key]\n\n    async def build_context_for_llm(\n        self,\n        session_id: uuid.UUID,\n        user_id: uuid.UUID,\n        db: Optional[AsyncSession] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Build comprehensive context for LLM prompt injection.\n\n        Returns dict with:\n        - conversation: Current conversation context\n        - user: User preferences and context\n        - timing: Optimal response timing\n        \"\"\"\n        conv_memory = self.get_conversation_memory(session_id, user_id)\n        user_context = self.get_user_context(user_id)\n        speech_profile = self.get_speech_profile(user_id)\n\n        return {\n            \"conversation\": await conv_memory.get_context_summary(db),\n            \"user\": await user_context.get_preferences(db),\n            \"timing\": speech_profile.get_optimal_timing(),\n        }\n\n\n# Global service instance\nmemory_context_service = MemoryContextService()\n"
}
