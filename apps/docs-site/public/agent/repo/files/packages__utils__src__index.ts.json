{
  "path": "packages/utils/src/index.ts",
  "language": "typescript",
  "size": 8106,
  "last_modified": "2025-11-29T04:27:41.406Z",
  "lines": 304,
  "content": "/**\n * VoiceAssist Utilities\n * Shared utility functions and helpers\n */\n\n// ============================================================================\n// String Utilities\n// ============================================================================\n\n/**\n * Capitalizes the first letter of a string\n */\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Truncates a string to a maximum length and adds ellipsis\n */\nexport function truncate(str: string, maxLength: number): string {\n  if (str.length <= maxLength) return str;\n  return str.slice(0, maxLength - 3) + \"...\";\n}\n\n/**\n * Converts a string to kebab-case\n */\nexport function kebabCase(str: string): string {\n  return str\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase();\n}\n\n/**\n * Converts a string to camelCase\n */\nexport function camelCase(str: string): string {\n  return str\n    .replace(/[-_\\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : \"\"))\n    .replace(/^[A-Z]/, (char) => char.toLowerCase());\n}\n\n// ============================================================================\n// Date/Time Utilities\n// ============================================================================\n\n/**\n * Formats a date to a human-readable string\n */\nexport function formatDate(\n  date: Date | string,\n  format: \"short\" | \"long\" = \"short\",\n): string {\n  const d = typeof date === \"string\" ? new Date(date) : date;\n\n  if (format === \"short\") {\n    return d.toLocaleDateString();\n  }\n\n  return d.toLocaleDateString(undefined, {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n  });\n}\n\n/**\n * Returns a relative time string (e.g., \"2 hours ago\")\n */\nexport function relativeTime(date: Date | string): string {\n  const d = typeof date === \"string\" ? new Date(date) : date;\n  const now = new Date();\n  const diffMs = now.getTime() - d.getTime();\n  const diffSec = Math.floor(diffMs / 1000);\n  const diffMin = Math.floor(diffSec / 60);\n  const diffHour = Math.floor(diffMin / 60);\n  const diffDay = Math.floor(diffHour / 24);\n\n  if (diffSec < 60) return \"just now\";\n  if (diffMin < 60) return `${diffMin} minute${diffMin > 1 ? \"s\" : \"\"} ago`;\n  if (diffHour < 24) return `${diffHour} hour${diffHour > 1 ? \"s\" : \"\"} ago`;\n  if (diffDay < 7) return `${diffDay} day${diffDay > 1 ? \"s\" : \"\"} ago`;\n\n  return formatDate(d);\n}\n\n// ============================================================================\n// Array Utilities\n// ============================================================================\n\n/**\n * Chunks an array into smaller arrays of specified size\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Removes duplicate values from an array\n */\nexport function unique<T>(array: T[]): T[] {\n  return Array.from(new Set(array));\n}\n\n/**\n * Shuffles an array randomly\n */\nexport function shuffle<T>(array: T[]): T[] {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\n// ============================================================================\n// Object Utilities\n// ============================================================================\n\n/**\n * Deeply clones an object\n */\nexport function deepClone<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Picks specified keys from an object\n */\nexport function pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[],\n): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach((key) => {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  });\n  return result;\n}\n\n/**\n * Omits specified keys from an object\n */\nexport function omit<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[],\n): Omit<T, K> {\n  const result = { ...obj };\n  keys.forEach((key) => {\n    delete result[key];\n  });\n  return result;\n}\n\n// ============================================================================\n// Validation Utilities\n// ============================================================================\n\n/**\n * Validates an email address\n */\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n/**\n * Validates a URL\n */\nexport function isValidUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Checks if a value is empty (null, undefined, '', [], {})\n */\nexport function isEmpty(value: unknown): boolean {\n  if (value === null || value === undefined) return true;\n  if (typeof value === \"string\") return value.trim().length === 0;\n  if (Array.isArray(value)) return value.length === 0;\n  if (typeof value === \"object\") return Object.keys(value).length === 0;\n  return false;\n}\n\n// ============================================================================\n// Formatting Utilities\n// ============================================================================\n\n/**\n * Formats a file size in bytes to a human-readable string\n */\nexport function formatBytes(bytes: number, decimals = 2): string {\n  if (bytes === 0) return \"0 Bytes\";\n\n  const k = 1024;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;\n}\n\n/**\n * Formats a number with thousand separators\n */\nexport function formatNumber(num: number): string {\n  return num.toLocaleString();\n}\n\n// ============================================================================\n// Debounce & Throttle\n// ============================================================================\n\n/**\n * Debounces a function call\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Throttles a function call\n */\nexport function throttle<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  limit: number,\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n\n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n\n// ============================================================================\n// PHI Detection Utilities (HIPAA Compliance)\n// ============================================================================\n\n/**\n * Patterns for detecting potential PHI (Protected Health Information)\n * Note: Non-global patterns used to avoid lastIndex mutation in .test() calls\n */\nconst PHI_PATTERNS = {\n  ssn: /\\b\\d{3}-\\d{2}-\\d{4}\\b/,\n  phone: /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/,\n  email: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/,\n  mrn: /\\b(MRN|Medical Record Number|Patient ID)[:\\s]*\\d+\\b/i,\n  dob: /\\b\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}\\b/,\n};\n\n/**\n * Checks if text contains potential PHI\n */\nexport function containsPHI(text: string): boolean {\n  return Object.values(PHI_PATTERNS).some((pattern) => pattern.test(text));\n}\n\n/**\n * Redacts potential PHI from text\n */\nexport function redactPHI(text: string): string {\n  let redacted = text;\n  Object.entries(PHI_PATTERNS).forEach(([type, pattern]) => {\n    // Create global version of pattern for replace (to redact all occurrences)\n    const globalPattern = new RegExp(pattern.source, pattern.flags + \"g\");\n    redacted = redacted.replace(\n      globalPattern,\n      `[REDACTED_${type.toUpperCase()}]`,\n    );\n  });\n  return redacted;\n}\n"
}
