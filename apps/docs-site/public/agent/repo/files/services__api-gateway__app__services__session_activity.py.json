{
  "path": "services/api-gateway/app/services/session_activity.py",
  "language": "python",
  "size": 7633,
  "last_modified": "2025-12-04T11:26:59.908Z",
  "lines": 213,
  "content": "\"\"\"\nSession activity tracking service using Redis.\n\nTracks user activity for session timeout enforcement:\n- Inactivity timeout: Logout after N minutes of no activity\n- Absolute timeout: Force re-login after N hours regardless of activity\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional, Tuple\n\nimport redis.asyncio as redis\nfrom app.core.config import settings\n\nlogger = logging.getLogger(__name__)\n\n\nclass SessionActivityService:\n    \"\"\"\n    Service for tracking session activity and enforcing timeouts.\n\n    Uses Redis to store:\n    - Last activity timestamp per user session\n    - Session creation timestamp for absolute timeout\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize Redis connection for session tracking.\"\"\"\n        self.redis_client: Optional[redis.Redis] = None\n\n    async def connect(self):\n        \"\"\"Connect to Redis (call during app startup).\"\"\"\n        try:\n            self.redis_client = await redis.from_url(settings.REDIS_URL, encoding=\"utf-8\", decode_responses=True)\n            await self.redis_client.ping()\n            logger.info(\"Session activity service connected to Redis\")\n        except Exception as e:\n            logger.error(f\"Failed to connect to Redis for session tracking: {e}\")\n\n    async def disconnect(self):\n        \"\"\"Disconnect from Redis (call during app shutdown).\"\"\"\n        if self.redis_client:\n            await self.redis_client.close()\n            logger.info(\"Session activity service disconnected from Redis\")\n\n    def _get_session_key(self, user_id: str, token_iat: int) -> str:\n        \"\"\"Generate Redis key for session activity tracking.\"\"\"\n        # Use token issued-at time to distinguish between sessions\n        return f\"session_activity:{user_id}:{token_iat}\"\n\n    async def record_activity(self, user_id: str, token_iat: int) -> bool:\n        \"\"\"\n        Record user activity for session timeout tracking.\n\n        Args:\n            user_id: User ID\n            token_iat: Token issued-at timestamp (identifies the session)\n\n        Returns:\n            True if activity was recorded, False if Redis unavailable\n        \"\"\"\n        if not self.redis_client:\n            logger.warning(\"Cannot record activity - Redis not connected\")\n            return False\n\n        try:\n            key = self._get_session_key(user_id, token_iat)\n            now = datetime.now(timezone.utc).isoformat()\n\n            # Store with TTL slightly longer than absolute timeout\n            ttl_seconds = (settings.SESSION_ABSOLUTE_TIMEOUT_HOURS * 3600) + 3600\n\n            await self.redis_client.setex(name=key, time=timedelta(seconds=ttl_seconds), value=now)\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to record activity: {e}\")\n            return False\n\n    async def get_last_activity(self, user_id: str, token_iat: int) -> Optional[datetime]:\n        \"\"\"\n        Get the last activity timestamp for a session.\n\n        Args:\n            user_id: User ID\n            token_iat: Token issued-at timestamp\n\n        Returns:\n            Last activity datetime or None if not found\n        \"\"\"\n        if not self.redis_client:\n            return None\n\n        try:\n            key = self._get_session_key(user_id, token_iat)\n            value = await self.redis_client.get(key)\n\n            if value:\n                return datetime.fromisoformat(value)\n            return None\n\n        except Exception as e:\n            logger.error(f\"Failed to get last activity: {e}\")\n            return None\n\n    async def check_session_timeouts(self, user_id: str, token_iat: int) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        Check if a session has timed out.\n\n        Args:\n            user_id: User ID\n            token_iat: Token issued-at timestamp (seconds since epoch)\n\n        Returns:\n            Tuple of (is_valid, error_reason)\n            - (True, None) if session is valid\n            - (False, \"reason\") if session has timed out\n        \"\"\"\n        now = datetime.now(timezone.utc)\n\n        # Check absolute timeout (based on token issue time)\n        token_issued = datetime.fromtimestamp(token_iat, tz=timezone.utc)\n        absolute_limit = timedelta(hours=settings.SESSION_ABSOLUTE_TIMEOUT_HOURS)\n\n        if now - token_issued > absolute_limit:\n            logger.info(f\"Session absolute timeout for user {user_id}\")\n            return (False, \"Session expired. Please log in again.\")\n\n        # Check inactivity timeout\n        last_activity = await self.get_last_activity(user_id, token_iat)\n\n        if last_activity:\n            inactivity_limit = timedelta(minutes=settings.SESSION_INACTIVITY_TIMEOUT_MINUTES)\n\n            if now - last_activity > inactivity_limit:\n                logger.info(f\"Session inactivity timeout for user {user_id}\")\n                return (\n                    False,\n                    \"Session timed out due to inactivity. Please log in again.\",\n                )\n\n        # Session is valid - record new activity\n        await self.record_activity(user_id, token_iat)\n\n        return (True, None)\n\n    async def get_session_info(self, user_id: str, token_iat: int) -> dict:\n        \"\"\"\n        Get session timeout information for the frontend.\n\n        Returns timing info that the frontend can use to show warnings.\n\n        Args:\n            user_id: User ID\n            token_iat: Token issued-at timestamp\n\n        Returns:\n            Dict with session timing info\n        \"\"\"\n        now = datetime.now(timezone.utc)\n        token_issued = datetime.fromtimestamp(token_iat, tz=timezone.utc)\n\n        # Calculate time remaining until absolute timeout\n        absolute_limit = timedelta(hours=settings.SESSION_ABSOLUTE_TIMEOUT_HOURS)\n        absolute_expires_at = token_issued + absolute_limit\n        absolute_remaining = (absolute_expires_at - now).total_seconds()\n\n        # Calculate time remaining until inactivity timeout\n        last_activity = await self.get_last_activity(user_id, token_iat)\n        if last_activity:\n            inactivity_limit = timedelta(minutes=settings.SESSION_INACTIVITY_TIMEOUT_MINUTES)\n            inactivity_expires_at = last_activity + inactivity_limit\n            inactivity_remaining = (inactivity_expires_at - now).total_seconds()\n        else:\n            # No activity recorded yet, assume now is the start\n            inactivity_remaining = settings.SESSION_INACTIVITY_TIMEOUT_MINUTES * 60\n\n        return {\n            \"absolute_timeout_hours\": settings.SESSION_ABSOLUTE_TIMEOUT_HOURS,\n            \"inactivity_timeout_minutes\": settings.SESSION_INACTIVITY_TIMEOUT_MINUTES,\n            \"absolute_remaining_seconds\": max(0, int(absolute_remaining)),\n            \"inactivity_remaining_seconds\": max(0, int(inactivity_remaining)),\n            \"session_started_at\": token_issued.isoformat(),\n            \"last_activity_at\": last_activity.isoformat() if last_activity else None,\n        }\n\n    async def invalidate_session(self, user_id: str, token_iat: int) -> bool:\n        \"\"\"\n        Invalidate a session (e.g., on logout).\n\n        Args:\n            user_id: User ID\n            token_iat: Token issued-at timestamp\n\n        Returns:\n            True if session was invalidated\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            key = self._get_session_key(user_id, token_iat)\n            await self.redis_client.delete(key)\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to invalidate session: {e}\")\n            return False\n\n\n# Global instance\nsession_activity_service = SessionActivityService()\n"
}
