{
  "path": "services/api-gateway/app/services/webrtc_signaling.py",
  "language": "python",
  "size": 3659,
  "last_modified": "2025-12-04T11:27:02.087Z",
  "lines": 105,
  "content": "\"\"\"In-memory WebRTC signaling helper.\n\nThis module tracks SDP offers/answers and ICE candidates so the\nfrontend can establish a peer connection for low-latency media\ndelivery. The goal is to keep signaling stateless for now while\nstill surfacing VAD and noise suppression preferences coming from\nserver-side audio utilities.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\n\nfrom app.core.logging import get_logger\nfrom app.services.audio_processor import AudioProcessor, AudioProcessorConfig\nfrom app.services.voice_activity_detector import VoiceActivityDetector\n\nlogger = get_logger(__name__)\n\n\n@dataclass\nclass WebRTCSession:\n    \"\"\"Cached signaling payloads for a single session.\"\"\"\n\n    session_id: str\n    user_id: str\n    offer_sdp: Optional[str] = None\n    answer_sdp: Optional[str] = None\n    ice_candidates: List[dict] = field(default_factory=list)\n    vad_threshold: float = 0.5\n    noise_suppression: bool = True\n\n\nclass WebRTCSignalingService:\n    \"\"\"Simple in-memory signaling store.\"\"\"\n\n    def __init__(self) -> None:\n        self._sessions: Dict[str, WebRTCSession] = {}\n        vad = VoiceActivityDetector()\n        self._default_vad_threshold = vad.config.threshold\n        self._audio_processor = AudioProcessor(AudioProcessorConfig())\n\n    def _get_or_create(self, session_id: str, user_id: str) -> WebRTCSession:\n        if session_id not in self._sessions:\n            self._sessions[session_id] = WebRTCSession(\n                session_id=session_id,\n                user_id=user_id,\n                vad_threshold=self._default_vad_threshold,\n                noise_suppression=self._audio_processor.config.noise_enabled,\n            )\n        return self._sessions[session_id]\n\n    def register_offer(self, *, session_id: str, user_id: str, sdp: str) -> WebRTCSession:\n        session = self._get_or_create(session_id, user_id)\n        session.offer_sdp = sdp\n        logger.info(\n            \"webrtc_offer_registered\",\n            extra={\"session_id\": session_id, \"user_id\": user_id},\n        )\n        return session\n\n    def register_answer(self, *, session_id: str, user_id: str, sdp: str) -> Optional[WebRTCSession]:\n        session = self._sessions.get(session_id)\n        if not session:\n            logger.warning(\n                \"webrtc_answer_missing_session\",\n                extra={\"session_id\": session_id, \"user_id\": user_id},\n            )\n            return None\n\n        session.answer_sdp = sdp\n        logger.info(\n            \"webrtc_answer_registered\",\n            extra={\"session_id\": session_id, \"user_id\": user_id},\n        )\n        return session\n\n    def add_ice_candidate(self, *, session_id: str, user_id: str, candidate: dict) -> Optional[WebRTCSession]:\n        session = self._sessions.get(session_id)\n        if not session:\n            logger.warning(\n                \"webrtc_candidate_missing_session\",\n                extra={\"session_id\": session_id, \"user_id\": user_id},\n            )\n            return None\n\n        session.ice_candidates.append(candidate)\n        logger.debug(\n            \"webrtc_candidate_added\",\n            extra={\"session_id\": session_id, \"count\": len(session.ice_candidates)},\n        )\n        return session\n\n    def get_session(self, session_id: str) -> Optional[WebRTCSession]:\n        return self._sessions.get(session_id)\n\n    def clear_session(self, session_id: str) -> None:\n        if session_id in self._sessions:\n            del self._sessions[session_id]\n            logger.info(\"webrtc_session_cleared\", extra={\"session_id\": session_id})\n\n\nsignaling_service = WebRTCSignalingService()\n"
}
