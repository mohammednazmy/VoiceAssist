{
  "path": "services/api-gateway/app/services/tools/calendar_tool.py",
  "language": "python",
  "size": 30908,
  "last_modified": "2025-12-04T11:27:01.712Z",
  "lines": 946,
  "content": "\"\"\"\nMulti-Provider Calendar Tool for VoiceAssist\n\nSupports Google Calendar, Microsoft Outlook, Apple iCloud, and Nextcloud (CalDAV).\nHandles multi-calendar scenarios with user clarification flow.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, List, Optional\n\nimport dateparser\nfrom app.services.tools.tool_service import ToolExecutionContext, ToolResult\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\n\nasync def get_user_calendar_connections(\n    user_id: str, db_session: Optional[AsyncSession] = None\n) -> List[Dict[str, Any]]:\n    \"\"\"Get all calendar connections for a user.\"\"\"\n    if not db_session:\n        # Return empty list if no database session\n        return []\n\n    from sqlalchemy import text\n\n    result = await db_session.execute(\n        text(\n            \"\"\"\n            SELECT id, provider, provider_display_name, status, caldav_url,\n                   last_sync_at, connected_at\n            FROM user_calendar_connections\n            WHERE user_id = :user_id\n            ORDER BY connected_at\n        \"\"\"\n        ),\n        {\"user_id\": user_id},\n    )\n    rows = result.fetchall()\n    return [\n        {\n            \"id\": str(row.id),\n            \"provider\": row.provider,\n            \"provider_display_name\": row.provider_display_name,\n            \"status\": row.status,\n            \"caldav_url\": row.caldav_url,\n            \"last_sync_at\": row.last_sync_at.isoformat() if row.last_sync_at else None,\n            \"connected_at\": row.connected_at.isoformat() if row.connected_at else None,\n        }\n        for row in rows\n    ]\n\n\ndef parse_datetime(time_str: str, reference_time: Optional[datetime] = None) -> Optional[datetime]:\n    \"\"\"\n    Parse a natural language time string into a datetime.\n\n    Handles:\n    - \"one hour from now\" → current time + 1 hour\n    - \"tomorrow at 2pm\" → next day at 14:00\n    - \"in 30 minutes\" → current time + 30 minutes\n    - \"next Monday\" → next Monday's date\n    - ISO format \"2025-12-01T14:00:00\" → passthrough\n\n    Args:\n        time_str: Natural language time string or ISO format\n        reference_time: Optional reference time for relative calculations (default: now)\n    \"\"\"\n    if not time_str:\n        return None\n\n    # Try ISO format first (passthrough for already-formatted dates)\n    try:\n        return datetime.fromisoformat(time_str.replace(\"Z\", \"+00:00\"))\n    except ValueError:\n        pass\n\n    # Use dateparser for natural language parsing\n    settings = {\n        \"PREFER_DATES_FROM\": \"future\",\n        \"PREFER_DAY_OF_MONTH\": \"first\",\n        \"RETURN_AS_TIMEZONE_AWARE\": True,\n    }\n\n    # Use reference time for relative calculations (e.g., \"in one hour\")\n    if reference_time:\n        settings[\"RELATIVE_BASE\"] = reference_time\n\n    parsed = dateparser.parse(time_str, settings=settings)\n    return parsed\n\n\nasync def handle_create_event(arguments: Dict[str, Any], context: ToolExecutionContext) -> ToolResult:\n    \"\"\"\n    Create a calendar event.\n\n    Handles multi-calendar scenarios by asking for clarification when needed.\n    \"\"\"\n    title = arguments.get(\"title\")\n    start_time_str = arguments.get(\"start_time\")\n    end_time_str = arguments.get(\"end_time\")\n    description = arguments.get(\"description\")\n    location = arguments.get(\"location\")\n    calendar_provider = arguments.get(\"calendar_provider\")\n\n    if not title or not start_time_str:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=\"Title and start_time are required\",\n            error_type=\"ValidationError\",\n        )\n\n    # Parse the start time\n    start_dt = parse_datetime(start_time_str)\n    if not start_dt:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=f\"Could not parse start time: {start_time_str}\",\n            error_type=\"ParseError\",\n        )\n\n    # Parse end time or default to 1 hour after start\n    if end_time_str:\n        end_dt = parse_datetime(end_time_str)\n        if not end_dt:\n            end_dt = start_dt + timedelta(hours=1)\n    else:\n        end_dt = start_dt + timedelta(hours=1)\n\n    # Get user's calendar connections\n    connections = await get_user_calendar_connections(context.user_id, context.db_session)\n    connected = [c for c in connections if c[\"status\"] == \"connected\"]\n\n    if not connected:\n        return ToolResult(\n            success=False,\n            data={\n                \"needs_connection\": True,\n                \"available_providers\": [\"google\", \"microsoft\", \"apple\", \"nextcloud\"],\n            },\n            needs_connection=True,\n            message=(\n                \"You don't have any calendars connected. \"\n                \"Would you like to connect Google Calendar, Outlook, iCloud, or Nextcloud?\"\n            ),\n        )\n\n    # If multiple calendars and no preference specified\n    if len(connected) > 1 and not calendar_provider:\n        providers = [c[\"provider\"] for c in connected]\n        provider_names = [c[\"provider_display_name\"] or c[\"provider\"] for c in connected]\n        return ToolResult(\n            success=False,\n            data={\n                \"needs_clarification\": True,\n                \"available_calendars\": providers,\n                \"calendar_names\": provider_names,\n            },\n            needs_clarification=True,\n            available_calendars=providers,\n            message=f\"Which calendar should I add this to? You have {', '.join(provider_names)} connected.\",\n        )\n\n    # Select the calendar to use\n    target_provider = calendar_provider or connected[0][\"provider\"]\n    target_connection = next((c for c in connected if c[\"provider\"] == target_provider), None)\n\n    if not target_connection:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=f\"No connected calendar found for provider: {target_provider}\",\n            error_type=\"ConnectionNotFound\",\n        )\n\n    # Create the event using the appropriate provider\n    try:\n        if target_provider == \"google\":\n            result = await _create_google_event(\n                context.user_id,\n                target_connection,\n                title,\n                start_dt,\n                end_dt,\n                description,\n                location,\n                context.db_session,\n            )\n        elif target_provider == \"microsoft\":\n            result = await _create_microsoft_event(\n                context.user_id,\n                target_connection,\n                title,\n                start_dt,\n                end_dt,\n                description,\n                location,\n                context.db_session,\n            )\n        elif target_provider in [\"apple\", \"nextcloud\", \"caldav\"]:\n            result = await _create_caldav_event(\n                context.user_id,\n                target_connection,\n                title,\n                start_dt,\n                end_dt,\n                description,\n                location,\n                context.db_session,\n            )\n        else:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"Unsupported calendar provider: {target_provider}\",\n                error_type=\"UnsupportedProvider\",\n            )\n\n        return ToolResult(\n            success=True,\n            data={\n                \"event_id\": result.get(\"event_id\"),\n                \"calendar\": target_connection[\"provider_display_name\"] or target_provider.title(),\n                \"title\": title,\n                \"start\": start_dt.isoformat(),\n                \"end\": end_dt.isoformat(),\n            },\n            message=(\n                f\"Added '{title}' to your {target_provider.title()} Calendar \"\n                f\"for {start_dt.strftime('%A, %B %d at %I:%M %p')}.\"\n            ),\n        )\n\n    except Exception as e:\n        logger.exception(f\"Error creating calendar event: {e}\")\n        return ToolResult(\n            success=False,\n            data=None,\n            error=str(e),\n            error_type=type(e).__name__,\n        )\n\n\nasync def _create_google_event(\n    user_id: str,\n    connection: Dict[str, Any],\n    title: str,\n    start: datetime,\n    end: datetime,\n    description: Optional[str],\n    location: Optional[str],\n    db_session: Optional[AsyncSession],\n) -> Dict[str, Any]:\n    \"\"\"Create event via Google Calendar API.\"\"\"\n    from app.services.tools.oauth_service import oauth_service\n\n    # Get decrypted tokens\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        raise ValueError(\"No valid tokens found for Google Calendar\")\n\n    # Use google-api-python-client\n    from google.oauth2.credentials import Credentials\n    from googleapiclient.discovery import build\n\n    creds = Credentials(\n        token=tokens[\"access_token\"],\n        refresh_token=tokens.get(\"refresh_token\"),\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_id=oauth_service.get_client_id(\"google\"),\n        client_secret=oauth_service.get_client_secret(\"google\"),\n    )\n\n    service = build(\"calendar\", \"v3\", credentials=creds)\n\n    # Get user's calendar timezone from their Google Calendar settings\n    try:\n        calendar_settings = service.settings().get(setting=\"timezone\").execute()\n        user_timezone = calendar_settings.get(\"value\", \"America/New_York\")\n    except Exception:\n        user_timezone = \"America/New_York\"  # Default fallback\n\n    # Format datetime for Google Calendar API\n    # Keep as local time (what the user intended) and specify their timezone\n    start_iso = start.strftime(\"%Y-%m-%dT%H:%M:%S\")\n    end_iso = end.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    logger.info(\n        f\"[Google Calendar] Creating event: title='{title}', \"\n        f\"start={start_iso}, end={end_iso} (timezone={user_timezone})\"\n    )\n\n    event_body = {\n        \"summary\": title,\n        \"start\": {\"dateTime\": start_iso, \"timeZone\": user_timezone},\n        \"end\": {\"dateTime\": end_iso, \"timeZone\": user_timezone},\n    }\n\n    if description:\n        event_body[\"description\"] = description\n    if location:\n        event_body[\"location\"] = location\n\n    logger.info(f\"[Google Calendar] Event body: {event_body}\")\n\n    event = service.events().insert(calendarId=\"primary\", body=event_body).execute()\n\n    logger.info(f\"[Google Calendar] Event created: id={event['id']}, link={event.get('htmlLink')}\")\n\n    return {\"event_id\": event[\"id\"], \"html_link\": event.get(\"htmlLink\")}\n\n\nasync def _create_microsoft_event(\n    user_id: str,\n    connection: Dict[str, Any],\n    title: str,\n    start: datetime,\n    end: datetime,\n    description: Optional[str],\n    location: Optional[str],\n    db_session: Optional[AsyncSession],\n) -> Dict[str, Any]:\n    \"\"\"Create event via Microsoft Graph API.\"\"\"\n    import httpx\n    from app.services.tools.oauth_service import oauth_service\n\n    # Get decrypted tokens\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        raise ValueError(\"No valid tokens found for Microsoft Calendar\")\n\n    event_body = {\n        \"subject\": title,\n        \"start\": {\n            \"dateTime\": start.strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            \"timeZone\": \"UTC\",\n        },\n        \"end\": {\n            \"dateTime\": end.strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            \"timeZone\": \"UTC\",\n        },\n    }\n\n    if description:\n        event_body[\"body\"] = {\"contentType\": \"text\", \"content\": description}\n    if location:\n        event_body[\"location\"] = {\"displayName\": location}\n\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            \"https://graph.microsoft.com/v1.0/me/events\",\n            headers={\n                \"Authorization\": f\"Bearer {tokens['access_token']}\",\n                \"Content-Type\": \"application/json\",\n            },\n            json=event_body,\n        )\n        response.raise_for_status()\n        event = response.json()\n\n    return {\"event_id\": event[\"id\"], \"web_link\": event.get(\"webLink\")}\n\n\nasync def _create_caldav_event(\n    user_id: str,\n    connection: Dict[str, Any],\n    title: str,\n    start: datetime,\n    end: datetime,\n    description: Optional[str],\n    location: Optional[str],\n    db_session: Optional[AsyncSession],\n) -> Dict[str, Any]:\n    \"\"\"Create event via CalDAV (Apple iCloud, Nextcloud, etc.).\"\"\"\n    from app.services.caldav_service import CalDAVService, CalendarEvent\n\n    # Get CalDAV credentials\n    caldav_url = connection.get(\"caldav_url\")\n    if not caldav_url:\n        raise ValueError(\"No CalDAV URL configured for this connection\")\n\n    from app.services.tools.oauth_service import oauth_service\n\n    caldav_creds = await oauth_service.get_caldav_credentials(connection[\"id\"], db_session)\n    if not caldav_creds:\n        raise ValueError(\"No CalDAV credentials found\")\n\n    # Create CalDAV service\n    caldav_service = CalDAVService(\n        url=caldav_url,\n        username=caldav_creds[\"username\"],\n        password=caldav_creds[\"password\"],\n    )\n\n    # Create the event\n    event = CalendarEvent(\n        uid=None,  # Will be generated\n        summary=title,\n        start=start,\n        end=end,\n        description=description,\n        location=location,\n    )\n\n    created_event = await caldav_service.create_event(event)\n\n    return {\"event_id\": created_event.uid}\n\n\nasync def handle_list_events(arguments: Dict[str, Any], context: ToolExecutionContext) -> ToolResult:\n    \"\"\"\n    List calendar events.\n\n    Supports querying across multiple calendars.\n    \"\"\"\n    start_date_str = arguments.get(\"start_date\", \"today\")\n    end_date_str = arguments.get(\"end_date\")\n    calendar_provider = arguments.get(\"calendar_provider\", \"all\")\n    max_results = arguments.get(\"max_results\", 10)\n\n    # Parse dates\n    start_dt = parse_datetime(start_date_str) or datetime.now()\n    if end_date_str:\n        end_dt = parse_datetime(end_date_str)\n    else:\n        end_dt = start_dt + timedelta(days=7)\n\n    # Get user's calendar connections\n    connections = await get_user_calendar_connections(context.user_id, context.db_session)\n    connected = [c for c in connections if c[\"status\"] == \"connected\"]\n\n    if not connected:\n        return ToolResult(\n            success=False,\n            data={\"needs_connection\": True},\n            needs_connection=True,\n            message=\"You don't have any calendars connected.\",\n        )\n\n    # Filter by provider if specified\n    if calendar_provider and calendar_provider != \"all\":\n        connected = [c for c in connected if c[\"provider\"] == calendar_provider]\n        if not connected:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"No connected {calendar_provider} calendar found\",\n            )\n\n    all_events = []\n\n    for conn in connected:\n        try:\n            if conn[\"provider\"] == \"google\":\n                events = await _list_google_events(\n                    context.user_id,\n                    conn,\n                    start_dt,\n                    end_dt,\n                    max_results,\n                    context.db_session,\n                )\n            elif conn[\"provider\"] == \"microsoft\":\n                events = await _list_microsoft_events(\n                    context.user_id,\n                    conn,\n                    start_dt,\n                    end_dt,\n                    max_results,\n                    context.db_session,\n                )\n            elif conn[\"provider\"] in [\"apple\", \"nextcloud\", \"caldav\"]:\n                events = await _list_caldav_events(\n                    context.user_id,\n                    conn,\n                    start_dt,\n                    end_dt,\n                    max_results,\n                    context.db_session,\n                )\n            else:\n                continue\n\n            # Add provider info to each event\n            for event in events:\n                event[\"calendar\"] = conn[\"provider_display_name\"] or conn[\"provider\"]\n                event[\"provider\"] = conn[\"provider\"]\n\n            all_events.extend(events)\n\n        except Exception as e:\n            logger.warning(f\"Error listing events from {conn['provider']}: {e}\")\n            # Continue with other calendars\n\n    # Sort by start time and limit\n    all_events.sort(key=lambda e: e.get(\"start\", \"\"))\n    all_events = all_events[:max_results]\n\n    if not all_events:\n        return ToolResult(\n            success=True,\n            data={\"events\": [], \"count\": 0},\n            message=f\"No events found between {start_dt.strftime('%B %d')} and {end_dt.strftime('%B %d')}.\",\n        )\n\n    return ToolResult(\n        success=True,\n        data={\n            \"events\": all_events,\n            \"count\": len(all_events),\n            \"start_date\": start_dt.isoformat(),\n            \"end_date\": end_dt.isoformat(),\n        },\n        message=f\"Found {len(all_events)} events.\",\n    )\n\n\nasync def _list_google_events(\n    user_id: str,\n    connection: Dict[str, Any],\n    start: datetime,\n    end: datetime,\n    max_results: int,\n    db_session: Optional[AsyncSession],\n) -> List[Dict[str, Any]]:\n    \"\"\"List events from Google Calendar.\"\"\"\n    from app.services.tools.oauth_service import oauth_service\n    from google.oauth2.credentials import Credentials\n    from googleapiclient.discovery import build\n\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        logger.warning(\"[Google Calendar] No tokens found for listing events\")\n        return []\n\n    creds = Credentials(\n        token=tokens[\"access_token\"],\n        refresh_token=tokens.get(\"refresh_token\"),\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_id=oauth_service.get_client_id(\"google\"),\n        client_secret=oauth_service.get_client_secret(\"google\"),\n    )\n\n    service = build(\"calendar\", \"v3\", credentials=creds)\n\n    # Format time range for Google Calendar API\n    # Need RFC3339 format with Z suffix for UTC\n    # If datetime is timezone-aware, convert to UTC first\n    if start.tzinfo is not None:\n        import pytz\n\n        start_utc = start.astimezone(pytz.UTC)\n        time_min = start_utc.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    else:\n        time_min = start.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n\n    if end.tzinfo is not None:\n        import pytz\n\n        end_utc = end.astimezone(pytz.UTC)\n        time_max = end_utc.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    else:\n        time_max = end.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n\n    logger.info(f\"[Google Calendar] Listing events: timeMin={time_min}, timeMax={time_max}, max={max_results}\")\n\n    events_result = (\n        service.events()\n        .list(\n            calendarId=\"primary\",\n            timeMin=time_min,\n            timeMax=time_max,\n            maxResults=max_results,\n            singleEvents=True,\n            orderBy=\"startTime\",\n        )\n        .execute()\n    )\n\n    logger.info(f\"[Google Calendar] Raw API response: {len(events_result.get('items', []))} events found\")\n\n    events = []\n    for item in events_result.get(\"items\", []):\n        events.append(\n            {\n                \"id\": item[\"id\"],\n                \"title\": item.get(\"summary\", \"Untitled\"),\n                \"start\": item[\"start\"].get(\"dateTime\", item[\"start\"].get(\"date\")),\n                \"end\": item[\"end\"].get(\"dateTime\", item[\"end\"].get(\"date\")),\n                \"location\": item.get(\"location\"),\n                \"description\": item.get(\"description\"),\n            }\n        )\n\n    logger.info(f\"[Google Calendar] Returning {len(events)} events\")\n    return events\n\n\nasync def _list_microsoft_events(\n    user_id: str,\n    connection: Dict[str, Any],\n    start: datetime,\n    end: datetime,\n    max_results: int,\n    db_session: Optional[AsyncSession],\n) -> List[Dict[str, Any]]:\n    \"\"\"List events from Microsoft Calendar.\"\"\"\n    import httpx\n    from app.services.tools.oauth_service import oauth_service\n\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        return []\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            \"https://graph.microsoft.com/v1.0/me/calendarView\",\n            headers={\"Authorization\": f\"Bearer {tokens['access_token']}\"},\n            params={\n                \"startDateTime\": start.isoformat(),\n                \"endDateTime\": end.isoformat(),\n                \"$top\": max_results,\n                \"$orderby\": \"start/dateTime\",\n            },\n        )\n        response.raise_for_status()\n        data = response.json()\n\n    events = []\n    for item in data.get(\"value\", []):\n        events.append(\n            {\n                \"id\": item[\"id\"],\n                \"title\": item.get(\"subject\", \"Untitled\"),\n                \"start\": item[\"start\"][\"dateTime\"],\n                \"end\": item[\"end\"][\"dateTime\"],\n                \"location\": item.get(\"location\", {}).get(\"displayName\"),\n                \"description\": item.get(\"body\", {}).get(\"content\"),\n            }\n        )\n\n    return events\n\n\nasync def _list_caldav_events(\n    user_id: str,\n    connection: Dict[str, Any],\n    start: datetime,\n    end: datetime,\n    max_results: int,\n    db_session: Optional[AsyncSession],\n) -> List[Dict[str, Any]]:\n    \"\"\"List events from CalDAV calendar.\"\"\"\n    from app.services.caldav_service import CalDAVService\n    from app.services.tools.oauth_service import oauth_service\n\n    caldav_url = connection.get(\"caldav_url\")\n    if not caldav_url:\n        return []\n\n    caldav_creds = await oauth_service.get_caldav_credentials(connection[\"id\"], db_session)\n    if not caldav_creds:\n        return []\n\n    caldav_service = CalDAVService(\n        url=caldav_url,\n        username=caldav_creds[\"username\"],\n        password=caldav_creds[\"password\"],\n    )\n\n    events_list = await caldav_service.list_events(start, end)\n\n    events = []\n    for event in events_list[:max_results]:\n        events.append(\n            {\n                \"id\": event.uid,\n                \"title\": event.summary,\n                \"start\": event.start.isoformat() if event.start else None,\n                \"end\": event.end.isoformat() if event.end else None,\n                \"location\": event.location,\n                \"description\": event.description,\n            }\n        )\n\n    return events\n\n\n# ==============================================================================\n# Update Event Handler\n# ==============================================================================\n\n\nasync def handle_update_event(arguments: Dict[str, Any], context: ToolExecutionContext) -> ToolResult:\n    \"\"\"\n    Update an existing calendar event.\n    \"\"\"\n    event_id = arguments.get(\"event_id\")\n    title = arguments.get(\"title\")\n    start_time_str = arguments.get(\"start_time\")\n    end_time_str = arguments.get(\"end_time\")\n    description = arguments.get(\"description\")\n    location = arguments.get(\"location\")\n    calendar_provider = arguments.get(\"calendar_provider\", \"google\")\n\n    if not event_id:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=\"event_id is required\",\n            error_type=\"ValidationError\",\n        )\n\n    # Parse times if provided\n    start_dt = parse_datetime(start_time_str) if start_time_str else None\n    end_dt = parse_datetime(end_time_str) if end_time_str else None\n\n    # Get user's calendar connections\n    connections = await get_user_calendar_connections(context.user_id, context.db_session)\n    connected = [c for c in connections if c[\"status\"] == \"connected\"]\n\n    if not connected:\n        return ToolResult(\n            success=False,\n            data={\"needs_connection\": True},\n            needs_connection=True,\n            message=\"You don't have any calendars connected.\",\n        )\n\n    # Find the connection for the specified provider\n    target_connection = next((c for c in connected if c[\"provider\"] == calendar_provider), None)\n    if not target_connection:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=f\"No connected {calendar_provider} calendar found\",\n        )\n\n    try:\n        if calendar_provider == \"google\":\n            result = await _update_google_event(\n                context.user_id,\n                target_connection,\n                event_id,\n                title,\n                start_dt,\n                end_dt,\n                description,\n                location,\n                context.db_session,\n            )\n        else:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"Update not yet supported for {calendar_provider}\",\n                error_type=\"UnsupportedProvider\",\n            )\n\n        return ToolResult(\n            success=True,\n            data=result,\n            message=\"Updated event successfully.\",\n        )\n\n    except Exception as e:\n        logger.exception(f\"Error updating calendar event: {e}\")\n        return ToolResult(\n            success=False,\n            data=None,\n            error=str(e),\n            error_type=type(e).__name__,\n        )\n\n\nasync def _update_google_event(\n    user_id: str,\n    connection: Dict[str, Any],\n    event_id: str,\n    title: Optional[str],\n    start: Optional[datetime],\n    end: Optional[datetime],\n    description: Optional[str],\n    location: Optional[str],\n    db_session: Optional[AsyncSession],\n) -> Dict[str, Any]:\n    \"\"\"Update event via Google Calendar API.\"\"\"\n    from app.services.tools.oauth_service import oauth_service\n    from google.oauth2.credentials import Credentials\n    from googleapiclient.discovery import build\n\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        raise ValueError(\"No valid tokens found for Google Calendar\")\n\n    creds = Credentials(\n        token=tokens[\"access_token\"],\n        refresh_token=tokens.get(\"refresh_token\"),\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_id=oauth_service.get_client_id(\"google\"),\n        client_secret=oauth_service.get_client_secret(\"google\"),\n    )\n\n    service = build(\"calendar\", \"v3\", credentials=creds)\n\n    # Get user's timezone\n    try:\n        calendar_settings = service.settings().get(setting=\"timezone\").execute()\n        user_timezone = calendar_settings.get(\"value\", \"America/New_York\")\n    except Exception:\n        user_timezone = \"America/New_York\"\n\n    # Get the existing event first\n    existing_event = service.events().get(calendarId=\"primary\", eventId=event_id).execute()\n\n    # Update only the fields that were provided\n    if title:\n        existing_event[\"summary\"] = title\n    if description is not None:\n        existing_event[\"description\"] = description\n    if location is not None:\n        existing_event[\"location\"] = location\n    if start:\n        start_iso = start.strftime(\"%Y-%m-%dT%H:%M:%S\")\n        existing_event[\"start\"] = {\"dateTime\": start_iso, \"timeZone\": user_timezone}\n    if end:\n        end_iso = end.strftime(\"%Y-%m-%dT%H:%M:%S\")\n        existing_event[\"end\"] = {\"dateTime\": end_iso, \"timeZone\": user_timezone}\n\n    logger.info(f\"[Google Calendar] Updating event {event_id}\")\n\n    updated_event = service.events().update(calendarId=\"primary\", eventId=event_id, body=existing_event).execute()\n\n    logger.info(f\"[Google Calendar] Event updated: id={updated_event['id']}\")\n\n    return {\"event_id\": updated_event[\"id\"], \"html_link\": updated_event.get(\"htmlLink\")}\n\n\n# ==============================================================================\n# Delete Event Handler\n# ==============================================================================\n\n\nasync def handle_delete_event(arguments: Dict[str, Any], context: ToolExecutionContext) -> ToolResult:\n    \"\"\"\n    Delete a calendar event.\n    \"\"\"\n    event_id = arguments.get(\"event_id\")\n    calendar_provider = arguments.get(\"calendar_provider\", \"google\")\n\n    if not event_id:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=\"event_id is required\",\n            error_type=\"ValidationError\",\n        )\n\n    # Get user's calendar connections\n    connections = await get_user_calendar_connections(context.user_id, context.db_session)\n    connected = [c for c in connections if c[\"status\"] == \"connected\"]\n\n    if not connected:\n        return ToolResult(\n            success=False,\n            data={\"needs_connection\": True},\n            needs_connection=True,\n            message=\"You don't have any calendars connected.\",\n        )\n\n    # Find the connection for the specified provider\n    target_connection = next((c for c in connected if c[\"provider\"] == calendar_provider), None)\n    if not target_connection:\n        return ToolResult(\n            success=False,\n            data=None,\n            error=f\"No connected {calendar_provider} calendar found\",\n        )\n\n    try:\n        if calendar_provider == \"google\":\n            await _delete_google_event(\n                context.user_id,\n                target_connection,\n                event_id,\n                context.db_session,\n            )\n        else:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"Delete not yet supported for {calendar_provider}\",\n                error_type=\"UnsupportedProvider\",\n            )\n\n        return ToolResult(\n            success=True,\n            data={\"deleted_event_id\": event_id},\n            message=\"Event deleted successfully.\",\n        )\n\n    except Exception as e:\n        logger.exception(f\"Error deleting calendar event: {e}\")\n        return ToolResult(\n            success=False,\n            data=None,\n            error=str(e),\n            error_type=type(e).__name__,\n        )\n\n\nasync def _delete_google_event(\n    user_id: str,\n    connection: Dict[str, Any],\n    event_id: str,\n    db_session: Optional[AsyncSession],\n) -> None:\n    \"\"\"Delete event via Google Calendar API.\"\"\"\n    from app.services.tools.oauth_service import oauth_service\n    from google.oauth2.credentials import Credentials\n    from googleapiclient.discovery import build\n\n    tokens = await oauth_service.get_decrypted_tokens(connection[\"id\"], db_session)\n    if not tokens:\n        raise ValueError(\"No valid tokens found for Google Calendar\")\n\n    creds = Credentials(\n        token=tokens[\"access_token\"],\n        refresh_token=tokens.get(\"refresh_token\"),\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_id=oauth_service.get_client_id(\"google\"),\n        client_secret=oauth_service.get_client_secret(\"google\"),\n    )\n\n    service = build(\"calendar\", \"v3\", credentials=creds)\n\n    logger.info(f\"[Google Calendar] Deleting event {event_id}\")\n\n    service.events().delete(calendarId=\"primary\", eventId=event_id).execute()\n\n    logger.info(f\"[Google Calendar] Event deleted: {event_id}\")\n"
}
