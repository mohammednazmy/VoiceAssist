{
  "path": "apps/web-app/src/components/voice/VoiceActivityIndicator.tsx",
  "language": "typescript",
  "size": 4432,
  "last_modified": "2025-11-29T09:47:34.325Z",
  "lines": 154,
  "content": "/**\n * VoiceActivityIndicator\n * Animated visualization showing voice activity for both user and AI\n *\n * Features:\n * - Green animated bars when user is speaking\n * - Blue animated bars when AI is responding\n * - Smooth transitions between states\n * - Responsive design\n */\n\nimport { useEffect, useRef, useCallback } from \"react\";\n\ninterface VoiceActivityIndicatorProps {\n  /** Whether the user is currently speaking */\n  isSpeaking: boolean;\n  /** Whether the AI is currently synthesizing/playing audio */\n  isSynthesizing: boolean;\n  /** Whether connected to voice session */\n  isConnected: boolean;\n  /** Optional className for the container */\n  className?: string;\n}\n\nconst BAR_COUNT = 5;\nconst MIN_HEIGHT = 4;\nconst MAX_HEIGHT = 32;\n\nexport function VoiceActivityIndicator({\n  isSpeaking,\n  isSynthesizing,\n  isConnected,\n  className = \"\",\n}: VoiceActivityIndicatorProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationRef = useRef<number | null>(null);\n  const barHeightsRef = useRef<number[]>(Array(BAR_COUNT).fill(MIN_HEIGHT));\n  const targetHeightsRef = useRef<number[]>(Array(BAR_COUNT).fill(MIN_HEIGHT));\n\n  // Determine active state and color\n  const isActive = isSpeaking || isSynthesizing;\n  const activeColor = isSpeaking ? \"#22c55e\" : \"#3b82f6\"; // green-500 : blue-500\n  const inactiveColor = \"#d1d5db\"; // gray-300\n\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const width = canvas.width;\n    const height = canvas.height;\n    const centerY = height / 2;\n    const barWidth = Math.min(8, (width - (BAR_COUNT - 1) * 6) / BAR_COUNT);\n    const gap = 6;\n    const totalWidth = BAR_COUNT * barWidth + (BAR_COUNT - 1) * gap;\n    const startX = (width - totalWidth) / 2;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // Update target heights based on active state\n    if (isActive) {\n      // Random target heights for animation\n      for (let i = 0; i < BAR_COUNT; i++) {\n        if (Math.random() > 0.7) {\n          targetHeightsRef.current[i] =\n            MIN_HEIGHT + Math.random() * (MAX_HEIGHT - MIN_HEIGHT);\n        }\n      }\n    } else {\n      // Return to minimum height when inactive\n      targetHeightsRef.current = Array(BAR_COUNT).fill(MIN_HEIGHT);\n    }\n\n    // Smoothly interpolate bar heights\n    for (let i = 0; i < BAR_COUNT; i++) {\n      const diff = targetHeightsRef.current[i] - barHeightsRef.current[i];\n      barHeightsRef.current[i] += diff * 0.2; // Easing factor\n    }\n\n    // Draw bars\n    for (let i = 0; i < BAR_COUNT; i++) {\n      const x = startX + i * (barWidth + gap);\n      const barHeight = barHeightsRef.current[i];\n      const y = centerY - barHeight / 2;\n\n      // Draw rounded bar\n      const radius = barWidth / 2;\n      ctx.fillStyle = isActive ? activeColor : inactiveColor;\n      ctx.beginPath();\n      ctx.roundRect(x, y, barWidth, barHeight, radius);\n      ctx.fill();\n    }\n\n    // Continue animation loop\n    animationRef.current = requestAnimationFrame(draw);\n  }, [isActive, activeColor, inactiveColor]);\n\n  // Start/stop animation based on connection status\n  useEffect(() => {\n    if (isConnected) {\n      draw();\n    } else if (animationRef.current) {\n      cancelAnimationFrame(animationRef.current);\n      animationRef.current = null;\n\n      // Draw idle state\n      const canvas = canvasRef.current;\n      if (canvas) {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n      }\n    }\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n    };\n  }, [isConnected, draw]);\n\n  if (!isConnected) {\n    return null;\n  }\n\n  return (\n    <div className={`flex flex-col items-center gap-1 ${className}`}>\n      <canvas\n        ref={canvasRef}\n        width={120}\n        height={48}\n        className=\"w-[120px] h-12\"\n        aria-hidden=\"true\"\n      />\n      <span\n        className={`text-xs font-medium transition-colors duration-200 ${\n          isSpeaking\n            ? \"text-green-600\"\n            : isSynthesizing\n              ? \"text-blue-600\"\n              : \"text-neutral-400\"\n        }`}\n      >\n        {isSpeaking ? \"Listening...\" : isSynthesizing ? \"Speaking...\" : \"Ready\"}\n      </span>\n    </div>\n  );\n}\n"
}
