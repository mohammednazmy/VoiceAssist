{
  "path": "services/api-gateway/app/api/conversations.py",
  "language": "python",
  "size": 40059,
  "last_modified": "2025-12-05T03:07:13.125Z",
  "lines": 1271,
  "content": "\"\"\"\nConversation branching API endpoints.\n\nThis module provides REST API endpoints for conversation branching functionality,\nallowing users to fork conversations at any message point and navigate between branches.\n\nNote: Pydantic schemas are now defined in app/api/conversations/schemas.py\n\"\"\"\n\nimport uuid\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom app.api.conversation_schemas.schemas import (\n    BranchInfo,\n    BranchResponse,\n    ConversationResponse,\n    ConversationSettingsSchema,\n    ConversationsListResponse,\n    CreateBranchRequest,\n    CreateConversationRequest,\n    CreateMessageRequest,\n    EditMessageRequest,\n    MessageResponse,\n    MessagesListResponse,\n    SessionEventResponse,\n    UpdateConversationRequest,\n)\nfrom app.core.api_envelope import ErrorCodes, error_response, success_response\nfrom app.core.database import get_db, transaction\nfrom app.core.dependencies import get_current_user\nfrom app.core.logging import get_logger\nfrom app.models.message import Message\nfrom app.models.session import Session as ChatSession\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy import and_, func\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter(prefix=\"/conversations\", tags=[\"conversations\"])\nlogger = get_logger(__name__)\n\n\n# Helper Functions\ndef generate_branch_id() -> str:\n    \"\"\"Generate a unique branch ID\"\"\"\n    timestamp = datetime.utcnow().strftime(\"%Y%m%d%H%M%S\")\n    short_uuid = str(uuid.uuid4())[:8]\n    return f\"branch-{timestamp}-{short_uuid}\"\n\n\ndef get_session_or_404(db: Session, session_id: uuid.UUID, user: User) -> ChatSession:\n    \"\"\"Get session by ID or raise 404 if not found or not owned by user\"\"\"\n    session = (\n        db.query(ChatSession)\n        .filter(\n            and_(\n                ChatSession.id == session_id,\n                ChatSession.user_id == user.id,\n            )\n        )\n        .first()\n    )\n\n    if not session:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=error_response(error_code=ErrorCodes.NOT_FOUND, message=\"Session not found\"),\n        )\n\n    return session\n\n\ndef get_message_or_404(db: Session, message_id: uuid.UUID, session: ChatSession) -> Message:\n    \"\"\"Get message by ID or raise 404 if not found or not in session\"\"\"\n    message = (\n        db.query(Message)\n        .filter(\n            and_(\n                Message.id == message_id,\n                Message.session_id == session.id,\n            )\n        )\n        .first()\n    )\n\n    if not message:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=error_response(error_code=ErrorCodes.NOT_FOUND, message=\"Message not found\"),\n        )\n\n    return message\n\n\n# API Endpoints - Conversation CRUD\n@router.get(\"\")\nasync def list_conversations(\n    page: int = 1,\n    pageSize: int = 20,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    List all conversations for the current user.\n\n    Returns paginated list of conversations with message counts and metadata.\n\n    Args:\n        page: Page number (1-indexed)\n        pageSize: Number of items per page\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        PaginatedResponse with conversations\n    \"\"\"\n    # Calculate offset\n    offset = (page - 1) * pageSize\n\n    # Query total count\n    total = db.query(func.count(ChatSession.id)).filter(ChatSession.user_id == current_user.id).scalar()\n\n    # Query sessions with message counts\n    sessions = (\n        db.query(\n            ChatSession,\n            func.count(Message.id).label(\"message_count\"),\n        )\n        .outerjoin(Message, Message.session_id == ChatSession.id)\n        .filter(ChatSession.user_id == current_user.id)\n        .group_by(ChatSession.id)\n        .order_by(ChatSession.updated_at.desc())\n        .offset(offset)\n        .limit(pageSize)\n        .all()\n    )\n\n    conversations = [\n        ConversationResponse(\n            id=str(session.id),\n            userId=str(session.user_id),\n            title=session.title or \"New Conversation\",\n            archived=bool(session.archived),  # Convert int to bool\n            messageCount=message_count,\n            folderId=str(session.folder_id) if session.folder_id else None,\n            createdAt=session.created_at.isoformat() + \"Z\",\n            updatedAt=session.updated_at.isoformat() + \"Z\",\n        )\n        for session, message_count in sessions\n    ]\n\n    return success_response(\n        data=ConversationsListResponse(\n            items=conversations,\n            total=total,\n            page=page,\n            pageSize=pageSize,\n        )\n    )\n\n\n@router.post(\"\")\nasync def create_conversation(\n    request: CreateConversationRequest,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Create a new conversation.\n\n    Args:\n        request: Conversation creation request\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        ConversationResponse with new conversation details\n    \"\"\"\n    # Validate folder_id if provided\n    folder_uuid = None\n    if request.folder_id:\n        try:\n            folder_uuid = uuid.UUID(request.folder_id)\n            # Verify folder exists and belongs to user\n            from app.models.folder import ConversationFolder\n\n            folder = (\n                db.query(ConversationFolder)\n                .filter(\n                    and_(\n                        ConversationFolder.id == folder_uuid,\n                        ConversationFolder.user_id == current_user.id,\n                    )\n                )\n                .first()\n            )\n            if not folder:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=error_response(error_code=ErrorCodes.NOT_FOUND, message=\"Folder not found\"),\n                )\n        except ValueError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=error_response(\n                    error_code=ErrorCodes.VALIDATION_ERROR,\n                    message=\"Invalid folder UUID format\",\n                ),\n            )\n\n    # Create new session with transaction management\n    new_session = ChatSession(\n        user_id=current_user.id,\n        title=request.title,\n        folder_id=folder_uuid,\n        archived=0,  # 0 = not archived, 1 = archived (Integer column)\n    )\n\n    with transaction(db):\n        db.add(new_session)\n        # Transaction context manager handles commit/rollback\n\n    db.refresh(new_session)\n    logger.info(f\"Created conversation {new_session.id} for user {current_user.id}\")\n\n    return success_response(\n        data=ConversationResponse(\n            id=str(new_session.id),\n            userId=str(new_session.user_id),\n            title=new_session.title,\n            archived=bool(new_session.archived),  # Convert int to bool\n            messageCount=0,\n            folderId=str(new_session.folder_id) if new_session.folder_id else None,\n            createdAt=new_session.created_at.isoformat() + \"Z\",\n            updatedAt=new_session.updated_at.isoformat() + \"Z\",\n        )\n    )\n\n\n@router.get(\"/{conversation_id}\")\nasync def get_conversation(\n    conversation_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get a specific conversation by ID.\n\n    Args:\n        conversation_id: UUID of the conversation\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        ConversationResponse with conversation details\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Get message count\n    message_count = db.query(func.count(Message.id)).filter(Message.session_id == session.id).scalar()\n\n    return success_response(\n        data=ConversationResponse(\n            id=str(session.id),\n            userId=str(session.user_id),\n            title=session.title or \"New Conversation\",\n            archived=bool(session.archived),  # Convert int to bool\n            messageCount=message_count,\n            folderId=str(session.folder_id) if session.folder_id else None,\n            createdAt=session.created_at.isoformat() + \"Z\",\n            updatedAt=session.updated_at.isoformat() + \"Z\",\n        )\n    )\n\n\n@router.patch(\"/{conversation_id}\")\nasync def update_conversation(\n    conversation_id: str,\n    request: UpdateConversationRequest,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Update a conversation's metadata.\n\n    Args:\n        conversation_id: UUID of the conversation\n        request: Update request with fields to change\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        ConversationResponse with updated conversation details\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Update fields if provided\n    if request.title is not None:\n        session.title = request.title\n    if request.archived is not None:\n        session.archived = 1 if request.archived else 0  # Convert bool to int\n    if request.folder_id is not None:\n        if request.folder_id:\n            try:\n                folder_uuid = uuid.UUID(request.folder_id)\n                # Verify folder exists and belongs to user\n                from app.models.folder import ConversationFolder\n\n                folder = (\n                    db.query(ConversationFolder)\n                    .filter(\n                        and_(\n                            ConversationFolder.id == folder_uuid,\n                            ConversationFolder.user_id == current_user.id,\n                        )\n                    )\n                    .first()\n                )\n                if not folder:\n                    raise HTTPException(\n                        status_code=status.HTTP_404_NOT_FOUND,\n                        detail=error_response(error_code=ErrorCodes.NOT_FOUND, message=\"Folder not found\"),\n                    )\n                session.folder_id = folder_uuid\n            except ValueError:\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=error_response(\n                        error_code=ErrorCodes.VALIDATION_ERROR,\n                        message=\"Invalid folder UUID format\",\n                    ),\n                )\n        else:\n            session.folder_id = None\n\n    with transaction(db):\n        pass  # Changes tracked by session, committed by transaction\n\n    db.refresh(session)\n\n    # Get message count\n    message_count = db.query(func.count(Message.id)).filter(Message.session_id == session.id).scalar()\n\n    logger.info(f\"Updated conversation {session.id}\")\n\n    return success_response(\n        data=ConversationResponse(\n            id=str(session.id),\n            userId=str(session.user_id),\n            title=session.title or \"New Conversation\",\n            archived=bool(session.archived),  # Convert int to bool\n            messageCount=message_count,\n            folderId=str(session.folder_id) if session.folder_id else None,\n            createdAt=session.created_at.isoformat() + \"Z\",\n            updatedAt=session.updated_at.isoformat() + \"Z\",\n        )\n    )\n\n\n@router.delete(\"/all\")\nasync def delete_all_conversations(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Delete ALL conversations for the current user.\n\n    This is a destructive operation that removes all conversations and their messages.\n    Used for bulk cleanup / account reset scenarios.\n\n    Args:\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Success response with count of deleted conversations\n    \"\"\"\n    # Get all user's conversations\n    user_sessions = db.query(ChatSession).filter(ChatSession.user_id == current_user.id).all()\n\n    session_ids = [s.id for s in user_sessions]\n\n    if not session_ids:\n        return success_response(data={\"deleted_count\": 0, \"message\": \"No conversations to delete\"})\n\n    # Delete all messages and sessions atomically\n    with transaction(db):\n        # Delete messages first (foreign key constraint)\n        deleted_messages = (\n            db.query(Message).filter(Message.session_id.in_(session_ids)).delete(synchronize_session=False)\n        )\n\n        # Delete all sessions\n        deleted_count = (\n            db.query(ChatSession).filter(ChatSession.user_id == current_user.id).delete(synchronize_session=False)\n        )\n\n    logger.info(f\"Deleted {deleted_count} conversations and {deleted_messages} messages for user {current_user.id}\")\n\n    return success_response(\n        data={\n            \"deleted_count\": deleted_count,\n            \"message\": f\"Successfully deleted {deleted_count} conversation(s)\",\n        }\n    )\n\n\n@router.delete(\"/{conversation_id}\")\nasync def delete_conversation(\n    conversation_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Delete a conversation and all its messages.\n\n    Args:\n        conversation_id: UUID of the conversation\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Success response\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Delete all messages and session atomically\n    with transaction(db):\n        db.query(Message).filter(Message.session_id == session.id).delete()\n        db.delete(session)\n\n    logger.info(f\"Deleted conversation {conversation_id}\")\n\n    return success_response(data={\"message\": \"Conversation deleted successfully\"})\n\n\n# API Endpoints - Messages\n@router.get(\"/{conversation_id}/messages\")\nasync def get_messages(\n    conversation_id: str,\n    page: int = 1,\n    pageSize: int = 50,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get all messages in a conversation (main branch).\n\n    Returns paginated list of messages in chronological order.\n\n    Args:\n        conversation_id: UUID of the conversation\n        page: Page number (1-indexed)\n        pageSize: Number of messages per page\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        PaginatedResponse with messages\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Calculate offset\n    offset = (page - 1) * pageSize\n\n    # Query total count (main branch only - no branch_id)\n    total = (\n        db.query(func.count(Message.id))\n        .filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id.is_(None),\n            )\n        )\n        .scalar()\n    )\n\n    # Query messages in chronological order\n    messages = (\n        db.query(Message)\n        .filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id.is_(None),\n            )\n        )\n        .order_by(Message.created_at.asc())\n        .offset(offset)\n        .limit(pageSize)\n        .all()\n    )\n\n    message_responses = [\n        MessageResponse(\n            id=str(msg.id),\n            session_id=str(msg.session_id),\n            role=msg.role,\n            content=msg.content,\n            parent_message_id=(str(msg.parent_message_id) if msg.parent_message_id else None),\n            branch_id=msg.branch_id,\n            created_at=msg.created_at.isoformat() + \"Z\",\n            tokens=msg.tokens,\n            model=msg.model,\n        )\n        for msg in messages\n    ]\n\n    return success_response(\n        data=MessagesListResponse(\n            items=message_responses,\n            total=total,\n            page=page,\n            pageSize=pageSize,\n        )\n    )\n\n\n@router.post(\"/{conversation_id}/messages\")\nasync def create_message(\n    conversation_id: str,\n    request: CreateMessageRequest,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Create a new message in a conversation with optional idempotency.\n\n    If `client_message_id` is provided, this endpoint is idempotent:\n    - If a message with the same (conversation_id, branch_id, client_message_id)\n      already exists, the existing message is returned without creating a duplicate.\n    - This allows safe retries without creating duplicate messages.\n\n    Args:\n        conversation_id: UUID of the conversation\n        request: Message creation request\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        MessageResponse with the created (or existing) message\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n        400: Invalid request (e.g., invalid UUIDs)\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Parse optional parent_message_id\n    parent_message_uuid = None\n    if request.parent_message_id:\n        try:\n            parent_message_uuid = uuid.UUID(request.parent_message_id)\n            # Verify parent message exists and belongs to session\n            get_message_or_404(db, parent_message_uuid, session)\n        except ValueError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=error_response(\n                    error_code=ErrorCodes.VALIDATION_ERROR,\n                    message=\"Invalid parent_message_id UUID format\",\n                ),\n            )\n\n    # Check for idempotent request\n    if request.client_message_id:\n        # Look for existing message with same idempotency key\n        existing_message = (\n            db.query(Message)\n            .filter(\n                and_(\n                    Message.session_id == session.id,\n                    Message.branch_id == request.branch_id,\n                    Message.client_message_id == request.client_message_id,\n                )\n            )\n            .first()\n        )\n\n        if existing_message:\n            logger.info(\n                f\"Idempotent message creation: returning existing message \"\n                f\"{existing_message.id} for client_message_id={request.client_message_id}\"\n            )\n            return success_response(\n                data=MessageResponse(\n                    id=str(existing_message.id),\n                    session_id=str(existing_message.session_id),\n                    role=existing_message.role,\n                    content=existing_message.content,\n                    parent_message_id=(\n                        str(existing_message.parent_message_id) if existing_message.parent_message_id else None\n                    ),\n                    branch_id=existing_message.branch_id,\n                    client_message_id=existing_message.client_message_id,\n                    created_at=existing_message.created_at.isoformat() + \"Z\",\n                    tokens=existing_message.tokens,\n                    model=existing_message.model,\n                    is_duplicate=True,\n                )\n            )\n\n    # Create new message\n    new_message = Message(\n        session_id=session.id,\n        role=request.role,\n        content=request.content,\n        branch_id=request.branch_id,\n        parent_message_id=parent_message_uuid,\n        client_message_id=request.client_message_id,\n        message_metadata=request.metadata,\n    )\n\n    db.add(new_message)\n    db.commit()\n    db.refresh(new_message)\n\n    logger.info(\n        f\"Created message {new_message.id} in conversation {conversation_id}\"\n        + (f\" with client_message_id={request.client_message_id}\" if request.client_message_id else \"\")\n    )\n\n    return success_response(\n        data=MessageResponse(\n            id=str(new_message.id),\n            session_id=str(new_message.session_id),\n            role=new_message.role,\n            content=new_message.content,\n            parent_message_id=(str(new_message.parent_message_id) if new_message.parent_message_id else None),\n            branch_id=new_message.branch_id,\n            client_message_id=new_message.client_message_id,\n            created_at=new_message.created_at.isoformat() + \"Z\",\n            tokens=new_message.tokens,\n            model=new_message.model,\n            is_duplicate=False,\n        )\n    )\n\n\n@router.patch(\"/{conversation_id}/messages/{message_id}\")\nasync def edit_message(\n    conversation_id: str,\n    message_id: str,\n    request: EditMessageRequest,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Edit a message's content.\n\n    Args:\n        conversation_id: UUID of the conversation\n        message_id: UUID of the message to edit\n        request: Edit request with new content\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        MessageResponse with updated message\n\n    Raises:\n        404: Conversation or message not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n        msg_uuid = uuid.UUID(message_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Get message\n    message = get_message_or_404(db, msg_uuid, session)\n\n    # Update content\n    message.content = request.content\n    db.commit()\n    db.refresh(message)\n\n    logger.info(f\"Edited message {message_id} in conversation {conversation_id}\")\n\n    return success_response(\n        data=MessageResponse(\n            id=str(message.id),\n            session_id=str(message.session_id),\n            role=message.role,\n            content=message.content,\n            parent_message_id=(str(message.parent_message_id) if message.parent_message_id else None),\n            branch_id=message.branch_id,\n            created_at=message.created_at.isoformat() + \"Z\",\n            tokens=message.tokens,\n            model=message.model,\n        )\n    )\n\n\n@router.delete(\"/{conversation_id}/messages/{message_id}\")\nasync def delete_message(\n    conversation_id: str,\n    message_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Delete a message.\n\n    Args:\n        conversation_id: UUID of the conversation\n        message_id: UUID of the message to delete\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Success response\n\n    Raises:\n        404: Conversation or message not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n        msg_uuid = uuid.UUID(message_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Get message\n    message = get_message_or_404(db, msg_uuid, session)\n\n    # Delete message\n    db.delete(message)\n    db.commit()\n\n    logger.info(f\"Deleted message {message_id} from conversation {conversation_id}\")\n\n    return success_response(data={\"message\": \"Message deleted successfully\"})\n\n\n# API Endpoints - Conversation Branching\n@router.post(\"/{session_id}/branches\", response_model=BranchResponse)\nasync def create_branch(\n    session_id: str,\n    request: CreateBranchRequest,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Create a new conversation branch from a specific message.\n\n    This endpoint allows forking a conversation at any message point,\n    creating an alternative conversation path.\n\n    Args:\n        session_id: UUID of the conversation session\n        request: Branch creation request with parent_message_id\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        BranchResponse with branch_id and metadata\n\n    Raises:\n        404: Session or parent message not found\n        403: User doesn't own the session\n    \"\"\"\n    try:\n        session_uuid = uuid.UUID(session_id)\n        parent_message_uuid = uuid.UUID(request.parent_message_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify session exists and belongs to user\n    session = get_session_or_404(db, session_uuid, current_user)\n\n    # Verify parent message exists and belongs to session\n    parent_message = get_message_or_404(db, parent_message_uuid, session)\n\n    # Generate unique branch ID\n    branch_id = generate_branch_id()\n\n    # If initial message provided, create it in the new branch\n    message_count = 0\n    if request.initial_message:\n        new_message = Message(\n            session_id=session.id,\n            role=\"user\",\n            content=request.initial_message,\n            parent_message_id=parent_message.id,\n            branch_id=branch_id,\n        )\n        db.add(new_message)\n        db.commit()\n        message_count = 1\n\n    logger.info(f\"Created branch {branch_id} from message {request.parent_message_id} \" f\"in session {session_id}\")\n\n    return success_response(\n        data=BranchResponse(\n            branch_id=branch_id,\n            session_id=str(session.id),\n            parent_message_id=request.parent_message_id,\n            created_at=datetime.utcnow().isoformat() + \"Z\",\n            message_count=message_count,\n        )\n    )\n\n\n@router.get(\"/{session_id}/branches\")\nasync def list_branches(\n    session_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    List all branches in a conversation.\n\n    Returns metadata about each branch including message count and timestamps.\n\n    Args:\n        session_id: UUID of the conversation session\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        List of BranchInfo objects\n\n    Raises:\n        404: Session not found\n        403: User doesn't own the session\n    \"\"\"\n    try:\n        session_uuid = uuid.UUID(session_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify session exists and belongs to user\n    session = get_session_or_404(db, session_uuid, current_user)\n\n    # Query all unique branch_ids with metadata\n    branch_data = (\n        db.query(\n            Message.branch_id,\n            Message.parent_message_id,\n            func.count(Message.id).label(\"message_count\"),\n            func.min(Message.created_at).label(\"created_at\"),\n            func.max(Message.created_at).label(\"last_activity\"),\n        )\n        .filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id.isnot(None),\n            )\n        )\n        .group_by(Message.branch_id, Message.parent_message_id)\n        .all()\n    )\n\n    branches = [\n        BranchInfo(\n            branch_id=row.branch_id,\n            parent_message_id=(str(row.parent_message_id) if row.parent_message_id else None),\n            message_count=row.message_count,\n            created_at=row.created_at.isoformat() + \"Z\",\n            last_activity=row.last_activity.isoformat() + \"Z\",\n        )\n        for row in branch_data\n    ]\n\n    # Include main branch if it has messages\n    main_branch_count = (\n        db.query(func.count(Message.id))\n        .filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id.is_(None),\n            )\n        )\n        .scalar()\n    )\n\n    if main_branch_count > 0:\n        main_branch_data = (\n            db.query(\n                func.min(Message.created_at).label(\"created_at\"),\n                func.max(Message.created_at).label(\"last_activity\"),\n            )\n            .filter(\n                and_(\n                    Message.session_id == session.id,\n                    Message.branch_id.is_(None),\n                )\n            )\n            .first()\n        )\n\n        branches.insert(\n            0,\n            BranchInfo(\n                branch_id=\"main\",\n                parent_message_id=None,\n                message_count=main_branch_count,\n                created_at=main_branch_data.created_at.isoformat() + \"Z\",\n                last_activity=main_branch_data.last_activity.isoformat() + \"Z\",\n            ),\n        )\n\n    return success_response(data=branches)\n\n\n@router.get(\"/{session_id}/branches/{branch_id}/messages\")\nasync def get_branch_messages(\n    session_id: str,\n    branch_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get all messages in a specific branch.\n\n    Returns messages in chronological order for the specified branch.\n\n    Args:\n        session_id: UUID of the conversation session\n        branch_id: Branch identifier (use \"main\" for main conversation)\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        List of MessageResponse objects\n\n    Raises:\n        404: Session not found\n        403: User doesn't own the session\n    \"\"\"\n    try:\n        session_uuid = uuid.UUID(session_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify session exists and belongs to user\n    session = get_session_or_404(db, session_uuid, current_user)\n\n    # Build query based on branch_id\n    if branch_id == \"main\":\n        # Main branch: messages with no branch_id\n        query = db.query(Message).filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id.is_(None),\n            )\n        )\n    else:\n        # Specific branch: messages with matching branch_id\n        query = db.query(Message).filter(\n            and_(\n                Message.session_id == session.id,\n                Message.branch_id == branch_id,\n            )\n        )\n\n    messages = query.order_by(Message.created_at.asc()).all()\n\n    message_responses = [\n        MessageResponse(\n            id=str(msg.id),\n            session_id=str(msg.session_id),\n            role=msg.role,\n            content=msg.content,\n            parent_message_id=(str(msg.parent_message_id) if msg.parent_message_id else None),\n            branch_id=msg.branch_id,\n            created_at=msg.created_at.isoformat() + \"Z\",\n            tokens=msg.tokens,\n            model=msg.model,\n        )\n        for msg in messages\n    ]\n\n    return success_response(data=message_responses)\n\n\n# ============================================================================\n# Session Events API (P0.5 - Structured Event Logging)\n# ============================================================================\n\n\n@router.get(\"/{conversation_id}/events\")\nasync def get_conversation_events(\n    conversation_id: str,\n    event_types: Optional[str] = None,\n    since: Optional[str] = None,\n    limit: int = 100,\n    offset: int = 0,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get events for a conversation (for session inspection/debugging).\n\n    This endpoint returns structured events logged during conversation/voice\n    sessions, useful for debugging, performance analysis, and session replay.\n\n    Args:\n        conversation_id: UUID of the conversation\n        event_types: Optional comma-separated list of event types to filter\n        since: Optional ISO timestamp to filter events after\n        limit: Max events to return (default 100, max 1000)\n        offset: Pagination offset\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        List of SessionEventResponse objects\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Import here to avoid circular imports\n    from app.models.session_event import SessionEvent\n\n    # Build query\n    query = db.query(SessionEvent).filter(SessionEvent.conversation_id == session.id)\n\n    # Filter by event types\n    if event_types:\n        type_list = [t.strip() for t in event_types.split(\",\")]\n        query = query.filter(SessionEvent.event_type.in_(type_list))\n\n    # Filter by time\n    if since:\n        try:\n            since_dt = datetime.fromisoformat(since.replace(\"Z\", \"+00:00\"))\n            query = query.filter(SessionEvent.created_at >= since_dt)\n        except ValueError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=error_response(\n                    error_code=ErrorCodes.VALIDATION_ERROR,\n                    message=\"Invalid 'since' timestamp format. Use ISO 8601.\",\n                ),\n            )\n\n    # Limit to reasonable max\n    limit = min(limit, 1000)\n\n    events = query.order_by(SessionEvent.created_at.asc()).offset(offset).limit(limit).all()\n\n    event_responses = [\n        SessionEventResponse(\n            id=str(event.id),\n            conversation_id=str(event.conversation_id),\n            session_id=event.session_id,\n            branch_id=event.branch_id,\n            event_type=event.event_type,\n            payload=event.payload,\n            source=event.source,\n            trace_id=event.trace_id,\n            created_at=event.created_at.isoformat() + \"Z\",\n        )\n        for event in events\n    ]\n\n    return success_response(data=event_responses)\n\n\n# ============================================================================\n# Conversation Settings API (P1 feature)\n# ============================================================================\n\n\n@router.get(\"/{conversation_id}/settings\")\nasync def get_conversation_settings(\n    conversation_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get settings for a conversation.\n\n    Args:\n        conversation_id: UUID of the conversation\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        ConversationSettingsSchema with current settings\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Return settings (or empty dict if none)\n    settings = session.settings or {}\n\n    return success_response(data=ConversationSettingsSchema(**settings))\n\n\n@router.put(\"/{conversation_id}/settings\")\nasync def update_conversation_settings(\n    conversation_id: str,\n    settings: ConversationSettingsSchema,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Update settings for a conversation.\n\n    Args:\n        conversation_id: UUID of the conversation\n        settings: New settings to apply\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Updated ConversationSettingsSchema\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=error_response(error_code=ErrorCodes.VALIDATION_ERROR, message=\"Invalid UUID format\"),\n        )\n\n    # Verify conversation exists and belongs to user\n    session = get_session_or_404(db, conv_uuid, current_user)\n\n    # Merge new settings with existing (exclude None values)\n    current_settings = session.settings or {}\n    new_settings = settings.model_dump(exclude_none=True)\n    merged_settings = {**current_settings, **new_settings}\n\n    # Update session\n    session.settings = merged_settings\n    db.commit()\n    db.refresh(session)\n\n    logger.info(f\"Updated settings for conversation {conversation_id}\")\n\n    return success_response(data=ConversationSettingsSchema(**merged_settings))\n\n\n@router.patch(\"/{conversation_id}/settings\")\nasync def patch_conversation_settings(\n    conversation_id: str,\n    settings: ConversationSettingsSchema,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Partially update settings for a conversation (same as PUT for this use case).\n\n    Args:\n        conversation_id: UUID of the conversation\n        settings: Settings to update (only non-None values are applied)\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Updated ConversationSettingsSchema\n\n    Raises:\n        404: Conversation not found\n        403: User doesn't own the conversation\n    \"\"\"\n    return await update_conversation_settings(conversation_id, settings, db, current_user)\n"
}
