{
  "path": "services/api-gateway/app/api/admin/utils.py",
  "language": "python",
  "size": 7428,
  "last_modified": "2025-12-04T11:26:44.593Z",
  "lines": 219,
  "content": "\"\"\"Admin Panel Utility Functions.\n\nProvides helper functions for rate limiting, audit logging, and WebSocket session tracking.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport secrets\nfrom datetime import datetime, timezone\nfrom typing import TYPE_CHECKING, Dict, Optional\n\nfrom app.core.database import redis_client, transaction\nfrom app.models.audit_log import AuditLog\nfrom fastapi import HTTPException, Request\nfrom sqlalchemy.orm import Session\n\nif TYPE_CHECKING:\n    pass\n\nlogger = logging.getLogger(__name__)\n\n# Redis keys for WebSocket session tracking and caching\nREDIS_WS_SESSIONS_KEY = \"voiceassist:ws:sessions\"\nREDIS_METRICS_CACHE_KEY = \"voiceassist:admin:metrics\"\nMETRICS_CACHE_TTL = 60  # Cache metrics for 60 seconds\n\n\ndef enforce_admin_action_rate_limit(\n    request: Request,\n    action: str,\n    calls: int = 5,\n    period: int = 60,\n) -> Dict[str, Optional[int]]:\n    \"\"\"Enforce a Redis-backed rate limit for sensitive admin actions.\n\n    Returns a rate limit payload that can be surfaced to clients. On failure,\n    raises an HTTPException with details that can be converted into an\n    APIEnvelope error response.\n    \"\"\"\n\n    identifier = getattr(request.state, \"user_id\", None) or (request.client.host if request.client else \"unknown\")\n    redis_key = f\"admin:{action}:{identifier}\"\n\n    try:\n        current = redis_client.get(redis_key)\n        current_count = int(current) if current else 0\n\n        if current_count >= calls:\n            ttl = redis_client.ttl(redis_key)\n            retry_after = ttl if ttl and ttl > 0 else period\n            raise HTTPException(\n                status_code=429,\n                detail={\n                    \"code\": \"RATE_LIMITED\",\n                    \"message\": f\"{action} limit reached\",\n                    \"rate_limit\": {\n                        \"limit\": calls,\n                        \"remaining\": 0,\n                        \"reset_in\": retry_after,\n                    },\n                },\n                headers={\"Retry-After\": str(retry_after)},\n            )\n\n        pipe = redis_client.pipeline()\n        pipe.incr(redis_key)\n        if current_count == 0:\n            pipe.expire(redis_key, period)\n        pipe.execute()\n\n        reset_in = redis_client.ttl(redis_key)\n        return {\n            \"limit\": calls,\n            \"remaining\": max(calls - (current_count + 1), 0),\n            \"reset_in\": reset_in if reset_in and reset_in > 0 else period,\n        }\n    except HTTPException:\n        raise\n    except Exception as exc:  # pragma: no cover - defensive path\n        logger.warning(f\"Rate limiting failed: {exc}\")\n        return {\"limit\": calls, \"remaining\": None, \"reset_in\": None}\n\n\ndef log_audit_event(\n    db: Session,\n    action: str,\n    user_id: Optional[str] = None,\n    user_email: Optional[str] = None,\n    resource_type: Optional[str] = None,\n    resource_id: Optional[str] = None,\n    success: bool = True,\n    details: Optional[str] = None,\n    request: Optional[Request] = None,\n) -> AuditLog:\n    \"\"\"Log an audit event to the database.\n\n    Args:\n        db: Database session\n        action: Action performed (e.g., 'user.update', 'user.delete')\n        user_id: ID of user performing the action\n        user_email: Email of user performing the action\n        resource_type: Type of resource affected (e.g., 'user', 'session')\n        resource_id: ID of the affected resource\n        success: Whether the action was successful\n        details: Additional details (JSON string)\n        request: FastAPI request object for context\n    \"\"\"\n    entry = AuditLog(\n        user_id=user_id,\n        user_email=user_email,\n        action=action,\n        resource_type=resource_type,\n        resource_id=resource_id,\n        success=success,\n        additional_data={\"details\": details} if details else None,\n        request_id=getattr(request.state, \"trace_id\", None) if request else None,\n        ip_address=request.client.host if request and request.client else None,\n        user_agent=request.headers.get(\"user-agent\", \"\")[:500] if request else None,\n        endpoint=str(request.url.path) if request else None,\n    )\n    # Calculate integrity hash\n    entry.hash = entry.calculate_hash()\n\n    with transaction(db):\n        db.add(entry)\n\n    db.refresh(entry)\n    return entry\n\n\n# ============================================================================\n# WebSocket Session Tracking (Redis-backed for distributed deployments)\n# ============================================================================\n\n\ndef register_websocket_session(session_id: str, user_id: str, session_type: str):\n    \"\"\"Register a new WebSocket session in Redis.\"\"\"\n    try:\n        session_data = json.dumps(\n            {\n                \"user_id\": user_id,\n                \"type\": session_type,\n                \"connected_at\": datetime.now(timezone.utc).isoformat(),\n            }\n        )\n        redis_client.hset(REDIS_WS_SESSIONS_KEY, session_id, session_data)\n        # Set expiry on the hash (auto-cleanup stale sessions after 24h)\n        redis_client.expire(REDIS_WS_SESSIONS_KEY, 86400)\n    except Exception as e:\n        logger.warning(f\"Failed to register WebSocket session in Redis: {e}\")\n\n\ndef unregister_websocket_session(session_id: str):\n    \"\"\"Unregister a WebSocket session from Redis.\"\"\"\n    try:\n        redis_client.hdel(REDIS_WS_SESSIONS_KEY, session_id)\n    except Exception as e:\n        logger.warning(f\"Failed to unregister WebSocket session from Redis: {e}\")\n\n\ndef get_all_websocket_sessions() -> Dict[str, dict]:\n    \"\"\"Get all active WebSocket sessions from Redis.\"\"\"\n    try:\n        sessions = redis_client.hgetall(REDIS_WS_SESSIONS_KEY)\n        return {sid: json.loads(data) if isinstance(data, str) else data for sid, data in sessions.items()}\n    except Exception as e:\n        logger.warning(f\"Failed to get WebSocket sessions from Redis: {e}\")\n        return {}\n\n\ndef get_active_websocket_count() -> int:\n    \"\"\"Get count of active WebSocket sessions.\"\"\"\n    try:\n        return redis_client.hlen(REDIS_WS_SESSIONS_KEY)\n    except Exception:\n        return 0\n\n\ndef register_websocket_session_cleanup(session_id: str):\n    \"\"\"Register a cleanup task for WebSocket session (legacy alias).\"\"\"\n    unregister_websocket_session(session_id)\n\n\n# ============================================================================\n# Password/Token Helpers\n# ============================================================================\n\n\ndef generate_temporary_password(length: int = 16) -> str:\n    \"\"\"Generate a secure temporary password.\"\"\"\n    return secrets.token_urlsafe(length)\n\n\ndef generate_secure_token(length: int = 32) -> str:\n    \"\"\"Generate a secure random token.\"\"\"\n    return secrets.token_urlsafe(length)\n\n\ndef resolve_admin_role(current_role: str, incoming_admin_flag: Optional[bool], incoming_role: Optional[str]) -> str:\n    \"\"\"Determine the resulting admin role based on incoming values.\"\"\"\n    from app.api.admin.schemas import ALLOWED_ADMIN_ROLES\n\n    if incoming_role:\n        if incoming_role not in ALLOWED_ADMIN_ROLES:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Invalid admin role specified\",\n            )\n        role = incoming_role\n    else:\n        role = current_role\n\n    if incoming_admin_flag is not None:\n        role = \"admin\" if incoming_admin_flag else (\"viewer\" if role == \"viewer\" else \"user\")\n\n    return role\n"
}
