{
  "path": "services/api-gateway/app/api/admin_calendar_connections.py",
  "language": "python",
  "size": 12651,
  "last_modified": "2025-12-05T03:07:13.124Z",
  "lines": 368,
  "content": "\"\"\"Admin Calendar Connections API endpoints.\n\nProvides admin endpoints for viewing and managing user calendar connections:\n- GET /api/admin/calendars/connections - List all calendar connections\n- GET /api/admin/calendars/connections/{user_id} - Get connections for specific user\n- DELETE /api/admin/calendars/connections/{connection_id} - Remove a connection\n- GET /api/admin/calendars/stats - Get calendar connection statistics\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Dict, Optional\n\nfrom app.core.api_envelope import success_response\nfrom app.core.database import get_async_db\nfrom app.core.dependencies import get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request\nfrom pydantic import BaseModel\nfrom sqlalchemy import text\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/calendars\", tags=[\"admin\", \"calendars\"])\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass CalendarConnectionAdmin(BaseModel):\n    \"\"\"Admin view of a calendar connection.\"\"\"\n\n    id: str\n    user_id: str\n    user_email: Optional[str] = None\n    provider: str\n    provider_display_name: str\n    status: str\n    caldav_url: Optional[str] = None\n    last_sync_at: Optional[str] = None\n    connected_at: Optional[str] = None\n    error_message: Optional[str] = None\n\n\nclass CalendarStatsResponse(BaseModel):\n    \"\"\"Statistics about calendar connections.\"\"\"\n\n    total_connections: int\n    connected_count: int\n    error_count: int\n    by_provider: Dict[str, int]\n    by_status: Dict[str, int]\n    users_with_connections: int\n    avg_connections_per_user: float\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"/connections\")\nasync def list_all_calendar_connections(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    db: AsyncSession = Depends(get_async_db),\n    provider: Optional[str] = Query(None, description=\"Filter by provider\"),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    limit: int = Query(50, ge=1, le=500),\n    offset: int = Query(0, ge=0),\n) -> Dict:\n    \"\"\"List all calendar connections across all users.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    # Build query with filters\n    filters = [\"1=1\"]\n    params = {\"limit\": limit, \"offset\": offset}\n\n    if provider:\n        filters.append(\"c.provider = :provider\")\n        params[\"provider\"] = provider\n\n    if status:\n        filters.append(\"c.status = :status\")\n        params[\"status\"] = status\n\n    where_clause = \" AND \".join(filters)\n\n    # Query connections with user info\n    # nosec B608 - where_clause is built from hardcoded filter strings, all values are parameterized\n    query = f\"\"\"\n        SELECT\n            c.id, c.user_id, u.email as user_email, c.provider,\n            c.provider_display_name, c.status, c.caldav_url,\n            c.last_sync_at, c.connected_at, c.error_message\n        FROM user_calendar_connections c\n        LEFT JOIN users u ON c.user_id::uuid = u.id\n        WHERE {where_clause}\n        ORDER BY c.connected_at DESC\n        LIMIT :limit OFFSET :offset\n    \"\"\"\n\n    result = await db.execute(text(query), params)\n    rows = result.fetchall()\n\n    # Get total count\n    # nosec B608 - where_clause is built from hardcoded filter strings, all values are parameterized\n    count_query = f\"\"\"\n        SELECT COUNT(*) as total\n        FROM user_calendar_connections c\n        WHERE {where_clause}\n    \"\"\"\n    count_params = {k: v for k, v in params.items() if k not in [\"limit\", \"offset\"]}\n    count_result = await db.execute(text(count_query), count_params)\n    total_count = count_result.scalar()\n\n    connections = [\n        {\n            \"id\": str(row.id),\n            \"user_id\": row.user_id,\n            \"user_email\": row.user_email,\n            \"provider\": row.provider,\n            \"provider_display_name\": row.provider_display_name,\n            \"status\": row.status,\n            \"caldav_url\": row.caldav_url,\n            \"last_sync_at\": row.last_sync_at.isoformat() if row.last_sync_at else None,\n            \"connected_at\": row.connected_at.isoformat() if row.connected_at else None,\n            \"error_message\": row.error_message,\n        }\n        for row in rows\n    ]\n\n    data = {\n        \"connections\": connections,\n        \"total\": total_count,\n        \"limit\": limit,\n        \"offset\": offset,\n        \"filters\": {\"provider\": provider, \"status\": status},\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/connections/user/{user_id}\")\nasync def get_user_calendar_connections(\n    request: Request,\n    user_id: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    db: AsyncSession = Depends(get_async_db),\n) -> Dict:\n    \"\"\"Get calendar connections for a specific user.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    query = \"\"\"\n        SELECT\n            c.id, c.user_id, u.email as user_email, c.provider,\n            c.provider_display_name, c.status, c.caldav_url,\n            c.last_sync_at, c.connected_at, c.error_message\n        FROM user_calendar_connections c\n        LEFT JOIN users u ON c.user_id::uuid = u.id\n        WHERE c.user_id = :user_id\n        ORDER BY c.connected_at\n    \"\"\"\n\n    result = await db.execute(text(query), {\"user_id\": user_id})\n    rows = result.fetchall()\n\n    connections = [\n        {\n            \"id\": str(row.id),\n            \"user_id\": row.user_id,\n            \"user_email\": row.user_email,\n            \"provider\": row.provider,\n            \"provider_display_name\": row.provider_display_name,\n            \"status\": row.status,\n            \"caldav_url\": row.caldav_url,\n            \"last_sync_at\": row.last_sync_at.isoformat() if row.last_sync_at else None,\n            \"connected_at\": row.connected_at.isoformat() if row.connected_at else None,\n            \"error_message\": row.error_message,\n        }\n        for row in rows\n    ]\n\n    data = {\n        \"user_id\": user_id,\n        \"connections\": connections,\n        \"total\": len(connections),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.delete(\"/connections/{connection_id}\")\nasync def admin_delete_calendar_connection(\n    request: Request,\n    connection_id: str,\n    current_admin_user: User = Depends(get_current_admin_user),\n    db: AsyncSession = Depends(get_async_db),\n) -> Dict:\n    \"\"\"Delete a calendar connection (admin only).\n\n    Use with caution - this removes the user's calendar integration.\n    \"\"\"\n    # First check if connection exists\n    check_query = \"\"\"\n        SELECT id, user_id, provider FROM user_calendar_connections WHERE id = :id\n    \"\"\"\n    result = await db.execute(text(check_query), {\"id\": connection_id})\n    connection = result.fetchone()\n\n    if not connection:\n        raise HTTPException(status_code=404, detail=\"Calendar connection not found\")\n\n    # Delete the connection\n    delete_query = \"DELETE FROM user_calendar_connections WHERE id = :id\"\n    await db.execute(text(delete_query), {\"id\": connection_id})\n    await db.commit()\n\n    logger.info(\n        f\"Admin {current_admin_user.email} deleted calendar connection {connection_id} \"\n        f\"(user: {connection.user_id}, provider: {connection.provider})\"\n    )\n\n    data = {\n        \"success\": True,\n        \"deleted_id\": connection_id,\n        \"user_id\": connection.user_id,\n        \"provider\": connection.provider,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/stats\")\nasync def get_calendar_stats(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    db: AsyncSession = Depends(get_async_db),\n) -> Dict:\n    \"\"\"Get statistics about calendar connections.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    # Get overall stats\n    stats_query = \"\"\"\n        SELECT\n            COUNT(*) as total_connections,\n            COUNT(CASE WHEN status = 'connected' THEN 1 END) as connected_count,\n            COUNT(CASE WHEN status = 'error' THEN 1 END) as error_count,\n            COUNT(DISTINCT user_id) as users_with_connections\n        FROM user_calendar_connections\n    \"\"\"\n    result = await db.execute(text(stats_query))\n    stats_row = result.fetchone()\n\n    # Get breakdown by provider\n    provider_query = \"\"\"\n        SELECT provider, COUNT(*) as count\n        FROM user_calendar_connections\n        GROUP BY provider\n        ORDER BY count DESC\n    \"\"\"\n    provider_result = await db.execute(text(provider_query))\n    by_provider = {row.provider: row.count for row in provider_result.fetchall()}\n\n    # Get breakdown by status\n    status_query = \"\"\"\n        SELECT status, COUNT(*) as count\n        FROM user_calendar_connections\n        GROUP BY status\n    \"\"\"\n    status_result = await db.execute(text(status_query))\n    by_status = {row.status: row.count for row in status_result.fetchall()}\n\n    total = stats_row.total_connections or 0\n    users = stats_row.users_with_connections or 0\n\n    data = {\n        \"total_connections\": total,\n        \"connected_count\": stats_row.connected_count or 0,\n        \"error_count\": stats_row.error_count or 0,\n        \"by_provider\": by_provider,\n        \"by_status\": by_status,\n        \"users_with_connections\": users,\n        \"avg_connections_per_user\": round(total / users, 2) if users > 0 else 0,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/providers\")\nasync def get_provider_config_status(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get configuration status for all calendar providers.\n\n    Shows which providers are properly configured in the environment.\n    \"\"\"\n    from app.core.config import settings\n\n    providers = {\n        \"google\": {\n            \"name\": \"Google Calendar\",\n            \"type\": \"oauth\",\n            \"configured\": bool(\n                getattr(settings, \"GOOGLE_CLIENT_ID\", None) and getattr(settings, \"GOOGLE_CLIENT_SECRET\", None)\n            ),\n            \"client_id_set\": bool(getattr(settings, \"GOOGLE_CLIENT_ID\", None)),\n            \"client_secret_set\": bool(getattr(settings, \"GOOGLE_CLIENT_SECRET\", None)),\n        },\n        \"microsoft\": {\n            \"name\": \"Microsoft Outlook\",\n            \"type\": \"oauth\",\n            \"configured\": bool(\n                getattr(settings, \"MICROSOFT_CLIENT_ID\", None) and getattr(settings, \"MICROSOFT_CLIENT_SECRET\", None)\n            ),\n            \"client_id_set\": bool(getattr(settings, \"MICROSOFT_CLIENT_ID\", None)),\n            \"client_secret_set\": bool(getattr(settings, \"MICROSOFT_CLIENT_SECRET\", None)),\n        },\n        \"apple\": {\n            \"name\": \"Apple iCloud\",\n            \"type\": \"caldav\",\n            \"configured\": True,  # CalDAV doesn't require server config\n            \"notes\": \"Users provide their own app-specific passwords\",\n        },\n        \"nextcloud\": {\n            \"name\": \"Nextcloud\",\n            \"type\": \"caldav\",\n            \"configured\": True,  # CalDAV doesn't require server config\n            \"notes\": \"Users provide their own server URL and credentials\",\n        },\n        \"caldav\": {\n            \"name\": \"Generic CalDAV\",\n            \"type\": \"caldav\",\n            \"configured\": True,\n            \"notes\": \"Users provide their own server URL and credentials\",\n        },\n    }\n\n    # Check encryption key\n    encryption_configured = bool(getattr(settings, \"CALENDAR_ENCRYPTION_KEY\", None))\n\n    data = {\n        \"providers\": providers,\n        \"encryption_key_configured\": encryption_configured,\n        \"oauth_redirect_uri\": getattr(settings, \"OAUTH_REDIRECT_URI\", None),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n"
}
