{
  "path": "services/api-gateway/app/api/admin_cache.py",
  "language": "python",
  "size": 9500,
  "last_modified": "2025-12-04T11:26:44.572Z",
  "lines": 314,
  "content": "\"\"\"Admin Cache Management API (Phase 7 Integration Improvements - P2.1).\n\nProvides endpoints for administrators to manage the multi-level cache:\n- View cache statistics\n- Clear caches (selective or all)\n- Invalidate specific patterns\n- Monitor cache performance\n\nThese endpoints require admin authentication.\n\"\"\"\n\nfrom app.core.api_envelope import success_response\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer\nfrom app.core.logging import get_logger\nfrom app.models.user import User\nfrom app.services.cache_service import cache_service\nfrom fastapi import APIRouter, Depends, Query\nfrom pydantic import BaseModel\n\nrouter = APIRouter(prefix=\"/api/admin/cache\", tags=[\"admin\", \"cache\"])\nlogger = get_logger(__name__)\n\n\nclass CacheStatsResponse(BaseModel):\n    \"\"\"Cache statistics response.\"\"\"\n\n    l1_size: int\n    l1_max_size: int\n    l1_utilization: float\n    l2_used_memory: int\n    l2_used_memory_human: str\n    l2_connected_clients: int\n\n\nclass CacheInvalidateRequest(BaseModel):\n    \"\"\"Request to invalidate cache by pattern.\"\"\"\n\n    pattern: str\n\n\n@router.get(\"/stats\", response_model=dict)\nasync def get_cache_stats(\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"\n    Get cache statistics for monitoring.\n\n    Returns:\n        Cache stats including L1 and L2 metrics\n    \"\"\"\n    try:\n        stats = await cache_service.get_stats()\n\n        response_data = CacheStatsResponse(\n            l1_size=stats.get(\"l1\", {}).get(\"size\", 0),\n            l1_max_size=stats.get(\"l1\", {}).get(\"max_size\", 0),\n            l1_utilization=stats.get(\"l1\", {}).get(\"utilization\", 0.0),\n            l2_used_memory=stats.get(\"l2\", {}).get(\"used_memory\", 0),\n            l2_used_memory_human=stats.get(\"l2\", {}).get(\"used_memory_human\", \"0B\"),\n            l2_connected_clients=stats.get(\"l2\", {}).get(\"connected_clients\", 0),\n        )\n\n        logger.info(\n            \"cache_stats_retrieved\",\n            extra={\n                \"admin_user_id\": str(current_admin_user.id),\n                \"l1_utilization\": response_data.l1_utilization,\n            },\n        )\n\n        return success_response(data=response_data.model_dump(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Error retrieving cache stats: {e}\", exc_info=True)\n        return success_response(\n            data={\"error\": str(e), \"message\": \"Failed to retrieve cache statistics\"},\n            version=\"2.0.0\",\n        )\n\n\n@router.post(\"/clear\", response_model=dict)\nasync def clear_cache(\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"\n    Clear all caches (L1 and L2).\n\n    WARNING: This will clear ALL cached data and may temporarily\n    impact performance while caches are repopulated.\n\n    Returns:\n        Success status\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        success = await cache_service.clear()\n\n        logger.warning(\n            \"cache_cleared_all\",\n            extra={\n                \"admin_user_id\": str(current_admin_user.id),\n                \"admin_email\": current_admin_user.email,\n                \"success\": success,\n            },\n        )\n\n        return success_response(\n            data={\n                \"success\": success,\n                \"message\": (\"All caches cleared successfully\" if success else \"Failed to clear caches\"),\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Error clearing cache: {e}\", exc_info=True)\n        return success_response(\n            data={\n                \"success\": False,\n                \"error\": str(e),\n                \"message\": \"Failed to clear caches\",\n            },\n            version=\"2.0.0\",\n        )\n\n\n@router.post(\"/invalidate\", response_model=dict)\nasync def invalidate_cache_pattern(\n    pattern: str = Query(..., description=\"Redis key pattern to invalidate (e.g., 'rag_query:*')\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"\n    Invalidate cache entries matching a pattern.\n\n    Examples:\n    - \"rag_query:*\" - All RAG query caches\n    - \"user:*\" - All user data caches\n    - \"search_results:*\" - All search result caches\n\n    Returns:\n        Number of keys deleted\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        deleted_count = await cache_service.delete_pattern(pattern)\n\n        logger.info(\n            \"cache_pattern_invalidated\",\n            extra={\n                \"admin_user_id\": str(current_admin_user.id),\n                \"pattern\": pattern,\n                \"deleted_count\": deleted_count,\n            },\n        )\n\n        return success_response(\n            data={\n                \"pattern\": pattern,\n                \"deleted_count\": deleted_count,\n                \"message\": f\"Invalidated {deleted_count} cache entries matching pattern '{pattern}'\",\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Error invalidating cache pattern: {e}\", exc_info=True)\n        return success_response(\n            data={\n                \"pattern\": pattern,\n                \"deleted_count\": 0,\n                \"error\": str(e),\n                \"message\": \"Failed to invalidate cache pattern\",\n            },\n            version=\"2.0.0\",\n        )\n\n\nclass NamespaceStats(BaseModel):\n    \"\"\"Cache stats for a specific namespace.\"\"\"\n\n    namespace: str\n    key_count: int\n    estimated_size_bytes: int\n\n\n@router.get(\"/stats/namespaces\", response_model=dict)\nasync def get_cache_stats_by_namespace(\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"\n    Get cache statistics broken down by namespace.\n\n    Returns:\n        Cache stats organized by namespace (e.g., rag_query, user, search_results)\n    \"\"\"\n    try:\n        from app.core.database import redis_client\n\n        # Define known namespaces to check\n        namespaces = [\n            \"voiceassist:*\",\n            \"rag_query:*\",\n            \"search_results:*\",\n            \"user:*\",\n            \"session:*\",\n            \"metrics:*\",\n            \"admin:*\",\n        ]\n\n        namespace_stats = []\n        for ns in namespaces:\n            try:\n                # Count keys matching the namespace pattern\n                cursor = 0\n                key_count = 0\n                while True:\n                    cursor, keys = redis_client.scan(cursor=cursor, match=ns, count=100)\n                    key_count += len(keys)\n                    if cursor == 0:\n                        break\n\n                if key_count > 0:\n                    namespace_stats.append(\n                        NamespaceStats(\n                            namespace=ns.rstrip(\":*\"),\n                            key_count=key_count,\n                            estimated_size_bytes=key_count * 1024,  # Rough estimate\n                        ).model_dump()\n                    )\n            except Exception as e:\n                logger.warning(f\"Error scanning namespace {ns}: {e}\")\n                continue\n\n        logger.info(\n            \"cache_namespace_stats_retrieved\",\n            extra={\n                \"admin_user_id\": str(current_admin_user.id),\n                \"namespace_count\": len(namespace_stats),\n            },\n        )\n\n        return success_response(\n            data={\n                \"namespaces\": namespace_stats,\n                \"total_namespaces\": len(namespace_stats),\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Error retrieving namespace stats: {e}\", exc_info=True)\n        return success_response(\n            data={\n                \"namespaces\": [],\n                \"error\": str(e),\n                \"message\": \"Failed to retrieve namespace statistics\",\n            },\n            version=\"2.0.0\",\n        )\n\n\n@router.post(\"/invalidate/namespace\", response_model=dict)\nasync def invalidate_namespace(\n    namespace: str = Query(..., description=\"Namespace to invalidate (e.g., 'rag_query', 'search_results')\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"\n    Invalidate all cache entries in a specific namespace.\n\n    This is a convenience endpoint that invalidates all keys matching {namespace}:*\n\n    Returns:\n        Number of keys deleted\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        pattern = f\"{namespace}:*\"\n        deleted_count = await cache_service.delete_pattern(pattern)\n\n        logger.warning(\n            \"cache_namespace_invalidated\",\n            extra={\n                \"admin_user_id\": str(current_admin_user.id),\n                \"admin_email\": current_admin_user.email,\n                \"namespace\": namespace,\n                \"deleted_count\": deleted_count,\n            },\n        )\n\n        return success_response(\n            data={\n                \"namespace\": namespace,\n                \"pattern\": pattern,\n                \"deleted_count\": deleted_count,\n                \"message\": f\"Invalidated {deleted_count} cache entries in namespace '{namespace}'\",\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Error invalidating namespace: {e}\", exc_info=True)\n        return success_response(\n            data={\n                \"namespace\": namespace,\n                \"deleted_count\": 0,\n                \"error\": str(e),\n                \"message\": \"Failed to invalidate namespace\",\n            },\n            version=\"2.0.0\",\n        )\n"
}
