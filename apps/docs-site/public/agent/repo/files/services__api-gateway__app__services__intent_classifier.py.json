{
  "path": "services/api-gateway/app/services/intent_classifier.py",
  "language": "python",
  "size": 5340,
  "last_modified": "2025-12-04T11:26:56.852Z",
  "lines": 175,
  "content": "\"\"\"Intent Classification Service for VoiceAssist.\n\nThis module classifies the medical intent of user queries to enable:\n- Better routing to appropriate models\n- Intent-specific prompt engineering\n- Analytics on query types\n\nSupported intents:\n- diagnosis: Questions about diagnosis, differential diagnosis\n- treatment: Questions about treatment plans, therapies\n- drug: Questions about medications, dosing, interactions\n- guideline: Questions about clinical guidelines, protocols\n- summary: Requests to summarize patient information\n- other: General medical questions\n\nFUTURE: This could be enhanced with ML-based classification using:\n- Fine-tuned BERT models\n- Few-shot learning with GPT\n- Traditional ML classifiers (SVM, Random Forest)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Literal\n\nlogger = logging.getLogger(__name__)\n\nIntentType = Literal[\"diagnosis\", \"treatment\", \"drug\", \"guideline\", \"summary\", \"other\"]\n\n\nclass IntentClassifier:\n    \"\"\"Rule-based intent classifier using keyword matching.\n\n    This is a simple implementation for MVP. Production systems should use\n    ML-based classification for better accuracy.\n    \"\"\"\n\n    def __init__(self):\n        # Define keyword patterns for each intent\n        self.intent_keywords = {\n            \"diagnosis\": [\n                \"diagnose\",\n                \"diagnosis\",\n                \"differential\",\n                \"could be\",\n                \"what is causing\",\n                \"what causes\",\n                \"symptoms suggest\",\n                \"likely diagnosis\",\n                \"rule out\",\n                \"consider\",\n                \"diagnostic\",\n                \"presenting with\",\n            ],\n            \"treatment\": [\n                \"treat\",\n                \"treatment\",\n                \"therapy\",\n                \"manage\",\n                \"management\",\n                \"intervention\",\n                \"procedure\",\n                \"surgery\",\n                \"operation\",\n                \"how to treat\",\n                \"what should i do\",\n                \"next steps\",\n                \"care plan\",\n            ],\n            \"drug\": [\n                \"medication\",\n                \"drug\",\n                \"prescription\",\n                \"dose\",\n                \"dosage\",\n                \"dosing\",\n                \"mg\",\n                \"tablet\",\n                \"pill\",\n                \"antibiotic\",\n                \"interaction\",\n                \"side effect\",\n                \"contraindication\",\n                \"pharma\",\n            ],\n            \"guideline\": [\n                \"guideline\",\n                \"protocol\",\n                \"recommendation\",\n                \"standard of care\",\n                \"best practice\",\n                \"accomodation\",\n                \"acc\",\n                \"aha\",\n                \"who\",\n                \"cdc\",\n                \"uptodate\",\n                \"evidence based\",\n            ],\n            \"summary\": [\n                \"summarize\",\n                \"summary\",\n                \"brief\",\n                \"overview\",\n                \"recap\",\n                \"condense\",\n                \"key points\",\n                \"in short\",\n            ],\n        }\n\n    def classify(self, query: str, clinical_context: dict | None = None) -> IntentType:\n        \"\"\"Classify the intent of a medical query.\n\n        Uses keyword matching with scoring to determine the most likely intent.\n\n        Args:\n            query: User query text\n            clinical_context: Optional clinical context (may provide additional signals)\n\n        Returns:\n            IntentType: The classified intent\n        \"\"\"\n        if not query:\n            return \"other\"\n\n        query_lower = query.lower()\n\n        # Score each intent based on keyword matches\n        intent_scores = {intent: 0 for intent in self.intent_keywords.keys()}\n\n        for intent, keywords in self.intent_keywords.items():\n            for keyword in keywords:\n                if keyword in query_lower:\n                    # Weight matches by keyword length (longer = more specific)\n                    intent_scores[intent] += len(keyword.split())\n\n        # Get the highest scoring intent\n        if max(intent_scores.values()) > 0:\n            best_intent = max(intent_scores.items(), key=lambda x: x[1])[0]\n            logger.debug(f\"Intent classified as '{best_intent}' with score {intent_scores[best_intent]}\")\n            return best_intent  # type: ignore\n\n        # Default to \"other\" if no keywords matched\n        logger.debug(\"Intent classified as 'other' (no keyword matches)\")\n        return \"other\"\n\n    def get_confidence(self, query: str, intent: IntentType) -> float:\n        \"\"\"Get confidence score for a classification.\n\n        Args:\n            query: User query text\n            intent: Classified intent\n\n        Returns:\n            Confidence score (0.0 - 1.0)\n        \"\"\"\n        if not query or intent == \"other\":\n            return 0.5  # Medium confidence for default\n\n        query_lower = query.lower()\n        keywords = self.intent_keywords.get(intent, [])\n\n        matches = sum(1 for kw in keywords if kw in query_lower)\n\n        if matches == 0:\n            return 0.5\n        elif matches == 1:\n            return 0.7\n        elif matches == 2:\n            return 0.85\n        else:\n            return 0.95\n"
}
