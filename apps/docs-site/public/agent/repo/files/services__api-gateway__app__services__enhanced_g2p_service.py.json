{
  "path": "services/api-gateway/app/services/enhanced_g2p_service.py",
  "language": "python",
  "size": 12700,
  "last_modified": "2025-12-05T03:07:13.133Z",
  "lines": 426,
  "content": "\"\"\"\nEnhanced G2P Service for Medical Pronunciation\nImplements CMUdict + gruut hybrid with espeak-ng fallback.\n\nPart of Voice Mode Enhancement Plan v4.1.2\nReference: docs/voice/design/g2p-alternatives-evaluation.md\n\"\"\"\n\nimport asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Tuple\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass G2PResult:\n    \"\"\"Result of G2P conversion.\"\"\"\n\n    term: str\n    phonemes: str\n    source: str  # \"cmudict\", \"gruut\", \"espeak\", \"cache\", \"fallback\"\n    confidence: float\n    alphabet: str = \"ipa\"\n\n\n# ARPABET to IPA conversion table\nARPABET_TO_IPA: Dict[str, str] = {\n    \"AA\": \"ɑ\",\n    \"AA0\": \"ɑ\",\n    \"AA1\": \"ˈɑ\",\n    \"AA2\": \"ˌɑ\",\n    \"AE\": \"æ\",\n    \"AE0\": \"æ\",\n    \"AE1\": \"ˈæ\",\n    \"AE2\": \"ˌæ\",\n    \"AH\": \"ʌ\",\n    \"AH0\": \"ə\",\n    \"AH1\": \"ˈʌ\",\n    \"AH2\": \"ˌʌ\",\n    \"AO\": \"ɔ\",\n    \"AO0\": \"ɔ\",\n    \"AO1\": \"ˈɔ\",\n    \"AO2\": \"ˌɔ\",\n    \"AW\": \"aʊ\",\n    \"AW0\": \"aʊ\",\n    \"AW1\": \"ˈaʊ\",\n    \"AW2\": \"ˌaʊ\",\n    \"AY\": \"aɪ\",\n    \"AY0\": \"aɪ\",\n    \"AY1\": \"ˈaɪ\",\n    \"AY2\": \"ˌaɪ\",\n    \"B\": \"b\",\n    \"CH\": \"tʃ\",\n    \"D\": \"d\",\n    \"DH\": \"ð\",\n    \"EH\": \"ɛ\",\n    \"EH0\": \"ɛ\",\n    \"EH1\": \"ˈɛ\",\n    \"EH2\": \"ˌɛ\",\n    \"ER\": \"ɝ\",\n    \"ER0\": \"ɚ\",\n    \"ER1\": \"ˈɝ\",\n    \"ER2\": \"ˌɝ\",\n    \"EY\": \"eɪ\",\n    \"EY0\": \"eɪ\",\n    \"EY1\": \"ˈeɪ\",\n    \"EY2\": \"ˌeɪ\",\n    \"F\": \"f\",\n    \"G\": \"ɡ\",\n    \"HH\": \"h\",\n    \"IH\": \"ɪ\",\n    \"IH0\": \"ɪ\",\n    \"IH1\": \"ˈɪ\",\n    \"IH2\": \"ˌɪ\",\n    \"IY\": \"i\",\n    \"IY0\": \"i\",\n    \"IY1\": \"ˈi\",\n    \"IY2\": \"ˌi\",\n    \"JH\": \"dʒ\",\n    \"K\": \"k\",\n    \"L\": \"l\",\n    \"M\": \"m\",\n    \"N\": \"n\",\n    \"NG\": \"ŋ\",\n    \"OW\": \"oʊ\",\n    \"OW0\": \"oʊ\",\n    \"OW1\": \"ˈoʊ\",\n    \"OW2\": \"ˌoʊ\",\n    \"OY\": \"ɔɪ\",\n    \"OY0\": \"ɔɪ\",\n    \"OY1\": \"ˈɔɪ\",\n    \"OY2\": \"ˌɔɪ\",\n    \"P\": \"p\",\n    \"R\": \"ɹ\",\n    \"S\": \"s\",\n    \"SH\": \"ʃ\",\n    \"T\": \"t\",\n    \"TH\": \"θ\",\n    \"UH\": \"ʊ\",\n    \"UH0\": \"ʊ\",\n    \"UH1\": \"ˈʊ\",\n    \"UH2\": \"ˌʊ\",\n    \"UW\": \"u\",\n    \"UW0\": \"u\",\n    \"UW1\": \"ˈu\",\n    \"UW2\": \"ˌu\",\n    \"V\": \"v\",\n    \"W\": \"w\",\n    \"Y\": \"j\",\n    \"Z\": \"z\",\n    \"ZH\": \"ʒ\",\n}\n\n# Pre-computed medical term pronunciations (most common terms)\nMEDICAL_PRONUNCIATION_CACHE: Dict[str, str] = {\n    # Common drugs\n    \"metformin\": \"mɛtˈfɔɹmɪn\",\n    \"lisinopril\": \"laɪˈsɪnəpɹɪl\",\n    \"amlodipine\": \"æmˈloʊdɪpiːn\",\n    \"atorvastatin\": \"əˌtɔɹvəˈstætɪn\",\n    \"omeprazole\": \"oʊˈmɛpɹəzoʊl\",\n    \"levothyroxine\": \"ˌlivoʊθaɪˈɹɑksɪn\",\n    \"simvastatin\": \"sɪmˈvæstətɪn\",\n    \"losartan\": \"loʊˈsɑɹtæn\",\n    \"gabapentin\": \"ˌɡæbəˈpɛntɪn\",\n    \"hydrochlorothiazide\": \"ˌhaɪdɹoʊˌklɔɹoʊˈθaɪəzaɪd\",\n    \"amoxicillin\": \"əˌmɑksɪˈsɪlɪn\",\n    \"azithromycin\": \"əˌzɪθɹoʊˈmaɪsɪn\",\n    \"prednisone\": \"ˈpɹɛdnɪsoʊn\",\n    \"ibuprofen\": \"aɪˈbjuːpɹoʊfən\",\n    \"acetaminophen\": \"əˌsiːtəˈmɪnəfɛn\",\n    \"aspirin\": \"ˈæspɹɪn\",\n    \"insulin\": \"ˈɪnsəlɪn\",\n    \"warfarin\": \"ˈwɔɹfəɹɪn\",\n    # Common conditions\n    \"diabetes\": \"ˌdaɪəˈbiːtiːz\",\n    \"hypertension\": \"ˌhaɪpɝˈtɛnʃən\",\n    \"hypotension\": \"ˌhaɪpoʊˈtɛnʃən\",\n    \"arrhythmia\": \"əˈɹɪðmiə\",\n    \"tachycardia\": \"ˌtækɪˈkɑɹdiə\",\n    \"bradycardia\": \"ˌbɹeɪdɪˈkɑɹdiə\",\n    \"pneumonia\": \"nuˈmoʊniə\",\n    \"bronchitis\": \"bɹɑŋˈkaɪtɪs\",\n    \"asthma\": \"ˈæzmə\",\n    \"emphysema\": \"ˌɛmfɪˈsiːmə\",\n    \"atherosclerosis\": \"ˌæθəɹoʊskləˈɹoʊsɪs\",\n    \"osteoporosis\": \"ˌɑstiːoʊpəˈɹoʊsɪs\",\n    \"arthritis\": \"ɑɹˈθɹaɪtɪs\",\n    \"leukemia\": \"luˈkiːmiə\",\n    \"lymphoma\": \"lɪmˈfoʊmə\",\n    \"melanoma\": \"ˌmɛləˈnoʊmə\",\n    \"carcinoma\": \"ˌkɑɹsɪˈnoʊmə\",\n    \"anemia\": \"əˈniːmiə\",\n    # Anatomy\n    \"cardiovascular\": \"ˌkɑɹdioʊˈvæskjəlɚ\",\n    \"gastrointestinal\": \"ˌɡæstɹoʊɪnˈtɛstɪnəl\",\n    \"musculoskeletal\": \"ˌmʌskjəloʊˈskɛlɪtəl\",\n    \"cerebrovascular\": \"ˌsɛɹɪbɹoʊˈvæskjəlɚ\",\n    \"pulmonary\": \"ˈpʊlməˌnɛɹi\",\n    \"hepatic\": \"hɪˈpætɪk\",\n    \"renal\": \"ˈɹiːnəl\",\n    \"pancreatic\": \"ˌpænkɹiˈætɪk\",\n    \"thyroid\": \"ˈθaɪɹɔɪd\",\n    \"adrenal\": \"əˈdɹiːnəl\",\n}\n\n# Gruut supported languages\nGRUUT_LANGUAGES = {\"en\", \"es\", \"de\", \"fr\", \"it\", \"pt\", \"nl\", \"sv\", \"cs\", \"pl\", \"ru\"}\n\n\nclass EnhancedG2PService:\n    \"\"\"\n    Enhanced Grapheme-to-Phoneme service using CMUdict + gruut hybrid.\n\n    Fallback chain:\n    1. Medical pronunciation cache (pre-computed common terms)\n    2. CMUdict lookup (English only)\n    3. gruut (multi-language support)\n    4. espeak-ng (final fallback)\n    \"\"\"\n\n    def __init__(self):\n        self._cmudict: Optional[Dict[str, List[List[str]]]] = None\n        self._gruut_available = False\n        self._espeak_available = False\n\n        # Runtime cache for G2P results\n        self._cache: Dict[Tuple[str, str], G2PResult] = {}\n        self._cache_max_size = 10000\n\n        # Initialize backends\n        self._init_backends()\n\n    def _init_backends(self) -> None:\n        \"\"\"Initialize available G2P backends.\"\"\"\n        # Try to load CMUdict\n        try:\n            import cmudict\n\n            self._cmudict = cmudict.dict()\n            logger.info(f\"CMUdict loaded with {len(self._cmudict)} entries\")\n        except ImportError:\n            logger.warning(\"cmudict not available, falling back to other backends\")\n            self._cmudict = None\n\n        # Check gruut availability\n        try:\n            from gruut import sentences  # noqa: F401\n\n            self._gruut_available = True\n            logger.info(\"gruut backend available\")\n        except ImportError:\n            self._gruut_available = False\n            logger.warning(\"gruut not available\")\n\n        # Check espeak-ng availability\n        try:\n            import shutil\n\n            self._espeak_available = shutil.which(\"espeak-ng\") is not None\n            if self._espeak_available:\n                logger.info(\"espeak-ng backend available\")\n            else:\n                logger.warning(\"espeak-ng not found in PATH\")\n        except Exception:\n            self._espeak_available = False\n\n    def _arpabet_to_ipa(self, arpabet: List[str]) -> str:\n        \"\"\"Convert ARPABET phoneme list to IPA string.\"\"\"\n        ipa_phonemes = []\n        for phone in arpabet:\n            ipa = ARPABET_TO_IPA.get(phone, phone.lower())\n            ipa_phonemes.append(ipa)\n        return \"\".join(ipa_phonemes)\n\n    async def generate(self, term: str, language: str = \"en\") -> G2PResult:\n        \"\"\"\n        Generate phoneme representation for a term.\n\n        Args:\n            term: The word/phrase to convert\n            language: ISO 639-1 language code\n\n        Returns:\n            G2PResult with phonemes and metadata\n        \"\"\"\n        # Check cache first\n        cache_key = (term.lower(), language)\n        if cache_key in self._cache:\n            cached = self._cache[cache_key]\n            return G2PResult(\n                term=term,\n                phonemes=cached.phonemes,\n                source=\"cache\",\n                confidence=cached.confidence,\n                alphabet=cached.alphabet,\n            )\n\n        result = await self._generate_uncached(term, language)\n\n        # Add to cache\n        if len(self._cache) < self._cache_max_size:\n            self._cache[cache_key] = result\n\n        return result\n\n    async def _generate_uncached(self, term: str, language: str) -> G2PResult:\n        \"\"\"Generate phonemes without cache lookup.\"\"\"\n        term_lower = term.lower()\n\n        # 1. Check medical pronunciation cache\n        if term_lower in MEDICAL_PRONUNCIATION_CACHE:\n            return G2PResult(\n                term=term,\n                phonemes=MEDICAL_PRONUNCIATION_CACHE[term_lower],\n                source=\"medical_cache\",\n                confidence=0.95,\n            )\n\n        # 2. For English, try CMUdict\n        if language == \"en\" and self._cmudict and term_lower in self._cmudict:\n            arpabet = self._cmudict[term_lower][0]  # Use first pronunciation\n            ipa = self._arpabet_to_ipa(arpabet)\n            return G2PResult(\n                term=term,\n                phonemes=ipa,\n                source=\"cmudict\",\n                confidence=0.9,\n            )\n\n        # 3. Try gruut for supported languages\n        if self._gruut_available and language in GRUUT_LANGUAGES:\n            try:\n                phonemes = await self._generate_gruut(term, language)\n                if phonemes:\n                    return G2PResult(\n                        term=term,\n                        phonemes=phonemes,\n                        source=\"gruut\",\n                        confidence=0.8,\n                    )\n            except Exception as e:\n                logger.warning(f\"gruut failed for '{term}': {e}\")\n\n        # 4. Fall back to espeak-ng\n        if self._espeak_available:\n            try:\n                phonemes = await self._generate_espeak(term, language)\n                if phonemes and not phonemes.startswith(\"/\"):\n                    return G2PResult(\n                        term=term,\n                        phonemes=phonemes,\n                        source=\"espeak\",\n                        confidence=0.7,\n                    )\n            except Exception as e:\n                logger.warning(f\"espeak failed for '{term}': {e}\")\n\n        # 5. Final fallback - return term wrapped in slashes\n        return G2PResult(\n            term=term,\n            phonemes=f\"/{term}/\",\n            source=\"fallback\",\n            confidence=0.3,\n        )\n\n    async def _generate_gruut(self, term: str, language: str) -> Optional[str]:\n        \"\"\"Generate phonemes using gruut.\"\"\"\n        from gruut import sentences\n\n        # Map to gruut language codes\n        gruut_lang_map = {\n            \"en\": \"en-us\",\n            \"es\": \"es-es\",\n            \"de\": \"de-de\",\n            \"fr\": \"fr-fr\",\n            \"it\": \"it-it\",\n            \"pt\": \"pt-pt\",\n            \"nl\": \"nl\",\n            \"sv\": \"sv-se\",\n            \"cs\": \"cs-cz\",\n            \"pl\": \"pl-pl\",\n            \"ru\": \"ru-ru\",\n        }\n\n        gruut_lang = gruut_lang_map.get(language, f\"{language}-{language}\")\n\n        phonemes = []\n        for sent in sentences(term, lang=gruut_lang):\n            for word in sent:\n                if word.phonemes:\n                    phonemes.extend(word.phonemes)\n\n        return \" \".join(phonemes) if phonemes else None\n\n    async def _generate_espeak(self, term: str, language: str) -> str:\n        \"\"\"Generate phonemes using espeak-ng.\"\"\"\n        # Map to espeak voice codes\n        voice_map = {\n            \"en\": \"en-us\",\n            \"es\": \"es\",\n            \"fr\": \"fr\",\n            \"de\": \"de\",\n            \"it\": \"it\",\n            \"pt\": \"pt\",\n            \"ar\": \"ar\",\n            \"hi\": \"hi\",\n            \"zh\": \"zh\",\n            \"ja\": \"ja\",\n            \"ko\": \"ko\",\n            \"ru\": \"ru\",\n            \"pl\": \"pl\",\n            \"tr\": \"tr\",\n        }\n\n        voice = voice_map.get(language, \"en-us\")\n\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                \"espeak-ng\",\n                \"-v\",\n                voice,\n                \"-q\",  # Quiet (no audio)\n                \"--ipa\",  # Output IPA\n                term,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=5.0)\n\n            if proc.returncode == 0:\n                return stdout.decode().strip()\n            else:\n                logger.warning(f\"espeak-ng error: {stderr.decode()}\")\n                return f\"/{term}/\"\n        except FileNotFoundError:\n            return f\"/{term}/\"\n        except asyncio.TimeoutError:\n            return f\"/{term}/\"\n\n    async def batch_generate(self, terms: List[str], language: str = \"en\") -> List[G2PResult]:\n        \"\"\"Generate phonemes for multiple terms.\"\"\"\n        results = await asyncio.gather(*[self.generate(term, language) for term in terms])\n        return list(results)\n\n    def get_stats(self) -> Dict[str, any]:\n        \"\"\"Get service statistics.\"\"\"\n        return {\n            \"cmudict_available\": self._cmudict is not None,\n            \"cmudict_entries\": len(self._cmudict) if self._cmudict else 0,\n            \"gruut_available\": self._gruut_available,\n            \"espeak_available\": self._espeak_available,\n            \"cache_size\": len(self._cache),\n            \"medical_cache_size\": len(MEDICAL_PRONUNCIATION_CACHE),\n        }\n\n    @property\n    def last_source(self) -> Optional[str]:\n        \"\"\"Get source of last lookup (for testing).\"\"\"\n        if self._cache:\n            last_key = list(self._cache.keys())[-1]\n            return self._cache[last_key].source\n        return None\n"
}
