{
  "path": "services/api-gateway/app/services/adaptive_vad_service.py",
  "language": "python",
  "size": 15422,
  "last_modified": "2025-12-04T21:30:58.282Z",
  "lines": 457,
  "content": "\"\"\"\nAdaptive VAD Service with User-Tunable Presets\nExtends base VAD with environment-aware presets and accessibility options.\n\nPart of Voice Mode Enhancement Plan v4.1 - Workstream 4\nReference: docs/voice/adaptive-vad-presets.md\n\nFeatures:\n- Three preset modes: Sensitive, Balanced, Relaxed\n- Custom preset support for power users\n- Auto-calibration based on ambient noise\n- Accessibility optimizations for speech impairments\n- User preference persistence\n\"\"\"\n\nimport logging\nimport struct\nimport time\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Callable, Dict, List, Optional\n\nfrom app.services.voice_activity_detector import VADConfig, VoiceActivityDetector\n\nlogger = logging.getLogger(__name__)\n\n\nclass VADPresetType(str, Enum):\n    \"\"\"Available VAD preset types.\"\"\"\n\n    SENSITIVE = \"sensitive\"  # Quiet environment\n    BALANCED = \"balanced\"  # Default\n    RELAXED = \"relaxed\"  # Noisy environment\n    ACCESSIBILITY = \"accessibility\"  # Speech impairments\n    CUSTOM = \"custom\"  # User-defined\n\n\n@dataclass\nclass VADPreset:\n    \"\"\"VAD preset configuration.\"\"\"\n\n    name: str\n    energy_threshold_db: float  # Energy threshold in dB\n    silence_duration_ms: int  # Silence before end-of-speech\n    min_speech_duration_ms: int  # Minimum speech duration\n    pre_speech_buffer_ms: int  # Buffer before speech start\n    post_speech_buffer_ms: int = 100  # Buffer after speech end\n    description: str = \"\"\n\n    def to_vad_config(self) -> VADConfig:\n        \"\"\"Convert preset to VADConfig.\"\"\"\n        # Convert dB threshold to normalized threshold (0-1)\n        # -50 dB -> 0.1, -25 dB -> 0.9\n        normalized_threshold = (self.energy_threshold_db + 50) / 30\n        normalized_threshold = max(0.1, min(0.9, normalized_threshold))\n\n        return VADConfig(\n            threshold=normalized_threshold,\n            silence_end_frames=int(self.silence_duration_ms / 30),  # 30ms frames\n            min_speech_duration_ms=self.min_speech_duration_ms,\n            prefix_padding_ms=self.pre_speech_buffer_ms,\n            suffix_padding_ms=self.post_speech_buffer_ms,\n        )\n\n\n# Predefined presets\nPRESETS: Dict[VADPresetType, VADPreset] = {\n    VADPresetType.SENSITIVE: VADPreset(\n        name=\"sensitive\",\n        energy_threshold_db=-45,\n        silence_duration_ms=300,\n        min_speech_duration_ms=100,\n        pre_speech_buffer_ms=200,\n        post_speech_buffer_ms=100,\n        description=\"Optimized for quiet environments with soft speech\",\n    ),\n    VADPresetType.BALANCED: VADPreset(\n        name=\"balanced\",\n        energy_threshold_db=-35,\n        silence_duration_ms=500,\n        min_speech_duration_ms=150,\n        pre_speech_buffer_ms=250,\n        post_speech_buffer_ms=150,\n        description=\"General-purpose preset for typical environments\",\n    ),\n    VADPresetType.RELAXED: VADPreset(\n        name=\"relaxed\",\n        energy_threshold_db=-25,\n        silence_duration_ms=800,\n        min_speech_duration_ms=200,\n        pre_speech_buffer_ms=300,\n        post_speech_buffer_ms=200,\n        description=\"Optimized for noisy environments or distant microphones\",\n    ),\n    VADPresetType.ACCESSIBILITY: VADPreset(\n        name=\"accessibility\",\n        energy_threshold_db=-42,\n        silence_duration_ms=1000,\n        min_speech_duration_ms=80,\n        pre_speech_buffer_ms=400,\n        post_speech_buffer_ms=300,\n        description=\"Optimized for users with speech impairments\",\n    ),\n}\n\n\n@dataclass\nclass CalibrationResult:\n    \"\"\"Result of ambient noise calibration.\"\"\"\n\n    noise_floor_db: float\n    recommended_preset: VADPresetType\n    suggested_threshold_db: float\n    calibration_duration_ms: float\n    sample_count: int\n\n\n@dataclass\nclass VADMetrics:\n    \"\"\"Metrics for VAD performance.\"\"\"\n\n    false_positive_rate: float = 0.0\n    false_negative_rate: float = 0.0\n    avg_detection_latency_ms: float = 0.0\n    total_speech_segments: int = 0\n    total_silence_segments: int = 0\n\n\nclass AdaptiveVADService:\n    \"\"\"\n    Adaptive Voice Activity Detection with user-tunable presets.\n\n    Provides:\n    - Preset-based configuration (Sensitive, Balanced, Relaxed)\n    - Auto-calibration based on ambient noise\n    - Accessibility optimizations\n    - Session-level preset management\n    - Performance metrics tracking\n    \"\"\"\n\n    def __init__(self, default_preset: VADPresetType = VADPresetType.BALANCED):\n        self.default_preset = default_preset\n        self._session_presets: Dict[str, VADPreset] = {}\n        self._session_vads: Dict[str, VoiceActivityDetector] = {}\n        self._session_metrics: Dict[str, VADMetrics] = {}\n        self._custom_presets: Dict[str, VADPreset] = {}\n\n    def get_preset(self, preset_type: VADPresetType) -> VADPreset:\n        \"\"\"Get a predefined preset by type.\"\"\"\n        return PRESETS.get(preset_type, PRESETS[VADPresetType.BALANCED])\n\n    def create_custom_preset(\n        self,\n        name: str,\n        energy_threshold_db: float,\n        silence_duration_ms: int,\n        min_speech_duration_ms: int = 150,\n        pre_speech_buffer_ms: int = 250,\n    ) -> VADPreset:\n        \"\"\"Create a custom VAD preset.\"\"\"\n        # Validate ranges\n        energy_threshold_db = max(-50, min(-20, energy_threshold_db))\n        silence_duration_ms = max(200, min(1500, silence_duration_ms))\n        min_speech_duration_ms = max(50, min(500, min_speech_duration_ms))\n        pre_speech_buffer_ms = max(100, min(500, pre_speech_buffer_ms))\n\n        preset = VADPreset(\n            name=name,\n            energy_threshold_db=energy_threshold_db,\n            silence_duration_ms=silence_duration_ms,\n            min_speech_duration_ms=min_speech_duration_ms,\n            pre_speech_buffer_ms=pre_speech_buffer_ms,\n            description=f\"Custom preset: {name}\",\n        )\n\n        self._custom_presets[name] = preset\n        return preset\n\n    async def set_preset(\n        self,\n        session_id: str,\n        preset: VADPresetType | str,\n    ) -> VADPreset:\n        \"\"\"\n        Set VAD preset for a session.\n\n        Args:\n            session_id: Session identifier\n            preset: Preset type or custom preset name\n\n        Returns:\n            The active VADPreset\n        \"\"\"\n        if isinstance(preset, VADPresetType):\n            active_preset = self.get_preset(preset)\n        elif preset in self._custom_presets:\n            active_preset = self._custom_presets[preset]\n        else:\n            # Try to parse as preset type\n            try:\n                preset_type = VADPresetType(preset)\n                active_preset = self.get_preset(preset_type)\n            except ValueError:\n                logger.warning(f\"Unknown preset '{preset}', using balanced\")\n                active_preset = self.get_preset(VADPresetType.BALANCED)\n\n        # Store and create VAD instance\n        self._session_presets[session_id] = active_preset\n        self._session_vads[session_id] = VoiceActivityDetector(config=active_preset.to_vad_config())\n        self._session_metrics[session_id] = VADMetrics()\n\n        logger.info(\n            \"VAD preset set\",\n            extra={\n                \"session_id\": session_id,\n                \"preset\": active_preset.name,\n                \"energy_threshold_db\": active_preset.energy_threshold_db,\n                \"silence_duration_ms\": active_preset.silence_duration_ms,\n            },\n        )\n\n        return active_preset\n\n    async def get_config(self, session_id: str) -> VADPreset:\n        \"\"\"Get current VAD configuration for a session.\"\"\"\n        if session_id not in self._session_presets:\n            await self.set_preset(session_id, self.default_preset)\n        return self._session_presets[session_id]\n\n    def get_vad(self, session_id: str) -> VoiceActivityDetector:\n        \"\"\"Get VAD instance for a session.\"\"\"\n        if session_id not in self._session_vads:\n            preset = self.get_preset(self.default_preset)\n            self._session_presets[session_id] = preset\n            self._session_vads[session_id] = VoiceActivityDetector(config=preset.to_vad_config())\n            self._session_metrics[session_id] = VADMetrics()\n        return self._session_vads[session_id]\n\n    async def calibrate(\n        self,\n        audio_sample: bytes,\n        duration_ms: int = 3000,\n    ) -> CalibrationResult:\n        \"\"\"\n        Calibrate VAD based on ambient noise sample.\n\n        Args:\n            audio_sample: Raw PCM audio bytes (16-bit, 16kHz)\n            duration_ms: Duration of the calibration sample\n\n        Returns:\n            CalibrationResult with recommended settings\n        \"\"\"\n        start_time = time.monotonic()\n\n        # Calculate RMS energy of the sample\n        n_samples = len(audio_sample) // 2\n        if n_samples == 0:\n            return CalibrationResult(\n                noise_floor_db=-40,\n                recommended_preset=VADPresetType.BALANCED,\n                suggested_threshold_db=-35,\n                calibration_duration_ms=0,\n                sample_count=0,\n            )\n\n        samples = struct.unpack(f\"<{n_samples}h\", audio_sample)\n        sum_squares = sum(s * s for s in samples)\n        rms = (sum_squares / n_samples) ** 0.5\n\n        # Convert RMS to dB (relative to max 16-bit value)\n        import math\n\n        if rms > 0:\n            noise_floor_db = 20 * math.log10(rms / 32767)\n        else:\n            noise_floor_db = -60\n\n        # Recommend preset based on noise floor\n        if noise_floor_db < -50:\n            recommended = VADPresetType.SENSITIVE\n            suggested_threshold_db = -45\n        elif noise_floor_db < -35:\n            recommended = VADPresetType.BALANCED\n            suggested_threshold_db = noise_floor_db + 10\n        else:\n            recommended = VADPresetType.RELAXED\n            suggested_threshold_db = noise_floor_db + 15\n\n        calibration_duration_ms = (time.monotonic() - start_time) * 1000\n\n        logger.info(\n            \"VAD calibration complete\",\n            extra={\n                \"noise_floor_db\": noise_floor_db,\n                \"recommended_preset\": recommended.value,\n                \"suggested_threshold_db\": suggested_threshold_db,\n            },\n        )\n\n        return CalibrationResult(\n            noise_floor_db=noise_floor_db,\n            recommended_preset=recommended,\n            suggested_threshold_db=suggested_threshold_db,\n            calibration_duration_ms=calibration_duration_ms,\n            sample_count=n_samples,\n        )\n\n    async def set_calibrated_config(\n        self,\n        session_id: str,\n        base_preset: VADPresetType,\n        noise_floor_db: float,\n    ) -> VADPreset:\n        \"\"\"\n        Set calibrated VAD config based on measured noise floor.\n\n        Args:\n            session_id: Session identifier\n            base_preset: Base preset to modify\n            noise_floor_db: Measured noise floor in dB\n\n        Returns:\n            Calibrated VADPreset\n        \"\"\"\n        base = self.get_preset(base_preset)\n\n        # Adjust threshold based on noise floor\n        # Keep threshold at least 10dB above noise floor\n        adjusted_threshold = max(\n            base.energy_threshold_db,\n            noise_floor_db + 10,\n        )\n\n        calibrated = VADPreset(\n            name=f\"{base.name}_calibrated\",\n            energy_threshold_db=adjusted_threshold,\n            silence_duration_ms=base.silence_duration_ms,\n            min_speech_duration_ms=base.min_speech_duration_ms,\n            pre_speech_buffer_ms=base.pre_speech_buffer_ms,\n            post_speech_buffer_ms=base.post_speech_buffer_ms,\n            description=f\"Calibrated from {base.name} (noise floor: {noise_floor_db:.1f}dB)\",\n        )\n\n        self._session_presets[session_id] = calibrated\n        self._session_vads[session_id] = VoiceActivityDetector(config=calibrated.to_vad_config())\n\n        return calibrated\n\n    async def process(\n        self,\n        audio_data: bytes,\n        session_id: Optional[str] = None,\n        on_speech_start: Optional[Callable[[], None]] = None,\n        on_speech_end: Optional[Callable[[int], None]] = None,\n    ) -> Dict:\n        \"\"\"\n        Process audio through VAD.\n\n        Args:\n            audio_data: Raw PCM audio bytes\n            session_id: Optional session ID for preset lookup\n            on_speech_start: Callback for speech start\n            on_speech_end: Callback for speech end\n\n        Returns:\n            Dict with detection results\n        \"\"\"\n        vad = self.get_vad(session_id or \"default\")\n\n        speech_detected = False\n        segments = []\n        current_segment_start = None\n\n        def track_speech_start():\n            nonlocal current_segment_start\n            current_segment_start = vad.state.total_frames_processed * vad.config.frame_duration_ms\n            if on_speech_start:\n                on_speech_start()\n\n        def track_speech_end(duration_ms: int):\n            nonlocal speech_detected, current_segment_start\n            speech_detected = True\n            segments.append(\n                {\n                    \"start_ms\": current_segment_start,\n                    \"duration_ms\": duration_ms,\n                }\n            )\n            current_segment_start = None\n            if on_speech_end:\n                on_speech_end(duration_ms)\n\n        states = vad.process_audio(\n            audio_data,\n            on_speech_start=track_speech_start,\n            on_speech_end=track_speech_end,\n        )\n\n        return {\n            \"speech_detected\": speech_detected,\n            \"segments\": segments,\n            \"final_state\": states[-1].value if states else \"silence\",\n            \"is_speaking\": vad.is_speaking(),\n            \"stats\": vad.get_stats(),\n        }\n\n    def get_metrics(self, session_id: str) -> VADMetrics:\n        \"\"\"Get VAD metrics for a session.\"\"\"\n        return self._session_metrics.get(session_id, VADMetrics())\n\n    def clear_session(self, session_id: str) -> None:\n        \"\"\"Clear session data.\"\"\"\n        self._session_presets.pop(session_id, None)\n        self._session_vads.pop(session_id, None)\n        self._session_metrics.pop(session_id, None)\n\n    def get_available_presets(self) -> List[Dict]:\n        \"\"\"Get list of available presets with descriptions.\"\"\"\n        presets = []\n        for preset_type, preset in PRESETS.items():\n            presets.append(\n                {\n                    \"type\": preset_type.value,\n                    \"name\": preset.name,\n                    \"description\": preset.description,\n                    \"energy_threshold_db\": preset.energy_threshold_db,\n                    \"silence_duration_ms\": preset.silence_duration_ms,\n                }\n            )\n\n        # Add custom presets\n        for name, preset in self._custom_presets.items():\n            presets.append(\n                {\n                    \"type\": \"custom\",\n                    \"name\": name,\n                    \"description\": preset.description,\n                    \"energy_threshold_db\": preset.energy_threshold_db,\n                    \"silence_duration_ms\": preset.silence_duration_ms,\n                }\n            )\n\n        return presets\n\n\n# Singleton instance\n_adaptive_vad_service: Optional[AdaptiveVADService] = None\n\n\nasync def get_adaptive_vad_service() -> AdaptiveVADService:\n    \"\"\"Get or create adaptive VAD service instance.\"\"\"\n    global _adaptive_vad_service\n    if _adaptive_vad_service is None:\n        _adaptive_vad_service = AdaptiveVADService()\n    return _adaptive_vad_service\n"
}
