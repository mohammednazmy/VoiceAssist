{
  "path": "services/api-gateway/app/services/feature_flags.py",
  "language": "python",
  "size": 35794,
  "last_modified": "2025-12-04T12:32:40.271Z",
  "lines": 1075,
  "content": "\"\"\"Feature Flag Service (Phase 7 - P3.1, P3.2 + Phase 10 Enhancement).\n\nProvides runtime feature flag management with multi-level caching for performance:\n- L1 Cache: In-memory LRU cache (1-minute TTL) for super fast access\n- L2 Cache: Redis distributed cache (5-minute TTL) for cross-instance consistency\n- L3 Persistence: PostgreSQL for durability\n\nThis three-tier architecture provides:\n- Sub-millisecond flag checks via L1 cache\n- Cross-instance consistency via L2 (Redis)\n- Durability and management via L3 (PostgreSQL)\n\nPhase 3.2 enhancements:\n- Multivariate flag support with variant selection\n- Targeting rules for user segmentation\n- Percentage rollout with consistent user assignment\n- Schedule-based activation\n\nUsage:\n    from app.services.feature_flags import feature_flag_service\n    from app.services.rule_engine import UserContext\n\n    # Check if feature is enabled (uses L1 -> L2 -> L3 cascade)\n    if await feature_flag_service.is_enabled(\"rbac_enforcement\"):\n        # RBAC logic\n        pass\n\n    # Get feature value\n    rag_strategy = await feature_flag_service.get_value(\"rag_strategy\", default=\"simple\")\n\n    # Get variant for multivariate flag (Phase 3.2)\n    user_ctx = UserContext(user_id=\"user-123\", user_role=\"admin\")\n    variant = await feature_flag_service.get_variant_for_user(\n        \"experiment.onboarding_v2\",\n        user_ctx\n    )\n\n    # Warm cache on startup\n    await feature_flag_service.warm_cache()\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.database import SessionLocal, redis_client\nfrom app.core.logging import get_logger\nfrom app.models.feature_flag import FeatureFlag, FeatureFlagType\nfrom cachetools import TTLCache\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nlogger = get_logger(__name__)\n\n# Redis key prefix for feature flags (L2 cache)\nFEATURE_FLAG_CACHE_PREFIX = \"feature_flag:\"\nFEATURE_FLAG_CACHE_TTL = 300  # 5 minutes (L2 TTL)\n\n# Local in-memory cache settings (L1 cache)\nLOCAL_CACHE_TTL = 60  # 1 minute (L1 TTL - much shorter for quick updates)\nLOCAL_CACHE_MAX_SIZE = 1000  # Maximum number of flags to cache in memory\n\n\nclass FeatureFlagService:\n    \"\"\"Service for managing and checking feature flags with multi-level caching.\n\n    Three-tier caching architecture:\n    - L1: In-memory TTL cache (1-minute TTL) - fastest, process-local\n    - L2: Redis distributed cache (5-minute TTL) - shared across instances\n    - L3: PostgreSQL persistence - source of truth\n\n    Features:\n    - Sub-millisecond flag checks via L1 cache\n    - Cross-instance consistency via L2 (Redis)\n    - PostgreSQL persistence for durability\n    - Automatic cache invalidation on updates (all levels)\n    - Cache warming on startup\n    - Graceful degradation if caches unavailable\n    - Support for boolean, string, number, and JSON values\n    - Prometheus metrics for cache performance\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize feature flag service with multi-level caching.\"\"\"\n        self.logger = get_logger(__name__)\n\n        # L1 Cache: Local in-memory cache with TTL\n        # Uses cachetools.TTLCache for automatic expiration\n        self._local_cache: TTLCache = TTLCache(maxsize=LOCAL_CACHE_MAX_SIZE, ttl=LOCAL_CACHE_TTL)\n        self._cache_stats = {\n            \"l1_hits\": 0,\n            \"l1_misses\": 0,\n            \"l2_hits\": 0,\n            \"l2_misses\": 0,\n            \"l3_hits\": 0,\n            \"l3_misses\": 0,\n        }\n\n    def _get_cache_key(self, flag_name: str) -> str:\n        \"\"\"Get Redis cache key for feature flag.\"\"\"\n        return f\"{FEATURE_FLAG_CACHE_PREFIX}{flag_name}\"\n\n    async def _get_from_local_cache(self, flag_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get feature flag from L1 (local in-memory) cache.\n\n        Args:\n            flag_name: Name of the feature flag\n\n        Returns:\n            Flag data dictionary or None if not in L1 cache\n        \"\"\"\n        try:\n            if flag_name in self._local_cache:\n                self._cache_stats[\"l1_hits\"] += 1\n                self.logger.debug(f\"L1 cache hit for flag: {flag_name}\")\n                return self._local_cache[flag_name]\n            else:\n                self._cache_stats[\"l1_misses\"] += 1\n                return None\n        except Exception as e:\n            self.logger.warning(f\"Failed to get from L1 cache: {e}\")\n            return None\n\n    async def _set_local_cache(self, flag_name: str, flag_data: Dict[str, Any]) -> None:\n        \"\"\"Set feature flag in L1 (local in-memory) cache.\n\n        Args:\n            flag_name: Name of the feature flag\n            flag_data: Flag data to cache\n        \"\"\"\n        try:\n            self._local_cache[flag_name] = flag_data\n            self.logger.debug(f\"Set L1 cache for flag: {flag_name}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to set L1 cache: {e}\")\n\n    async def _invalidate_local_cache(self, flag_name: str) -> None:\n        \"\"\"Invalidate feature flag from L1 cache.\n\n        Args:\n            flag_name: Name of the feature flag\n        \"\"\"\n        try:\n            if flag_name in self._local_cache:\n                del self._local_cache[flag_name]\n                self.logger.debug(f\"Invalidated L1 cache for flag: {flag_name}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to invalidate L1 cache: {e}\")\n\n    async def _get_from_cache(self, flag_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get feature flag from L2 (Redis) cache.\n\n        Args:\n            flag_name: Name of the feature flag\n\n        Returns:\n            Flag data dictionary or None if not in L2 cache\n        \"\"\"\n        try:\n            cache_key = self._get_cache_key(flag_name)\n            cached_value = redis_client.get(cache_key)\n            if cached_value:\n                self._cache_stats[\"l2_hits\"] += 1\n                self.logger.debug(f\"L2 cache hit for flag: {flag_name}\")\n                return json.loads(cached_value)\n            else:\n                self._cache_stats[\"l2_misses\"] += 1\n                return None\n        except Exception as e:\n            self.logger.warning(f\"Failed to get feature flag from L2 cache: {e}\")\n            return None\n\n    async def _set_cache(self, flag_name: str, flag_data: Dict[str, Any]) -> None:\n        \"\"\"Set feature flag in both L1 and L2 caches.\n\n        Args:\n            flag_name: Name of the feature flag\n            flag_data: Flag data to cache\n        \"\"\"\n        # Set in L1 (local cache)\n        await self._set_local_cache(flag_name, flag_data)\n\n        # Set in L2 (Redis cache)\n        try:\n            cache_key = self._get_cache_key(flag_name)\n            redis_client.setex(cache_key, FEATURE_FLAG_CACHE_TTL, json.dumps(flag_data))\n            self.logger.debug(f\"Set L2 cache for flag: {flag_name}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to set L2 cache: {e}\")\n\n    async def _invalidate_cache(self, flag_name: str) -> None:\n        \"\"\"Invalidate feature flag from both L1 and L2 caches.\n\n        Args:\n            flag_name: Name of the feature flag\n        \"\"\"\n        # Invalidate L1 (local cache)\n        await self._invalidate_local_cache(flag_name)\n\n        # Invalidate L2 (Redis cache)\n        try:\n            cache_key = self._get_cache_key(flag_name)\n            redis_client.delete(cache_key)\n            self.logger.debug(f\"Invalidated L2 cache for flag: {flag_name}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to invalidate L2 cache: {e}\")\n\n    async def is_enabled(self, flag_name: str, default: bool = False, db: Optional[Session] = None) -> bool:\n        \"\"\"Check if a boolean feature flag is enabled.\n\n        Uses three-tier cache lookup: L1 (local) -> L2 (Redis) -> L3 (PostgreSQL)\n\n        Args:\n            flag_name: Name of the feature flag\n            default: Default value if flag not found\n            db: Optional database session (creates new if not provided)\n\n        Returns:\n            True if flag is enabled, False otherwise\n        \"\"\"\n        # Try L1 cache first (local in-memory)\n        cached = await self._get_from_local_cache(flag_name)\n        if cached is not None:\n            return cached.get(\"enabled\", default)\n\n        # Try L2 cache (Redis)\n        cached = await self._get_from_cache(flag_name)\n        if cached is not None:\n            # Promote to L1 cache\n            await self._set_local_cache(flag_name, cached)\n            return cached.get(\"enabled\", default)\n\n        # L1 and L2 miss - query L3 (database)\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n\n            if flag:\n                # Cache the result in both L1 and L2\n                self._cache_stats[\"l3_hits\"] += 1\n                await self._set_cache(flag_name, flag.to_dict())\n                return flag.enabled\n            else:\n                self._cache_stats[\"l3_misses\"] += 1\n                return default\n        except Exception as e:\n            self.logger.error(f\"Failed to query feature flag '{flag_name}': {e}\", exc_info=True)\n            return default\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_value(self, flag_name: str, default: Any = None, db: Optional[Session] = None) -> Any:\n        \"\"\"Get feature flag value (for non-boolean flags).\n\n        Uses three-tier cache lookup: L1 (local) -> L2 (Redis) -> L3 (PostgreSQL)\n\n        Args:\n            flag_name: Name of the feature flag\n            default: Default value if flag not found\n            db: Optional database session\n\n        Returns:\n            Feature flag value or default\n        \"\"\"\n        # Try L1 cache first (local in-memory)\n        cached = await self._get_from_local_cache(flag_name)\n        if cached is not None:\n            return cached.get(\"value\", default)\n\n        # Try L2 cache (Redis)\n        cached = await self._get_from_cache(flag_name)\n        if cached is not None:\n            # Promote to L1 cache\n            await self._set_local_cache(flag_name, cached)\n            return cached.get(\"value\", default)\n\n        # L1 and L2 miss - query L3 (database)\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n\n            if flag:\n                # Cache the result\n                await self._set_cache(flag_name, flag.to_dict())\n                return flag.value if flag.value is not None else default\n            else:\n                return default\n        except Exception as e:\n            self.logger.error(f\"Failed to query feature flag '{flag_name}': {e}\", exc_info=True)\n            return default\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_flag(self, flag_name: str, db: Optional[Session] = None) -> Optional[FeatureFlag]:\n        \"\"\"Get complete feature flag object.\n\n        Args:\n            flag_name: Name of the feature flag\n            db: Optional database session\n\n        Returns:\n            FeatureFlag object or None if not found\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            return flag\n        except Exception as e:\n            self.logger.error(f\"Failed to get feature flag '{flag_name}': {e}\", exc_info=True)\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def list_flags(self, db: Session) -> List[FeatureFlag]:\n        \"\"\"List all feature flags.\n\n        Args:\n            db: Database session\n\n        Returns:\n            List of all feature flags\n        \"\"\"\n        try:\n            return db.query(FeatureFlag).order_by(FeatureFlag.name).all()\n        except Exception as e:\n            self.logger.error(f\"Failed to list feature flags: {e}\", exc_info=True)\n            return []\n\n    async def create_flag(\n        self,\n        name: str,\n        description: str,\n        flag_type: FeatureFlagType = FeatureFlagType.BOOLEAN,\n        enabled: bool = False,\n        value: Any = None,\n        default_value: Any = None,\n        metadata: Optional[Dict] = None,\n        db: Session = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Create a new feature flag.\n\n        Args:\n            name: Unique flag identifier\n            description: Human-readable description\n            flag_type: Type of flag (boolean, string, number, json)\n            enabled: Initial enabled state (for boolean flags)\n            value: Initial value (for non-boolean flags)\n            default_value: Default value when flag is not found\n            metadata: Additional metadata (owner, tags, etc.)\n            db: Database session\n\n        Returns:\n            Created FeatureFlag object or None on error\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = FeatureFlag(\n                name=name,\n                description=description,\n                flag_type=flag_type.value,\n                enabled=enabled,\n                value=value,\n                default_value=default_value,\n                metadata=metadata or {},\n            )\n            db.add(flag)\n            db.commit()\n            db.refresh(flag)\n\n            # Cache the new flag\n            await self._set_cache(name, flag.to_dict())\n\n            # Publish real-time update to connected clients\n            await self._publish_flag_update(name, flag.to_dict())\n\n            self.logger.info(f\"Created feature flag: {name}\")\n            return flag\n        except IntegrityError:\n            db.rollback()\n            self.logger.warning(f\"Feature flag already exists: {name}\")\n            return None\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to create feature flag '{name}': {e}\", exc_info=True)\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def update_flag(\n        self,\n        name: str,\n        enabled: Optional[bool] = None,\n        value: Any = None,\n        description: Optional[str] = None,\n        metadata: Optional[Dict] = None,\n        db: Session = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Update an existing feature flag.\n\n        Args:\n            name: Flag identifier\n            enabled: New enabled state (optional)\n            value: New value (optional)\n            description: New description (optional)\n            metadata: New metadata (optional)\n            db: Database session\n\n        Returns:\n            Updated FeatureFlag object or None on error\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == name).first()\n\n            if not flag:\n                self.logger.warning(f\"Feature flag not found: {name}\")\n                return None\n\n            # Update fields\n            if enabled is not None:\n                flag.enabled = enabled\n            if value is not None:\n                flag.value = value\n            if description is not None:\n                flag.description = description\n            if metadata is not None:\n                flag.flag_metadata = metadata\n\n            flag.updated_at = datetime.now(timezone.utc)\n\n            db.commit()\n            db.refresh(flag)\n\n            # Invalidate cache to force refresh\n            await self._invalidate_cache(name)\n\n            # Publish real-time update to connected clients\n            await self._publish_flag_update(name, flag.to_dict())\n\n            self.logger.info(f\"Updated feature flag: {name}\")\n            return flag\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to update feature flag '{name}': {e}\", exc_info=True)\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def _publish_flag_update(self, flag_name: str, flag_data: Dict[str, Any]) -> None:\n        \"\"\"Publish a flag update to real-time subscribers.\n\n        Imports the publish function lazily to avoid circular imports.\n\n        Args:\n            flag_name: Name of the updated flag\n            flag_data: Complete flag data dictionary\n        \"\"\"\n        try:\n            from app.api.feature_flags_realtime import publish_flag_update\n\n            await publish_flag_update(flag_name, flag_data)\n        except ImportError:\n            # Real-time module not available (e.g., in tests)\n            self.logger.debug(\"Real-time publish not available\")\n        except Exception as e:\n            # Don't fail the update if publish fails\n            self.logger.warning(f\"Failed to publish flag update: {e}\")\n\n    async def delete_flag(self, name: str, db: Session = None) -> bool:\n        \"\"\"Delete a feature flag.\n\n        Args:\n            name: Flag identifier\n            db: Database session\n\n        Returns:\n            True if deleted, False on error\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == name).first()\n\n            if not flag:\n                self.logger.warning(f\"Feature flag not found: {name}\")\n                return False\n\n            db.delete(flag)\n            db.commit()\n\n            # Invalidate cache\n            await self._invalidate_cache(name)\n\n            self.logger.info(f\"Deleted feature flag: {name}\")\n            return True\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to delete feature flag '{name}': {e}\", exc_info=True)\n            return False\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def warm_cache(self, db: Optional[Session] = None) -> int:\n        \"\"\"Warm both L1 and L2 caches with all feature flags on startup.\n\n        This preloads all feature flags into cache to ensure fast access\n        on first use. Should be called during application startup.\n\n        Args:\n            db: Optional database session\n\n        Returns:\n            Number of flags cached\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            # Query all feature flags\n            flags = db.query(FeatureFlag).all()\n\n            # Cache each flag in both L1 and L2\n            for flag in flags:\n                await self._set_cache(flag.name, flag.to_dict())\n\n            self.logger.info(f\"Cache warmed: {len(flags)} feature flags cached\")\n            return len(flags)\n\n        except Exception as e:\n            self.logger.error(f\"Failed to warm cache: {e}\", exc_info=True)\n            return 0\n        finally:\n            if should_close_db:\n                db.close()\n\n    def get_cache_stats(self) -> Dict[str, Any]:\n        \"\"\"Get cache statistics for monitoring.\n\n        Returns:\n            Dictionary with cache hit/miss statistics for all cache levels\n        \"\"\"\n        total_l1_requests = self._cache_stats[\"l1_hits\"] + self._cache_stats[\"l1_misses\"]\n        total_l2_requests = self._cache_stats[\"l2_hits\"] + self._cache_stats[\"l2_misses\"]\n        total_l3_requests = self._cache_stats[\"l3_hits\"] + self._cache_stats[\"l3_misses\"]\n\n        stats = {\n            \"l1_cache\": {\n                \"hits\": self._cache_stats[\"l1_hits\"],\n                \"misses\": self._cache_stats[\"l1_misses\"],\n                \"hit_rate\": ((self._cache_stats[\"l1_hits\"] / total_l1_requests * 100) if total_l1_requests > 0 else 0),\n                \"size\": len(self._local_cache),\n                \"max_size\": LOCAL_CACHE_MAX_SIZE,\n                \"ttl_seconds\": LOCAL_CACHE_TTL,\n            },\n            \"l2_cache\": {\n                \"hits\": self._cache_stats[\"l2_hits\"],\n                \"misses\": self._cache_stats[\"l2_misses\"],\n                \"hit_rate\": ((self._cache_stats[\"l2_hits\"] / total_l2_requests * 100) if total_l2_requests > 0 else 0),\n                \"ttl_seconds\": FEATURE_FLAG_CACHE_TTL,\n            },\n            \"l3_database\": {\n                \"hits\": self._cache_stats[\"l3_hits\"],\n                \"misses\": self._cache_stats[\"l3_misses\"],\n                \"hit_rate\": ((self._cache_stats[\"l3_hits\"] / total_l3_requests * 100) if total_l3_requests > 0 else 0),\n            },\n            \"overall\": {\n                \"total_requests\": total_l1_requests,\n                \"cache_hit_rate\": (\n                    ((self._cache_stats[\"l1_hits\"] + self._cache_stats[\"l2_hits\"]) / total_l1_requests * 100)\n                    if total_l1_requests > 0\n                    else 0\n                ),\n            },\n        }\n\n        return stats\n\n    # =========================================================================\n    # Phase 3.2: Multivariate and Targeting Support\n    # =========================================================================\n\n    async def get_variant_for_user(\n        self,\n        flag_name: str,\n        user_context: Optional[\"UserContext\"] = None,\n        db: Optional[Session] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Get the variant for a user for a multivariate flag.\n\n        Evaluates targeting rules and rollout percentage to determine\n        which variant a user should see.\n\n        Args:\n            flag_name: Name of the feature flag\n            user_context: User context for targeting (optional)\n            db: Optional database session\n\n        Returns:\n            Dictionary with variant info:\n            {\n                \"enabled\": bool,\n                \"variant\": str or None,\n                \"value\": Any,\n                \"reason\": str (\"targeting_rule\", \"rollout\", \"default\", \"disabled\")\n            }\n        \"\"\"\n        from app.services.rule_engine import UserContext, rule_engine\n\n        # Get flag data\n        flag_data = await self._get_flag_data(flag_name, db)\n\n        if not flag_data:\n            return {\n                \"enabled\": False,\n                \"variant\": None,\n                \"value\": None,\n                \"reason\": \"flag_not_found\",\n            }\n\n        # Check if flag is globally disabled\n        if not flag_data.get(\"enabled\", False):\n            return {\n                \"enabled\": False,\n                \"variant\": None,\n                \"value\": flag_data.get(\"default_value\"),\n                \"reason\": \"disabled\",\n            }\n\n        # Check schedule (Phase 3.2)\n        schedule = flag_data.get(\"schedule\")\n        if schedule:\n            if not self._is_schedule_active(schedule):\n                return {\n                    \"enabled\": False,\n                    \"variant\": None,\n                    \"value\": flag_data.get(\"default_value\"),\n                    \"reason\": \"scheduled_inactive\",\n                }\n\n        # Create user context if not provided\n        if user_context is None:\n            user_context = UserContext()\n\n        # Check targeting rules first (Phase 3.2)\n        targeting_rules = flag_data.get(\"targeting_rules\")\n        if targeting_rules:\n            result = rule_engine.evaluate_targeting_rules(\n                targeting_rules,\n                user_context,\n                flag_data.get(\"flag_type\", \"boolean\"),\n            )\n            if result.matched:\n                return {\n                    \"enabled\": result.enabled if result.enabled is not None else True,\n                    \"variant\": result.variant,\n                    \"value\": (\n                        result.value\n                        if result.value is not None\n                        else self._get_variant_value(\n                            flag_data.get(\"variants\", []),\n                            result.variant,\n                        )\n                    ),\n                    \"reason\": \"targeting_rule\",\n                    \"matched_rule\": result.matched_rule_name,\n                }\n\n        # Check rollout percentage\n        rollout_percentage = flag_data.get(\"rollout_percentage\", 100)\n        if rollout_percentage < 100 and user_context.user_id:\n            if not rule_engine.is_in_rollout(\n                user_context.user_id,\n                flag_name,\n                rollout_percentage,\n                flag_data.get(\"rollout_salt\"),\n            ):\n                return {\n                    \"enabled\": False,\n                    \"variant\": None,\n                    \"value\": flag_data.get(\"default_value\"),\n                    \"reason\": \"rollout_excluded\",\n                }\n\n        # For multivariate flags, select a variant\n        variants = flag_data.get(\"variants\", [])\n        if variants and user_context.user_id:\n            selected_variant = rule_engine.select_variant(\n                variants,\n                user_context.user_id,\n                flag_name,\n                flag_data.get(\"rollout_salt\"),\n            )\n            if selected_variant:\n                return {\n                    \"enabled\": True,\n                    \"variant\": selected_variant.id,\n                    \"value\": selected_variant.value,\n                    \"reason\": \"variant_selected\",\n                }\n\n        # Return default\n        return {\n            \"enabled\": True,\n            \"variant\": None,\n            \"value\": flag_data.get(\"value\", flag_data.get(\"default_value\")),\n            \"reason\": \"default\",\n        }\n\n    async def is_enabled_for_user(\n        self,\n        flag_name: str,\n        user_context: Optional[\"UserContext\"] = None,\n        default: bool = False,\n        db: Optional[Session] = None,\n    ) -> bool:\n        \"\"\"Check if a feature flag is enabled for a specific user.\n\n        Takes targeting rules and rollout percentage into account.\n\n        Args:\n            flag_name: Name of the feature flag\n            user_context: User context for targeting\n            default: Default value if flag not found\n            db: Optional database session\n\n        Returns:\n            True if feature is enabled for this user\n        \"\"\"\n        result = await self.get_variant_for_user(flag_name, user_context, db)\n        return result.get(\"enabled\", default)\n\n    async def _get_flag_data(\n        self,\n        flag_name: str,\n        db: Optional[Session] = None,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Get flag data from cache or database.\n\n        Args:\n            flag_name: Name of the feature flag\n            db: Optional database session\n\n        Returns:\n            Flag data dictionary or None\n        \"\"\"\n        # Try L1 cache\n        cached = await self._get_from_local_cache(flag_name)\n        if cached is not None:\n            return cached\n\n        # Try L2 cache\n        cached = await self._get_from_cache(flag_name)\n        if cached is not None:\n            await self._set_local_cache(flag_name, cached)\n            return cached\n\n        # Query database\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            if flag:\n                flag_data = flag.to_dict()\n                await self._set_cache(flag_name, flag_data)\n                return flag_data\n            return None\n        except Exception as e:\n            self.logger.error(f\"Failed to get flag data '{flag_name}': {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    def _get_variant_value(\n        self,\n        variants: List[Dict[str, Any]],\n        variant_id: Optional[str],\n    ) -> Any:\n        \"\"\"Get the value for a specific variant.\n\n        Args:\n            variants: List of variant definitions\n            variant_id: ID of the variant to find\n\n        Returns:\n            Variant value or None\n        \"\"\"\n        if not variants or not variant_id:\n            return None\n        for variant in variants:\n            if variant.get(\"id\") == variant_id:\n                return variant.get(\"value\")\n        return None\n\n    def _is_schedule_active(self, schedule: Dict[str, Any]) -> bool:\n        \"\"\"Check if a schedule is currently active.\n\n        Args:\n            schedule: Schedule configuration\n\n        Returns:\n            True if schedule is currently active\n        \"\"\"\n        if not schedule:\n            return True\n\n        now = datetime.now(timezone.utc)\n\n        start_at = schedule.get(\"start_at\")\n        if start_at:\n            try:\n                start_dt = datetime.fromisoformat(start_at.replace(\"Z\", \"+00:00\"))\n                if now < start_dt:\n                    return False\n            except (ValueError, TypeError):\n                pass\n\n        end_at = schedule.get(\"end_at\")\n        if end_at:\n            try:\n                end_dt = datetime.fromisoformat(end_at.replace(\"Z\", \"+00:00\"))\n                if now > end_dt:\n                    return False\n            except (ValueError, TypeError):\n                pass\n\n        return True\n\n    async def update_flag_variants(\n        self,\n        flag_name: str,\n        variants: List[Dict[str, Any]],\n        db: Optional[Session] = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Update variants for a multivariate flag.\n\n        Args:\n            flag_name: Name of the feature flag\n            variants: List of variant definitions\n            db: Database session\n\n        Returns:\n            Updated FeatureFlag or None\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            if not flag:\n                return None\n\n            flag.variants = variants\n            flag.flag_type = FeatureFlagType.MULTIVARIATE.value\n            flag.updated_at = datetime.now(timezone.utc)\n\n            db.commit()\n            db.refresh(flag)\n\n            await self._invalidate_cache(flag_name)\n            return flag\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to update variants for '{flag_name}': {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def update_flag_targeting_rules(\n        self,\n        flag_name: str,\n        targeting_rules: Dict[str, Any],\n        db: Optional[Session] = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Update targeting rules for a flag.\n\n        Args:\n            flag_name: Name of the feature flag\n            targeting_rules: Targeting rules configuration\n            db: Database session\n\n        Returns:\n            Updated FeatureFlag or None\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            if not flag:\n                return None\n\n            flag.targeting_rules = targeting_rules\n            flag.updated_at = datetime.now(timezone.utc)\n\n            db.commit()\n            db.refresh(flag)\n\n            await self._invalidate_cache(flag_name)\n            return flag\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to update targeting rules for '{flag_name}': {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def update_flag_schedule(\n        self,\n        flag_name: str,\n        schedule: Dict[str, Any],\n        db: Optional[Session] = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Update schedule for a flag.\n\n        Args:\n            flag_name: Name of the feature flag\n            schedule: Schedule configuration\n            db: Database session\n\n        Returns:\n            Updated FeatureFlag or None\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            if not flag:\n                return None\n\n            flag.schedule = schedule\n            flag.updated_at = datetime.now(timezone.utc)\n\n            db.commit()\n            db.refresh(flag)\n\n            await self._invalidate_cache(flag_name)\n            return flag\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to update schedule for '{flag_name}': {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def archive_flag(\n        self,\n        flag_name: str,\n        db: Optional[Session] = None,\n    ) -> Optional[FeatureFlag]:\n        \"\"\"Archive a feature flag (soft delete).\n\n        Args:\n            flag_name: Name of the feature flag\n            db: Database session\n\n        Returns:\n            Archived FeatureFlag or None\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n            if not flag:\n                return None\n\n            flag.archived = True\n            flag.archived_at = datetime.now(timezone.utc)\n            flag.updated_at = datetime.now(timezone.utc)\n\n            db.commit()\n            db.refresh(flag)\n\n            await self._invalidate_cache(flag_name)\n            self.logger.info(f\"Archived feature flag: {flag_name}\")\n            return flag\n        except Exception as e:\n            db.rollback()\n            self.logger.error(f\"Failed to archive flag '{flag_name}': {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def list_flags_by_environment(\n        self,\n        environment: str = \"production\",\n        include_archived: bool = False,\n        db: Optional[Session] = None,\n    ) -> List[FeatureFlag]:\n        \"\"\"List flags for a specific environment.\n\n        Args:\n            environment: Environment name (development, staging, production)\n            include_archived: Whether to include archived flags\n            db: Database session\n\n        Returns:\n            List of FeatureFlag objects\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            query = db.query(FeatureFlag).filter(FeatureFlag.environment == environment)\n            if not include_archived:\n                query = query.filter(FeatureFlag.archived == False)  # noqa: E712\n            return query.order_by(FeatureFlag.name).all()\n        except Exception as e:\n            self.logger.error(f\"Failed to list flags for environment '{environment}': {e}\")\n            return []\n        finally:\n            if should_close_db:\n                db.close()\n\n\n# Global singleton instance\nfeature_flag_service = FeatureFlagService()\n\n\n# Type import for annotations\nif False:  # TYPE_CHECKING\n    from app.services.rule_engine import UserContext\n"
}
