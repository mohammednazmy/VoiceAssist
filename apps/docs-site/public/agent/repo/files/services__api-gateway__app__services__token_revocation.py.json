{
  "path": "services/api-gateway/app/services/token_revocation.py",
  "language": "python",
  "size": 6053,
  "last_modified": "2025-12-04T11:27:00.442Z",
  "lines": 183,
  "content": "\"\"\"\nToken revocation service using Redis for blacklisting JWT tokens.\n\nAllows immediate invalidation of tokens (e.g., on logout or security breach).\n\"\"\"\n\nimport logging\nfrom datetime import timedelta\nfrom typing import Optional\n\nimport redis.asyncio as redis\nfrom app.core.config import settings\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenRevocationService:\n    \"\"\"\n    Service for revoking JWT tokens using Redis as a blacklist.\n\n    Revoked tokens are stored in Redis with TTL equal to token expiry time.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize Redis connection for token revocation.\"\"\"\n        self.redis_client: Optional[redis.Redis] = None\n\n    async def connect(self):\n        \"\"\"Connect to Redis (call during app startup).\"\"\"\n        try:\n            self.redis_client = await redis.from_url(settings.REDIS_URL, encoding=\"utf-8\", decode_responses=True)\n            # Test connection\n            await self.redis_client.ping()\n            logger.info(\"Token revocation service connected to Redis\")\n        except Exception as e:\n            logger.error(f\"Failed to connect to Redis for token revocation: {e}\")\n            # Don't raise - allow app to start even if Redis is unavailable\n            # Token revocation just won't work until Redis is available\n\n    async def disconnect(self):\n        \"\"\"Disconnect from Redis (call during app shutdown).\"\"\"\n        if self.redis_client:\n            await self.redis_client.close()\n            logger.info(\"Token revocation service disconnected from Redis\")\n\n    async def revoke_token(self, token: str, ttl_seconds: int = 900) -> bool:\n        \"\"\"\n        Revoke a token by adding it to the blacklist.\n\n        Args:\n            token: JWT token to revoke\n            ttl_seconds: How long to keep token in blacklist (should match token expiry)\n\n        Returns:\n            True if token was revoked, False if Redis unavailable\n        \"\"\"\n        if not self.redis_client:\n            logger.warning(\"Cannot revoke token - Redis not connected\")\n            return False\n\n        try:\n            # Store token in Redis with TTL\n            key = f\"revoked_token:{token}\"\n            await self.redis_client.setex(name=key, time=timedelta(seconds=ttl_seconds), value=\"1\")\n            logger.info(f\"Token revoked (TTL: {ttl_seconds}s)\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to revoke token: {e}\")\n            return False\n\n    async def is_token_revoked(self, token: str) -> bool:\n        \"\"\"\n        Check if a token has been revoked.\n\n        Args:\n            token: JWT token to check\n\n        Returns:\n            True if token is revoked, False if valid or Redis unavailable\n        \"\"\"\n        if not self.redis_client:\n            # If Redis is down, assume token is valid (fail open)\n            # This prevents Redis downtime from blocking all authenticated requests\n            logger.warning(\"Cannot check token revocation - Redis not connected, assuming valid\")\n            return False\n\n        try:\n            key = f\"revoked_token:{token}\"\n            result = await self.redis_client.exists(key)\n            return result > 0\n\n        except Exception as e:\n            logger.error(f\"Failed to check token revocation: {e}\")\n            # Fail open - assume token is valid if we can't check\n            return False\n\n    async def revoke_all_user_tokens(self, user_id: str, ttl_seconds: int = 900) -> bool:\n        \"\"\"\n        Revoke all tokens for a specific user.\n\n        This is useful when:\n        - User changes password (invalidate all sessions)\n        - Security breach detected\n        - Admin forcibly logs out a user\n\n        Note: This requires tracking active tokens per user, which is more complex.\n        For simplicity, we'll just add a user-level revocation flag.\n\n        Args:\n            user_id: User ID to revoke all tokens for\n            ttl_seconds: How long to keep user revocation flag\n\n        Returns:\n            True if revocation was recorded, False if Redis unavailable\n        \"\"\"\n        if not self.redis_client:\n            logger.warning(\"Cannot revoke user tokens - Redis not connected\")\n            return False\n\n        try:\n            # Store user-level revocation timestamp\n            key = f\"revoked_user:{user_id}\"\n            await self.redis_client.setex(name=key, time=timedelta(seconds=ttl_seconds), value=\"1\")\n            logger.info(f\"All tokens revoked for user {user_id}\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to revoke user tokens: {e}\")\n            return False\n\n    async def is_user_revoked(self, user_id: str) -> bool:\n        \"\"\"\n        Check if all tokens for a user have been revoked.\n\n        Args:\n            user_id: User ID to check\n\n        Returns:\n            True if user's tokens are revoked, False otherwise\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            key = f\"revoked_user:{user_id}\"\n            result = await self.redis_client.exists(key)\n            return result > 0\n\n        except Exception as e:\n            logger.error(f\"Failed to check user revocation: {e}\")\n            return False\n\n    async def get_revoked_token_count(self) -> int:\n        \"\"\"\n        Get count of currently revoked tokens (for monitoring).\n\n        Returns:\n            Number of revoked tokens, or -1 if Redis unavailable\n        \"\"\"\n        if not self.redis_client:\n            return -1\n\n        try:\n            # Count keys matching pattern\n            cursor = 0\n            count = 0\n            while True:\n                cursor, keys = await self.redis_client.scan(cursor=cursor, match=\"revoked_token:*\", count=100)\n                count += len(keys)\n                if cursor == 0:\n                    break\n\n            return count\n\n        except Exception as e:\n            logger.error(f\"Failed to count revoked tokens: {e}\")\n            return -1\n\n\n# Global instance\ntoken_revocation_service = TokenRevocationService()\n"
}
