{
  "path": "services/api-gateway/app/services/voice_fallback_orchestrator.py",
  "language": "python",
  "size": 24925,
  "last_modified": "2025-12-05T03:13:40.181Z",
  "lines": 738,
  "content": "\"\"\"\nVoice Fallback Orchestrator - Graceful Degradation for Voice Pipeline\n\nVoice Mode v4 - Phase 1 Foundation\n\nProvides automatic failover and graceful degradation for voice services:\n- STT fallback chain (Deepgram -> Local Whisper -> Degraded mode)\n- TTS fallback chain (ElevenLabs -> OpenAI -> Browser TTS)\n- LLM fallback chain (GPT-4o -> GPT-4 -> GPT-3.5)\n- Health monitoring and circuit breakers\n- Automatic recovery with exponential backoff\n\nEnsures voice mode remains functional even during provider outages.\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, Generic, List, Optional, Tuple, TypeVar\n\nlogger = logging.getLogger(__name__)\n\n\nclass ServiceType(Enum):\n    \"\"\"Voice service types.\"\"\"\n    STT = \"stt\"  # Speech-to-Text\n    TTS = \"tts\"  # Text-to-Speech\n    LLM = \"llm\"  # Language Model\n    VAD = \"vad\"  # Voice Activity Detection\n    TRANSLATION = \"translation\"\n\n\nclass ServiceHealth(Enum):\n    \"\"\"Service health status.\"\"\"\n    HEALTHY = \"healthy\"\n    DEGRADED = \"degraded\"\n    UNHEALTHY = \"unhealthy\"\n    UNKNOWN = \"unknown\"\n\n\nclass CircuitState(Enum):\n    \"\"\"Circuit breaker state.\"\"\"\n    CLOSED = \"closed\"  # Normal operation\n    OPEN = \"open\"  # Failing, not attempting calls\n    HALF_OPEN = \"half_open\"  # Testing recovery\n\n\n@dataclass\nclass ProviderConfig:\n    \"\"\"Configuration for a voice provider.\"\"\"\n    name: str\n    service_type: ServiceType\n    priority: int  # Lower = higher priority\n    enabled: bool = True\n    timeout_seconds: float = 10.0\n    max_retries: int = 2\n    health_check_interval_seconds: float = 30.0\n\n    # Circuit breaker settings\n    failure_threshold: int = 5\n    recovery_timeout_seconds: float = 60.0\n    half_open_max_calls: int = 3\n\n\n@dataclass\nclass ProviderState:\n    \"\"\"Runtime state for a provider.\"\"\"\n    config: ProviderConfig\n    health: ServiceHealth = ServiceHealth.UNKNOWN\n    circuit_state: CircuitState = CircuitState.CLOSED\n    consecutive_failures: int = 0\n    consecutive_successes: int = 0\n    last_failure_time: Optional[datetime] = None\n    last_success_time: Optional[datetime] = None\n    last_health_check: Optional[datetime] = None\n    total_calls: int = 0\n    total_failures: int = 0\n    avg_latency_ms: float = 0.0\n    half_open_calls: int = 0\n\n\n@dataclass\nclass FallbackResult:\n    \"\"\"Result of a fallback operation.\"\"\"\n    success: bool\n    provider_used: str\n    providers_tried: List[str]\n    result: Any\n    latency_ms: float\n    fallback_activated: bool\n    error: Optional[str] = None\n\n\n@dataclass\nclass OrchestratorConfig:\n    \"\"\"Configuration for the fallback orchestrator.\"\"\"\n    # Health monitoring\n    enable_health_checks: bool = True\n    health_check_interval_seconds: float = 30.0\n\n    # Fallback behavior\n    enable_automatic_fallback: bool = True\n    max_fallback_attempts: int = 3\n\n    # Recovery\n    enable_automatic_recovery: bool = True\n    recovery_check_interval_seconds: float = 60.0\n\n    # Logging\n    log_fallback_events: bool = True\n    log_health_transitions: bool = True\n\n    # Degraded mode\n    enable_degraded_mode: bool = True\n    degraded_mode_timeout_seconds: float = 300.0\n\n\n@dataclass\nclass OrchestratorMetrics:\n    \"\"\"Metrics for the fallback orchestrator.\"\"\"\n    total_requests: int = 0\n    successful_requests: int = 0\n    failed_requests: int = 0\n    fallback_activations: int = 0\n    circuit_opens: int = 0\n    circuit_closes: int = 0\n    recovery_attempts: int = 0\n    successful_recoveries: int = 0\n    provider_switches: int = 0\n    degraded_mode_activations: int = 0\n\n\nT = TypeVar('T')\n\n\nclass VoiceFallbackOrchestrator:\n    \"\"\"\n    Orchestrates fallback behavior across voice services.\n\n    Manages provider health, circuit breakers, and automatic failover\n    to ensure continuous voice operation.\n    \"\"\"\n\n    def __init__(self, config: Optional[OrchestratorConfig] = None):\n        self.config = config or OrchestratorConfig()\n        self._initialized = False\n        self._metrics = OrchestratorMetrics()\n\n        # Provider registry\n        self._providers: Dict[ServiceType, List[ProviderState]] = {\n            service_type: [] for service_type in ServiceType\n        }\n\n        # Provider handlers\n        self._handlers: Dict[str, Callable] = {}\n\n        # Health check task\n        self._health_check_task: Optional[asyncio.Task] = None\n\n        # Recovery task\n        self._recovery_task: Optional[asyncio.Task] = None\n\n        # Callbacks\n        self._on_fallback: Optional[Callable[[str, str, str], None]] = None\n        self._on_health_change: Optional[Callable[[str, ServiceHealth, ServiceHealth], None]] = None\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize the orchestrator.\"\"\"\n        if self._initialized:\n            return\n\n        logger.info(\"Initializing VoiceFallbackOrchestrator\")\n\n        # Register default providers\n        await self._register_default_providers()\n\n        # Start health checks\n        if self.config.enable_health_checks:\n            self._health_check_task = asyncio.create_task(\n                self._health_check_loop()\n            )\n\n        # Start recovery checks\n        if self.config.enable_automatic_recovery:\n            self._recovery_task = asyncio.create_task(\n                self._recovery_check_loop()\n            )\n\n        self._initialized = True\n\n    async def _register_default_providers(self) -> None:\n        \"\"\"Register default voice providers.\"\"\"\n        # STT providers\n        self.register_provider(ProviderConfig(\n            name=\"deepgram\",\n            service_type=ServiceType.STT,\n            priority=1,\n            timeout_seconds=10.0,\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"whisper_local\",\n            service_type=ServiceType.STT,\n            priority=2,\n            timeout_seconds=30.0,  # Local can be slower\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"browser_stt\",\n            service_type=ServiceType.STT,\n            priority=3,\n            enabled=True,  # Last resort\n        ))\n\n        # TTS providers\n        self.register_provider(ProviderConfig(\n            name=\"elevenlabs\",\n            service_type=ServiceType.TTS,\n            priority=1,\n            timeout_seconds=15.0,\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"openai_tts\",\n            service_type=ServiceType.TTS,\n            priority=2,\n            timeout_seconds=10.0,\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"browser_tts\",\n            service_type=ServiceType.TTS,\n            priority=3,\n            enabled=True,  # Last resort\n        ))\n\n        # LLM providers\n        self.register_provider(ProviderConfig(\n            name=\"gpt-4o\",\n            service_type=ServiceType.LLM,\n            priority=1,\n            timeout_seconds=30.0,\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"gpt-4\",\n            service_type=ServiceType.LLM,\n            priority=2,\n            timeout_seconds=45.0,\n        ))\n        self.register_provider(ProviderConfig(\n            name=\"gpt-3.5-turbo\",\n            service_type=ServiceType.LLM,\n            priority=3,\n            timeout_seconds=20.0,\n        ))\n\n    def register_provider(self, config: ProviderConfig) -> None:\n        \"\"\"Register a new provider.\"\"\"\n        state = ProviderState(config=config)\n        self._providers[config.service_type].append(state)\n\n        # Sort by priority\n        self._providers[config.service_type].sort(\n            key=lambda p: p.config.priority\n        )\n\n        logger.debug(\n            f\"Registered provider {config.name} for {config.service_type.value}\"\n        )\n\n    def register_handler(\n        self,\n        provider_name: str,\n        handler: Callable[..., Any]\n    ) -> None:\n        \"\"\"\n        Register a handler function for a provider.\n\n        Args:\n            provider_name: Name of the provider\n            handler: Async callable that handles requests\n        \"\"\"\n        self._handlers[provider_name] = handler\n\n    async def execute_with_fallback(\n        self,\n        service_type: ServiceType,\n        *args,\n        preferred_provider: Optional[str] = None,\n        **kwargs\n    ) -> FallbackResult:\n        \"\"\"\n        Execute a service call with automatic fallback.\n\n        Args:\n            service_type: Type of service to call\n            *args: Arguments to pass to handler\n            preferred_provider: Optional preferred provider name\n            **kwargs: Keyword arguments to pass to handler\n\n        Returns:\n            FallbackResult with operation outcome\n        \"\"\"\n        if not self._initialized:\n            await self.initialize()\n\n        start_time = time.time()\n        self._metrics.total_requests += 1\n        providers_tried = []\n        fallback_activated = False\n\n        # Get available providers\n        available = self._get_available_providers(\n            service_type, preferred_provider\n        )\n\n        if not available:\n            self._metrics.failed_requests += 1\n            return FallbackResult(\n                success=False,\n                provider_used=\"none\",\n                providers_tried=[],\n                result=None,\n                latency_ms=0,\n                fallback_activated=False,\n                error=\"No available providers\"\n            )\n\n        for provider_state in available:\n            provider_name = provider_state.config.name\n            providers_tried.append(provider_name)\n\n            # Check circuit breaker\n            if not self._can_call_provider(provider_state):\n                logger.debug(f\"Circuit open for {provider_name}, skipping\")\n                continue\n\n            try:\n                # Get handler\n                handler = self._handlers.get(provider_name)\n                if not handler:\n                    logger.warning(f\"No handler registered for {provider_name}\")\n                    continue\n\n                # Execute with timeout\n                timeout = provider_state.config.timeout_seconds\n                result = await asyncio.wait_for(\n                    handler(*args, **kwargs),\n                    timeout=timeout\n                )\n\n                # Success\n                self._record_success(provider_state)\n                latency_ms = (time.time() - start_time) * 1000\n\n                self._metrics.successful_requests += 1\n                if fallback_activated:\n                    self._metrics.fallback_activations += 1\n\n                return FallbackResult(\n                    success=True,\n                    provider_used=provider_name,\n                    providers_tried=providers_tried,\n                    result=result,\n                    latency_ms=latency_ms,\n                    fallback_activated=fallback_activated,\n                )\n\n            except asyncio.TimeoutError:\n                logger.warning(f\"Timeout calling {provider_name}\")\n                self._record_failure(provider_state, \"timeout\")\n                fallback_activated = True\n\n            except Exception as e:\n                logger.warning(f\"Error calling {provider_name}: {e}\")\n                self._record_failure(provider_state, str(e))\n                fallback_activated = True\n\n        # All providers failed\n        self._metrics.failed_requests += 1\n        latency_ms = (time.time() - start_time) * 1000\n\n        return FallbackResult(\n            success=False,\n            provider_used=\"none\",\n            providers_tried=providers_tried,\n            result=None,\n            latency_ms=latency_ms,\n            fallback_activated=True,\n            error=\"All providers failed\"\n        )\n\n    def _get_available_providers(\n        self,\n        service_type: ServiceType,\n        preferred: Optional[str] = None\n    ) -> List[ProviderState]:\n        \"\"\"Get available providers for a service type.\"\"\"\n        providers = self._providers.get(service_type, [])\n\n        # Filter enabled providers\n        available = [\n            p for p in providers\n            if p.config.enabled\n        ]\n\n        # Reorder if preferred provider specified\n        if preferred:\n            preferred_state = None\n            others = []\n            for p in available:\n                if p.config.name == preferred:\n                    preferred_state = p\n                else:\n                    others.append(p)\n            if preferred_state:\n                return [preferred_state] + others\n\n        return available\n\n    def _can_call_provider(self, provider_state: ProviderState) -> bool:\n        \"\"\"Check if a provider can be called (circuit breaker logic).\"\"\"\n        state = provider_state.circuit_state\n\n        if state == CircuitState.CLOSED:\n            return True\n\n        if state == CircuitState.OPEN:\n            # Check if recovery timeout has passed\n            if provider_state.last_failure_time:\n                elapsed = (datetime.now(timezone.utc) - provider_state.last_failure_time).total_seconds()\n                if elapsed >= provider_state.config.recovery_timeout_seconds:\n                    # Transition to half-open\n                    self._set_circuit_state(provider_state, CircuitState.HALF_OPEN)\n                    return True\n            return False\n\n        if state == CircuitState.HALF_OPEN:\n            # Allow limited calls in half-open state\n            if provider_state.half_open_calls < provider_state.config.half_open_max_calls:\n                provider_state.half_open_calls += 1\n                return True\n            return False\n\n        return False\n\n    def _record_success(self, provider_state: ProviderState) -> None:\n        \"\"\"Record a successful call.\"\"\"\n        provider_state.consecutive_successes += 1\n        provider_state.consecutive_failures = 0\n        provider_state.total_calls += 1\n        provider_state.last_success_time = datetime.now(timezone.utc)\n\n        # Update circuit state\n        if provider_state.circuit_state == CircuitState.HALF_OPEN:\n            if provider_state.consecutive_successes >= provider_state.config.half_open_max_calls:\n                self._set_circuit_state(provider_state, CircuitState.CLOSED)\n                provider_state.half_open_calls = 0\n                self._metrics.circuit_closes += 1\n                self._metrics.successful_recoveries += 1\n\n    def _record_failure(\n        self,\n        provider_state: ProviderState,\n        error: str\n    ) -> None:\n        \"\"\"Record a failed call.\"\"\"\n        provider_state.consecutive_failures += 1\n        provider_state.consecutive_successes = 0\n        provider_state.total_calls += 1\n        provider_state.total_failures += 1\n        provider_state.last_failure_time = datetime.now(timezone.utc)\n\n        # Check if circuit should open\n        if provider_state.circuit_state == CircuitState.CLOSED:\n            if provider_state.consecutive_failures >= provider_state.config.failure_threshold:\n                self._set_circuit_state(provider_state, CircuitState.OPEN)\n                self._metrics.circuit_opens += 1\n                logger.warning(\n                    f\"Circuit opened for {provider_state.config.name} \"\n                    f\"after {provider_state.consecutive_failures} failures\"\n                )\n\n        elif provider_state.circuit_state == CircuitState.HALF_OPEN:\n            # Failed during recovery, reopen circuit\n            self._set_circuit_state(provider_state, CircuitState.OPEN)\n            provider_state.half_open_calls = 0\n\n    def _set_circuit_state(\n        self,\n        provider_state: ProviderState,\n        new_state: CircuitState\n    ) -> None:\n        \"\"\"Set circuit state with logging and callbacks.\"\"\"\n        old_state = provider_state.circuit_state\n        provider_state.circuit_state = new_state\n\n        if self.config.log_health_transitions:\n            logger.info(\n                f\"Circuit state change for {provider_state.config.name}: \"\n                f\"{old_state.value} -> {new_state.value}\"\n            )\n\n    def _update_health(\n        self,\n        provider_state: ProviderState,\n        new_health: ServiceHealth\n    ) -> None:\n        \"\"\"Update provider health with callbacks.\"\"\"\n        old_health = provider_state.health\n        provider_state.health = new_health\n        provider_state.last_health_check = datetime.now(timezone.utc)\n\n        if old_health != new_health:\n            if self.config.log_health_transitions:\n                logger.info(\n                    f\"Health change for {provider_state.config.name}: \"\n                    f\"{old_health.value} -> {new_health.value}\"\n                )\n\n            if self._on_health_change:\n                self._on_health_change(\n                    provider_state.config.name,\n                    old_health,\n                    new_health\n                )\n\n    async def _health_check_loop(self) -> None:\n        \"\"\"Background task for health checking.\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(self.config.health_check_interval_seconds)\n\n                for service_type in ServiceType:\n                    for provider_state in self._providers.get(service_type, []):\n                        await self._check_provider_health(provider_state)\n\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Health check error: {e}\")\n\n    async def _check_provider_health(\n        self,\n        provider_state: ProviderState\n    ) -> None:\n        \"\"\"Check health of a single provider.\"\"\"\n        # Determine health based on circuit state and recent failures\n        if provider_state.circuit_state == CircuitState.OPEN:\n            self._update_health(provider_state, ServiceHealth.UNHEALTHY)\n        elif provider_state.circuit_state == CircuitState.HALF_OPEN:\n            self._update_health(provider_state, ServiceHealth.DEGRADED)\n        else:\n            # Check failure rate\n            if provider_state.total_calls > 0:\n                failure_rate = provider_state.total_failures / provider_state.total_calls\n                if failure_rate > 0.5:\n                    self._update_health(provider_state, ServiceHealth.DEGRADED)\n                elif failure_rate > 0.1:\n                    self._update_health(provider_state, ServiceHealth.DEGRADED)\n                else:\n                    self._update_health(provider_state, ServiceHealth.HEALTHY)\n            else:\n                self._update_health(provider_state, ServiceHealth.UNKNOWN)\n\n    async def _recovery_check_loop(self) -> None:\n        \"\"\"Background task for recovery attempts.\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(self.config.recovery_check_interval_seconds)\n\n                for service_type in ServiceType:\n                    for provider_state in self._providers.get(service_type, []):\n                        if provider_state.circuit_state == CircuitState.OPEN:\n                            # Check if ready for recovery attempt\n                            if provider_state.last_failure_time:\n                                elapsed = (\n                                    datetime.now(timezone.utc) -\n                                    provider_state.last_failure_time\n                                ).total_seconds()\n\n                                if elapsed >= provider_state.config.recovery_timeout_seconds:\n                                    self._set_circuit_state(\n                                        provider_state,\n                                        CircuitState.HALF_OPEN\n                                    )\n                                    self._metrics.recovery_attempts += 1\n\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Recovery check error: {e}\")\n\n    def get_provider_status(\n        self,\n        service_type: Optional[ServiceType] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Get status of all providers or providers of a specific type.\"\"\"\n        status = {}\n\n        service_types = [service_type] if service_type else list(ServiceType)\n\n        for svc_type in service_types:\n            providers = self._providers.get(svc_type, [])\n            status[svc_type.value] = [\n                {\n                    \"name\": p.config.name,\n                    \"priority\": p.config.priority,\n                    \"enabled\": p.config.enabled,\n                    \"health\": p.health.value,\n                    \"circuit_state\": p.circuit_state.value,\n                    \"consecutive_failures\": p.consecutive_failures,\n                    \"total_calls\": p.total_calls,\n                    \"failure_rate\": p.total_failures / p.total_calls if p.total_calls > 0 else 0,\n                    \"avg_latency_ms\": p.avg_latency_ms,\n                    \"last_success\": p.last_success_time.isoformat() if p.last_success_time else None,\n                    \"last_failure\": p.last_failure_time.isoformat() if p.last_failure_time else None,\n                }\n                for p in providers\n            ]\n\n        return status\n\n    def get_healthy_providers(\n        self,\n        service_type: ServiceType\n    ) -> List[str]:\n        \"\"\"Get list of healthy provider names for a service type.\"\"\"\n        providers = self._providers.get(service_type, [])\n        return [\n            p.config.name\n            for p in providers\n            if p.health in [ServiceHealth.HEALTHY, ServiceHealth.UNKNOWN]\n            and p.circuit_state == CircuitState.CLOSED\n            and p.config.enabled\n        ]\n\n    def set_provider_enabled(\n        self,\n        provider_name: str,\n        enabled: bool\n    ) -> bool:\n        \"\"\"Enable or disable a provider.\"\"\"\n        for providers in self._providers.values():\n            for p in providers:\n                if p.config.name == provider_name:\n                    p.config.enabled = enabled\n                    logger.info(\n                        f\"Provider {provider_name} \"\n                        f\"{'enabled' if enabled else 'disabled'}\"\n                    )\n                    return True\n        return False\n\n    def reset_circuit(self, provider_name: str) -> bool:\n        \"\"\"Manually reset a provider's circuit breaker.\"\"\"\n        for providers in self._providers.values():\n            for p in providers:\n                if p.config.name == provider_name:\n                    p.circuit_state = CircuitState.CLOSED\n                    p.consecutive_failures = 0\n                    p.half_open_calls = 0\n                    logger.info(f\"Circuit reset for {provider_name}\")\n                    return True\n        return False\n\n    def on_fallback(\n        self,\n        callback: Callable[[str, str, str], None]\n    ) -> None:\n        \"\"\"Register callback for fallback events (from, to, reason).\"\"\"\n        self._on_fallback = callback\n\n    def on_health_change(\n        self,\n        callback: Callable[[str, ServiceHealth, ServiceHealth], None]\n    ) -> None:\n        \"\"\"Register callback for health change events.\"\"\"\n        self._on_health_change = callback\n\n    def get_metrics(self) -> OrchestratorMetrics:\n        \"\"\"Get orchestrator metrics.\"\"\"\n        return self._metrics\n\n    def reset_metrics(self) -> None:\n        \"\"\"Reset orchestrator metrics.\"\"\"\n        self._metrics = OrchestratorMetrics()\n\n    async def cleanup(self) -> None:\n        \"\"\"Clean up background tasks.\"\"\"\n        if self._health_check_task:\n            self._health_check_task.cancel()\n            try:\n                await self._health_check_task\n            except asyncio.CancelledError:\n                pass\n\n        if self._recovery_task:\n            self._recovery_task.cancel()\n            try:\n                await self._recovery_task\n            except asyncio.CancelledError:\n                pass\n\n        self._initialized = False\n\n\n# Singleton instance\n_fallback_orchestrator: Optional[VoiceFallbackOrchestrator] = None\n\n\ndef get_voice_fallback_orchestrator() -> VoiceFallbackOrchestrator:\n    \"\"\"Get or create the singleton VoiceFallbackOrchestrator instance.\"\"\"\n    global _fallback_orchestrator\n    if _fallback_orchestrator is None:\n        _fallback_orchestrator = VoiceFallbackOrchestrator()\n    return _fallback_orchestrator\n\n\nasync def execute_with_fallback(\n    service_type: ServiceType,\n    *args,\n    **kwargs\n) -> FallbackResult:\n    \"\"\"\n    Convenience function for executing with fallback.\n\n    Args:\n        service_type: Type of service to call\n        *args: Arguments to pass to handler\n        **kwargs: Keyword arguments to pass to handler\n\n    Returns:\n        FallbackResult with operation outcome\n    \"\"\"\n    orchestrator = get_voice_fallback_orchestrator()\n    await orchestrator.initialize()\n    return await orchestrator.execute_with_fallback(service_type, *args, **kwargs)\n"
}
