{
  "path": "services/api-gateway/app/api/auth_oauth.py",
  "language": "python",
  "size": 11505,
  "last_modified": "2025-12-04T11:26:46.808Z",
  "lines": 351,
  "content": "\"\"\"\nOAuth authentication endpoints for Google and Microsoft login\n\"\"\"\n\nimport secrets\nfrom datetime import datetime, timezone\nfrom typing import Literal\nfrom urllib.parse import urlencode\n\nimport httpx\nfrom app.core.api_envelope import success_response\nfrom app.core.business_metrics import user_logins_total, user_registrations_total\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.core.logging import get_logger\nfrom app.core.security import create_access_token, create_refresh_token\nfrom app.models.user import User\nfrom app.schemas.auth import TokenResponse\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\nfrom sqlalchemy.orm import Session\n\nlogger = get_logger(__name__)\nrouter = APIRouter(prefix=\"/api/auth/oauth\", tags=[\"authentication\", \"oauth\"])\nlimiter = Limiter(key_func=get_remote_address)\n\n# OAuth provider configurations\nOAUTH_PROVIDERS = {\n    \"google\": {\n        \"authorize_url\": \"https://accounts.google.com/o/oauth2/v2/auth\",\n        \"token_url\": \"https://oauth2.googleapis.com/token\",\n        \"userinfo_url\": \"https://www.googleapis.com/oauth2/v2/userinfo\",\n        \"scopes\": [\"openid\", \"email\", \"profile\"],\n    },\n    \"microsoft\": {\n        \"authorize_url\": \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\",\n        \"token_url\": \"https://login.microsoftonline.com/common/oauth2/v2.0/token\",\n        \"userinfo_url\": \"https://graph.microsoft.com/v1.0/me\",\n        \"scopes\": [\"openid\", \"email\", \"profile\", \"User.Read\"],\n    },\n}\n\n\ndef get_oauth_config(provider: str) -> dict | None:\n    \"\"\"Get OAuth configuration for a provider if configured\"\"\"\n    if provider == \"google\":\n        if settings.GOOGLE_CLIENT_ID and settings.GOOGLE_CLIENT_SECRET:\n            return {\n                \"client_id\": settings.GOOGLE_CLIENT_ID,\n                \"client_secret\": settings.GOOGLE_CLIENT_SECRET,\n                \"redirect_uri\": settings.GOOGLE_OAUTH_REDIRECT_URI\n                or f\"{settings.ALLOWED_ORIGINS.split(',')[0]}/auth/callback/google\",\n            }\n    elif provider == \"microsoft\":\n        if settings.MICROSOFT_CLIENT_ID and settings.MICROSOFT_CLIENT_SECRET:\n            return {\n                \"client_id\": settings.MICROSOFT_CLIENT_ID,\n                \"client_secret\": settings.MICROSOFT_CLIENT_SECRET,\n                \"redirect_uri\": settings.MICROSOFT_OAUTH_REDIRECT_URI\n                or f\"{settings.ALLOWED_ORIGINS.split(',')[0]}/auth/callback/microsoft\",\n            }\n    return None\n\n\n@router.get(\"/{provider}/authorize\")\n@limiter.limit(\"30/minute\")\nasync def oauth_authorize(\n    request: Request,\n    provider: Literal[\"google\", \"microsoft\"],\n):\n    \"\"\"\n    Get OAuth authorization URL for the specified provider\n\n    Returns a URL that the frontend should redirect to for OAuth login.\n\n    - **provider**: \"google\" or \"microsoft\"\n\n    Returns: { data: { url: string } }\n\n    Rate limit: 30 requests per minute per IP\n    \"\"\"\n    if provider not in OAUTH_PROVIDERS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Unknown OAuth provider: {provider}\",\n        )\n\n    config = get_oauth_config(provider)\n    if not config:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=f\"{provider.title()} OAuth is not configured. Please contact the administrator.\",\n        )\n\n    provider_config = OAUTH_PROVIDERS[provider]\n\n    # Generate state parameter for CSRF protection\n    state = secrets.token_urlsafe(32)\n\n    # Build authorization URL\n    params = {\n        \"client_id\": config[\"client_id\"],\n        \"redirect_uri\": config[\"redirect_uri\"],\n        \"response_type\": \"code\",\n        \"scope\": \" \".join(provider_config[\"scopes\"]),\n        \"state\": state,\n    }\n\n    # Provider-specific parameters\n    if provider == \"google\":\n        params[\"access_type\"] = \"online\"\n        params[\"include_granted_scopes\"] = \"true\"\n        params[\"prompt\"] = \"select_account\"\n    elif provider == \"microsoft\":\n        params[\"response_mode\"] = \"query\"\n        params[\"prompt\"] = \"select_account\"\n\n    auth_url = f\"{provider_config['authorize_url']}?{urlencode(params)}\"\n\n    logger.info(\n        \"oauth_authorize_url_generated\",\n        provider=provider,\n        redirect_uri=config[\"redirect_uri\"],\n    )\n\n    return success_response({\"url\": auth_url, \"state\": state})\n\n\n@router.post(\"/{provider}/callback\")\n@limiter.limit(\"10/minute\")\nasync def oauth_callback(\n    request: Request,\n    provider: Literal[\"google\", \"microsoft\"],\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Handle OAuth callback and exchange code for tokens\n\n    - **provider**: \"google\" or \"microsoft\"\n    - **code**: Authorization code from OAuth provider (in request body)\n\n    Returns JWT tokens for the authenticated user.\n\n    Rate limit: 10 requests per minute per IP\n    \"\"\"\n    body = await request.json()\n    code = body.get(\"code\")\n\n    if not code:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Missing authorization code\",\n        )\n\n    if provider not in OAUTH_PROVIDERS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Unknown OAuth provider: {provider}\",\n        )\n\n    config = get_oauth_config(provider)\n    if not config:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=f\"{provider.title()} OAuth is not configured\",\n        )\n\n    provider_config = OAUTH_PROVIDERS[provider]\n\n    # Exchange authorization code for access token\n    async with httpx.AsyncClient() as client:\n        token_data = {\n            \"client_id\": config[\"client_id\"],\n            \"client_secret\": config[\"client_secret\"],\n            \"code\": code,\n            \"redirect_uri\": config[\"redirect_uri\"],\n            \"grant_type\": \"authorization_code\",\n        }\n\n        try:\n            token_response = await client.post(\n                provider_config[\"token_url\"],\n                data=token_data,\n                headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n                timeout=10.0,\n            )\n            token_response.raise_for_status()\n            tokens = token_response.json()\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                \"oauth_token_exchange_failed\",\n                provider=provider,\n                status_code=e.response.status_code,\n                response=e.response.text[:500],\n            )\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Failed to exchange authorization code for tokens\",\n            )\n        except httpx.RequestError as e:\n            logger.error(\n                \"oauth_token_exchange_error\",\n                provider=provider,\n                error=str(e),\n            )\n            raise HTTPException(\n                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                detail=\"OAuth provider is temporarily unavailable\",\n            )\n\n        # Fetch user info from provider\n        access_token = tokens.get(\"access_token\")\n        if not access_token:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"No access token received from OAuth provider\",\n            )\n\n        try:\n            userinfo_response = await client.get(\n                provider_config[\"userinfo_url\"],\n                headers={\"Authorization\": f\"Bearer {access_token}\"},\n                timeout=10.0,\n            )\n            userinfo_response.raise_for_status()\n            userinfo = userinfo_response.json()\n        except httpx.HTTPError as e:\n            logger.error(\n                \"oauth_userinfo_fetch_failed\",\n                provider=provider,\n                error=str(e),\n            )\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Failed to fetch user information from OAuth provider\",\n            )\n\n    # Extract user info based on provider\n    if provider == \"google\":\n        email = userinfo.get(\"email\")\n        full_name = userinfo.get(\"name\") or email.split(\"@\")[0]\n        provider_user_id = userinfo.get(\"id\")\n    elif provider == \"microsoft\":\n        email = userinfo.get(\"mail\") or userinfo.get(\"userPrincipalName\")\n        full_name = userinfo.get(\"displayName\") or email.split(\"@\")[0]\n        provider_user_id = userinfo.get(\"id\")\n    else:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Unknown OAuth provider\",\n        )\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email not available from OAuth provider. Please ensure email permissions are granted.\",\n        )\n\n    # Find or create user\n    user = (\n        db.query(User)\n        .filter(\n            (User.email == email) | ((User.oauth_provider == provider) & (User.oauth_provider_id == provider_user_id))\n        )\n        .first()\n    )\n\n    is_new_user = False\n    if not user:\n        # Create new user from OAuth\n        user = User(\n            email=email,\n            full_name=full_name,\n            hashed_password=None,  # No password for OAuth users\n            is_active=True,\n            is_admin=False,\n            admin_role=\"user\",\n            oauth_provider=provider,\n            oauth_provider_id=provider_user_id,\n        )\n        db.add(user)\n        is_new_user = True\n        logger.info(\n            \"oauth_user_created\",\n            provider=provider,\n            email=email,\n        )\n        user_registrations_total.inc()\n    else:\n        # Update OAuth info if not set (linking existing account)\n        if not user.oauth_provider:\n            user.oauth_provider = provider\n            user.oauth_provider_id = provider_user_id\n            logger.info(\n                \"oauth_account_linked\",\n                provider=provider,\n                email=email,\n            )\n\n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User account is inactive\",\n        )\n\n    # Update last login\n    user.last_login = datetime.now(timezone.utc)\n    db.commit()\n    db.refresh(user)\n\n    # Track login metric\n    user_logins_total.inc()\n\n    # Create JWT tokens\n    jwt_access_token = create_access_token(data={\"sub\": str(user.id), \"email\": user.email})\n    jwt_refresh_token = create_refresh_token(data={\"sub\": str(user.id)})\n\n    logger.info(\n        \"oauth_login_success\",\n        provider=provider,\n        email=email,\n        is_new_user=is_new_user,\n    )\n\n    return TokenResponse(\n        access_token=jwt_access_token,\n        refresh_token=jwt_refresh_token,\n        token_type=\"bearer\",\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n    )\n\n\n@router.get(\"/{provider}/status\")\nasync def oauth_provider_status(provider: Literal[\"google\", \"microsoft\"]):\n    \"\"\"\n    Check if an OAuth provider is configured\n\n    Returns whether the specified provider is available for login.\n\n    - **provider**: \"google\" or \"microsoft\"\n    \"\"\"\n    config = get_oauth_config(provider)\n    return success_response(\n        {\n            \"provider\": provider,\n            \"configured\": config is not None,\n            \"enabled\": config is not None,\n        }\n    )\n"
}
