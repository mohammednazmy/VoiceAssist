{
  "path": "services/api-gateway/app/services/tools/analytics_service.py",
  "language": "python",
  "size": 16478,
  "last_modified": "2025-12-05T03:07:13.135Z",
  "lines": 482,
  "content": "\"\"\"\nTool Analytics Service\n\nProvides analytics and insights on tool/function call usage across\nVoice and Chat modes.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, List, Optional\n\nfrom sqlalchemy import text\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\n\nclass ToolAnalyticsService:\n    \"\"\"\n    Service for analyzing tool invocation logs.\n\n    Provides metrics on:\n    - Tool usage counts and trends\n    - Success/failure rates\n    - Latency statistics\n    - User/session breakdowns\n    - Mode comparisons (voice vs chat)\n    \"\"\"\n\n    async def get_tool_usage_summary(\n        self,\n        db_session: AsyncSession,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n        user_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get summary statistics for tool usage.\n\n        Args:\n            db_session: Database session\n            start_date: Optional start date filter\n            end_date: Optional end date filter\n            user_id: Optional user ID filter\n\n        Returns:\n            Dict with summary statistics\n        \"\"\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        # Build query with filters\n        filters = [\"created_at >= :start_date\", \"created_at <= :end_date\"]\n        params = {\"start_date\": start_date, \"end_date\": end_date}\n\n        if user_id:\n            filters.append(\"user_id = :user_id\")\n            params[\"user_id\"] = user_id\n\n        where_clause = \" AND \".join(filters)\n\n        # Get overall statistics\n        # nosec B608 - where_clause is built from hardcoded filter strings, all values are parameterized\n        stats_query = f\"\"\"\n            SELECT\n                COUNT(*) as total_calls,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_calls,\n                COUNT(CASE WHEN status = 'error' THEN 1 END) as failed_calls,\n                AVG(duration_ms) as avg_duration_ms,\n                MIN(duration_ms) as min_duration_ms,\n                MAX(duration_ms) as max_duration_ms,\n                PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_ms) as median_duration_ms,\n                PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms) as p95_duration_ms,\n                COUNT(DISTINCT user_id) as unique_users,\n                COUNT(DISTINCT session_id) as unique_sessions\n            FROM tool_invocation_logs\n            WHERE {where_clause}\n        \"\"\"\n\n        result = await db_session.execute(text(stats_query), params)\n        row = result.fetchone()\n\n        if not row:\n            return {\n                \"total_calls\": 0,\n                \"successful_calls\": 0,\n                \"failed_calls\": 0,\n                \"success_rate\": 0.0,\n                \"avg_duration_ms\": 0,\n                \"median_duration_ms\": 0,\n                \"p95_duration_ms\": 0,\n                \"unique_users\": 0,\n                \"unique_sessions\": 0,\n            }\n\n        total = row.total_calls or 0\n        successful = row.successful_calls or 0\n\n        return {\n            \"total_calls\": total,\n            \"successful_calls\": successful,\n            \"failed_calls\": row.failed_calls or 0,\n            \"success_rate\": (successful / total * 100) if total > 0 else 0.0,\n            \"avg_duration_ms\": round(row.avg_duration_ms or 0, 2),\n            \"min_duration_ms\": row.min_duration_ms or 0,\n            \"max_duration_ms\": row.max_duration_ms or 0,\n            \"median_duration_ms\": round(row.median_duration_ms or 0, 2),\n            \"p95_duration_ms\": round(row.p95_duration_ms or 0, 2),\n            \"unique_users\": row.unique_users or 0,\n            \"unique_sessions\": row.unique_sessions or 0,\n            \"date_range\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat(),\n            },\n        }\n\n    async def get_tool_breakdown(\n        self,\n        db_session: AsyncSession,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get usage breakdown by tool name.\n\n        Returns list of tools with their usage stats sorted by call count.\n        \"\"\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        query = \"\"\"\n            SELECT\n                tool_name,\n                COUNT(*) as call_count,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as success_count,\n                COUNT(CASE WHEN status = 'error' THEN 1 END) as error_count,\n                AVG(duration_ms) as avg_duration_ms,\n                COUNT(DISTINCT user_id) as unique_users\n            FROM tool_invocation_logs\n            WHERE created_at >= :start_date AND created_at <= :end_date\n            GROUP BY tool_name\n            ORDER BY call_count DESC\n        \"\"\"\n\n        result = await db_session.execute(\n            text(query),\n            {\"start_date\": start_date, \"end_date\": end_date},\n        )\n        rows = result.fetchall()\n\n        return [\n            {\n                \"tool_name\": row.tool_name,\n                \"call_count\": row.call_count,\n                \"success_count\": row.success_count,\n                \"error_count\": row.error_count,\n                \"success_rate\": round(\n                    ((row.success_count / row.call_count * 100) if row.call_count > 0 else 0),\n                    2,\n                ),\n                \"avg_duration_ms\": round(row.avg_duration_ms or 0, 2),\n                \"unique_users\": row.unique_users,\n            }\n            for row in rows\n        ]\n\n    async def get_mode_comparison(\n        self,\n        db_session: AsyncSession,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Compare tool usage between voice and chat modes.\n        \"\"\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        query = \"\"\"\n            SELECT\n                mode,\n                COUNT(*) as call_count,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as success_count,\n                AVG(duration_ms) as avg_duration_ms,\n                COUNT(DISTINCT user_id) as unique_users\n            FROM tool_invocation_logs\n            WHERE created_at >= :start_date AND created_at <= :end_date\n            GROUP BY mode\n        \"\"\"\n\n        result = await db_session.execute(\n            text(query),\n            {\"start_date\": start_date, \"end_date\": end_date},\n        )\n        rows = result.fetchall()\n\n        comparison = {}\n        for row in rows:\n            mode = row.mode or \"unknown\"\n            comparison[mode] = {\n                \"call_count\": row.call_count,\n                \"success_count\": row.success_count,\n                \"success_rate\": round(\n                    ((row.success_count / row.call_count * 100) if row.call_count > 0 else 0),\n                    2,\n                ),\n                \"avg_duration_ms\": round(row.avg_duration_ms or 0, 2),\n                \"unique_users\": row.unique_users,\n            }\n\n        return comparison\n\n    async def get_daily_trend(\n        self,\n        db_session: AsyncSession,\n        days: int = 30,\n        tool_name: Optional[str] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get daily tool usage trend.\n\n        Args:\n            db_session: Database session\n            days: Number of days to look back\n            tool_name: Optional filter for specific tool\n\n        Returns:\n            List of daily usage data points\n        \"\"\"\n        start_date = datetime.utcnow() - timedelta(days=days)\n\n        filters = [\"created_at >= :start_date\"]\n        params = {\"start_date\": start_date}\n\n        if tool_name:\n            filters.append(\"tool_name = :tool_name\")\n            params[\"tool_name\"] = tool_name\n\n        where_clause = \" AND \".join(filters)\n\n        # nosec B608 - where_clause is built from hardcoded filter strings, all values are parameterized\n        query = f\"\"\"\n            SELECT\n                DATE(created_at) as date,\n                COUNT(*) as call_count,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as success_count,\n                AVG(duration_ms) as avg_duration_ms\n            FROM tool_invocation_logs\n            WHERE {where_clause}\n            GROUP BY DATE(created_at)\n            ORDER BY date\n        \"\"\"\n\n        result = await db_session.execute(text(query), params)\n        rows = result.fetchall()\n\n        return [\n            {\n                \"date\": row.date.isoformat(),\n                \"call_count\": row.call_count,\n                \"success_count\": row.success_count,\n                \"success_rate\": round(\n                    ((row.success_count / row.call_count * 100) if row.call_count > 0 else 0),\n                    2,\n                ),\n                \"avg_duration_ms\": round(row.avg_duration_ms or 0, 2),\n            }\n            for row in rows\n        ]\n\n    async def get_error_analysis(\n        self,\n        db_session: AsyncSession,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n        limit: int = 20,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get analysis of tool errors.\n\n        Returns most common error types and their frequency.\n        \"\"\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=7)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        query = \"\"\"\n            SELECT\n                tool_name,\n                error_type,\n                error_message,\n                COUNT(*) as error_count,\n                MIN(created_at) as first_seen,\n                MAX(created_at) as last_seen\n            FROM tool_invocation_logs\n            WHERE status = 'error'\n              AND created_at >= :start_date\n              AND created_at <= :end_date\n            GROUP BY tool_name, error_type, error_message\n            ORDER BY error_count DESC\n            LIMIT :limit\n        \"\"\"\n\n        result = await db_session.execute(\n            text(query),\n            {\"start_date\": start_date, \"end_date\": end_date, \"limit\": limit},\n        )\n        rows = result.fetchall()\n\n        return [\n            {\n                \"tool_name\": row.tool_name,\n                \"error_type\": row.error_type,\n                \"error_message\": row.error_message[:200] if row.error_message else None,\n                \"error_count\": row.error_count,\n                \"first_seen\": row.first_seen.isoformat() if row.first_seen else None,\n                \"last_seen\": row.last_seen.isoformat() if row.last_seen else None,\n            }\n            for row in rows\n        ]\n\n    async def get_user_activity(\n        self,\n        db_session: AsyncSession,\n        user_id: str,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get tool usage activity for a specific user.\n        \"\"\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        # Get summary for user\n        summary_query = \"\"\"\n            SELECT\n                COUNT(*) as total_calls,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_calls,\n                AVG(duration_ms) as avg_duration_ms,\n                COUNT(DISTINCT session_id) as unique_sessions,\n                COUNT(DISTINCT tool_name) as tools_used\n            FROM tool_invocation_logs\n            WHERE user_id = :user_id\n              AND created_at >= :start_date\n              AND created_at <= :end_date\n        \"\"\"\n\n        result = await db_session.execute(\n            text(summary_query),\n            {\"user_id\": user_id, \"start_date\": start_date, \"end_date\": end_date},\n        )\n        summary_row = result.fetchone()\n\n        # Get tool breakdown for user\n        tools_query = \"\"\"\n            SELECT\n                tool_name,\n                COUNT(*) as call_count,\n                COUNT(CASE WHEN status = 'success' THEN 1 END) as success_count\n            FROM tool_invocation_logs\n            WHERE user_id = :user_id\n              AND created_at >= :start_date\n              AND created_at <= :end_date\n            GROUP BY tool_name\n            ORDER BY call_count DESC\n        \"\"\"\n\n        result = await db_session.execute(\n            text(tools_query),\n            {\"user_id\": user_id, \"start_date\": start_date, \"end_date\": end_date},\n        )\n        tool_rows = result.fetchall()\n\n        return {\n            \"user_id\": user_id,\n            \"total_calls\": summary_row.total_calls if summary_row else 0,\n            \"successful_calls\": summary_row.successful_calls if summary_row else 0,\n            \"success_rate\": round(\n                (\n                    (summary_row.successful_calls / summary_row.total_calls * 100)\n                    if summary_row and summary_row.total_calls > 0\n                    else 0\n                ),\n                2,\n            ),\n            \"avg_duration_ms\": round(\n                (summary_row.avg_duration_ms if summary_row and summary_row.avg_duration_ms else 0),\n                2,\n            ),\n            \"unique_sessions\": summary_row.unique_sessions if summary_row else 0,\n            \"tools_used\": summary_row.tools_used if summary_row else 0,\n            \"tool_breakdown\": [\n                {\n                    \"tool_name\": row.tool_name,\n                    \"call_count\": row.call_count,\n                    \"success_count\": row.success_count,\n                }\n                for row in tool_rows\n            ],\n            \"date_range\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat(),\n            },\n        }\n\n    async def get_recent_invocations(\n        self,\n        db_session: AsyncSession,\n        limit: int = 50,\n        tool_name: Optional[str] = None,\n        user_id: Optional[str] = None,\n        status: Optional[str] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get recent tool invocations for debugging/monitoring.\n        \"\"\"\n        filters = [\"1=1\"]\n        params = {\"limit\": limit}\n\n        if tool_name:\n            filters.append(\"tool_name = :tool_name\")\n            params[\"tool_name\"] = tool_name\n\n        if user_id:\n            filters.append(\"user_id = :user_id\")\n            params[\"user_id\"] = user_id\n\n        if status:\n            filters.append(\"status = :status\")\n            params[\"status\"] = status\n\n        where_clause = \" AND \".join(filters)\n\n        # nosec B608 - where_clause is built from hardcoded filter strings, all values are parameterized\n        query = f\"\"\"\n            SELECT\n                id, tool_name, arguments, result, status, error_type, error_message,\n                duration_ms, mode, user_id, session_id, trace_id, created_at\n            FROM tool_invocation_logs\n            WHERE {where_clause}\n            ORDER BY created_at DESC\n            LIMIT :limit\n        \"\"\"\n\n        result = await db_session.execute(text(query), params)\n        rows = result.fetchall()\n\n        return [\n            {\n                \"id\": str(row.id),\n                \"tool_name\": row.tool_name,\n                \"arguments\": row.arguments,\n                \"result_preview\": (str(row.result)[:200] if row.result else None),\n                \"status\": row.status,\n                \"error_type\": row.error_type,\n                \"error_message\": row.error_message,\n                \"duration_ms\": row.duration_ms,\n                \"mode\": row.mode,\n                \"user_id\": (row.user_id[:8] + \"...\" if row.user_id and len(row.user_id) > 8 else row.user_id),\n                \"session_id\": (\n                    row.session_id[:8] + \"...\" if row.session_id and len(row.session_id) > 8 else row.session_id\n                ),\n                \"trace_id\": row.trace_id,\n                \"created_at\": row.created_at.isoformat() if row.created_at else None,\n            }\n            for row in rows\n        ]\n\n\n# Global singleton instance\ntool_analytics_service = ToolAnalyticsService()\n"
}
