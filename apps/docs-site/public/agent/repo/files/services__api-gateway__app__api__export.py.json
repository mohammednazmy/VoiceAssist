{
  "path": "services/api-gateway/app/api/export.py",
  "language": "python",
  "size": 7822,
  "last_modified": "2025-12-05T03:07:13.125Z",
  "lines": 256,
  "content": "\"\"\"\nAPI endpoints for conversation export (PDF/Markdown)\n\"\"\"\n\nfrom datetime import datetime\nfrom io import BytesIO\nfrom typing import List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.message import Message\nfrom app.models.session import Session\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.responses import StreamingResponse\nfrom sqlalchemy.orm import Session as DBSession\n\nrouter = APIRouter()\n\n\ndef generate_markdown(session: Session, messages: List[Message], user: User) -> str:\n    \"\"\"\n    Generate Markdown export of a conversation.\n\n    Args:\n        session: Conversation session\n        messages: List of messages\n        user: User who owns the session\n\n    Returns:\n        Markdown formatted string\n    \"\"\"\n    md_lines = []\n\n    # Header\n    md_lines.append(f\"# {session.title or 'Untitled Conversation'}\")\n    md_lines.append(\"\")\n    md_lines.append(f\"**User:** {user.email}\")\n    md_lines.append(f\"**Created:** {session.created_at.strftime('%Y-%m-%d %H:%M:%S UTC')}\")\n    md_lines.append(f\"**Last Updated:** {session.updated_at.strftime('%Y-%m-%d %H:%M:%S UTC')}\")\n    md_lines.append(f\"**Messages:** {len(messages)}\")\n    md_lines.append(\"\")\n    md_lines.append(\"---\")\n    md_lines.append(\"\")\n\n    # Messages\n    for msg in messages:\n        role = msg.role.capitalize()\n        timestamp = msg.created_at.strftime(\"%H:%M:%S\")\n\n        md_lines.append(f\"## {role} - {timestamp}\")\n        md_lines.append(\"\")\n        md_lines.append(msg.content)\n        md_lines.append(\"\")\n\n        # Include tool calls if present\n        if msg.tool_calls:\n            md_lines.append(\"**Tool Calls:**\")\n            md_lines.append(\"```json\")\n            import json\n\n            md_lines.append(json.dumps(msg.tool_calls, indent=2))\n            md_lines.append(\"```\")\n            md_lines.append(\"\")\n\n        # Include tool results if present\n        if msg.tool_results:\n            md_lines.append(\"**Tool Results:**\")\n            md_lines.append(\"```json\")\n            import json\n\n            md_lines.append(json.dumps(msg.tool_results, indent=2))\n            md_lines.append(\"```\")\n            md_lines.append(\"\")\n\n        md_lines.append(\"---\")\n        md_lines.append(\"\")\n\n    # Footer\n    md_lines.append(\"\")\n    md_lines.append(f\"*Exported from VoiceAssist on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}*\")\n\n    return \"\\n\".join(md_lines)\n\n\ndef generate_pdf(session: Session, messages: List[Message], user: User) -> bytes:\n    \"\"\"\n    Generate PDF export of a conversation.\n\n    Args:\n        session: Conversation session\n        messages: List of messages\n        user: User who owns the session\n\n    Returns:\n        PDF bytes\n    \"\"\"\n    try:\n        from reportlab.lib import colors\n        from reportlab.lib.pagesizes import letter\n        from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet\n        from reportlab.lib.units import inch\n        from reportlab.platypus import Paragraph, SimpleDocTemplate, Spacer, Table, TableStyle\n    except ImportError:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"PDF generation not available. Install reportlab: pip install reportlab\",\n        )\n\n    # Create PDF buffer\n    buffer = BytesIO()\n    doc = SimpleDocTemplate(buffer, pagesize=letter)\n    story = []\n    styles = getSampleStyleSheet()\n\n    # Custom styles\n    title_style = ParagraphStyle(\n        \"CustomTitle\",\n        parent=styles[\"Heading1\"],\n        fontSize=24,\n        textColor=colors.HexColor(\"#2C3E50\"),\n        spaceAfter=30,\n    )\n\n    heading_style = ParagraphStyle(\n        \"CustomHeading\",\n        parent=styles[\"Heading2\"],\n        fontSize=14,\n        textColor=colors.HexColor(\"#34495E\"),\n        spaceAfter=12,\n    )\n\n    # Title\n    story.append(Paragraph(session.title or \"Untitled Conversation\", title_style))\n    story.append(Spacer(1, 0.2 * inch))\n\n    # Metadata table\n    metadata = [\n        [\"User:\", user.email],\n        [\"Created:\", session.created_at.strftime(\"%Y-%m-%d %H:%M:%S UTC\")],\n        [\"Last Updated:\", session.updated_at.strftime(\"%Y-%m-%d %H:%M:%S UTC\")],\n        [\"Messages:\", str(len(messages))],\n    ]\n\n    metadata_table = Table(metadata, colWidths=[1.5 * inch, 5 * inch])\n    metadata_table.setStyle(\n        TableStyle(\n            [\n                (\"FONT\", (0, 0), (0, -1), \"Helvetica-Bold\"),\n                (\"FONT\", (1, 0), (1, -1), \"Helvetica\"),\n                (\"FONTSIZE\", (0, 0), (-1, -1), 10),\n                (\"BOTTOMPADDING\", (0, 0), (-1, -1), 6),\n            ]\n        )\n    )\n    story.append(metadata_table)\n    story.append(Spacer(1, 0.3 * inch))\n\n    # Messages\n    for msg in messages:\n        role = msg.role.capitalize()\n        timestamp = msg.created_at.strftime(\"%H:%M:%S\")\n\n        # Message header\n        story.append(Paragraph(f\"{role} - {timestamp}\", heading_style))\n\n        # Message content\n        content = msg.content.replace(\"\\n\", \"<br/>\")\n        story.append(Paragraph(content, styles[\"Normal\"]))\n        story.append(Spacer(1, 0.2 * inch))\n\n    # Footer\n    footer_text = f\"Exported from VoiceAssist on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\"\n    story.append(Spacer(1, 0.3 * inch))\n    story.append(Paragraph(footer_text, styles[\"Italic\"]))\n\n    # Build PDF\n    doc.build(story)\n    buffer.seek(0)\n    return buffer.read()\n\n\n@router.get(\"/sessions/{session_id}/export/markdown\", response_class=StreamingResponse)\nasync def export_markdown(\n    session_id: UUID,\n    db: DBSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Export conversation as Markdown file.\n\n    Args:\n        session_id: Session UUID\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Markdown file\n    \"\"\"\n    # Get session\n    session = db.query(Session).filter(Session.id == session_id, Session.user_id == current_user.id).first()\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n\n    # Get messages\n    messages = db.query(Message).filter(Message.session_id == session_id).order_by(Message.created_at).all()\n\n    # Generate Markdown\n    markdown_content = generate_markdown(session, messages, current_user)\n\n    # Return as file\n    filename = f\"{session.title or 'conversation'}_{session_id}.md\"\n    return StreamingResponse(\n        iter([markdown_content.encode(\"utf-8\")]),\n        media_type=\"text/markdown\",\n        headers={\"Content-Disposition\": f\"attachment; filename={filename}\"},\n    )\n\n\n@router.get(\"/sessions/{session_id}/export/pdf\", response_class=StreamingResponse)\nasync def export_pdf(\n    session_id: UUID,\n    db: DBSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Export conversation as PDF file.\n\n    Args:\n        session_id: Session UUID\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        PDF file\n    \"\"\"\n    # Get session\n    session = db.query(Session).filter(Session.id == session_id, Session.user_id == current_user.id).first()\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n\n    # Get messages\n    messages = db.query(Message).filter(Message.session_id == session_id).order_by(Message.created_at).all()\n\n    # Generate PDF\n    pdf_bytes = generate_pdf(session, messages, current_user)\n\n    # Return as file\n    filename = f\"{session.title or 'conversation'}_{session_id}.pdf\"\n    return StreamingResponse(\n        iter([pdf_bytes]),\n        media_type=\"application/pdf\",\n        headers={\"Content-Disposition\": f\"attachment; filename={filename}\"},\n    )\n"
}
