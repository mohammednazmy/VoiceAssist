{
  "path": "services/api-gateway/app/api/admin_voice.py",
  "language": "python",
  "size": 52783,
  "last_modified": "2025-12-05T03:07:13.125Z",
  "lines": 1596,
  "content": "\"\"\"Admin Voice API endpoints (Sprint 1 - Voice Monitor + Phase 11.1).\n\nProvides voice/realtime session monitoring and management for the Admin Panel.\n\nEndpoints:\nSession Management:\n- GET /api/admin/voice/sessions - List active WebSocket voice sessions\n- GET /api/admin/voice/sessions/{id} - Get session details\n- POST /api/admin/voice/sessions/{id}/disconnect - Force disconnect session\n\nMetrics & Analytics:\n- GET /api/admin/voice/metrics - Voice metrics summary\n- GET /api/admin/voice/health - Voice service health\n- GET /api/admin/voice/analytics - Usage analytics by period\n- GET /api/admin/voice/analytics/latency - Latency histograms\n- GET /api/admin/voice/analytics/costs - Cost breakdown by provider\n\nConfiguration:\n- GET /api/admin/voice/config - Get voice configuration\n- PATCH /api/admin/voice/config - Update voice configuration (admin only)\n- GET /api/admin/voice/providers - List available TTS/STT providers\n- GET /api/admin/voice/voices - List voices for selected provider\n- POST /api/admin/voice/test-provider - Test provider connectivity\n\nFeature Flags:\n- GET /api/admin/voice/feature-flags - List voice feature flags\n- PATCH /api/admin/voice/feature-flags/{name} - Update feature flag\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom decimal import Decimal\nfrom typing import Any, Dict, List, Literal, Optional\n\n# Import audit logging helper from admin_panel\nfrom app.api.admin_panel import log_audit_event\nfrom app.core.api_envelope import success_response\nfrom app.core.config import settings\nfrom app.core.database import get_db, redis_client\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.feature_flag import FeatureFlag\nfrom app.models.user import User\nfrom app.services.realtime_voice_service import realtime_voice_service\nfrom fastapi import APIRouter, Depends, HTTPException, Path, Query, Request\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session\n\n# Import ElevenLabs service for provider testing\ntry:\n    from app.services.elevenlabs_service import elevenlabs_service\nexcept ImportError:\n    elevenlabs_service = None\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/voice\", tags=[\"admin\", \"voice\"])\n\n# Redis keys for voice session tracking\nREDIS_VOICE_SESSIONS_KEY = \"voiceassist:voice:sessions\"\nREDIS_VOICE_CONFIG_KEY = \"voiceassist:voice:admin_config\"\nREDIS_VOICE_METRICS_KEY = \"voiceassist:voice:metrics_24h\"\nREDIS_VOICE_ANALYTICS_KEY = \"voiceassist:voice:analytics\"\nREDIS_VOICE_LATENCY_KEY = \"voiceassist:voice:latency_histogram\"\nREDIS_VOICE_COSTS_KEY = \"voiceassist:voice:costs\"\n\n# Voice feature flag names (prefixed for organization)\nVOICE_FEATURE_FLAGS = [\n    \"voice.echo_detection_enabled\",\n    \"voice.adaptive_vad_enabled\",\n    \"voice.elevenlabs_enabled\",\n    \"voice.streaming_tts_enabled\",\n    \"voice.barge_in_enabled\",\n    \"voice.realtime_api_enabled\",\n]\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass VoiceSessionInfo(BaseModel):\n    \"\"\"Response model for voice session information.\"\"\"\n\n    session_id: str\n    user_id: str\n    user_email: Optional[str] = None\n    connected_at: str\n    session_type: Literal[\"text\", \"voice\", \"realtime\"]\n    client_info: Dict = Field(default_factory=dict)\n    messages_count: int = 0\n    last_activity: Optional[str] = None\n\n\nclass VoiceSessionDetail(VoiceSessionInfo):\n    \"\"\"Detailed voice session information.\"\"\"\n\n    conversation_id: Optional[str] = None\n    voice: Optional[str] = None\n    language: Optional[str] = None\n    duration_seconds: Optional[float] = None\n    audio_format: Optional[str] = None\n\n\nclass VoiceMetrics(BaseModel):\n    \"\"\"Voice service metrics summary.\"\"\"\n\n    active_sessions: int = 0\n    total_sessions_24h: int = 0\n    avg_session_duration_sec: float = 0.0\n    stt_latency_p95_ms: float = 0.0\n    tts_latency_p95_ms: float = 0.0\n    error_rate_24h: float = 0.0\n    connections_by_type: Dict[str, int] = Field(default_factory=dict)\n\n\nclass VoiceHealthStatus(BaseModel):\n    \"\"\"Voice service health status.\"\"\"\n\n    status: Literal[\"healthy\", \"degraded\", \"unhealthy\"]\n    realtime_api_enabled: bool\n    openai_api_configured: bool\n    redis_connected: bool\n    active_connections: int\n    details: Dict = Field(default_factory=dict)\n\n\nclass VoiceConfig(BaseModel):\n    \"\"\"Voice configuration.\"\"\"\n\n    default_voice: str = \"alloy\"\n    default_language: str = \"en\"\n    vad_enabled: bool = True\n    vad_threshold: float = 0.5\n    max_session_duration_sec: int = 3600\n    stt_provider: str = \"openai\"\n    tts_provider: str = \"openai\"\n    realtime_enabled: bool = False\n\n\nclass VoiceConfigUpdate(BaseModel):\n    \"\"\"Request model for updating voice configuration.\"\"\"\n\n    default_voice: Optional[str] = None\n    default_language: Optional[str] = None\n    vad_enabled: Optional[bool] = None\n    vad_threshold: Optional[float] = Field(None, ge=0.0, le=1.0)\n    max_session_duration_sec: Optional[int] = Field(None, ge=60, le=7200)\n\n\nclass DisconnectResponse(BaseModel):\n    \"\"\"Response for session disconnect.\"\"\"\n\n    success: bool\n    session_id: str\n    message: str\n\n\n# Phase 11.1: Additional models for analytics, providers, and feature flags\n\n\nclass VoiceAnalytics(BaseModel):\n    \"\"\"Voice usage analytics.\"\"\"\n\n    period: str  # \"24h\", \"7d\", \"30d\"\n    total_sessions: int = 0\n    unique_users: int = 0\n    total_duration_seconds: float = 0.0\n    avg_session_duration_seconds: float = 0.0\n    messages_processed: int = 0\n    errors: int = 0\n    error_rate: float = 0.0\n    by_provider: Dict[str, int] = Field(default_factory=dict)\n    by_voice: Dict[str, int] = Field(default_factory=dict)\n    peak_concurrent: int = 0\n\n\nclass LatencyHistogram(BaseModel):\n    \"\"\"Latency distribution data.\"\"\"\n\n    metric: str  # \"stt\" or \"tts\"\n    period: str\n    buckets: List[Dict[str, Any]] = Field(default_factory=list)\n    p50_ms: float = 0.0\n    p95_ms: float = 0.0\n    p99_ms: float = 0.0\n    avg_ms: float = 0.0\n    min_ms: float = 0.0\n    max_ms: float = 0.0\n    sample_count: int = 0\n\n\nclass CostBreakdown(BaseModel):\n    \"\"\"Cost breakdown by provider.\"\"\"\n\n    period: str\n    total_cost_usd: Decimal = Decimal(\"0.00\")\n    by_provider: Dict[str, Decimal] = Field(default_factory=dict)\n    by_voice: Dict[str, Decimal] = Field(default_factory=dict)\n    tts_characters: int = 0\n    stt_minutes: float = 0.0\n    realtime_minutes: float = 0.0\n\n\nclass ProviderInfo(BaseModel):\n    \"\"\"TTS/STT provider information.\"\"\"\n\n    id: str\n    name: str\n    type: Literal[\"tts\", \"stt\", \"both\"]\n    enabled: bool\n    configured: bool\n    features: List[str] = Field(default_factory=list)\n    models: List[Dict[str, str]] = Field(default_factory=list)\n\n\nclass VoiceInfo(BaseModel):\n    \"\"\"Voice information.\"\"\"\n\n    voice_id: str\n    name: str\n    provider: str\n    category: Optional[str] = None\n    preview_url: Optional[str] = None\n    description: Optional[str] = None\n    labels: Dict[str, str] = Field(default_factory=dict)\n    supported_languages: List[str] = Field(default_factory=list)\n\n\nclass ProviderTestRequest(BaseModel):\n    \"\"\"Request to test a provider.\"\"\"\n\n    provider: Literal[\"openai\", \"elevenlabs\"]\n    voice_id: Optional[str] = None\n    test_text: str = \"Hello, this is a test of the voice synthesis system.\"\n\n\nclass ProviderTestResult(BaseModel):\n    \"\"\"Result of provider connectivity test.\"\"\"\n\n    provider: str\n    success: bool\n    latency_ms: Optional[float] = None\n    error: Optional[str] = None\n    audio_size_bytes: Optional[int] = None\n\n\nclass VoiceFeatureFlag(BaseModel):\n    \"\"\"Voice-specific feature flag.\"\"\"\n\n    name: str\n    description: str\n    enabled: bool\n    rollout_percentage: int = 100\n    updated_at: Optional[str] = None\n\n\nclass VoiceFeatureFlagUpdate(BaseModel):\n    \"\"\"Request to update a voice feature flag.\"\"\"\n\n    enabled: Optional[bool] = None\n    rollout_percentage: Optional[int] = Field(None, ge=0, le=100)\n\n\n# ============================================================================\n# Voice Session Tracking Helpers\n# ============================================================================\n\n\ndef register_voice_session(\n    session_id: str,\n    user_id: str,\n    user_email: str,\n    session_type: str = \"voice\",\n    conversation_id: Optional[str] = None,\n    voice: Optional[str] = None,\n    language: Optional[str] = None,\n) -> None:\n    \"\"\"Register a new voice session in Redis.\"\"\"\n    try:\n        session_data = json.dumps(\n            {\n                \"user_id\": user_id,\n                \"user_email\": user_email,\n                \"type\": session_type,\n                \"conversation_id\": conversation_id,\n                \"voice\": voice,\n                \"language\": language,\n                \"connected_at\": datetime.now(timezone.utc).isoformat(),\n                \"last_activity\": datetime.now(timezone.utc).isoformat(),\n                \"messages_count\": 0,\n            }\n        )\n        redis_client.hset(REDIS_VOICE_SESSIONS_KEY, session_id, session_data)\n        # Set expiry on the hash (auto-cleanup stale sessions after 24h)\n        redis_client.expire(REDIS_VOICE_SESSIONS_KEY, 86400)\n    except Exception as e:\n        logger.warning(f\"Failed to register voice session in Redis: {e}\")\n\n\ndef unregister_voice_session(session_id: str) -> None:\n    \"\"\"Unregister a voice session from Redis.\"\"\"\n    try:\n        redis_client.hdel(REDIS_VOICE_SESSIONS_KEY, session_id)\n    except Exception as e:\n        logger.warning(f\"Failed to unregister voice session from Redis: {e}\")\n\n\ndef get_all_voice_sessions() -> Dict[str, dict]:\n    \"\"\"Get all active voice sessions from Redis.\"\"\"\n    try:\n        sessions = redis_client.hgetall(REDIS_VOICE_SESSIONS_KEY)\n        result = {}\n        for sid, data in sessions.items():\n            # Handle both bytes and str from Redis\n            if isinstance(sid, bytes):\n                sid = sid.decode(\"utf-8\")\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            result[sid] = json.loads(data) if isinstance(data, str) else data\n        return result\n    except Exception as e:\n        logger.warning(f\"Failed to get voice sessions from Redis: {e}\")\n        return {}\n\n\ndef get_voice_session(session_id: str) -> Optional[dict]:\n    \"\"\"Get a specific voice session from Redis.\"\"\"\n    try:\n        data = redis_client.hget(REDIS_VOICE_SESSIONS_KEY, session_id)\n        if data:\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            return json.loads(data) if isinstance(data, str) else data\n        return None\n    except Exception as e:\n        logger.warning(f\"Failed to get voice session from Redis: {e}\")\n        return None\n\n\ndef update_voice_session_activity(session_id: str) -> None:\n    \"\"\"Update last activity timestamp for a voice session.\"\"\"\n    try:\n        session = get_voice_session(session_id)\n        if session:\n            session[\"last_activity\"] = datetime.now(timezone.utc).isoformat()\n            session[\"messages_count\"] = session.get(\"messages_count\", 0) + 1\n            redis_client.hset(REDIS_VOICE_SESSIONS_KEY, session_id, json.dumps(session))\n    except Exception as e:\n        logger.warning(f\"Failed to update voice session activity: {e}\")\n\n\ndef get_voice_config() -> VoiceConfig:\n    \"\"\"Get voice configuration from Redis or return defaults.\"\"\"\n    try:\n        config_data = redis_client.get(REDIS_VOICE_CONFIG_KEY)\n        if config_data:\n            if isinstance(config_data, bytes):\n                config_data = config_data.decode(\"utf-8\")\n            return VoiceConfig(**json.loads(config_data))\n    except Exception as e:\n        logger.warning(f\"Failed to get voice config from Redis: {e}\")\n\n    # Return default config with settings values (handle None values)\n    return VoiceConfig(\n        default_voice=getattr(settings, \"TTS_VOICE\", None) or \"alloy\",\n        default_language=\"en\",\n        vad_enabled=True,\n        vad_threshold=0.5,\n        max_session_duration_sec=3600,\n        stt_provider=getattr(settings, \"STT_PROVIDER\", None) or \"openai\",\n        tts_provider=getattr(settings, \"TTS_PROVIDER\", None) or \"openai\",\n        realtime_enabled=getattr(settings, \"REALTIME_ENABLED\", False),\n    )\n\n\ndef save_voice_config(config: VoiceConfig) -> None:\n    \"\"\"Save voice configuration to Redis.\"\"\"\n    try:\n        redis_client.set(REDIS_VOICE_CONFIG_KEY, json.dumps(config.model_dump()))\n    except Exception as e:\n        logger.warning(f\"Failed to save voice config to Redis: {e}\")\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"/sessions\")\nasync def list_voice_sessions(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    session_type: Optional[str] = Query(None, description=\"Filter by session type\"),\n    limit: int = Query(50, ge=1, le=200),\n) -> Dict:\n    \"\"\"List active voice/realtime WebSocket sessions.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    sessions = get_all_voice_sessions()\n\n    # Filter by type if specified\n    if session_type:\n        sessions = {sid: info for sid, info in sessions.items() if info.get(\"type\") == session_type}\n\n    # Convert to list format\n    session_list: List[dict] = []\n    for sid, info in list(sessions.items())[:limit]:\n        session_list.append(\n            {\n                \"session_id\": sid,\n                \"user_id\": info.get(\"user_id\", \"\"),\n                \"user_email\": info.get(\"user_email\"),\n                \"connected_at\": info.get(\"connected_at\", \"\"),\n                \"session_type\": info.get(\"type\", \"voice\"),\n                \"client_info\": info.get(\"client_info\", {}),\n                \"messages_count\": info.get(\"messages_count\", 0),\n                \"last_activity\": info.get(\"last_activity\"),\n            }\n        )\n\n    # Sort by connected_at descending\n    session_list.sort(key=lambda x: x.get(\"connected_at\", \"\"), reverse=True)\n\n    data = {\n        \"sessions\": session_list,\n        \"total\": len(sessions),\n        \"filtered\": len(session_list),\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/sessions/{session_id}\")\nasync def get_session_details(\n    request: Request,\n    session_id: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get details for a specific voice session.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    session = get_voice_session(session_id)\n\n    if not session:\n        raise HTTPException(status_code=404, detail=\"Session not found\")\n\n    # Calculate duration if connected_at exists\n    duration_seconds = None\n    connected_at = session.get(\"connected_at\")\n    if connected_at:\n        try:\n            connected_dt = datetime.fromisoformat(connected_at.replace(\"Z\", \"+00:00\"))\n            duration_seconds = (datetime.now(timezone.utc) - connected_dt).total_seconds()\n        except Exception:\n            pass\n\n    data = {\n        \"session_id\": session_id,\n        \"user_id\": session.get(\"user_id\", \"\"),\n        \"user_email\": session.get(\"user_email\"),\n        \"connected_at\": connected_at,\n        \"session_type\": session.get(\"type\", \"voice\"),\n        \"conversation_id\": session.get(\"conversation_id\"),\n        \"voice\": session.get(\"voice\"),\n        \"language\": session.get(\"language\"),\n        \"client_info\": session.get(\"client_info\", {}),\n        \"messages_count\": session.get(\"messages_count\", 0),\n        \"last_activity\": session.get(\"last_activity\"),\n        \"duration_seconds\": duration_seconds,\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.post(\"/sessions/{session_id}/disconnect\")\nasync def force_disconnect_session(\n    request: Request,\n    session_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Force disconnect a voice session (admin only).\n\n    This removes the session from tracking. The actual WebSocket\n    disconnection should be handled by the realtime service.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    session = get_voice_session(session_id)\n    if not session:\n        raise HTTPException(status_code=404, detail=\"Session not found\")\n\n    # Remove from Redis\n    unregister_voice_session(session_id)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"voice.session.disconnect\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"voice_session\",\n        resource_id=session_id,\n        success=True,\n        details=json.dumps(\n            {\n                \"target_user_id\": session.get(\"user_id\"),\n                \"target_user_email\": session.get(\"user_email\"),\n                \"session_type\": session.get(\"type\"),\n            }\n        ),\n        request=request,\n    )\n\n    logger.info(\n        f\"Admin {current_admin_user.email} force disconnected voice session {session_id}\",\n        extra={\n            \"admin_id\": current_admin_user.id,\n            \"session_id\": session_id,\n            \"target_user_id\": session.get(\"user_id\"),\n        },\n    )\n\n    data = {\n        \"success\": True,\n        \"session_id\": session_id,\n        \"message\": \"Session disconnected successfully\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/metrics\")\nasync def get_voice_metrics(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get voice service metrics summary.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    sessions = get_all_voice_sessions()\n\n    # Count by type\n    connections_by_type: Dict[str, int] = {\"voice\": 0, \"realtime\": 0, \"text\": 0}\n    total_duration_sec = 0.0\n    active_with_duration = 0\n\n    for info in sessions.values():\n        conn_type = info.get(\"type\", \"voice\")\n        if conn_type in connections_by_type:\n            connections_by_type[conn_type] += 1\n        else:\n            connections_by_type[conn_type] = 1\n\n        # Calculate duration for average\n        connected_at = info.get(\"connected_at\")\n        if connected_at:\n            try:\n                connected_dt = datetime.fromisoformat(connected_at.replace(\"Z\", \"+00:00\"))\n                duration = (datetime.now(timezone.utc) - connected_dt).total_seconds()\n                total_duration_sec += duration\n                active_with_duration += 1\n            except Exception:\n                pass\n\n    avg_duration = total_duration_sec / active_with_duration if active_with_duration > 0 else 0.0\n\n    # Try to get cached 24h metrics from Redis\n    total_sessions_24h = 0\n    error_rate_24h = 0.0\n    stt_latency_p95 = 0.0\n    tts_latency_p95 = 0.0\n\n    try:\n        metrics_data = redis_client.get(REDIS_VOICE_METRICS_KEY)\n        if metrics_data:\n            if isinstance(metrics_data, bytes):\n                metrics_data = metrics_data.decode(\"utf-8\")\n            cached_metrics = json.loads(metrics_data)\n            total_sessions_24h = cached_metrics.get(\"total_sessions_24h\", 0)\n            error_rate_24h = cached_metrics.get(\"error_rate_24h\", 0.0)\n            stt_latency_p95 = cached_metrics.get(\"stt_latency_p95_ms\", 0.0)\n            tts_latency_p95 = cached_metrics.get(\"tts_latency_p95_ms\", 0.0)\n    except Exception:\n        pass\n\n    data = {\n        \"active_sessions\": len(sessions),\n        \"total_sessions_24h\": total_sessions_24h,\n        \"avg_session_duration_sec\": round(avg_duration, 2),\n        \"stt_latency_p95_ms\": stt_latency_p95,\n        \"tts_latency_p95_ms\": tts_latency_p95,\n        \"error_rate_24h\": error_rate_24h,\n        \"connections_by_type\": connections_by_type,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/health\")\nasync def get_voice_health(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get voice service health status.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    # Check various voice service components\n    realtime_enabled = realtime_voice_service.is_enabled()\n    openai_configured = bool(getattr(settings, \"OPENAI_API_KEY\", None))\n\n    # Check Redis connectivity\n    redis_ok = False\n    try:\n        redis_client.ping()\n        redis_ok = True\n    except Exception:\n        pass\n\n    # Get active connections count\n    sessions = get_all_voice_sessions()\n    active_count = len(sessions)\n\n    # Determine overall status\n    if not redis_ok:\n        status = \"unhealthy\"\n    elif not openai_configured:\n        status = \"degraded\"\n    else:\n        status = \"healthy\"\n\n    data = {\n        \"status\": status,\n        \"realtime_api_enabled\": realtime_enabled,\n        \"openai_api_configured\": openai_configured,\n        \"redis_connected\": redis_ok,\n        \"active_connections\": active_count,\n        \"details\": {\n            \"realtime_model\": getattr(settings, \"REALTIME_MODEL\", \"gpt-4o-realtime-preview\"),\n            \"stt_provider\": getattr(settings, \"STT_PROVIDER\", \"openai\"),\n            \"tts_provider\": getattr(settings, \"TTS_PROVIDER\", \"openai\"),\n            \"tts_voice\": getattr(settings, \"TTS_VOICE\", \"alloy\"),\n        },\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/config\")\nasync def get_voice_config_endpoint(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get voice configuration.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    config = get_voice_config()\n\n    data = config.model_dump()\n    data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.patch(\"/config\")\nasync def update_voice_config_endpoint(\n    request: Request,\n    config_update: VoiceConfigUpdate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Update voice configuration (admin only).\n\n    Only admin users can modify voice configuration.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    # Get current config\n    current_config = get_voice_config()\n    original_config = current_config.model_dump()\n\n    # Apply updates\n    update_data = config_update.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(current_config, field, value)\n\n    # Save updated config\n    save_voice_config(current_config)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"voice.config.update\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"voice_config\",\n        resource_id=\"global\",\n        success=True,\n        details=json.dumps({\"original\": original_config, \"updated\": update_data}),\n        request=request,\n    )\n\n    logger.info(\n        f\"Admin {current_admin_user.email} updated voice configuration\",\n        extra={\n            \"admin_id\": current_admin_user.id,\n            \"changes\": update_data,\n        },\n    )\n\n    data = current_config.model_dump()\n    data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Phase 11.1: Analytics Endpoints\n# ============================================================================\n\n\n@router.get(\"/analytics\")\nasync def get_voice_analytics(\n    request: Request,\n    period: str = Query(\"24h\", description=\"Time period: 24h, 7d, or 30d\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get voice usage analytics for the specified period.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    valid_periods = [\"24h\", \"7d\", \"30d\"]\n    if period not in valid_periods:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid period. Must be one of: {', '.join(valid_periods)}\",\n        )\n\n    # Get analytics from Redis cache\n    analytics_key = f\"{REDIS_VOICE_ANALYTICS_KEY}:{period}\"\n    try:\n        cached_data = redis_client.get(analytics_key)\n        if cached_data:\n            if isinstance(cached_data, bytes):\n                cached_data = cached_data.decode(\"utf-8\")\n            data = json.loads(cached_data)\n            data[\"period\"] = period\n            data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n    except Exception as e:\n        logger.warning(f\"Failed to get analytics from cache: {e}\")\n\n    # Return default/empty analytics if no cache\n    data = VoiceAnalytics(period=period).model_dump()\n    data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/analytics/latency\")\nasync def get_voice_latency_histogram(\n    request: Request,\n    metric: str = Query(\"stt\", description=\"Metric type: stt or tts\"),\n    period: str = Query(\"24h\", description=\"Time period: 24h, 7d, or 30d\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get latency histogram for STT or TTS.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    valid_metrics = [\"stt\", \"tts\"]\n    if metric not in valid_metrics:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid metric. Must be one of: {', '.join(valid_metrics)}\",\n        )\n\n    # Get latency data from Redis\n    latency_key = f\"{REDIS_VOICE_LATENCY_KEY}:{metric}:{period}\"\n    try:\n        cached_data = redis_client.get(latency_key)\n        if cached_data:\n            if isinstance(cached_data, bytes):\n                cached_data = cached_data.decode(\"utf-8\")\n            data = json.loads(cached_data)\n            data[\"metric\"] = metric\n            data[\"period\"] = period\n            data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n    except Exception as e:\n        logger.warning(f\"Failed to get latency data from cache: {e}\")\n\n    # Return default histogram\n    data = LatencyHistogram(metric=metric, period=period).model_dump()\n    data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/analytics/costs\")\nasync def get_voice_cost_breakdown(\n    request: Request,\n    period: str = Query(\"30d\", description=\"Time period: 24h, 7d, or 30d\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get cost breakdown by provider.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    # Get cost data from Redis\n    costs_key = f\"{REDIS_VOICE_COSTS_KEY}:{period}\"\n    try:\n        cached_data = redis_client.get(costs_key)\n        if cached_data:\n            if isinstance(cached_data, bytes):\n                cached_data = cached_data.decode(\"utf-8\")\n            data = json.loads(cached_data)\n            data[\"period\"] = period\n            data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n    except Exception as e:\n        logger.warning(f\"Failed to get cost data from cache: {e}\")\n\n    # Return default cost breakdown\n    data = {\n        \"period\": period,\n        \"total_cost_usd\": \"0.00\",\n        \"by_provider\": {\"openai\": \"0.00\", \"elevenlabs\": \"0.00\"},\n        \"by_voice\": {},\n        \"tts_characters\": 0,\n        \"stt_minutes\": 0.0,\n        \"realtime_minutes\": 0.0,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Phase 11.1: Provider & Voice Endpoints\n# ============================================================================\n\n\n@router.get(\"/providers\")\nasync def get_voice_providers(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get list of available TTS/STT providers.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    providers = []\n\n    # OpenAI provider\n    openai_configured = bool(getattr(settings, \"OPENAI_API_KEY\", None))\n    providers.append(\n        {\n            \"id\": \"openai\",\n            \"name\": \"OpenAI\",\n            \"type\": \"both\",\n            \"enabled\": True,\n            \"configured\": openai_configured,\n            \"features\": [\"tts\", \"stt\", \"realtime\", \"streaming\"],\n            \"models\": [\n                {\"id\": \"tts-1\", \"name\": \"TTS-1 (Fast)\"},\n                {\"id\": \"tts-1-hd\", \"name\": \"TTS-1 HD (Quality)\"},\n                {\"id\": \"gpt-4o-realtime-preview\", \"name\": \"GPT-4o Realtime\"},\n            ],\n        }\n    )\n\n    # ElevenLabs provider\n    elevenlabs_configured = bool(getattr(settings, \"ELEVENLABS_API_KEY\", None))\n    elevenlabs_enabled = elevenlabs_service is not None and elevenlabs_service.is_enabled()\n    providers.append(\n        {\n            \"id\": \"elevenlabs\",\n            \"name\": \"ElevenLabs\",\n            \"type\": \"tts\",\n            \"enabled\": elevenlabs_enabled,\n            \"configured\": elevenlabs_configured,\n            \"features\": [\"tts\", \"streaming\", \"emotion_control\", \"multilingual\"],\n            \"models\": [\n                {\n                    \"id\": \"eleven_multilingual_v2\",\n                    \"name\": \"Multilingual v2 (Best Quality)\",\n                },\n                {\"id\": \"eleven_turbo_v2\", \"name\": \"Turbo v2 (Fast, English)\"},\n                {\"id\": \"eleven_monolingual_v1\", \"name\": \"Monolingual v1 (Legacy)\"},\n            ],\n        }\n    )\n\n    data = {\n        \"providers\": providers,\n        \"default_tts_provider\": getattr(settings, \"TTS_PROVIDER\", \"openai\"),\n        \"default_stt_provider\": getattr(settings, \"STT_PROVIDER\", \"openai\"),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/voices\")\nasync def get_available_voices(\n    request: Request,\n    provider: Optional[str] = Query(None, description=\"Filter by provider: openai or elevenlabs\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get list of available voices for the specified provider.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    voices = []\n\n    # OpenAI voices\n    if provider is None or provider == \"openai\":\n        openai_voices = [\n            {\n                \"voice_id\": \"alloy\",\n                \"name\": \"Alloy\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n            {\n                \"voice_id\": \"echo\",\n                \"name\": \"Echo\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n            {\n                \"voice_id\": \"fable\",\n                \"name\": \"Fable\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n            {\n                \"voice_id\": \"onyx\",\n                \"name\": \"Onyx\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n            {\n                \"voice_id\": \"nova\",\n                \"name\": \"Nova\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n            {\n                \"voice_id\": \"shimmer\",\n                \"name\": \"Shimmer\",\n                \"provider\": \"openai\",\n                \"category\": \"neural\",\n            },\n        ]\n        voices.extend(openai_voices)\n\n    # ElevenLabs voices\n    if (provider is None or provider == \"elevenlabs\") and elevenlabs_service:\n        try:\n            elevenlabs_voices = await elevenlabs_service.get_voices()\n            for v in elevenlabs_voices:\n                voices.append(\n                    {\n                        \"voice_id\": v.voice_id,\n                        \"name\": v.name,\n                        \"provider\": \"elevenlabs\",\n                        \"category\": v.category,\n                        \"preview_url\": v.preview_url,\n                        \"description\": v.description,\n                        \"labels\": v.labels,\n                    }\n                )\n        except Exception as e:\n            logger.warning(f\"Failed to fetch ElevenLabs voices: {e}\")\n\n    # Get default voice\n    config = get_voice_config()\n    default_voice_id = config.default_voice\n\n    data = {\n        \"voices\": voices,\n        \"total\": len(voices),\n        \"default_voice_id\": default_voice_id,\n        \"default_provider\": config.tts_provider,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.post(\"/test-provider\")\nasync def test_voice_provider(\n    request: Request,\n    test_request: ProviderTestRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Test connectivity to a TTS provider.\n\n    Admin only. Generates test audio to verify provider is working.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    import time\n\n    start_time = time.time()\n    result = {\n        \"provider\": test_request.provider,\n        \"success\": False,\n        \"latency_ms\": None,\n        \"error\": None,\n        \"audio_size_bytes\": None,\n    }\n\n    try:\n        if test_request.provider == \"openai\":\n            # Test OpenAI TTS\n            import httpx\n\n            async with httpx.AsyncClient() as client:\n                response = await client.post(\n                    \"https://api.openai.com/v1/audio/speech\",\n                    headers={\n                        \"Authorization\": f\"Bearer {settings.OPENAI_API_KEY}\",\n                        \"Content-Type\": \"application/json\",\n                    },\n                    json={\n                        \"model\": \"tts-1\",\n                        \"input\": test_request.test_text,\n                        \"voice\": test_request.voice_id or \"alloy\",\n                    },\n                    timeout=30.0,\n                )\n                if response.status_code == 200:\n                    result[\"success\"] = True\n                    result[\"audio_size_bytes\"] = len(response.content)\n                else:\n                    result[\"error\"] = f\"HTTP {response.status_code}: {response.text}\"\n\n        elif test_request.provider == \"elevenlabs\":\n            if not elevenlabs_service or not elevenlabs_service.is_enabled():\n                result[\"error\"] = \"ElevenLabs is not configured\"\n            else:\n                synthesis_result = await elevenlabs_service.synthesize(\n                    text=test_request.test_text,\n                    voice_id=test_request.voice_id,\n                )\n                result[\"success\"] = True\n                result[\"audio_size_bytes\"] = len(synthesis_result.audio_data)\n\n    except Exception as e:\n        result[\"error\"] = str(e)\n\n    result[\"latency_ms\"] = round((time.time() - start_time) * 1000, 2)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"voice.provider.test\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"voice_provider\",\n        resource_id=test_request.provider,\n        success=result[\"success\"],\n        details=json.dumps(\n            {\n                \"provider\": test_request.provider,\n                \"voice_id\": test_request.voice_id,\n                \"latency_ms\": result[\"latency_ms\"],\n                \"error\": result[\"error\"],\n            }\n        ),\n        request=request,\n    )\n\n    data = result\n    data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Phase 11.1: Feature Flags Endpoints\n# ============================================================================\n\n\n# Default voice feature flag definitions\nVOICE_FEATURE_FLAG_DEFINITIONS = {\n    \"voice.echo_detection_enabled\": {\n        \"description\": \"Enable local echo detection in AudioWorklet to suppress speaker feedback\",\n        \"default\": True,\n    },\n    \"voice.adaptive_vad_enabled\": {\n        \"description\": \"Automatically adjust silence detection based on user speech patterns\",\n        \"default\": True,\n    },\n    \"voice.elevenlabs_enabled\": {\n        \"description\": \"Enable ElevenLabs as an alternative TTS provider\",\n        \"default\": True,\n    },\n    \"voice.streaming_tts_enabled\": {\n        \"description\": \"Stream audio chunks for lower latency playback\",\n        \"default\": True,\n    },\n    \"voice.barge_in_enabled\": {\n        \"description\": \"Allow users to interrupt AI responses by speaking\",\n        \"default\": True,\n    },\n    \"voice.realtime_api_enabled\": {\n        \"description\": \"Enable OpenAI Realtime API for voice conversations\",\n        \"default\": True,\n    },\n}\n\n\n@router.get(\"/feature-flags\")\nasync def get_voice_feature_flags(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get voice-specific feature flags.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    flags = []\n\n    for flag_name in VOICE_FEATURE_FLAGS:\n        # Try to get from database\n        flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n\n        if flag:\n            flags.append(\n                {\n                    \"name\": flag.name,\n                    \"description\": flag.description,\n                    \"enabled\": flag.enabled,\n                    \"rollout_percentage\": flag.rollout_percentage or 100,\n                    \"updated_at\": (flag.updated_at.isoformat() if flag.updated_at else None),\n                }\n            )\n        else:\n            # Return default if not in database\n            definition = VOICE_FEATURE_FLAG_DEFINITIONS.get(flag_name, {})\n            flags.append(\n                {\n                    \"name\": flag_name,\n                    \"description\": definition.get(\"description\", \"No description\"),\n                    \"enabled\": definition.get(\"default\", False),\n                    \"rollout_percentage\": 100,\n                    \"updated_at\": None,\n                }\n            )\n\n    data = {\n        \"flags\": flags,\n        \"total\": len(flags),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Thinker-Talker Pipeline Endpoints\n# ============================================================================\n\n\nclass TTSessionInfo(BaseModel):\n    \"\"\"Thinker-Talker session information.\"\"\"\n\n    session_id: str\n    user_id: str\n    user_email: Optional[str] = None\n    state: str\n    conversation_id: Optional[str] = None\n    message_count: int = 0\n    tool_calls_count: int = 0\n    created_at: str\n    last_activity: Optional[str] = None\n\n\nclass TTContextInfo(BaseModel):\n    \"\"\"Cached conversation context information.\"\"\"\n\n    conversation_id: str\n    user_id: str\n    message_count: int\n    last_activity: str\n    expires_at: Optional[str] = None\n\n\nclass QualityPresetInfo(BaseModel):\n    \"\"\"TTS quality preset configuration.\"\"\"\n\n    name: str\n    model: str\n    bitrate: Optional[str] = None\n    sample_rate: Optional[int] = None\n    description: Optional[str] = None\n    enabled: bool = True\n\n\nclass TTAnalytics(BaseModel):\n    \"\"\"Thinker-Talker analytics data.\"\"\"\n\n    period: str\n    total_sessions: int = 0\n    unique_users: int = 0\n    tool_calls_by_name: Dict[str, int] = Field(default_factory=dict)\n    avg_response_latency_ms: float = 0.0\n    avg_tool_latency_ms: float = 0.0\n    success_rate: float = 100.0\n\n\n# Redis keys for TT tracking\nREDIS_TT_SESSIONS_KEY = \"voiceassist:tt:sessions\"\nREDIS_TT_CONTEXTS_KEY = \"voiceassist:tt:contexts\"\nREDIS_TT_ANALYTICS_KEY = \"voiceassist:tt:analytics\"\n\n\n@router.get(\"/tt-sessions\")\nasync def get_tt_sessions(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(50, ge=1, le=200),\n) -> Dict:\n    \"\"\"Get active Thinker-Talker pipeline sessions.\n\n    Shows sessions using the new TT voice pipeline (not legacy Realtime API).\n    \"\"\"\n    sessions = []\n\n    try:\n        # Get TT sessions from Redis\n        tt_sessions = redis_client.hgetall(REDIS_TT_SESSIONS_KEY)\n        for sid, data in tt_sessions.items():\n            if isinstance(sid, bytes):\n                sid = sid.decode(\"utf-8\")\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            session_data = json.loads(data) if isinstance(data, str) else data\n            sessions.append(\n                {\n                    \"session_id\": sid,\n                    \"user_id\": session_data.get(\"user_id\", \"\"),\n                    \"user_email\": session_data.get(\"user_email\"),\n                    \"state\": session_data.get(\"state\", \"unknown\"),\n                    \"conversation_id\": session_data.get(\"conversation_id\"),\n                    \"message_count\": session_data.get(\"message_count\", 0),\n                    \"tool_calls_count\": session_data.get(\"tool_calls_count\", 0),\n                    \"created_at\": session_data.get(\"created_at\", \"\"),\n                    \"last_activity\": session_data.get(\"last_activity\"),\n                }\n            )\n    except Exception as e:\n        logger.warning(f\"Failed to get TT sessions from Redis: {e}\")\n\n    # Sort by created_at descending and limit\n    sessions.sort(key=lambda x: x.get(\"created_at\", \"\"), reverse=True)\n    sessions = sessions[:limit]\n\n    data = {\n        \"sessions\": sessions,\n        \"total\": len(sessions),\n        \"pipeline\": \"thinker-talker\",\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/contexts\")\nasync def get_tt_contexts(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(50, ge=1, le=200),\n) -> Dict:\n    \"\"\"Get cached conversation contexts from ThinkerService.\n\n    Shows active conversation contexts that are cached for voice mode.\n    \"\"\"\n    contexts = []\n\n    try:\n        # Get context info from Redis\n        ctx_data = redis_client.hgetall(REDIS_TT_CONTEXTS_KEY)\n        for conv_id, data in ctx_data.items():\n            if isinstance(conv_id, bytes):\n                conv_id = conv_id.decode(\"utf-8\")\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            context_data = json.loads(data) if isinstance(data, str) else data\n            contexts.append(\n                {\n                    \"conversation_id\": conv_id,\n                    \"user_id\": context_data.get(\"user_id\", \"\"),\n                    \"message_count\": context_data.get(\"message_count\", 0),\n                    \"last_activity\": context_data.get(\"last_activity\", \"\"),\n                    \"expires_at\": context_data.get(\"expires_at\"),\n                }\n            )\n    except Exception as e:\n        logger.warning(f\"Failed to get TT contexts from Redis: {e}\")\n\n    # Sort by last_activity descending\n    contexts.sort(key=lambda x: x.get(\"last_activity\", \"\"), reverse=True)\n    contexts = contexts[:limit]\n\n    data = {\n        \"contexts\": contexts,\n        \"total\": len(contexts),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.post(\"/contexts/cleanup\")\nasync def cleanup_tt_contexts(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n    max_age_minutes: int = Query(60, ge=5, le=1440),\n) -> Dict:\n    \"\"\"Cleanup expired conversation contexts.\n\n    Admin only. Removes contexts that haven't been accessed recently.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    cleaned = 0\n    cutoff_time = datetime.now(timezone.utc) - timedelta(minutes=max_age_minutes)\n\n    try:\n        ctx_data = redis_client.hgetall(REDIS_TT_CONTEXTS_KEY)\n        for conv_id, data in ctx_data.items():\n            if isinstance(conv_id, bytes):\n                conv_id = conv_id.decode(\"utf-8\")\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            context_data = json.loads(data) if isinstance(data, str) else data\n\n            last_activity = context_data.get(\"last_activity\")\n            if last_activity:\n                try:\n                    last_dt = datetime.fromisoformat(last_activity.replace(\"Z\", \"+00:00\"))\n                    if last_dt < cutoff_time:\n                        redis_client.hdel(REDIS_TT_CONTEXTS_KEY, conv_id)\n                        cleaned += 1\n                except Exception:\n                    pass\n    except Exception as e:\n        logger.warning(f\"Failed to cleanup TT contexts: {e}\")\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"voice.tt.cleanup\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"tt_contexts\",\n        resource_id=\"all\",\n        success=True,\n        details=json.dumps({\"max_age_minutes\": max_age_minutes, \"cleaned_count\": cleaned}),\n        request=request,\n    )\n\n    data = {\n        \"cleaned\": cleaned,\n        \"max_age_minutes\": max_age_minutes,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/quality-presets\")\nasync def get_quality_presets(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get TTS quality presets configuration.\n\n    Shows available quality presets for the Talker service.\n    \"\"\"\n    # Default quality presets (would be loaded from config in production)\n    presets = [\n        {\n            \"name\": \"standard\",\n            \"model\": \"tts-1\",\n            \"bitrate\": \"128k\",\n            \"sample_rate\": 24000,\n            \"description\": \"Fast synthesis, good quality\",\n            \"enabled\": True,\n        },\n        {\n            \"name\": \"high_quality\",\n            \"model\": \"tts-1-hd\",\n            \"bitrate\": \"192k\",\n            \"sample_rate\": 48000,\n            \"description\": \"Higher quality, slower synthesis\",\n            \"enabled\": True,\n        },\n        {\n            \"name\": \"realtime\",\n            \"model\": \"gpt-4o-realtime-preview\",\n            \"bitrate\": None,\n            \"sample_rate\": 24000,\n            \"description\": \"Real-time streaming, lowest latency\",\n            \"enabled\": realtime_voice_service.is_enabled(),\n        },\n    ]\n\n    data = {\n        \"presets\": presets,\n        \"default_preset\": \"standard\",\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/analytics/tools\")\nasync def get_tt_tool_analytics(\n    request: Request,\n    period: str = Query(\"24h\", description=\"Time period: 24h, 7d, or 30d\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get tool call analytics for the Thinker-Talker pipeline.\n\n    Shows which tools are being called most frequently in voice mode.\n    \"\"\"\n    valid_periods = [\"24h\", \"7d\", \"30d\"]\n    if period not in valid_periods:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid period. Must be one of: {', '.join(valid_periods)}\",\n        )\n\n    # Get analytics from Redis cache\n    analytics_key = f\"{REDIS_TT_ANALYTICS_KEY}:tools:{period}\"\n    try:\n        cached_data = redis_client.get(analytics_key)\n        if cached_data:\n            if isinstance(cached_data, bytes):\n                cached_data = cached_data.decode(\"utf-8\")\n            data = json.loads(cached_data)\n            data[\"period\"] = period\n            data[\"timestamp\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n    except Exception as e:\n        logger.warning(f\"Failed to get TT tool analytics from cache: {e}\")\n\n    # Return default analytics\n    data = {\n        \"period\": period,\n        \"total_tool_calls\": 0,\n        \"tool_calls_by_name\": {},\n        \"avg_tool_latency_ms\": 0.0,\n        \"success_rate\": 100.0,\n        \"top_tools\": [],\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.patch(\"/feature-flags/{flag_name:path}\")\nasync def update_voice_feature_flag(\n    request: Request,\n    flag_name: str = Path(..., description=\"Feature flag name\"),\n    update: VoiceFeatureFlagUpdate = ...,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Update a voice feature flag.\n\n    Admin only.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    # Validate flag name\n    if flag_name not in VOICE_FEATURE_FLAGS:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"Unknown voice feature flag: {flag_name}\",\n        )\n\n    # Get or create flag\n    flag = db.query(FeatureFlag).filter(FeatureFlag.name == flag_name).first()\n    definition = VOICE_FEATURE_FLAG_DEFINITIONS.get(flag_name, {})\n\n    if not flag:\n        # Create new flag\n        flag = FeatureFlag(\n            name=flag_name,\n            description=definition.get(\"description\", \"No description\"),\n            flag_type=\"boolean\",\n            enabled=definition.get(\"default\", False),\n            rollout_percentage=100,\n        )\n        db.add(flag)\n\n    # Store original values for audit\n    original_values = {\n        \"enabled\": flag.enabled,\n        \"rollout_percentage\": flag.rollout_percentage,\n    }\n\n    # Apply updates\n    if update.enabled is not None:\n        flag.enabled = update.enabled\n    if update.rollout_percentage is not None:\n        flag.rollout_percentage = update.rollout_percentage\n\n    flag.updated_at = datetime.utcnow()\n\n    db.commit()\n    db.refresh(flag)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"voice.feature_flag.update\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"voice_feature_flag\",\n        resource_id=flag_name,\n        success=True,\n        details=json.dumps(\n            {\n                \"original\": original_values,\n                \"updated\": update.model_dump(exclude_unset=True),\n            }\n        ),\n        request=request,\n    )\n\n    logger.info(\n        f\"Admin {current_admin_user.email} updated voice feature flag {flag_name}\",\n        extra={\n            \"admin_id\": current_admin_user.id,\n            \"flag_name\": flag_name,\n            \"changes\": update.model_dump(exclude_unset=True),\n        },\n    )\n\n    data = {\n        \"name\": flag.name,\n        \"description\": flag.description,\n        \"enabled\": flag.enabled,\n        \"rollout_percentage\": flag.rollout_percentage,\n        \"updated_at\": flag.updated_at.isoformat() if flag.updated_at else None,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n"
}
