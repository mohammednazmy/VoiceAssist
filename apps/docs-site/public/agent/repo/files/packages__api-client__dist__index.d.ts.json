{
  "path": "packages/api-client/dist/index.d.ts",
  "language": "typescript",
  "size": 29868,
  "last_modified": "2025-12-04T10:50:20.769Z",
  "lines": 857,
  "content": "import { AxiosRequestConfig } from 'axios';\nimport { LoginRequest, AuthTokens, User, PaginatedResponse, Conversation, UpdateConversationRequest, Message, CreateBranchRequest, Branch, SearchResult, Document, SystemMetrics, AuditLogEntry, Folder, CreateFolderRequest, UpdateFolderRequest, ShareRequest, ShareResponse, ShareLink, AttachmentUploadResponse, Attachment, ClinicalContextCreate, ClinicalContext, ClinicalContextUpdate, ClinicalContextPreset, ClinicalPresetCreate, ClinicalPresetUpdate, IntegrationSummary, IntegrationDetail, IntegrationConfigUpdate, IntegrationTestResult, IntegrationMetrics, IntegrationsHealthSummary, PHIRulesResponse, PHIRule, PHIRuleUpdate, PHITestRequest, PHITestResult, PHIRedactResult, PHIRoutingConfig, PHIRoutingUpdate, PHIStats, PHIEventsResponse, PHIHealthStatus, ModelInfo, ModelUsageMetrics, SearchStats, EmbeddingStats, ModelRoutingConfig, ModelRoutingUpdate, ResourceMetrics, SystemHealth, BackupStatus, BackupHistoryEntry, BackupType, BackupTriggerResult, MaintenanceStatus, MaintenanceRequest, CacheNamespacesResponse, CacheInvalidateResult } from '@voiceassist/types';\n\n/**\n * Retry Logic Utility\n * Implements exponential backoff for failed API calls\n */\ninterface RetryConfig {\n    maxRetries: number;\n    baseDelay: number;\n    maxDelay: number;\n    retryableStatuses: number[];\n}\n\n/**\n * VoiceAssist API Client\n * HTTP client for communicating with VoiceAssist backend services\n */\n\n/**\n * Response when 2FA is required during login\n */\ninterface TwoFactorRequiredResponse {\n    requires_2fa: true;\n    user_id: string;\n    message: string;\n}\n/**\n * Type guard to check if login response requires 2FA\n */\ndeclare function isTwoFactorRequired(response: AuthTokens | TwoFactorRequiredResponse): response is TwoFactorRequiredResponse;\ninterface ApiClientConfig {\n    baseURL: string;\n    timeout?: number;\n    onUnauthorized?: () => void;\n    getAccessToken?: () => string | null;\n    enableRetry?: boolean;\n    retryConfig?: Partial<RetryConfig>;\n    onRetry?: (attempt: number, error: any) => void;\n    correlationId?: string;\n    environment?: \"staging\" | \"production\" | string;\n}\n/** Admin KB document in list response */\ninterface AdminKBDocument {\n    document_id: string;\n    title: string;\n    source_type: string;\n    upload_date: string;\n    chunks_indexed: number;\n}\n/** Admin KB document detail response */\ninterface AdminKBDocumentDetail {\n    document_id: string;\n    title: string;\n    source_type: string;\n    filename: string;\n    file_type: string;\n    chunks_indexed: number;\n    total_tokens: number | null;\n    indexing_status: string;\n    indexing_error: string | null;\n    metadata: Record<string, unknown>;\n    created_at: string;\n    updated_at: string;\n}\n/** Admin KB upload response */\ninterface AdminKBUploadResponse {\n    document_id: string;\n    title: string;\n    status: string;\n    chunks_indexed: number;\n    message: string;\n}\n/** Feature Flag configuration */\ninterface FeatureFlag {\n    name: string;\n    enabled: boolean;\n    description: string;\n    created_at: string;\n    updated_at: string;\n    rollout_percentage?: number;\n    user_groups?: string[];\n    metadata?: Record<string, unknown>;\n}\n/** Request to create a new feature flag */\ninterface CreateFeatureFlagRequest {\n    name: string;\n    enabled?: boolean;\n    description: string;\n    rollout_percentage?: number;\n    user_groups?: string[];\n    metadata?: Record<string, unknown>;\n}\n/** Request to update an existing feature flag */\ninterface UpdateFeatureFlagRequest {\n    enabled?: boolean;\n    description?: string;\n    rollout_percentage?: number;\n    user_groups?: string[];\n    metadata?: Record<string, unknown>;\n}\n/** Cache statistics */\ninterface CacheStats {\n    total_keys: number;\n    memory_used_bytes: number;\n    memory_used_human: string;\n    hit_rate: number;\n    miss_rate: number;\n    uptime_seconds: number;\n    connected_clients: number;\n    keys_by_prefix: Record<string, number>;\n}\ndeclare class VoiceAssistApiClient {\n    private client;\n    private config;\n    private correlationId;\n    constructor(config: ApiClientConfig);\n    /**\n     * Wrap a request with retry logic if enabled\n     */\n    private withRetryIfEnabled;\n    /**\n     * Execute an arbitrary HTTP request using the configured Axios client.\n     * This is useful for endpoints that don't yet have a dedicated helper.\n     */\n    request<T = any>(config: AxiosRequestConfig): Promise<T>;\n    /**\n     * Expose the configured base URL for diagnostic and display purposes\n     */\n    getBaseUrl(): string;\n    login(credentials: LoginRequest): Promise<AuthTokens | TwoFactorRequiredResponse>;\n    /**\n     * Verify 2FA code during login and get tokens\n     */\n    verify2FALogin(userId: string, code: string, isBackupCode?: boolean): Promise<AuthTokens>;\n    register(data: {\n        email: string;\n        password: string;\n        full_name: string;\n    }): Promise<User>;\n    logout(): Promise<void>;\n    refreshToken(refreshToken: string): Promise<AuthTokens>;\n    getCurrentUser(): Promise<User>;\n    /**\n     * Get session timeout information for the current session.\n     * Used by frontend to display session expiration warnings.\n     */\n    getSessionInfo(): Promise<{\n        absolute_timeout_hours: number;\n        inactivity_timeout_minutes: number;\n        absolute_remaining_seconds: number;\n        inactivity_remaining_seconds: number;\n        session_started_at: string;\n        last_activity_at: string | null;\n    }>;\n    updateProfile(updates: {\n        name?: string;\n        email?: string;\n    }): Promise<User>;\n    changePassword(currentPassword: string, newPassword: string): Promise<void>;\n    transcribeAudio(audio: Blob, filename?: string): Promise<string>;\n    synthesizeSpeech(text: string, voiceId?: string): Promise<Blob>;\n    /**\n     * Synthesize speech with streaming audio response (low latency).\n     * Uses ElevenLabs streaming when available, falls back to standard TTS.\n     *\n     * @param text - Text to synthesize\n     * @param options - TTS options including voice settings\n     * @returns Response object with streaming body\n     */\n    synthesizeSpeechStream(text: string, options?: {\n        voiceId?: string;\n        provider?: \"openai\" | \"elevenlabs\";\n        stability?: number;\n        similarityBoost?: number;\n        style?: number;\n        language?: string;\n    }): Promise<Response>;\n    createRealtimeSession(request: {\n        conversation_id?: string | null;\n        voice?: string | null;\n        language?: string | null;\n        vad_sensitivity?: number | null;\n    }): Promise<{\n        url: string;\n        model: string;\n        session_id: string;\n        expires_at: number;\n        conversation_id?: string | null;\n        auth: {\n            type: string;\n            token: string;\n            expires_at: number;\n        };\n        voice_config: {\n            voice: string;\n            language?: string | null;\n            modalities: string[];\n            input_audio_format: string;\n            output_audio_format: string;\n            input_audio_transcription: {\n                model: string;\n            };\n            turn_detection: {\n                type: string;\n                threshold: number;\n                prefix_padding_ms: number;\n                silence_duration_ms: number;\n            };\n        };\n    }>;\n    relayVoiceTranscript(request: {\n        conversation_id: string;\n        transcript: string;\n        clinical_context_id?: string | null;\n    }): Promise<{\n        user_message_id: string;\n        assistant_message_id: string;\n        answer: string;\n        citations: Record<string, any>[];\n    }>;\n    /**\n     * Phase 11: Get available TTS voices from all configured providers\n     * @param provider Optional filter by provider (\"openai\" | \"elevenlabs\")\n     */\n    getAvailableVoices(provider?: string): Promise<{\n        voices: Array<{\n            voice_id: string;\n            name: string;\n            provider: string;\n            category?: string | null;\n            preview_url?: string | null;\n            description?: string | null;\n            labels?: Record<string, string> | null;\n        }>;\n        default_voice_id?: string | null;\n        default_provider: string;\n    }>;\n    /**\n     * Submit voice session metrics for observability\n     * Note: For page unload scenarios, use sendBeacon directly instead\n     */\n    submitVoiceMetrics(metrics: {\n        conversation_id?: string | null;\n        connection_time_ms?: number | null;\n        time_to_first_transcript_ms?: number | null;\n        last_stt_latency_ms?: number | null;\n        last_response_latency_ms?: number | null;\n        session_duration_ms?: number | null;\n        user_transcript_count?: number;\n        ai_response_count?: number;\n        reconnect_count?: number;\n        session_started_at?: number | null;\n    }): Promise<{\n        status: string;\n    }>;\n    /**\n     * Log a voice event (e.g., barge-in) for analytics and observability\n     */\n    logVoiceEvent(event: {\n        conversation_id?: string | null;\n        event_type: \"barge_in\" | \"connection_error\" | \"transcription_error\" | \"synthesis_error\";\n        timestamp: number;\n        metadata?: {\n            interrupted_content?: string;\n            completion_percentage?: number;\n            error_message?: string;\n            [key: string]: unknown;\n        };\n    }): Promise<{\n        status: string;\n        event_id: string;\n    }>;\n    /**\n     * Get Thinker/Talker pipeline status and availability\n     * Returns information about STT, TTS, and LLM services\n     */\n    getTTPipelineStatus(): Promise<{\n        available: boolean;\n        mode: string;\n        services: {\n            stt: {\n                primary: string;\n                fallback: string;\n                status: \"healthy\" | \"degraded\" | \"unavailable\";\n            };\n            tts: {\n                provider: string;\n                status: \"healthy\" | \"degraded\" | \"unavailable\";\n            };\n            llm: {\n                model: string;\n                status: \"healthy\" | \"degraded\" | \"unavailable\";\n            };\n        };\n        latency_targets: {\n            stt_ms: number;\n            llm_first_token_ms: number;\n            tts_ttfb_ms: number;\n            total_ms: number;\n        };\n    }>;\n    /**\n     * Get WebSocket URL for Thinker/Talker voice pipeline\n     * This is the endpoint for the T/T voice WebSocket connection\n     */\n    getTTPipelineWebSocketUrl(): string;\n    /**\n     * Submit T/T pipeline metrics for observability\n     */\n    submitTTPipelineMetrics(metrics: {\n        conversation_id?: string | null;\n        session_id?: string | null;\n        connection_time_ms?: number | null;\n        stt_latency_ms?: number | null;\n        llm_first_token_ms?: number | null;\n        tts_first_audio_ms?: number | null;\n        total_latency_ms?: number | null;\n        session_duration_ms?: number | null;\n        user_utterance_count?: number;\n        ai_response_count?: number;\n        tool_call_count?: number;\n        barge_in_count?: number;\n        reconnect_count?: number;\n        pipeline_mode?: string;\n    }): Promise<{\n        status: string;\n    }>;\n    getOAuthUrl(provider: \"google\" | \"microsoft\"): Promise<string>;\n    handleOAuthCallback(provider: \"google\" | \"microsoft\", code: string): Promise<AuthTokens>;\n    getConversations(page?: number, pageSize?: number): Promise<PaginatedResponse<Conversation>>;\n    getConversation(id: string): Promise<Conversation>;\n    createConversation(title: string): Promise<Conversation>;\n    updateConversation(id: string, updates: UpdateConversationRequest): Promise<Conversation>;\n    archiveConversation(id: string): Promise<Conversation>;\n    unarchiveConversation(id: string): Promise<Conversation>;\n    deleteConversation(id: string): Promise<void>;\n    /**\n     * Delete ALL conversations for the current user.\n     * This is a destructive operation - use with caution.\n     * @returns Object with deleted_count and confirmation message\n     */\n    deleteAllConversations(): Promise<{\n        deleted_count: number;\n        message: string;\n    }>;\n    getMessages(conversationId: string, page?: number, pageSize?: number): Promise<PaginatedResponse<Message>>;\n    /**\n     * Send a message to a conversation\n     * @param conversationId - The conversation ID\n     * @param content - The message content\n     * @param options - Optional parameters including idempotency key\n     */\n    sendMessage(conversationId: string, content: string, options?: {\n        role?: \"user\" | \"assistant\" | \"system\";\n        branchId?: string;\n        parentMessageId?: string;\n        clientMessageId?: string;\n        metadata?: Record<string, any>;\n    }): Promise<Message & {\n        isDuplicate?: boolean;\n    }>;\n    /**\n     * Send an idempotent message to a conversation\n     * Safe to retry - will return existing message if client_message_id already exists\n     * @param conversationId - The conversation ID\n     * @param clientMessageId - Unique client-generated ID for deduplication\n     * @param content - The message content\n     * @param options - Optional parameters\n     */\n    sendIdempotentMessage(conversationId: string, clientMessageId: string, content: string, options?: {\n        role?: \"user\" | \"assistant\" | \"system\";\n        branchId?: string;\n        parentMessageId?: string;\n        metadata?: Record<string, any>;\n    }): Promise<Message & {\n        isDuplicate: boolean;\n    }>;\n    editMessage(conversationId: string, messageId: string, content: string): Promise<Message>;\n    deleteMessage(conversationId: string, messageId: string): Promise<void>;\n    /**\n     * Regenerate a message with custom options\n     * Creates a branch to preserve the original message\n     */\n    regenerateWithOptions(conversationId: string, messageId: string, options: {\n        temperature?: number;\n        lengthPreference?: \"short\" | \"medium\" | \"detailed\";\n        useClinicalContext?: boolean;\n        createBranch?: boolean;\n        clinicalContextId?: string;\n    }): Promise<{\n        message: Message;\n        branchId?: string;\n        originalMessageId: string;\n    }>;\n    createBranch(sessionId: string, request: CreateBranchRequest): Promise<Branch>;\n    listBranches(sessionId: string): Promise<Branch[]>;\n    getBranchMessages(sessionId: string, branchId: string): Promise<Message[]>;\n    searchKnowledgeBase(query: string, limit?: number): Promise<SearchResult[]>;\n    getDocuments(page?: number, pageSize?: number): Promise<PaginatedResponse<Document>>;\n    getDocument(id: string): Promise<Document>;\n    uploadDocument(file: File, category: string): Promise<Document>;\n    deleteDocument(id: string): Promise<void>;\n    getSystemMetrics(): Promise<SystemMetrics>;\n    getAuditLogs(page?: number, pageSize?: number): Promise<PaginatedResponse<AuditLogEntry>>;\n    getUsers(page?: number, pageSize?: number): Promise<PaginatedResponse<User>>;\n    /**\n     * List all documents in the knowledge base (admin only)\n     * @param skip - Number of documents to skip for pagination\n     * @param limit - Maximum number of documents to return\n     * @param sourceType - Optional filter by source type\n     */\n    getAdminKBDocuments(skip?: number, limit?: number, sourceType?: string): Promise<{\n        documents: AdminKBDocument[];\n        total: number;\n    }>;\n    /**\n     * Get details for a specific document (admin only)\n     * @param documentId - Document ID\n     */\n    getAdminKBDocument(documentId: string): Promise<AdminKBDocumentDetail>;\n    /**\n     * Upload and index a document to the knowledge base (admin only)\n     * @param file - File to upload\n     * @param title - Optional document title (defaults to filename)\n     * @param sourceType - Type of source (e.g., \"uploaded\", \"guideline\", \"journal\")\n     * @param onProgress - Optional progress callback\n     */\n    uploadAdminKBDocument(file: File, title?: string, sourceType?: string, onProgress?: (progress: number) => void): Promise<AdminKBUploadResponse>;\n    /**\n     * Delete a document from the knowledge base (admin only)\n     * @param documentId - Document ID to delete\n     */\n    deleteAdminKBDocument(documentId: string): Promise<{\n        document_id: string;\n        status: string;\n        message: string;\n    }>;\n    getFolders(parentId?: string | null): Promise<Folder[]>;\n    getFolderTree(): Promise<Folder[]>;\n    getFolder(id: string): Promise<Folder>;\n    createFolder(request: CreateFolderRequest): Promise<Folder>;\n    updateFolder(id: string, request: UpdateFolderRequest): Promise<Folder>;\n    deleteFolder(id: string): Promise<void>;\n    moveFolder(folderId: string, targetFolderId: string): Promise<Folder>;\n    moveConversationToFolder(conversationId: string, folderId: string | null): Promise<Conversation>;\n    createShareLink(sessionId: string, request: ShareRequest): Promise<ShareResponse>;\n    getSharedConversation(shareToken: string, password?: string): Promise<any>;\n    listShareLinks(sessionId: string): Promise<ShareLink[]>;\n    revokeShareLink(sessionId: string, shareToken: string): Promise<void>;\n    uploadAttachment(messageId: string, file: File, onProgress?: (progress: number) => void): Promise<AttachmentUploadResponse>;\n    listAttachments(messageId: string): Promise<Attachment[]>;\n    deleteAttachment(attachmentId: string): Promise<void>;\n    downloadAttachment(attachmentId: string): Promise<Blob>;\n    getAttachmentUrl(attachmentId: string): string;\n    createClinicalContext(context: ClinicalContextCreate): Promise<ClinicalContext>;\n    getCurrentClinicalContext(sessionId?: string): Promise<ClinicalContext>;\n    getClinicalContext(contextId: string): Promise<ClinicalContext>;\n    updateClinicalContext(contextId: string, update: ClinicalContextUpdate): Promise<ClinicalContext>;\n    deleteClinicalContext(contextId: string): Promise<void>;\n    /**\n     * Get all clinical context presets for the current user\n     * Includes both built-in presets and user-created custom presets\n     */\n    listClinicalPresets(): Promise<ClinicalContextPreset[]>;\n    /**\n     * Get a specific clinical context preset by ID\n     */\n    getClinicalPreset(presetId: string): Promise<ClinicalContextPreset>;\n    /**\n     * Create a new custom clinical context preset\n     */\n    createClinicalPreset(preset: ClinicalPresetCreate): Promise<ClinicalContextPreset>;\n    /**\n     * Update an existing custom clinical context preset\n     * Note: Built-in presets cannot be modified\n     */\n    updateClinicalPreset(presetId: string, update: ClinicalPresetUpdate): Promise<ClinicalContextPreset>;\n    /**\n     * Delete a custom clinical context preset\n     * Note: Built-in presets cannot be deleted\n     */\n    deleteClinicalPreset(presetId: string): Promise<void>;\n    /**\n     * Apply a preset to create or update the current clinical context\n     * Returns the new clinical context\n     */\n    applyClinicalPreset(presetId: string, sessionId?: string): Promise<ClinicalContext>;\n    /**\n     * Export conversation as Markdown\n     * Returns a Blob that can be downloaded\n     */\n    exportConversationAsMarkdown(conversationId: string): Promise<Blob>;\n    /**\n     * Export conversation as PDF\n     * Returns a Blob that can be downloaded\n     */\n    exportConversationAsPdf(conversationId: string): Promise<Blob>;\n    getFeatureFlags(): Promise<FeatureFlag[]>;\n    getFeatureFlag(flagName: string): Promise<FeatureFlag>;\n    createFeatureFlag(flag: CreateFeatureFlagRequest): Promise<FeatureFlag>;\n    updateFeatureFlag(flagName: string, updates: UpdateFeatureFlagRequest): Promise<FeatureFlag>;\n    deleteFeatureFlag(flagName: string): Promise<void>;\n    toggleFeatureFlag(flagName: string): Promise<FeatureFlag>;\n    getCacheStats(): Promise<CacheStats>;\n    clearCache(): Promise<{\n        status: string;\n        message: string;\n    }>;\n    invalidateCachePattern(pattern: string): Promise<{\n        status: string;\n        keys_invalidated: number;\n    }>;\n    /**\n     * List all integrations with their current status\n     */\n    getIntegrations(): Promise<IntegrationSummary[]>;\n    /**\n     * Get detailed information about a specific integration\n     * @param integrationId - Integration identifier (e.g., \"postgres\", \"redis\", \"openai\")\n     */\n    getIntegration(integrationId: string): Promise<IntegrationDetail>;\n    /**\n     * Update configuration for an integration (admin only)\n     * @param integrationId - Integration identifier\n     * @param config - Configuration updates\n     */\n    updateIntegrationConfig(integrationId: string, config: IntegrationConfigUpdate): Promise<IntegrationDetail>;\n    /**\n     * Test connectivity for an integration (admin only)\n     * @param integrationId - Integration identifier\n     */\n    testIntegration(integrationId: string): Promise<IntegrationTestResult>;\n    /**\n     * Get metrics for all integrations\n     */\n    getIntegrationMetrics(): Promise<IntegrationMetrics[]>;\n    /**\n     * Get overall health summary of all integrations\n     */\n    getIntegrationsHealth(): Promise<IntegrationsHealthSummary>;\n    /**\n     * List all PHI detection rules with their current status\n     */\n    getPHIRules(): Promise<PHIRulesResponse>;\n    /**\n     * Get details of a specific PHI detection rule\n     */\n    getPHIRule(ruleId: string): Promise<PHIRule>;\n    /**\n     * Update a PHI detection rule (enable/disable)\n     */\n    updatePHIRule(ruleId: string, update: PHIRuleUpdate): Promise<PHIRule>;\n    /**\n     * Test PHI detection on provided text\n     */\n    testPHIDetection(request: PHITestRequest): Promise<PHITestResult>;\n    /**\n     * Redact PHI from provided text\n     */\n    redactPHI(request: PHITestRequest): Promise<PHIRedactResult>;\n    /**\n     * Get current PHI routing configuration\n     */\n    getPHIRouting(): Promise<PHIRoutingConfig>;\n    /**\n     * Update PHI routing configuration\n     */\n    updatePHIRouting(update: PHIRoutingUpdate): Promise<PHIRoutingConfig>;\n    /**\n     * Get PHI detection statistics\n     */\n    getPHIStats(days?: number): Promise<PHIStats>;\n    /**\n     * Get recent PHI detection events\n     */\n    getPHIEvents(limit?: number, offset?: number): Promise<PHIEventsResponse>;\n    /**\n     * Get PHI detection system health status\n     */\n    getPHIHealth(): Promise<PHIHealthStatus>;\n    /**\n     * List all available AI models with their configuration\n     */\n    getModels(): Promise<ModelInfo[]>;\n    /**\n     * Get detailed information about a specific model\n     */\n    getModel(modelId: string): Promise<ModelInfo & {\n        usage_24h?: any;\n    }>;\n    /**\n     * Get AI model usage metrics and cost tracking\n     */\n    getModelMetrics(days?: number): Promise<ModelUsageMetrics>;\n    /**\n     * Get search analytics and statistics\n     */\n    getSearchStats(days?: number): Promise<SearchStats>;\n    /**\n     * Get embedding database statistics\n     */\n    getEmbeddingStats(): Promise<EmbeddingStats>;\n    /**\n     * Get current model routing configuration\n     */\n    getModelRouting(): Promise<ModelRoutingConfig>;\n    /**\n     * Update model routing configuration\n     */\n    updateModelRouting(update: ModelRoutingUpdate): Promise<{\n        message: string;\n        updates: ModelRoutingUpdate;\n    }>;\n    /**\n     * Get system resource metrics (disk, memory, CPU)\n     */\n    getSystemResources(): Promise<ResourceMetrics>;\n    /**\n     * Get overall system health status\n     */\n    getSystemHealth(): Promise<SystemHealth>;\n    /**\n     * Get current backup status and configuration\n     */\n    getBackupStatus(): Promise<BackupStatus>;\n    /**\n     * Get backup history\n     */\n    getBackupHistory(limit?: number): Promise<{\n        history: BackupHistoryEntry[];\n        total: number;\n    }>;\n    /**\n     * Trigger a manual backup (admin only)\n     */\n    triggerBackup(backupType?: BackupType): Promise<BackupTriggerResult>;\n    /**\n     * Get current maintenance mode status\n     */\n    getMaintenanceStatus(): Promise<MaintenanceStatus>;\n    /**\n     * Enable maintenance mode (admin only)\n     */\n    enableMaintenance(request: MaintenanceRequest): Promise<MaintenanceStatus>;\n    /**\n     * Disable maintenance mode (admin only)\n     */\n    disableMaintenance(): Promise<{\n        enabled: boolean;\n        action: string;\n        disabled_by: string;\n    }>;\n    /**\n     * Get cache statistics by namespace\n     */\n    getCacheNamespaces(): Promise<CacheNamespacesResponse>;\n    /**\n     * Invalidate all cache entries in a specific namespace\n     */\n    invalidateCacheNamespace(namespace: string): Promise<CacheInvalidateResult>;\n    /**\n     * List all conversations across all users (admin only)\n     */\n    getAdminConversations(params?: {\n        limit?: number;\n        offset?: number;\n        user_id?: string;\n        search?: string;\n    }): Promise<{\n        conversations: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * Get a specific conversation with details (admin only)\n     */\n    getAdminConversation(conversationId: string): Promise<{\n        conversation: any;\n    }>;\n    /**\n     * Get messages for a conversation (admin only)\n     */\n    getAdminConversationMessages(conversationId: string, params?: {\n        limit?: number;\n        offset?: number;\n    }): Promise<{\n        messages: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * Export a conversation (admin only)\n     */\n    exportAdminConversation(conversationId: string, format: \"json\" | \"markdown\"): Promise<{\n        export: {\n            content: string;\n            format: string;\n        };\n    }>;\n    /**\n     * List all clinical contexts across all users (admin only)\n     * PHI is masked by default - set includePhi=true to access full data (logged for audit)\n     */\n    getAdminClinicalContexts(params?: {\n        limit?: number;\n        offset?: number;\n        user_id?: string;\n        include_phi?: boolean;\n    }): Promise<{\n        contexts: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * Get a specific clinical context (admin only)\n     * PHI is masked by default - set includePhi=true to access full data (logged for audit)\n     */\n    getAdminClinicalContext(contextId: string, includePhi?: boolean): Promise<{\n        context: any;\n    }>;\n    /**\n     * Get clinical context statistics (admin only)\n     */\n    getAdminClinicalStats(): Promise<any>;\n    /**\n     * Get PHI access audit log (admin only)\n     */\n    getAdminPHIAuditLog(params?: {\n        limit?: number;\n        offset?: number;\n        admin_user_id?: string;\n        context_id?: string;\n    }): Promise<{\n        logs: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * List all active voice sessions (admin only)\n     */\n    getAdminVoiceSessions(): Promise<{\n        sessions: any[];\n        total: number;\n    }>;\n    /**\n     * Get voice metrics (admin only)\n     */\n    getAdminVoiceMetrics(): Promise<any>;\n    /**\n     * Get voice health status (admin only)\n     */\n    getAdminVoiceHealth(): Promise<any>;\n    /**\n     * Get voice configuration (admin only)\n     */\n    getAdminVoiceConfig(): Promise<any>;\n    /**\n     * Disconnect a voice session (admin only)\n     */\n    disconnectAdminVoiceSession(sessionId: string): Promise<void>;\n    /**\n     * List TT pipeline sessions (admin only)\n     */\n    getAdminTTSessions(): Promise<{\n        sessions: any[];\n        total: number;\n    }>;\n    /**\n     * List TT conversation contexts (admin only)\n     */\n    getAdminTTContexts(): Promise<{\n        contexts: any[];\n        total: number;\n    }>;\n    /**\n     * Cleanup expired TT contexts (admin only)\n     */\n    cleanupAdminTTContexts(): Promise<{\n        cleaned_count: number;\n    }>;\n    /**\n     * Get TT quality presets (admin only)\n     */\n    getAdminQualityPresets(): Promise<{\n        presets: any[];\n    }>;\n    /**\n     * Get TT tool analytics (admin only)\n     */\n    getAdminTTAnalytics(): Promise<any>;\n    /**\n     * List all attachments across all users (admin only)\n     */\n    getAdminAttachments(params?: {\n        limit?: number;\n        offset?: number;\n        user_id?: string;\n        file_type?: string;\n    }): Promise<{\n        attachments: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * Get attachment storage statistics (admin only)\n     */\n    getAdminAttachmentStats(days?: number): Promise<any>;\n    /**\n     * Delete an attachment (admin only)\n     */\n    deleteAdminAttachment(attachmentId: string): Promise<void>;\n    /**\n     * Bulk delete attachments (admin only)\n     */\n    bulkDeleteAdminAttachments(attachmentIds: string[]): Promise<{\n        deleted_count: number;\n    }>;\n    /**\n     * Cleanup orphaned attachments (admin only)\n     */\n    cleanupOrphanedAttachments(): Promise<{\n        cleaned_count: number;\n    }>;\n    /**\n     * List all folders across all users (admin only)\n     */\n    getAdminFolders(params?: {\n        limit?: number;\n        offset?: number;\n        user_id?: string;\n    }): Promise<{\n        folders: any[];\n        total: number;\n        limit: number;\n        offset: number;\n    }>;\n    /**\n     * Get folder statistics (admin only)\n     */\n    getAdminFolderStats(): Promise<any>;\n    /**\n     * Delete a folder (admin only)\n     */\n    deleteAdminFolder(folderId: string, recursive?: boolean): Promise<{\n        deleted_folders: number;\n        orphaned_conversations: number;\n    }>;\n}\n\nexport { type AdminKBDocument, type AdminKBDocumentDetail, type AdminKBUploadResponse, type ApiClientConfig, type CacheStats, type CreateFeatureFlagRequest, type FeatureFlag, type TwoFactorRequiredResponse, type UpdateFeatureFlagRequest, VoiceAssistApiClient, VoiceAssistApiClient as default, isTwoFactorRequired };\n"
}
