{
  "path": "services/api-gateway/app/api/admin_feature_flags.py",
  "language": "python",
  "size": 28156,
  "last_modified": "2025-12-04T12:32:40.264Z",
  "lines": 809,
  "content": "\"\"\"Admin Feature Flags API (Phase 7 - P3.1).\n\nProvides admin-only endpoints for managing feature flags.\nRequires admin authentication (RBAC).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.api_envelope import ErrorCodes, error_response, success_response\nfrom app.core.database import get_db\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer\nfrom app.core.logging import get_logger\nfrom app.models.feature_flag import FeatureFlagType\nfrom app.models.user import User\nfrom app.services.feature_flags import feature_flag_service\nfrom app.services.variant_assignment import ScheduledChange, variant_assignment_service\nfrom fastapi import APIRouter, Depends, Query, status\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter(prefix=\"/api/admin/feature-flags\", tags=[\"admin\", \"feature-flags\"])\nlogger = get_logger(__name__)\n\n\n# Request/Response Models\n\n\nclass FeatureFlagCreate(BaseModel):\n    \"\"\"Request model for creating a feature flag.\"\"\"\n\n    name: str = Field(..., description=\"Unique feature flag identifier\", max_length=255)\n    description: str = Field(..., description=\"Human-readable description\")\n    flag_type: FeatureFlagType = Field(default=FeatureFlagType.BOOLEAN, description=\"Type of flag value\")\n    enabled: bool = Field(default=False, description=\"Initial enabled state (for boolean flags)\")\n    value: Optional[Any] = Field(default=None, description=\"Initial value (for non-boolean flags)\")\n    default_value: Optional[Any] = Field(default=None, description=\"Default value when flag not found\")\n    metadata: Optional[Dict] = Field(default=None, description=\"Additional metadata (tags, owner, etc.)\")\n\n\nclass FeatureFlagUpdate(BaseModel):\n    \"\"\"Request model for updating a feature flag.\"\"\"\n\n    enabled: Optional[bool] = Field(default=None, description=\"New enabled state\")\n    value: Optional[Any] = Field(default=None, description=\"New value\")\n    description: Optional[str] = Field(default=None, description=\"New description\")\n    metadata: Optional[Dict] = Field(default=None, description=\"New metadata\")\n\n\nclass FeatureFlagResponse(BaseModel):\n    \"\"\"Response model for feature flag.\"\"\"\n\n    name: str\n    description: str\n    flag_type: str\n    enabled: bool\n    value: Optional[Any]\n    default_value: Optional[Any]\n    created_at: str\n    updated_at: str\n    metadata: Optional[Dict]\n\n\nclass FeatureFlagListResponse(BaseModel):\n    \"\"\"Response model for listing feature flags.\"\"\"\n\n    flags: List[FeatureFlagResponse]\n    total: int\n\n\n# API Endpoints\n\n\n@router.get(\"\", response_model=dict)\nasync def list_feature_flags(\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"List all feature flags.\n\n    Returns all feature flags with their current state.\n\n    Requires: Admin authentication\n    \"\"\"\n    try:\n        flags = await feature_flag_service.list_flags(db)\n\n        flags_data = [flag.to_dict() for flag in flags]\n\n        response = FeatureFlagListResponse(flags=flags_data, total=len(flags_data))\n\n        logger.info(f\"Admin {current_admin_user.email} listed {len(flags_data)} feature flags\")\n\n        return success_response(data=response.model_dump(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to list feature flags: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to list feature flags\")\n\n\n@router.get(\"/{flag_name}\", response_model=dict)\nasync def get_feature_flag(\n    flag_name: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get a specific feature flag.\n\n    Returns detailed information about a feature flag.\n\n    Args:\n        flag_name: Unique feature flag identifier\n\n    Requires: Admin authentication\n    \"\"\"\n    try:\n        flag = await feature_flag_service.get_flag(flag_name, db)\n\n        if not flag:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Feature flag '{flag_name}' not found\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} retrieved feature flag: {flag_name}\")\n\n        return success_response(data=flag.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to get feature flag '{flag_name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to retrieve feature flag\")\n\n\n@router.post(\"\", response_model=dict, status_code=status.HTTP_201_CREATED)\nasync def create_feature_flag(\n    flag_data: FeatureFlagCreate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Create a new feature flag.\n\n    Creates a new feature flag with the specified configuration.\n\n    Args:\n        flag_data: Feature flag configuration\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Check if flag already exists\n        existing_flag = await feature_flag_service.get_flag(flag_data.name, db)\n        if existing_flag:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=f\"Feature flag '{flag_data.name}' already exists\",\n            )\n\n        # Create flag\n        flag = await feature_flag_service.create_flag(\n            name=flag_data.name,\n            description=flag_data.description,\n            flag_type=flag_data.flag_type,\n            enabled=flag_data.enabled,\n            value=flag_data.value,\n            default_value=flag_data.default_value,\n            metadata=flag_data.metadata or {\"created_by\": current_admin_user.email},\n            db=db,\n        )\n\n        if not flag:\n            return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to create feature flag\")\n\n        logger.info(f\"Admin {current_admin_user.email} created feature flag: {flag_data.name}\")\n\n        return success_response(data=flag.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to create feature flag '{flag_data.name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to create feature flag\")\n\n\n@router.patch(\"/{flag_name}\", response_model=dict)\nasync def update_feature_flag(\n    flag_name: str,\n    flag_update: FeatureFlagUpdate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Update an existing feature flag.\n\n    Updates one or more fields of a feature flag.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        flag_update: Fields to update\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Check if flag exists\n        existing_flag = await feature_flag_service.get_flag(flag_name, db)\n        if not existing_flag:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Feature flag '{flag_name}' not found\",\n            )\n\n        # Add update metadata\n        metadata = flag_update.metadata or existing_flag.flag_metadata or {}\n        metadata[\"updated_by\"] = current_admin_user.email\n\n        # Update flag\n        flag = await feature_flag_service.update_flag(\n            name=flag_name,\n            enabled=flag_update.enabled,\n            value=flag_update.value,\n            description=flag_update.description,\n            metadata=metadata,\n            db=db,\n        )\n\n        if not flag:\n            return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to update feature flag\")\n\n        logger.info(f\"Admin {current_admin_user.email} updated feature flag: {flag_name}\")\n\n        return success_response(data=flag.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to update feature flag '{flag_name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to update feature flag\")\n\n\n@router.delete(\"/{flag_name}\", response_model=dict)\nasync def delete_feature_flag(\n    flag_name: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Delete a feature flag.\n\n    Permanently deletes a feature flag.\n\n    Args:\n        flag_name: Unique feature flag identifier\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Check if flag exists\n        existing_flag = await feature_flag_service.get_flag(flag_name, db)\n        if not existing_flag:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Feature flag '{flag_name}' not found\",\n            )\n\n        # Delete flag\n        success = await feature_flag_service.delete_flag(flag_name, db)\n\n        if not success:\n            return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to delete feature flag\")\n\n        logger.info(f\"Admin {current_admin_user.email} deleted feature flag: {flag_name}\")\n\n        return success_response(\n            data={\"message\": f\"Feature flag '{flag_name}' deleted successfully\"},\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(f\"Failed to delete feature flag '{flag_name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to delete feature flag\")\n\n\n@router.post(\"/{flag_name}/toggle\", response_model=dict)\nasync def toggle_feature_flag(\n    flag_name: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Toggle a boolean feature flag.\n\n    Quickly toggle a boolean feature flag between enabled and disabled.\n\n    Args:\n        flag_name: Unique feature flag identifier\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Get current flag\n        existing_flag = await feature_flag_service.get_flag(flag_name, db)\n        if not existing_flag:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Feature flag '{flag_name}' not found\",\n            )\n\n        # Toggle enabled state\n        new_enabled_state = not existing_flag.enabled\n        flag = await feature_flag_service.update_flag(\n            name=flag_name,\n            enabled=new_enabled_state,\n            metadata={\n                **(existing_flag.flag_metadata or {}),\n                \"toggled_by\": current_admin_user.email,\n            },\n            db=db,\n        )\n\n        if not flag:\n            return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to toggle feature flag\")\n\n        logger.info(f\"Admin {current_admin_user.email} toggled feature flag '{flag_name}' \" f\"to {new_enabled_state}\")\n\n        return success_response(data=flag.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to toggle feature flag '{flag_name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to toggle feature flag\")\n\n\n# ============================================================================\n# Scheduled Variant Changes API\n# ============================================================================\n\n\nclass ScheduledChangeCreate(BaseModel):\n    \"\"\"Request model for creating a scheduled variant change.\"\"\"\n\n    scheduled_at: datetime = Field(..., description=\"When to apply the change (ISO 8601 format)\")\n    changes: Dict[str, int] = Field(..., description=\"Variant weight changes: {variant_id: new_weight}\")\n    description: Optional[str] = Field(None, description=\"Description of the change\")\n    timezone_id: str = Field(default=\"UTC\", description=\"IANA timezone identifier\")\n\n\nclass ScheduledChangeUpdate(BaseModel):\n    \"\"\"Request model for updating a scheduled change.\"\"\"\n\n    scheduled_at: Optional[datetime] = Field(None, description=\"New scheduled time\")\n    changes: Optional[Dict[str, int]] = Field(None, description=\"Updated variant weight changes\")\n    description: Optional[str] = Field(None, description=\"Updated description\")\n    timezone_id: Optional[str] = Field(None, description=\"Updated timezone\")\n\n\nclass ScheduledChangeResponse(BaseModel):\n    \"\"\"Response model for a scheduled change.\"\"\"\n\n    id: str\n    flag_name: Optional[str]\n    scheduled_at: Optional[str]\n    changes: Dict[str, int]\n    description: Optional[str]\n    timezone_id: str\n    applied: bool\n    cancelled: bool\n    created_at: Optional[str]\n    created_by: Optional[str]\n    modified_at: Optional[str]\n    modified_by: Optional[str]\n    cancelled_at: Optional[str]\n    cancelled_by: Optional[str]\n\n\n@router.get(\"/{flag_name}/scheduled-changes\", response_model=dict)\nasync def list_scheduled_changes(\n    flag_name: str,\n    include_applied: bool = Query(False, description=\"Include already-applied changes\"),\n    include_cancelled: bool = Query(False, description=\"Include cancelled changes\"),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"List scheduled variant changes for a flag.\n\n    Returns all scheduled changes for a flag, optionally including\n    applied or cancelled changes.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        include_applied: Include changes that have already been applied\n        include_cancelled: Include cancelled changes\n\n    Requires: Admin authentication\n    \"\"\"\n    try:\n        changes = await variant_assignment_service.get_scheduled_changes(\n            flag_name,\n            include_applied=include_applied,\n            include_cancelled=include_cancelled,\n        )\n\n        changes_data = [change.to_dict() for change in changes]\n\n        logger.info(\n            f\"Admin {current_admin_user.email} listed {len(changes_data)} scheduled changes \" f\"for flag {flag_name}\"\n        )\n\n        return success_response(\n            data={\n                \"flag_name\": flag_name,\n                \"scheduled_changes\": changes_data,\n                \"total\": len(changes_data),\n            },\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(f\"Failed to list scheduled changes for '{flag_name}': {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to list scheduled changes\",\n        )\n\n\n@router.post(\n    \"/{flag_name}/scheduled-changes\",\n    response_model=dict,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_scheduled_change(\n    flag_name: str,\n    change_data: ScheduledChangeCreate,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Create a scheduled variant change for a flag.\n\n    Schedules a change to variant weights to be applied at a specific time.\n    Useful for gradual rollouts or timed feature releases.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        change_data: Scheduled change configuration\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Validate scheduled_at is in the future\n        now = datetime.now(timezone.utc)\n        scheduled_at = change_data.scheduled_at\n        if scheduled_at.tzinfo is None:\n            scheduled_at = scheduled_at.replace(tzinfo=timezone.utc)\n\n        if scheduled_at <= now:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=\"Scheduled time must be in the future\",\n            )\n\n        # Create the scheduled change\n        change = ScheduledChange(\n            id=str(uuid.uuid4()),\n            scheduled_at=scheduled_at,\n            changes=change_data.changes,\n            flag_name=flag_name,\n            description=change_data.description,\n            created_by=current_admin_user.email,\n            timezone_id=change_data.timezone_id,\n        )\n\n        success = await variant_assignment_service.save_scheduled_change(flag_name, change)\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to save scheduled change\",\n            )\n\n        logger.info(\n            f\"Admin {current_admin_user.email} created scheduled change {change.id} \"\n            f\"for flag {flag_name} at {scheduled_at.isoformat()}\"\n        )\n\n        return success_response(data=change.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(f\"Failed to create scheduled change for '{flag_name}': {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to create scheduled change\",\n        )\n\n\n@router.get(\"/{flag_name}/scheduled-changes/{change_id}/preview\", response_model=dict)\nasync def preview_scheduled_change(\n    flag_name: str,\n    change_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Preview what a scheduled change would do.\n\n    Shows the before/after state of variants when the change is applied.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        change_id: Scheduled change ID\n\n    Requires: Admin authentication\n    \"\"\"\n    try:\n        # Get the scheduled change\n        changes = await variant_assignment_service.get_scheduled_changes(\n            flag_name, include_applied=True, include_cancelled=True\n        )\n\n        change = next((c for c in changes if c.id == change_id), None)\n        if not change:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Scheduled change '{change_id}' not found\",\n            )\n\n        # Get current flag state to show preview\n        flag = await feature_flag_service.get_flag(flag_name, db)\n        if not flag:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Feature flag '{flag_name}' not found\",\n            )\n\n        # Get variants from flag metadata\n        from app.services.variant_assignment import FlagVariant\n\n        variants_data = flag.flag_metadata.get(\"variants\", []) if flag.flag_metadata else []\n        variants = [FlagVariant.from_dict(v) for v in variants_data]\n\n        # Generate preview\n        preview = change.preview(variants)\n        preview[\"flag_name\"] = flag_name\n        preview[\"flag_enabled\"] = flag.enabled\n        preview[\"status\"] = \"cancelled\" if change.cancelled else (\"applied\" if change.applied else \"pending\")\n\n        logger.info(f\"Admin {current_admin_user.email} previewed scheduled change {change_id} \" f\"for flag {flag_name}\")\n\n        return success_response(data=preview, version=\"2.0.0\")\n    except Exception as e:\n        logger.error(\n            f\"Failed to preview scheduled change '{change_id}' for '{flag_name}': {e}\",\n            exc_info=True,\n        )\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to preview scheduled change\",\n        )\n\n\n@router.patch(\"/{flag_name}/scheduled-changes/{change_id}\", response_model=dict)\nasync def update_scheduled_change(\n    flag_name: str,\n    change_id: str,\n    update_data: ScheduledChangeUpdate,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Update a pending scheduled change.\n\n    Only pending (not applied, not cancelled) changes can be updated.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        change_id: Scheduled change ID\n        update_data: Fields to update\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        # Get the scheduled change\n        changes = await variant_assignment_service.get_scheduled_changes(flag_name)\n        change = next((c for c in changes if c.id == change_id), None)\n\n        if not change:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Scheduled change '{change_id}' not found or already applied/cancelled\",\n            )\n\n        # Update fields\n        if update_data.scheduled_at is not None:\n            scheduled_at = update_data.scheduled_at\n            if scheduled_at.tzinfo is None:\n                scheduled_at = scheduled_at.replace(tzinfo=timezone.utc)\n\n            now = datetime.now(timezone.utc)\n            if scheduled_at <= now:\n                return error_response(\n                    code=ErrorCodes.VALIDATION_ERROR,\n                    message=\"Scheduled time must be in the future\",\n                )\n            change.scheduled_at = scheduled_at\n\n        if update_data.changes is not None:\n            change.changes = update_data.changes\n\n        if update_data.description is not None:\n            change.description = update_data.description\n\n        if update_data.timezone_id is not None:\n            change.timezone_id = update_data.timezone_id\n\n        # Update modification metadata\n        change.modified_at = datetime.now(timezone.utc)\n        change.modified_by = current_admin_user.email\n\n        # Delete old entry and save updated one\n        await variant_assignment_service.delete_scheduled_change(flag_name, change_id)\n        success = await variant_assignment_service.save_scheduled_change(flag_name, change)\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to update scheduled change\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} updated scheduled change {change_id} \" f\"for flag {flag_name}\")\n\n        return success_response(data=change.to_dict(), version=\"2.0.0\")\n    except Exception as e:\n        logger.error(\n            f\"Failed to update scheduled change '{change_id}' for '{flag_name}': {e}\",\n            exc_info=True,\n        )\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to update scheduled change\",\n        )\n\n\n@router.post(\"/{flag_name}/scheduled-changes/{change_id}/cancel\", response_model=dict)\nasync def cancel_scheduled_change(\n    flag_name: str,\n    change_id: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Cancel a scheduled change.\n\n    Marks a scheduled change as cancelled. The change will not be applied.\n    Cancelled changes are kept for audit purposes.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        change_id: Scheduled change ID\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        success = await variant_assignment_service.cancel_scheduled_change(\n            flag_name,\n            change_id,\n            cancelled_by=current_admin_user.email,\n        )\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Scheduled change '{change_id}' not found\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} cancelled scheduled change {change_id} \" f\"for flag {flag_name}\")\n\n        return success_response(\n            data={\"message\": f\"Scheduled change '{change_id}' cancelled successfully\"},\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(\n            f\"Failed to cancel scheduled change '{change_id}' for '{flag_name}': {e}\",\n            exc_info=True,\n        )\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to cancel scheduled change\",\n        )\n\n\n@router.delete(\"/{flag_name}/scheduled-changes/{change_id}\", response_model=dict)\nasync def delete_scheduled_change(\n    flag_name: str,\n    change_id: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Delete a scheduled change permanently.\n\n    Permanently removes a scheduled change. Use cancel instead if you\n    want to keep the change for audit purposes.\n\n    Args:\n        flag_name: Unique feature flag identifier\n        change_id: Scheduled change ID\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        success = await variant_assignment_service.delete_scheduled_change(\n            flag_name,\n            change_id,\n        )\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Scheduled change '{change_id}' not found\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} deleted scheduled change {change_id} \" f\"for flag {flag_name}\")\n\n        return success_response(\n            data={\"message\": f\"Scheduled change '{change_id}' deleted successfully\"},\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(\n            f\"Failed to delete scheduled change '{change_id}' for '{flag_name}': {e}\",\n            exc_info=True,\n        )\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to delete scheduled change\",\n        )\n\n\n@router.get(\"/scheduled-changes/all\", response_model=dict)\nasync def list_all_scheduled_changes(\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"List all pending scheduled changes across all flags.\n\n    Returns a summary of all pending scheduled changes grouped by flag.\n    Useful for viewing upcoming changes in the admin dashboard.\n\n    Requires: Admin authentication\n    \"\"\"\n    try:\n        all_changes = await variant_assignment_service.get_all_pending_scheduled_changes()\n\n        # Format response\n        changes_summary = []\n        total_pending = 0\n        for flag_name, changes in all_changes.items():\n            for change in changes:\n                total_pending += 1\n                changes_summary.append(\n                    {\n                        \"flag_name\": flag_name,\n                        **change.to_dict(),\n                    }\n                )\n\n        # Sort by scheduled_at\n        changes_summary.sort(\n            key=lambda c: c.get(\"scheduled_at\") or \"\",\n        )\n\n        logger.info(f\"Admin {current_admin_user.email} listed {total_pending} pending scheduled changes\")\n\n        return success_response(\n            data={\n                \"scheduled_changes\": changes_summary,\n                \"total\": total_pending,\n                \"flags_with_changes\": len(all_changes),\n            },\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(f\"Failed to list all scheduled changes: {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to list scheduled changes\",\n        )\n\n\n@router.post(\"/{flag_name}/invalidate-cache\", response_model=dict)\nasync def invalidate_flag_cache(\n    flag_name: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Invalidate cached variant assignments for a flag.\n\n    Forces all users to be re-evaluated against current variant configuration.\n    Use this after making manual changes to variant weights.\n\n    Args:\n        flag_name: Unique feature flag identifier\n\n    Requires: Admin authentication\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n    try:\n        invalidated = await variant_assignment_service.invalidate_bucket_cache_for_flag(flag_name)\n\n        logger.info(\n            f\"Admin {current_admin_user.email} invalidated {invalidated} cache entries \" f\"for flag {flag_name}\"\n        )\n\n        return success_response(\n            data={\n                \"flag_name\": flag_name,\n                \"cache_entries_invalidated\": invalidated,\n            },\n            version=\"2.0.0\",\n        )\n    except Exception as e:\n        logger.error(f\"Failed to invalidate cache for '{flag_name}': {e}\", exc_info=True)\n        return error_response(\n            code=ErrorCodes.INTERNAL_ERROR,\n            message=\"Failed to invalidate cache\",\n        )\n"
}
