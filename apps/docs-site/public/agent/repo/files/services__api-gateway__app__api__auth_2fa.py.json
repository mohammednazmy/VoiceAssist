{
  "path": "services/api-gateway/app/api/auth_2fa.py",
  "language": "python",
  "size": 12752,
  "last_modified": "2025-12-04T11:26:47.062Z",
  "lines": 418,
  "content": "\"\"\"\nTwo-Factor Authentication (2FA) API endpoints.\n\nProvides endpoints for:\n- Setting up 2FA with TOTP\n- Verifying 2FA codes during login\n- Disabling 2FA\n- Managing backup codes\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom typing import Optional\n\nfrom app.core.business_metrics import user_logins_total\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.core.security import create_access_token, create_refresh_token, verify_password\nfrom app.models.user import User\nfrom app.schemas.auth import TokenResponse\nfrom app.services.admin_audit_log_service import admin_audit_log_service\nfrom app.services.two_factor import two_factor_service\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\nfrom pydantic import BaseModel, Field\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter(prefix=\"/api/auth/2fa\", tags=[\"two-factor-authentication\"])\nlimiter = Limiter(key_func=get_remote_address)\n\n\n# Request/Response schemas\nclass TwoFactorStatusResponse(BaseModel):\n    \"\"\"2FA status for the current user.\"\"\"\n\n    enabled: bool\n    verified_at: Optional[str] = None\n    backup_codes_remaining: int = 0\n\n\nclass TwoFactorSetupResponse(BaseModel):\n    \"\"\"Response for 2FA setup initiation.\"\"\"\n\n    qr_code: str = Field(..., description=\"Base64-encoded QR code PNG\")\n    manual_entry_key: str = Field(..., description=\"Secret for manual entry\")\n    backup_codes: list[str] = Field(..., description=\"One-time backup codes\")\n\n\nclass TwoFactorVerifyRequest(BaseModel):\n    \"\"\"Request to verify/enable 2FA.\"\"\"\n\n    code: str = Field(..., min_length=6, max_length=6, pattern=r\"^\\d{6}$\")\n\n\nclass TwoFactorDisableRequest(BaseModel):\n    \"\"\"Request to disable 2FA.\"\"\"\n\n    password: str\n    code: str = Field(..., description=\"TOTP code or backup code\")\n\n\nclass TwoFactorBackupCodesResponse(BaseModel):\n    \"\"\"Response with regenerated backup codes.\"\"\"\n\n    backup_codes: list[str]\n    message: str\n\n\nclass TwoFactorLoginVerifyRequest(BaseModel):\n    \"\"\"Request to verify 2FA during login.\"\"\"\n\n    user_id: str\n    code: str = Field(..., description=\"TOTP code or backup code\")\n    is_backup_code: bool = False\n\n\n@router.get(\"/status\", response_model=TwoFactorStatusResponse)\nasync def get_2fa_status(\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Get 2FA status for the current user.\n\n    Returns whether 2FA is enabled and backup code count.\n    \"\"\"\n    backup_count = 0\n    if current_user.totp_enabled and current_user.totp_backup_codes:\n        codes = two_factor_service.decrypt_backup_codes(current_user.totp_backup_codes)\n        backup_count = len(codes)\n\n    return TwoFactorStatusResponse(\n        enabled=current_user.totp_enabled,\n        verified_at=(current_user.totp_verified_at.isoformat() if current_user.totp_verified_at else None),\n        backup_codes_remaining=backup_count,\n    )\n\n\n@router.post(\"/setup\", response_model=TwoFactorSetupResponse)\n@limiter.limit(\"5/hour\")\nasync def setup_2fa(\n    request: Request,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Start 2FA setup for the current user.\n\n    Returns QR code and backup codes. User must verify with a TOTP code\n    to complete setup.\n\n    Rate limit: 5 attempts per hour\n    \"\"\"\n    if current_user.totp_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA is already enabled. Disable it first to reconfigure.\",\n        )\n\n    # Generate 2FA setup data\n    setup_data = two_factor_service.setup_2fa(current_user.email)\n\n    # Store encrypted secret temporarily (not enabled until verified)\n    current_user.totp_secret = setup_data[\"encrypted_secret\"]\n    current_user.totp_backup_codes = setup_data[\"encrypted_backup_codes\"]\n    db.commit()\n\n    return TwoFactorSetupResponse(\n        qr_code=setup_data[\"qr_code\"],\n        manual_entry_key=setup_data[\"secret\"],\n        backup_codes=setup_data[\"backup_codes\"],\n    )\n\n\n@router.post(\"/verify\")\n@limiter.limit(\"10/minute\")\nasync def verify_2fa(\n    request: Request,\n    verify_request: TwoFactorVerifyRequest,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Verify TOTP code to complete 2FA setup.\n\n    After successful verification, 2FA will be enabled for the account.\n\n    Rate limit: 10 attempts per minute\n    \"\"\"\n    if current_user.totp_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA is already enabled\",\n        )\n\n    if not current_user.totp_secret:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA setup not started. Call /setup first.\",\n        )\n\n    # Decrypt secret and verify code\n    secret = two_factor_service.decrypt_secret(current_user.totp_secret)\n    is_valid = two_factor_service.verify_code(secret, verify_request.code)\n\n    if not is_valid:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid verification code. Please try again.\",\n        )\n\n    # Enable 2FA\n    current_user.totp_enabled = True\n    current_user.totp_verified_at = datetime.now(timezone.utc)\n    db.commit()\n\n    # Log 2FA enabled\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=current_user,\n        action=\"auth.2fa_enabled\",\n        target_type=\"user\",\n        target_id=str(current_user.id),\n        success=True,\n        request=request,\n    )\n\n    return {\n        \"message\": \"2FA has been enabled successfully\",\n        \"enabled\": True,\n        \"verified_at\": current_user.totp_verified_at.isoformat(),\n    }\n\n\n@router.post(\"/disable\")\n@limiter.limit(\"5/hour\")\nasync def disable_2fa(\n    request: Request,\n    disable_request: TwoFactorDisableRequest,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Disable 2FA for the current user.\n\n    Requires password and a valid TOTP code or backup code.\n\n    Rate limit: 5 attempts per hour\n    \"\"\"\n    if not current_user.totp_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA is not enabled\",\n        )\n\n    # Verify password\n    if not verify_password(disable_request.password, current_user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid password\",\n        )\n\n    # Verify TOTP code or backup code\n    secret = two_factor_service.decrypt_secret(current_user.totp_secret)\n    code = disable_request.code.strip()\n\n    # Check if it's a backup code (format: XXXX-XXXX or XXXXXXXX)\n    is_backup_code = len(code.replace(\"-\", \"\")) == 8\n\n    if is_backup_code:\n        is_valid, _ = two_factor_service.verify_backup_code(current_user.totp_backup_codes, code)\n    else:\n        is_valid = two_factor_service.verify_code(secret, code)\n\n    if not is_valid:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid verification code\",\n        )\n\n    # Disable 2FA\n    current_user.totp_enabled = False\n    current_user.totp_secret = None\n    current_user.totp_backup_codes = None\n    current_user.totp_verified_at = None\n    db.commit()\n\n    # Log 2FA disabled\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=current_user,\n        action=\"auth.2fa_disabled\",\n        target_type=\"user\",\n        target_id=str(current_user.id),\n        success=True,\n        metadata={\"method\": \"backup_code\" if is_backup_code else \"totp\"},\n        request=request,\n    )\n\n    return {\"message\": \"2FA has been disabled successfully\", \"enabled\": False}\n\n\n@router.post(\"/backup-codes\", response_model=TwoFactorBackupCodesResponse)\n@limiter.limit(\"3/hour\")\nasync def regenerate_backup_codes(\n    request: Request,\n    verify_request: TwoFactorVerifyRequest,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Regenerate backup codes for the current user.\n\n    Requires a valid TOTP code. Previous backup codes will be invalidated.\n\n    Rate limit: 3 attempts per hour\n    \"\"\"\n    if not current_user.totp_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA is not enabled\",\n        )\n\n    # Verify TOTP code\n    secret = two_factor_service.decrypt_secret(current_user.totp_secret)\n    if not two_factor_service.verify_code(secret, verify_request.code):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid verification code\",\n        )\n\n    # Generate new backup codes\n    new_codes = two_factor_service.generate_backup_codes()\n    current_user.totp_backup_codes = two_factor_service.encrypt_backup_codes(new_codes)\n    db.commit()\n\n    return TwoFactorBackupCodesResponse(\n        backup_codes=new_codes,\n        message=\"New backup codes generated. Previous codes are now invalid.\",\n    )\n\n\n@router.post(\"/verify-login\", response_model=TokenResponse)\n@limiter.limit(\"10/minute\")\nasync def verify_2fa_login(\n    request: Request,\n    verify_request: TwoFactorLoginVerifyRequest,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Verify 2FA code during login flow and issue tokens.\n\n    This endpoint is called after successful password authentication\n    when the user has 2FA enabled. Returns JWT tokens on success.\n\n    Rate limit: 10 attempts per minute\n    \"\"\"\n    # Find user\n    user = db.query(User).filter(User.id == verify_request.user_id).first()\n\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\",\n        )\n\n    if not user.totp_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA is not enabled for this user\",\n        )\n\n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User account is inactive\",\n        )\n\n    code = verify_request.code.strip()\n\n    if verify_request.is_backup_code:\n        # Verify backup code\n        is_valid, new_encrypted_codes = two_factor_service.verify_backup_code(user.totp_backup_codes, code)\n        if is_valid:\n            # Update backup codes (remove used one)\n            user.totp_backup_codes = new_encrypted_codes\n            db.commit()\n    else:\n        # Verify TOTP code\n        secret = two_factor_service.decrypt_secret(user.totp_secret)\n        is_valid = two_factor_service.verify_code(secret, code)\n\n    if not is_valid:\n        # Log failed 2FA verification\n        admin_audit_log_service.log_action(\n            db=db,\n            actor=user,\n            action=\"auth.2fa_verify_failed\",\n            target_type=\"user\",\n            target_id=str(user.id),\n            success=False,\n            metadata={\"method\": \"backup_code\" if verify_request.is_backup_code else \"totp\"},\n            request=request,\n        )\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid verification code\",\n        )\n\n    # Update last login timestamp\n    user.last_login = datetime.now(timezone.utc)\n    db.commit()\n\n    # Track login metric\n    user_logins_total.inc()\n\n    # Log successful 2FA login\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=user,\n        action=\"auth.login_success\",\n        target_type=\"user\",\n        target_id=str(user.id),\n        success=True,\n        metadata={\n            \"method\": \"password+2fa\",\n            \"2fa_method\": \"backup_code\" if verify_request.is_backup_code else \"totp\",\n        },\n        request=request,\n    )\n\n    # Create tokens\n    token_role = user.admin_role or (\"admin\" if user.is_admin else \"user\")\n    password_epoch = int(\n        user.password_changed_at.replace(tzinfo=timezone.utc).timestamp()\n        if user.password_changed_at.tzinfo is None\n        else user.password_changed_at.timestamp()\n    )\n\n    base_claims = {\n        \"sub\": str(user.id),\n        \"email\": user.email,\n        \"role\": token_role,\n        \"pwd\": password_epoch,\n    }\n    access_token = create_access_token(data=base_claims)\n    refresh_token = create_refresh_token(data=base_claims)\n\n    return TokenResponse(\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=\"bearer\",\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n        refresh_expires_in=settings.REFRESH_TOKEN_EXPIRE_MINUTES * 60,\n        role=token_role,\n    )\n"
}
