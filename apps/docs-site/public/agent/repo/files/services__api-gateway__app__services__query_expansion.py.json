{
  "path": "services/api-gateway/app/services/query_expansion.py",
  "language": "python",
  "size": 19031,
  "last_modified": "2025-12-04T11:26:59.576Z",
  "lines": 549,
  "content": "\"\"\"\nQuery Expansion Service (Phase 5 - Advanced RAG)\n\nImproves search recall by expanding queries with related terms.\n\nFeatures:\n- Medical abbreviation expansion\n- Synonym expansion using medical thesaurus\n- LLM-based query reformulation\n- Query decomposition for multi-aspect questions\n- UMLS concept linking for terminology standardization\n\nQuery expansion techniques:\n1. Lexical: Add synonyms and related terms\n2. Semantic: Use embeddings to find similar terms\n3. Knowledge-based: Use medical ontologies (UMLS, SNOMED)\n4. Neural: Use LLM to reformulate queries\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport re\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Set\n\nfrom app.services.cache_service import cache_service, generate_cache_key\nfrom openai import AsyncOpenAI\n\nlogger = logging.getLogger(__name__)\n\n# Shared async OpenAI client\n_async_openai_client: AsyncOpenAI | None = None\n\n\ndef get_async_openai_client() -> AsyncOpenAI:\n    \"\"\"Get or create async OpenAI client.\"\"\"\n    global _async_openai_client\n    if _async_openai_client is None:\n        _async_openai_client = AsyncOpenAI()\n    return _async_openai_client\n\n\nclass ExpansionMethod(str, Enum):\n    \"\"\"Query expansion methods.\"\"\"\n\n    ABBREVIATION = \"abbreviation\"\n    SYNONYM = \"synonym\"\n    LLM_REFORMULATION = \"llm_reformulation\"\n    DECOMPOSITION = \"decomposition\"\n    UMLS = \"umls\"\n\n\n@dataclass\nclass ExpandedQuery:\n    \"\"\"Result of query expansion.\"\"\"\n\n    original_query: str\n    expanded_query: str\n    expansion_terms: List[str] = field(default_factory=list)\n    sub_queries: List[str] = field(default_factory=list)\n    method: str = \"none\"\n    confidence: float = 1.0\n\n\n@dataclass\nclass QueryExpansionConfig:\n    \"\"\"Configuration for query expansion.\"\"\"\n\n    enable_abbreviation: bool = True\n    enable_synonym: bool = True\n    enable_llm: bool = False  # Disabled by default (costs tokens)\n    enable_decomposition: bool = True\n    max_expansion_terms: int = 5\n    synonym_confidence_threshold: float = 0.8\n    cache_ttl: int = 3600\n\n\n# Medical abbreviation dictionary\nMEDICAL_ABBREVIATIONS: Dict[str, List[str]] = {\n    # Cardiovascular\n    \"mi\": [\"myocardial infarction\", \"heart attack\"],\n    \"cad\": [\"coronary artery disease\"],\n    \"chf\": [\"congestive heart failure\", \"heart failure\"],\n    \"htn\": [\"hypertension\", \"high blood pressure\"],\n    \"afib\": [\"atrial fibrillation\", \"a-fib\"],\n    \"svt\": [\"supraventricular tachycardia\"],\n    \"vt\": [\"ventricular tachycardia\"],\n    \"vf\": [\"ventricular fibrillation\"],\n    \"av\": [\"atrioventricular\"],\n    \"bp\": [\"blood pressure\"],\n    \"hr\": [\"heart rate\"],\n    \"ecg\": [\"electrocardiogram\", \"ekg\"],\n    \"lvef\": [\"left ventricular ejection fraction\"],\n    \"cabg\": [\"coronary artery bypass graft\", \"bypass surgery\"],\n    \"pci\": [\"percutaneous coronary intervention\", \"angioplasty\"],\n    \"stemi\": [\"st-elevation myocardial infarction\"],\n    \"nstemi\": [\"non-st-elevation myocardial infarction\"],\n    # Respiratory\n    \"copd\": [\"chronic obstructive pulmonary disease\"],\n    \"sob\": [\"shortness of breath\", \"dyspnea\"],\n    \"pe\": [\"pulmonary embolism\"],\n    \"ards\": [\"acute respiratory distress syndrome\"],\n    \"cxr\": [\"chest x-ray\", \"chest radiograph\"],\n    \"ct\": [\"computed tomography\"],\n    \"pft\": [\"pulmonary function test\"],\n    \"fev1\": [\"forced expiratory volume in 1 second\"],\n    \"fvc\": [\"forced vital capacity\"],\n    # Neurological\n    \"cva\": [\"cerebrovascular accident\", \"stroke\"],\n    \"tia\": [\"transient ischemic attack\", \"mini-stroke\"],\n    \"ms\": [\"multiple sclerosis\"],\n    \"als\": [\"amyotrophic lateral sclerosis\", \"lou gehrig's disease\"],\n    \"lp\": [\"lumbar puncture\", \"spinal tap\"],\n    \"mri\": [\"magnetic resonance imaging\"],\n    \"eeg\": [\"electroencephalogram\"],\n    \"loc\": [\"loss of consciousness\"],\n    \"gcs\": [\"glasgow coma scale\"],\n    # Gastrointestinal\n    \"gerd\": [\"gastroesophageal reflux disease\", \"acid reflux\"],\n    \"ibs\": [\"irritable bowel syndrome\"],\n    \"ibd\": [\"inflammatory bowel disease\"],\n    \"uc\": [\"ulcerative colitis\"],\n    \"gi\": [\"gastrointestinal\"],\n    \"npo\": [\"nothing by mouth\", \"nil per os\"],\n    \"lfts\": [\"liver function tests\"],\n    \"ercp\": [\"endoscopic retrograde cholangiopancreatography\"],\n    # Endocrine\n    \"dm\": [\"diabetes mellitus\", \"diabetes\"],\n    \"t1dm\": [\"type 1 diabetes mellitus\"],\n    \"t2dm\": [\"type 2 diabetes mellitus\"],\n    \"hba1c\": [\"hemoglobin a1c\", \"glycated hemoglobin\"],\n    \"dka\": [\"diabetic ketoacidosis\"],\n    \"tsh\": [\"thyroid stimulating hormone\"],\n    \"t3\": [\"triiodothyronine\"],\n    \"t4\": [\"thyroxine\"],\n    # Renal\n    \"ckd\": [\"chronic kidney disease\"],\n    \"aki\": [\"acute kidney injury\"],\n    \"esrd\": [\"end-stage renal disease\"],\n    \"gfr\": [\"glomerular filtration rate\"],\n    \"egfr\": [\"estimated glomerular filtration rate\"],\n    \"bun\": [\"blood urea nitrogen\"],\n    \"creatinine\": [\"cr\", \"creat\"],\n    \"hd\": [\"hemodialysis\"],\n    \"pd\": [\"peritoneal dialysis\"],\n    # Infectious Disease\n    \"uti\": [\"urinary tract infection\"],\n    \"uri\": [\"upper respiratory infection\"],\n    \"lrti\": [\"lower respiratory tract infection\"],\n    \"cap\": [\"community-acquired pneumonia\"],\n    \"hap\": [\"hospital-acquired pneumonia\"],\n    \"mrsa\": [\"methicillin-resistant staphylococcus aureus\"],\n    \"vre\": [\"vancomycin-resistant enterococcus\"],\n    \"hiv\": [\"human immunodeficiency virus\"],\n    \"aids\": [\"acquired immunodeficiency syndrome\"],\n    \"tb\": [\"tuberculosis\"],\n    # Hematology/Oncology\n    \"wbc\": [\"white blood cell\", \"leukocyte\"],\n    \"rbc\": [\"red blood cell\", \"erythrocyte\"],\n    \"plt\": [\"platelet\", \"thrombocyte\"],\n    \"hgb\": [\"hemoglobin\"],\n    \"hct\": [\"hematocrit\"],\n    \"inr\": [\"international normalized ratio\"],\n    \"pt\": [\"prothrombin time\"],\n    \"ptt\": [\"partial thromboplastin time\"],\n    \"dvt\": [\"deep vein thrombosis\"],\n    \"aml\": [\"acute myeloid leukemia\"],\n    \"all\": [\"acute lymphoblastic leukemia\"],\n    \"cll\": [\"chronic lymphocytic leukemia\"],\n    \"cml\": [\"chronic myeloid leukemia\"],\n    # Musculoskeletal\n    \"ra\": [\"rheumatoid arthritis\"],\n    \"oa\": [\"osteoarthritis\"],\n    \"sle\": [\"systemic lupus erythematosus\", \"lupus\"],\n    \"rom\": [\"range of motion\"],\n    \"orif\": [\"open reduction internal fixation\"],\n    # Medications\n    \"nsaid\": [\"non-steroidal anti-inflammatory drug\", \"ibuprofen\", \"naproxen\"],\n    \"ace\": [\"angiotensin converting enzyme inhibitor\", \"ace inhibitor\"],\n    \"arb\": [\"angiotensin receptor blocker\"],\n    \"bb\": [\"beta blocker\"],\n    \"ccb\": [\"calcium channel blocker\"],\n    \"ssri\": [\"selective serotonin reuptake inhibitor\"],\n    \"snri\": [\"serotonin-norepinephrine reuptake inhibitor\"],\n    \"tca\": [\"tricyclic antidepressant\"],\n    \"ppi\": [\"proton pump inhibitor\"],\n    \"abx\": [\"antibiotics\"],\n    \"pcn\": [\"penicillin\"],\n    \"prn\": [\"as needed\", \"pro re nata\"],\n    \"bid\": [\"twice daily\"],\n    \"tid\": [\"three times daily\"],\n    \"qid\": [\"four times daily\"],\n    \"qd\": [\"once daily\"],\n    \"qhs\": [\"at bedtime\"],\n    \"po\": [\"by mouth\", \"oral\"],\n    \"iv\": [\"intravenous\"],\n    \"im\": [\"intramuscular\"],\n    \"sq\": [\"subcutaneous\"],\n    # Clinical Findings\n    \"cp\": [\"chest pain\"],\n    \"ha\": [\"headache\"],\n    \"n/v\": [\"nausea and vomiting\"],\n    \"abd\": [\"abdominal\"],\n    \"r/o\": [\"rule out\"],\n    \"h/o\": [\"history of\"],\n    \"s/p\": [\"status post\"],\n    \"c/o\": [\"complaining of\"],\n    \"hpi\": [\"history of present illness\"],\n    \"pmh\": [\"past medical history\"],\n    \"psh\": [\"past surgical history\"],\n    \"fh\": [\"family history\"],\n    \"sh\": [\"social history\"],\n    \"ros\": [\"review of systems\"],\n    \"phys_exam\": [\"physical exam\", \"physical examination\"],\n    \"a/p\": [\"assessment and plan\"],\n    \"dx\": [\"diagnosis\"],\n    \"ddx\": [\"differential diagnosis\"],\n    \"tx\": [\"treatment\"],\n    \"rx\": [\"prescription\"],\n    \"f/u\": [\"follow up\"],\n}\n\n# Medical synonyms (simplified)\nMEDICAL_SYNONYMS: Dict[str, List[str]] = {\n    \"pain\": [\"ache\", \"discomfort\", \"soreness\", \"tenderness\"],\n    \"fever\": [\"pyrexia\", \"elevated temperature\", \"febrile\"],\n    \"swelling\": [\"edema\", \"oedema\", \"inflammation\"],\n    \"rash\": [\"eruption\", \"exanthem\", \"dermatitis\"],\n    \"fatigue\": [\"tiredness\", \"exhaustion\", \"weakness\", \"malaise\"],\n    \"nausea\": [\"queasiness\", \"stomach upset\"],\n    \"vomiting\": [\"emesis\", \"throwing up\"],\n    \"diarrhea\": [\"loose stools\", \"frequent bowel movements\"],\n    \"constipation\": [\"hard stools\", \"infrequent bowel movements\"],\n    \"cough\": [\"tussis\"],\n    \"headache\": [\"cephalalgia\", \"head pain\"],\n    \"dizziness\": [\"vertigo\", \"lightheadedness\"],\n    \"infection\": [\"sepsis\", \"infectious disease\"],\n    \"inflammation\": [\"swelling\", \"inflammatory response\"],\n    \"bleeding\": [\"hemorrhage\", \"haemorrhage\"],\n    \"cancer\": [\"malignancy\", \"neoplasm\", \"tumor\", \"tumour\"],\n    \"heart attack\": [\"myocardial infarction\", \"mi\"],\n    \"stroke\": [\"cva\", \"cerebrovascular accident\"],\n    \"high blood pressure\": [\"hypertension\", \"htn\"],\n    \"diabetes\": [\"dm\", \"diabetes mellitus\"],\n    \"kidney disease\": [\"renal disease\", \"nephropathy\"],\n    \"liver disease\": [\"hepatic disease\", \"hepatopathy\"],\n}\n\n\nclass QueryExpansionService:\n    \"\"\"\n    Main query expansion service.\n\n    Orchestrates different expansion methods to improve search recall.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[QueryExpansionConfig] = None,\n    ):\n        self.config = config or QueryExpansionConfig()\n        self._llm_client = None\n\n    async def expand(\n        self,\n        query: str,\n        methods: Optional[List[ExpansionMethod]] = None,\n    ) -> ExpandedQuery:\n        \"\"\"\n        Expand a query using configured methods.\n\n        Args:\n            query: Original search query\n            methods: Specific methods to use (default: all enabled)\n\n        Returns:\n            Expanded query with additional terms\n        \"\"\"\n        # Check cache\n        cache_key = generate_cache_key(\"query_expansion\", query)\n        cached = await cache_service.get(cache_key)\n        if cached is not None:\n            return ExpandedQuery(**cached)\n\n        # Determine methods to use\n        if methods is None:\n            methods = []\n            if self.config.enable_abbreviation:\n                methods.append(ExpansionMethod.ABBREVIATION)\n            if self.config.enable_synonym:\n                methods.append(ExpansionMethod.SYNONYM)\n            if self.config.enable_llm:\n                methods.append(ExpansionMethod.LLM_REFORMULATION)\n\n        # Apply expansions\n        expansion_terms: Set[str] = set()\n        expanded_query = query\n\n        if ExpansionMethod.ABBREVIATION in methods:\n            abbrev_terms = self._expand_abbreviations(query)\n            expansion_terms.update(abbrev_terms)\n\n        if ExpansionMethod.SYNONYM in methods:\n            synonym_terms = self._expand_synonyms(query)\n            expansion_terms.update(synonym_terms)\n\n        if ExpansionMethod.LLM_REFORMULATION in methods:\n            llm_result = await self._llm_reformulation(query)\n            if llm_result:\n                expansion_terms.update(llm_result)\n\n        # Limit expansion terms\n        expansion_list = list(expansion_terms)[: self.config.max_expansion_terms]\n\n        # Build expanded query\n        if expansion_list:\n            expanded_query = f\"{query} {' '.join(expansion_list)}\"\n\n        result = ExpandedQuery(\n            original_query=query,\n            expanded_query=expanded_query,\n            expansion_terms=expansion_list,\n            method=\",\".join(m.value for m in methods),\n        )\n\n        # Cache result\n        await cache_service.set(\n            cache_key,\n            {\n                \"original_query\": result.original_query,\n                \"expanded_query\": result.expanded_query,\n                \"expansion_terms\": result.expansion_terms,\n                \"sub_queries\": result.sub_queries,\n                \"method\": result.method,\n                \"confidence\": result.confidence,\n            },\n            ttl=self.config.cache_ttl,\n        )\n\n        return result\n\n    def _expand_abbreviations(self, query: str) -> List[str]:\n        \"\"\"Expand medical abbreviations in query.\"\"\"\n        expansions = []\n        query_lower = query.lower()\n        words = re.findall(r\"\\b[a-z0-9]+\\b\", query_lower)\n\n        for word in words:\n            if word in MEDICAL_ABBREVIATIONS:\n                expansions.extend(MEDICAL_ABBREVIATIONS[word])\n\n        return expansions\n\n    def _expand_synonyms(self, query: str) -> List[str]:\n        \"\"\"Expand with synonyms.\"\"\"\n        expansions = []\n        query_lower = query.lower()\n\n        for term, synonyms in MEDICAL_SYNONYMS.items():\n            if term in query_lower:\n                # Add synonyms (limit to avoid query explosion)\n                expansions.extend(synonyms[:2])\n\n        return expansions\n\n    async def _llm_reformulation(self, query: str) -> List[str]:\n        \"\"\"Use LLM to suggest query reformulations.\"\"\"\n        try:\n            prompt = (\n                \"Given the medical search query below, suggest 3 alternative \"\n                \"phrasings or related terms that might help find relevant information.\\n\\n\"\n                f\"Query: {query}\\n\\n\"\n                \"Provide only the alternative terms/phrasings, one per line, \"\n                \"without numbering or explanations:\"\n            )\n\n            client = get_async_openai_client()\n            response = await client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                max_tokens=100,\n                temperature=0.3,\n            )\n\n            suggestions = response.choices[0].message.content.strip().split(\"\\n\")\n            return [s.strip() for s in suggestions if s.strip() and len(s.strip()) > 3]\n\n        except Exception as e:\n            logger.error(f\"LLM reformulation error: {e}\")\n            return []\n\n    async def decompose(self, query: str) -> List[str]:\n        \"\"\"\n        Decompose a complex query into sub-queries.\n\n        Useful for multi-aspect questions like:\n        \"What are the symptoms, causes, and treatment of diabetes?\"\n        \"\"\"\n        # Check cache\n        cache_key = generate_cache_key(\"query_decomposition\", query)\n        cached = await cache_service.get(cache_key)\n        if cached is not None:\n            return cached\n\n        # Simple rule-based decomposition\n        sub_queries = []\n\n        # Check for conjunctions\n        conjunction_patterns = [\n            r\"\\band\\b\",\n            r\"\\bor\\b\",\n            r\",\\s*(?:and|or)?\\s*\",\n        ]\n\n        # Check for question words\n        question_words = [\"what\", \"how\", \"why\", \"when\", \"where\", \"which\"]\n        has_multiple_questions = sum(1 for w in question_words if w in query.lower()) > 1\n\n        # If complex query, use LLM decomposition\n        if has_multiple_questions or any(re.search(p, query, re.I) for p in conjunction_patterns):\n            sub_queries = await self._llm_decomposition(query)\n\n        if not sub_queries:\n            sub_queries = [query]\n\n        # Cache\n        await cache_service.set(cache_key, sub_queries, ttl=self.config.cache_ttl)\n\n        return sub_queries\n\n    async def _llm_decomposition(self, query: str) -> List[str]:\n        \"\"\"Use LLM to decompose complex query.\"\"\"\n        try:\n            prompt = (\n                \"Break down this complex medical question into simpler sub-questions \"\n                \"that can be searched separately.\\n\\n\"\n                f\"Complex question: {query}\\n\\n\"\n                \"Provide the sub-questions, one per line. \"\n                \"If the question is already simple, just return it as-is:\"\n            )\n\n            client = get_async_openai_client()\n            response = await client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                max_tokens=200,\n                temperature=0.2,\n            )\n\n            sub_queries = response.choices[0].message.content.strip().split(\"\\n\")\n            return [q.strip() for q in sub_queries if q.strip() and len(q.strip()) > 10]\n\n        except Exception as e:\n            logger.error(f\"LLM decomposition error: {e}\")\n            return []\n\n    async def normalize_terminology(self, query: str) -> str:\n        \"\"\"\n        Normalize medical terminology to standard forms.\n\n        In production, this would use UMLS for concept normalization.\n        \"\"\"\n        normalized = query\n\n        # Simple normalization rules\n        normalizations = {\n            r\"\\bheart attack\\b\": \"myocardial infarction\",\n            r\"\\bstroke\\b\": \"cerebrovascular accident\",\n            r\"\\bhigh blood pressure\\b\": \"hypertension\",\n            r\"\\bhigh cholesterol\\b\": \"hyperlipidemia\",\n            r\"\\bkidney failure\\b\": \"renal failure\",\n            r\"\\bliver failure\\b\": \"hepatic failure\",\n            r\"\\bsugar\\b\": \"glucose\",\n            r\"\\bblood thinners?\\b\": \"anticoagulants\",\n        }\n\n        for pattern, replacement in normalizations.items():\n            normalized = re.sub(pattern, replacement, normalized, flags=re.I)\n\n        return normalized\n\n    async def extract_entities(self, query: str) -> Dict[str, List[str]]:\n        \"\"\"\n        Extract medical entities from query.\n\n        Returns dict with entity types: diseases, drugs, symptoms, etc.\n        \"\"\"\n        entities: Dict[str, List[str]] = {\n            \"diseases\": [],\n            \"drugs\": [],\n            \"symptoms\": [],\n            \"procedures\": [],\n            \"anatomy\": [],\n        }\n\n        query_lower = query.lower()\n\n        # Simple pattern-based extraction\n        # In production, use NER models (scispaCy, etc.)\n\n        # Check for common disease patterns\n        disease_indicators = [\n            \"disease\",\n            \"syndrome\",\n            \"disorder\",\n            \"infection\",\n            \"cancer\",\n            \"itis\",\n            \"osis\",\n            \"emia\",\n            \"pathy\",\n        ]\n        for indicator in disease_indicators:\n            if indicator in query_lower:\n                # Extract surrounding context\n                words = query_lower.split()\n                for i, word in enumerate(words):\n                    if indicator in word:\n                        # Get word and maybe preceding adjective\n                        if i > 0:\n                            entities[\"diseases\"].append(f\"{words[i-1]} {word}\")\n                        else:\n                            entities[\"diseases\"].append(word)\n\n        # Check for drug-related terms\n        drug_suffixes = [\"mab\", \"nib\", \"pril\", \"olol\", \"sartan\", \"statin\", \"cillin\"]\n        for suffix in drug_suffixes:\n            pattern = rf\"\\b\\w+{suffix}\\b\"\n            matches = re.findall(pattern, query_lower)\n            entities[\"drugs\"].extend(matches)\n\n        # Check for symptoms\n        symptom_terms = [\n            \"pain\",\n            \"ache\",\n            \"fever\",\n            \"fatigue\",\n            \"nausea\",\n            \"vomiting\",\n            \"cough\",\n        ]\n        for term in symptom_terms:\n            if term in query_lower:\n                entities[\"symptoms\"].append(term)\n\n        return entities\n"
}
