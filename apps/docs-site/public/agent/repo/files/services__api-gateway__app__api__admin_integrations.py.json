{
  "path": "services/api-gateway/app/api/admin_integrations.py",
  "language": "python",
  "size": 38437,
  "last_modified": "2025-12-04T11:26:46.044Z",
  "lines": 1150,
  "content": "\"\"\"Admin Integrations API endpoints.\n\nProvides administrative endpoints for managing external integrations:\n- List all integrations with status\n- Get integration details and configuration\n- Update integration configuration\n- Test integration connectivity\n- Get integration metrics\n\nRBAC:\n- admin: Full access (read/write/test)\n- viewer: Read-only access (list/details/metrics)\n\"\"\"\n\nimport json\nimport time\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Optional\n\nimport httpx\nimport redis\nfrom app.api.admin_panel import log_audit_event\nfrom app.core.api_envelope import success_response\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_admin_user\nfrom app.core.logging import get_logger\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import text\nfrom sqlalchemy.orm import Session\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/integrations\", tags=[\"admin-integrations\"])\n\n# Redis client for caching integration status\ntry:\n    redis_client = redis.from_url(settings.REDIS_URL, decode_responses=True)\nexcept Exception:\n    redis_client = None\n\nREDIS_INTEGRATION_METRICS_KEY = \"admin:integration:metrics\"\n\n\nclass IntegrationStatus(str, Enum):\n    \"\"\"Integration connection status.\"\"\"\n\n    CONNECTED = \"connected\"\n    DISCONNECTED = \"disconnected\"\n    ERROR = \"error\"\n    DEGRADED = \"degraded\"\n    NOT_CONFIGURED = \"not_configured\"\n\n\nclass IntegrationType(str, Enum):\n    \"\"\"Types of integrations.\"\"\"\n\n    DATABASE = \"database\"\n    CACHE = \"cache\"\n    VECTOR_DB = \"vector_db\"\n    STORAGE = \"storage\"\n    LLM = \"llm\"\n    TTS = \"tts\"\n    STT = \"stt\"\n    REALTIME = \"realtime\"\n    OAUTH = \"oauth\"\n    MONITORING = \"monitoring\"\n    EXTERNAL_API = \"external_api\"\n\n\nclass IntegrationSummary(BaseModel):\n    \"\"\"Summary of an integration for listing.\"\"\"\n\n    id: str\n    name: str\n    type: IntegrationType\n    status: IntegrationStatus\n    provider: str\n    last_checked: Optional[str] = None\n    error_message: Optional[str] = None\n\n\nclass IntegrationConfig(BaseModel):\n    \"\"\"Non-sensitive configuration for an integration.\"\"\"\n\n    host: Optional[str] = None\n    port: Optional[int] = None\n    enabled: Optional[bool] = None\n    timeout_sec: Optional[int] = None\n    model: Optional[str] = None\n    endpoint: Optional[str] = None\n    extra: Optional[dict] = None\n\n\nclass IntegrationDetail(BaseModel):\n    \"\"\"Detailed information about an integration.\"\"\"\n\n    id: str\n    name: str\n    type: IntegrationType\n    status: IntegrationStatus\n    provider: str\n    description: str\n    config: IntegrationConfig\n    has_api_key: bool = False\n    last_checked: Optional[str] = None\n    error_message: Optional[str] = None\n    metrics: Optional[dict] = None\n\n\nclass IntegrationConfigUpdate(BaseModel):\n    \"\"\"Request to update integration configuration.\"\"\"\n\n    enabled: Optional[bool] = None\n    timeout_sec: Optional[int] = Field(None, ge=1, le=300)\n    model: Optional[str] = None\n    endpoint: Optional[str] = None\n    extra: Optional[dict] = None\n\n\nclass TestResult(BaseModel):\n    \"\"\"Result of testing an integration.\"\"\"\n\n    success: bool\n    latency_ms: float\n    message: str\n    details: Optional[dict] = None\n\n\nclass IntegrationMetrics(BaseModel):\n    \"\"\"Metrics for an integration.\"\"\"\n\n    integration_id: str\n    total_requests: int = 0\n    successful_requests: int = 0\n    failed_requests: int = 0\n    avg_latency_ms: float = 0.0\n    p99_latency_ms: float = 0.0\n    last_error: Optional[str] = None\n    last_error_time: Optional[str] = None\n\n\n# Integration definitions\nINTEGRATIONS = {\n    \"postgres\": {\n        \"name\": \"PostgreSQL Database\",\n        \"type\": IntegrationType.DATABASE,\n        \"provider\": \"PostgreSQL\",\n        \"description\": \"Primary relational database for user data, sessions, and conversations.\",\n    },\n    \"redis\": {\n        \"name\": \"Redis Cache\",\n        \"type\": IntegrationType.CACHE,\n        \"provider\": \"Redis\",\n        \"description\": \"In-memory cache for sessions, rate limiting, and real-time data.\",\n    },\n    \"qdrant\": {\n        \"name\": \"Qdrant Vector Database\",\n        \"type\": IntegrationType.VECTOR_DB,\n        \"provider\": \"Qdrant\",\n        \"description\": \"Vector database for semantic search and knowledge base embeddings.\",\n    },\n    \"nextcloud\": {\n        \"name\": \"Nextcloud Storage\",\n        \"type\": IntegrationType.STORAGE,\n        \"provider\": \"Nextcloud\",\n        \"description\": \"File storage integration for document management.\",\n    },\n    \"openai\": {\n        \"name\": \"OpenAI API\",\n        \"type\": IntegrationType.LLM,\n        \"provider\": \"OpenAI\",\n        \"description\": \"Primary LLM provider for chat completions and embeddings.\",\n    },\n    \"openai_realtime\": {\n        \"name\": \"OpenAI Realtime API\",\n        \"type\": IntegrationType.REALTIME,\n        \"provider\": \"OpenAI\",\n        \"description\": \"WebSocket-based real-time voice conversation API.\",\n    },\n    \"openai_tts\": {\n        \"name\": \"OpenAI TTS\",\n        \"type\": IntegrationType.TTS,\n        \"provider\": \"OpenAI\",\n        \"description\": \"Text-to-speech synthesis using OpenAI voices.\",\n    },\n    \"openai_stt\": {\n        \"name\": \"OpenAI Whisper STT\",\n        \"type\": IntegrationType.STT,\n        \"provider\": \"OpenAI\",\n        \"description\": \"Speech-to-text transcription using Whisper.\",\n    },\n    \"elevenlabs\": {\n        \"name\": \"ElevenLabs TTS\",\n        \"type\": IntegrationType.TTS,\n        \"provider\": \"ElevenLabs\",\n        \"description\": \"High-quality neural text-to-speech synthesis.\",\n    },\n    \"deepgram\": {\n        \"name\": \"Deepgram STT\",\n        \"type\": IntegrationType.STT,\n        \"provider\": \"Deepgram\",\n        \"description\": \"Fast, accurate speech-to-text transcription.\",\n    },\n    \"google_oauth\": {\n        \"name\": \"Google OAuth\",\n        \"type\": IntegrationType.OAUTH,\n        \"provider\": \"Google\",\n        \"description\": \"Google authentication for user sign-in.\",\n    },\n    \"microsoft_oauth\": {\n        \"name\": \"Microsoft OAuth\",\n        \"type\": IntegrationType.OAUTH,\n        \"provider\": \"Microsoft\",\n        \"description\": \"Microsoft/Azure AD authentication for user sign-in.\",\n    },\n    \"sentry\": {\n        \"name\": \"Sentry Error Tracking\",\n        \"type\": IntegrationType.MONITORING,\n        \"provider\": \"Sentry\",\n        \"description\": \"Error tracking and performance monitoring.\",\n    },\n    \"opentelemetry\": {\n        \"name\": \"OpenTelemetry Tracing\",\n        \"type\": IntegrationType.MONITORING,\n        \"provider\": \"OpenTelemetry\",\n        \"description\": \"Distributed tracing for request flow analysis.\",\n    },\n    \"openevidence\": {\n        \"name\": \"OpenEvidence API\",\n        \"type\": IntegrationType.EXTERNAL_API,\n        \"provider\": \"OpenEvidence\",\n        \"description\": \"Medical evidence synthesis API.\",\n    },\n    \"pubmed\": {\n        \"name\": \"PubMed API\",\n        \"type\": IntegrationType.EXTERNAL_API,\n        \"provider\": \"NCBI\",\n        \"description\": \"Medical literature database API.\",\n    },\n}\n\n\ndef get_integration_status(\n    integration_id: str,\n) -> tuple[IntegrationStatus, Optional[str]]:\n    \"\"\"Get the current status of an integration.\"\"\"\n    if integration_id == \"postgres\":\n        try:\n            from app.core.database import engine\n\n            with engine.connect() as conn:\n                conn.execute(text(\"SELECT 1\"))\n            return IntegrationStatus.CONNECTED, None\n        except Exception as e:\n            return IntegrationStatus.ERROR, str(e)\n\n    elif integration_id == \"redis\":\n        try:\n            if redis_client and redis_client.ping():\n                return IntegrationStatus.CONNECTED, None\n            return IntegrationStatus.DISCONNECTED, \"Redis ping failed\"\n        except Exception as e:\n            return IntegrationStatus.ERROR, str(e)\n\n    elif integration_id == \"qdrant\":\n        if not settings.QDRANT_ENABLED:\n            return IntegrationStatus.NOT_CONFIGURED, \"Qdrant is disabled\"\n        try:\n            resp = httpx.get(f\"{settings.QDRANT_URL}/collections\", timeout=5.0)\n            if resp.status_code == 200:\n                return IntegrationStatus.CONNECTED, None\n            return IntegrationStatus.ERROR, f\"HTTP {resp.status_code}\"\n        except Exception as e:\n            return IntegrationStatus.ERROR, str(e)\n\n    elif integration_id == \"nextcloud\":\n        try:\n            resp = httpx.get(\n                f\"{settings.NEXTCLOUD_URL}/status.php\",\n                timeout=5.0,\n                follow_redirects=True,\n            )\n            if resp.status_code == 200:\n                return IntegrationStatus.CONNECTED, None\n            return IntegrationStatus.ERROR, f\"HTTP {resp.status_code}\"\n        except Exception as e:\n            return IntegrationStatus.ERROR, str(e)\n\n    elif integration_id == \"openai\":\n        if not settings.OPENAI_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None  # Assume configured = connected\n\n    elif integration_id == \"openai_realtime\":\n        if not settings.REALTIME_ENABLED:\n            return IntegrationStatus.NOT_CONFIGURED, \"Realtime API disabled\"\n        if not settings.OPENAI_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id in (\"openai_tts\", \"openai_stt\"):\n        if not settings.OPENAI_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"elevenlabs\":\n        if not settings.ELEVENLABS_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"deepgram\":\n        if not settings.DEEPGRAM_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"google_oauth\":\n        if not settings.GOOGLE_CLIENT_ID:\n            return IntegrationStatus.NOT_CONFIGURED, \"Client ID not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"microsoft_oauth\":\n        if not settings.MICROSOFT_CLIENT_ID:\n            return IntegrationStatus.NOT_CONFIGURED, \"Client ID not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"sentry\":\n        if not settings.SENTRY_DSN:\n            return IntegrationStatus.NOT_CONFIGURED, \"DSN not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"opentelemetry\":\n        if not settings.TRACING_ENABLED:\n            return IntegrationStatus.NOT_CONFIGURED, \"Tracing disabled\"\n        if not settings.OTLP_ENDPOINT and not settings.JAEGER_HOST:\n            return IntegrationStatus.NOT_CONFIGURED, \"No endpoint configured\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"openevidence\":\n        if not settings.OPENEVIDENCE_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    elif integration_id == \"pubmed\":\n        if not settings.PUBMED_API_KEY:\n            return IntegrationStatus.NOT_CONFIGURED, \"API key not set\"\n        return IntegrationStatus.CONNECTED, None\n\n    return IntegrationStatus.NOT_CONFIGURED, \"Unknown integration\"\n\n\ndef get_integration_config(integration_id: str) -> IntegrationConfig:\n    \"\"\"Get non-sensitive configuration for an integration.\"\"\"\n    if integration_id == \"postgres\":\n        return IntegrationConfig(\n            host=settings.POSTGRES_HOST,\n            port=settings.POSTGRES_PORT,\n            extra={\"database\": settings.POSTGRES_DB},\n        )\n    elif integration_id == \"redis\":\n        return IntegrationConfig(\n            host=settings.REDIS_HOST,\n            port=settings.REDIS_PORT,\n        )\n    elif integration_id == \"qdrant\":\n        return IntegrationConfig(\n            host=settings.QDRANT_HOST,\n            port=settings.QDRANT_PORT,\n            enabled=settings.QDRANT_ENABLED,\n        )\n    elif integration_id == \"nextcloud\":\n        return IntegrationConfig(\n            endpoint=settings.NEXTCLOUD_URL,\n        )\n    elif integration_id == \"openai\":\n        return IntegrationConfig(\n            timeout_sec=settings.OPENAI_TIMEOUT_SEC,\n            model=settings.MODEL_SELECTION_DEFAULT,\n        )\n    elif integration_id == \"openai_realtime\":\n        return IntegrationConfig(\n            enabled=settings.REALTIME_ENABLED,\n            model=settings.REALTIME_MODEL,\n            endpoint=settings.REALTIME_BASE_URL,\n            extra={\"token_expiry_sec\": settings.REALTIME_TOKEN_EXPIRY_SEC},\n        )\n    elif integration_id == \"openai_tts\":\n        return IntegrationConfig(\n            model=\"tts-1\",\n            extra={\"voice\": settings.TTS_VOICE or \"alloy\"},\n        )\n    elif integration_id == \"openai_stt\":\n        return IntegrationConfig(\n            model=\"whisper-1\",\n        )\n    elif integration_id == \"elevenlabs\":\n        return IntegrationConfig(\n            endpoint=settings.TTS_ENDPOINT,\n        )\n    elif integration_id == \"deepgram\":\n        return IntegrationConfig(\n            endpoint=settings.STT_ENDPOINT,\n        )\n    elif integration_id == \"google_oauth\":\n        return IntegrationConfig(\n            extra={\"redirect_uri\": settings.GOOGLE_OAUTH_REDIRECT_URI},\n        )\n    elif integration_id == \"microsoft_oauth\":\n        return IntegrationConfig(\n            extra={\"redirect_uri\": settings.MICROSOFT_OAUTH_REDIRECT_URI},\n        )\n    elif integration_id == \"sentry\":\n        return IntegrationConfig(\n            extra={\n                \"traces_sample_rate\": settings.SENTRY_TRACES_SAMPLE_RATE,\n                \"profiles_sample_rate\": settings.SENTRY_PROFILES_SAMPLE_RATE,\n            },\n        )\n    elif integration_id == \"opentelemetry\":\n        return IntegrationConfig(\n            enabled=settings.TRACING_ENABLED,\n            endpoint=settings.OTLP_ENDPOINT,\n            extra={\"jaeger_host\": settings.JAEGER_HOST},\n        )\n    elif integration_id == \"openevidence\":\n        return IntegrationConfig(\n            endpoint=settings.OPENEVIDENCE_BASE_URL,\n            extra={\"sync_minutes\": settings.OPENEVIDENCE_SYNC_MINUTES},\n        )\n    elif integration_id == \"pubmed\":\n        return IntegrationConfig(\n            extra={\"sync_minutes\": settings.PUBMED_SYNC_MINUTES},\n        )\n    return IntegrationConfig()\n\n\ndef has_api_key(integration_id: str) -> bool:\n    \"\"\"Check if an integration has an API key configured.\"\"\"\n    key_map = {\n        \"openai\": settings.OPENAI_API_KEY,\n        \"openai_realtime\": settings.OPENAI_API_KEY,\n        \"openai_tts\": settings.OPENAI_API_KEY,\n        \"openai_stt\": settings.OPENAI_API_KEY,\n        \"elevenlabs\": settings.ELEVENLABS_API_KEY,\n        \"deepgram\": settings.DEEPGRAM_API_KEY,\n        \"google_oauth\": settings.GOOGLE_CLIENT_SECRET,\n        \"microsoft_oauth\": settings.MICROSOFT_CLIENT_SECRET,\n        \"openevidence\": settings.OPENEVIDENCE_API_KEY,\n        \"pubmed\": settings.PUBMED_API_KEY,\n    }\n    return bool(key_map.get(integration_id))\n\n\n# Endpoints\n\n\n@router.get(\"/\")\nasync def list_integrations(\n    admin_user: User = Depends(get_current_admin_user),\n) -> dict:\n    \"\"\"List all integrations with their current status.\n\n    Available to both admin and viewer roles.\n    \"\"\"\n    now = datetime.now(timezone.utc).isoformat()\n    result = []\n\n    for int_id, info in INTEGRATIONS.items():\n        int_status, error = get_integration_status(int_id)\n        result.append(\n            IntegrationSummary(\n                id=int_id,\n                name=info[\"name\"],\n                type=info[\"type\"],\n                status=int_status,\n                provider=info[\"provider\"],\n                last_checked=now,\n                error_message=error,\n            ).model_dump()\n        )\n\n    return success_response(result)\n\n\n@router.get(\"/health\")\nasync def get_integrations_health(\n    admin_user: User = Depends(get_current_admin_user),\n) -> dict:\n    \"\"\"Get overall health summary of all integrations.\n\n    Available to both admin and viewer roles.\n    \"\"\"\n    total = len(INTEGRATIONS)\n    connected = 0\n    degraded = 0\n    errors = 0\n    not_configured = 0\n\n    for int_id in INTEGRATIONS:\n        int_status, _ = get_integration_status(int_id)\n        if int_status == IntegrationStatus.CONNECTED:\n            connected += 1\n        elif int_status == IntegrationStatus.DEGRADED:\n            degraded += 1\n        elif int_status == IntegrationStatus.ERROR:\n            errors += 1\n        elif int_status == IntegrationStatus.NOT_CONFIGURED:\n            not_configured += 1\n\n    overall = \"healthy\"\n    if errors > 0:\n        overall = \"unhealthy\"\n    elif degraded > 0:\n        overall = \"degraded\"\n    elif connected == 0:\n        overall = \"critical\"\n\n    return success_response(\n        {\n            \"overall_status\": overall,\n            \"total_integrations\": total,\n            \"connected\": connected,\n            \"degraded\": degraded,\n            \"errors\": errors,\n            \"not_configured\": not_configured,\n            \"checked_at\": datetime.now(timezone.utc).isoformat(),\n        }\n    )\n\n\n@router.get(\"/metrics/summary\")\nasync def get_integration_metrics(\n    admin_user: User = Depends(get_current_admin_user),\n) -> dict:\n    \"\"\"Get metrics for all integrations.\n\n    Available to both admin and viewer roles.\n\n    Note: This returns mock data in the current implementation.\n    Real metrics would come from Prometheus/metrics collection.\n    \"\"\"\n    # In a real implementation, this would query Prometheus or\n    # read from Redis counters. For now, return placeholder metrics.\n    result = []\n    for int_id in INTEGRATIONS:\n        metrics_key = f\"admin:integration:{int_id}:metrics\"\n        metrics_data = {}\n\n        if redis_client:\n            try:\n                data = redis_client.get(metrics_key)\n                if data:\n                    metrics_data = json.loads(data)\n            except Exception:\n                pass\n\n        result.append(\n            IntegrationMetrics(\n                integration_id=int_id,\n                total_requests=metrics_data.get(\"total_requests\", 0),\n                successful_requests=metrics_data.get(\"successful_requests\", 0),\n                failed_requests=metrics_data.get(\"failed_requests\", 0),\n                avg_latency_ms=metrics_data.get(\"avg_latency_ms\", 0.0),\n                p99_latency_ms=metrics_data.get(\"p99_latency_ms\", 0.0),\n                last_error=metrics_data.get(\"last_error\"),\n                last_error_time=metrics_data.get(\"last_error_time\"),\n            ).model_dump()\n        )\n\n    return success_response(result)\n\n\n@router.get(\"/{integration_id}\")\nasync def get_integration(\n    integration_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n) -> dict:\n    \"\"\"Get detailed information about a specific integration.\n\n    Available to both admin and viewer roles.\n    \"\"\"\n    if integration_id not in INTEGRATIONS:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Integration '{integration_id}' not found\",\n        )\n\n    info = INTEGRATIONS[integration_id]\n    int_status, error = get_integration_status(integration_id)\n    config = get_integration_config(integration_id)\n\n    return success_response(\n        IntegrationDetail(\n            id=integration_id,\n            name=info[\"name\"],\n            type=info[\"type\"],\n            status=int_status,\n            provider=info[\"provider\"],\n            description=info[\"description\"],\n            config=config,\n            has_api_key=has_api_key(integration_id),\n            last_checked=datetime.now(timezone.utc).isoformat(),\n            error_message=error,\n        ).model_dump()\n    )\n\n\n@router.patch(\"/{integration_id}/config\")\nasync def update_integration_config(\n    integration_id: str,\n    config_update: IntegrationConfigUpdate,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> dict:\n    \"\"\"Update configuration for an integration.\n\n    Admin role required.\n\n    Note: This endpoint updates runtime configuration stored in Redis.\n    Persistent configuration changes require environment variable updates.\n    \"\"\"\n    if admin_user.admin_role != \"admin\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Admin role required for configuration updates\",\n        )\n\n    if integration_id not in INTEGRATIONS:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Integration '{integration_id}' not found\",\n        )\n\n    # Store runtime config override in Redis\n    config_key = f\"admin:integration:{integration_id}:config\"\n    if redis_client:\n        existing = redis_client.get(config_key)\n        existing_config = json.loads(existing) if existing else {}\n        update_data = config_update.model_dump(exclude_none=True)\n        existing_config.update(update_data)\n        redis_client.set(config_key, json.dumps(existing_config))\n\n    # Log audit event\n    log_audit_event(\n        db,\n        action=\"integration_config_update\",\n        user_id=str(admin_user.id),\n        user_email=admin_user.email,\n        resource_type=\"integration\",\n        resource_id=integration_id,\n        success=True,\n        details=json.dumps({\"updates\": config_update.model_dump(exclude_none=True)}),\n    )\n\n    return await get_integration(integration_id, admin_user)\n\n\n@router.post(\"/{integration_id}/test\")\nasync def test_integration(\n    integration_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> dict:\n    \"\"\"Test connectivity for an integration.\n\n    Admin role required.\n    \"\"\"\n    if admin_user.admin_role != \"admin\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Admin role required for integration testing\",\n        )\n\n    if integration_id not in INTEGRATIONS:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Integration '{integration_id}' not found\",\n        )\n\n    start_time = time.time()\n    success = False\n    message = \"\"\n    details = {}\n\n    try:\n        if integration_id == \"postgres\":\n            from app.core.database import engine\n\n            with engine.connect() as conn:\n                result = conn.execute(text(\"SELECT version()\"))\n                row = result.fetchone()\n                details[\"version\"] = row[0] if row else \"unknown\"\n            success = True\n            message = \"PostgreSQL connection successful\"\n\n        elif integration_id == \"redis\":\n            if redis_client:\n                info = redis_client.info()\n                details[\"redis_version\"] = info.get(\"redis_version\")\n                details[\"connected_clients\"] = info.get(\"connected_clients\")\n                success = True\n                message = \"Redis connection successful\"\n            else:\n                message = \"Redis client not initialized\"\n\n        elif integration_id == \"qdrant\":\n            resp = httpx.get(f\"{settings.QDRANT_URL}/collections\", timeout=10.0)\n            if resp.status_code == 200:\n                data = resp.json()\n                details[\"collections_count\"] = len(data.get(\"result\", {}).get(\"collections\", []))\n                success = True\n                message = \"Qdrant connection successful\"\n            else:\n                message = f\"Qdrant returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"nextcloud\":\n            resp = httpx.get(\n                f\"{settings.NEXTCLOUD_URL}/status.php\",\n                timeout=10.0,\n                follow_redirects=True,\n            )\n            if resp.status_code == 200:\n                data = resp.json()\n                details[\"version\"] = data.get(\"version\")\n                details[\"installed\"] = data.get(\"installed\")\n                success = True\n                message = \"Nextcloud connection successful\"\n            else:\n                message = f\"Nextcloud returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"openai\":\n            if not settings.OPENAI_API_KEY:\n                message = \"OpenAI API key not configured\"\n            else:\n                # Test with a minimal API call (models list)\n                resp = httpx.get(\n                    \"https://api.openai.com/v1/models\",\n                    headers={\"Authorization\": f\"Bearer {settings.OPENAI_API_KEY}\"},\n                    timeout=10.0,\n                )\n                if resp.status_code == 200:\n                    success = True\n                    message = \"OpenAI API connection successful\"\n                else:\n                    message = f\"OpenAI returned HTTP {resp.status_code}\"\n\n        elif integration_id in (\"openai_realtime\", \"openai_tts\", \"openai_stt\"):\n            # These share the OpenAI API key\n            if not settings.OPENAI_API_KEY:\n                message = \"OpenAI API key not configured\"\n            else:\n                success = True\n                message = f\"{INTEGRATIONS[integration_id]['name']} is configured\"\n\n        elif integration_id == \"elevenlabs\":\n            if not settings.ELEVENLABS_API_KEY:\n                message = \"ElevenLabs API key not configured\"\n            else:\n                resp = httpx.get(\n                    \"https://api.elevenlabs.io/v1/user\",\n                    headers={\"xi-api-key\": settings.ELEVENLABS_API_KEY},\n                    timeout=10.0,\n                )\n                if resp.status_code == 200:\n                    success = True\n                    message = \"ElevenLabs API connection successful\"\n                else:\n                    message = f\"ElevenLabs returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"deepgram\":\n            if not settings.DEEPGRAM_API_KEY:\n                message = \"Deepgram API key not configured\"\n            else:\n                # Test with projects endpoint\n                resp = httpx.get(\n                    \"https://api.deepgram.com/v1/projects\",\n                    headers={\"Authorization\": f\"Token {settings.DEEPGRAM_API_KEY}\"},\n                    timeout=10.0,\n                )\n                if resp.status_code == 200:\n                    success = True\n                    message = \"Deepgram API connection successful\"\n                else:\n                    message = f\"Deepgram returned HTTP {resp.status_code}\"\n\n        elif integration_id in (\"google_oauth\", \"microsoft_oauth\"):\n            # OAuth configs can't be easily tested without user interaction\n            if integration_id == \"google_oauth\" and settings.GOOGLE_CLIENT_ID:\n                success = True\n                message = \"Google OAuth is configured\"\n            elif integration_id == \"microsoft_oauth\" and settings.MICROSOFT_CLIENT_ID:\n                success = True\n                message = \"Microsoft OAuth is configured\"\n            else:\n                message = \"OAuth client ID not configured\"\n\n        elif integration_id == \"sentry\":\n            if settings.SENTRY_DSN:\n                success = True\n                message = \"Sentry DSN is configured\"\n            else:\n                message = \"Sentry DSN not configured\"\n\n        elif integration_id == \"opentelemetry\":\n            if settings.TRACING_ENABLED and (settings.OTLP_ENDPOINT or settings.JAEGER_HOST):\n                success = True\n                message = \"OpenTelemetry is configured\"\n            else:\n                message = \"OpenTelemetry not configured or disabled\"\n\n        elif integration_id == \"openevidence\":\n            if not settings.OPENEVIDENCE_API_KEY:\n                message = \"OpenEvidence API key not configured\"\n            else:\n                success = True\n                message = \"OpenEvidence is configured\"\n\n        elif integration_id == \"pubmed\":\n            # PubMed can work without API key (with rate limits)\n            resp = httpx.get(\n                \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi?retmode=json\",\n                timeout=10.0,\n            )\n            if resp.status_code == 200:\n                success = True\n                message = \"PubMed API connection successful\"\n            else:\n                message = f\"PubMed returned HTTP {resp.status_code}\"\n\n        else:\n            message = f\"Test not implemented for {integration_id}\"\n\n    except Exception as e:\n        message = f\"Test failed: {str(e)}\"\n        details[\"error\"] = str(e)\n\n    latency_ms = (time.time() - start_time) * 1000\n\n    # Log audit event\n    log_audit_event(\n        db,\n        action=\"integration_test\",\n        user_id=str(admin_user.id),\n        user_email=admin_user.email,\n        resource_type=\"integration\",\n        resource_id=integration_id,\n        success=success,\n        details=json.dumps({\"latency_ms\": latency_ms, \"message\": message}),\n    )\n\n    return success_response(\n        TestResult(\n            success=success,\n            latency_ms=round(latency_ms, 2),\n            message=message,\n            details=details if details else None,\n        ).model_dump()\n    )\n\n\n# =============================================================================\n# System API Key Management Endpoints\n# =============================================================================\n\n\nclass SystemKeyInfo(BaseModel):\n    \"\"\"Information about a system API key.\"\"\"\n\n    integration_id: str\n    key_name: str\n    is_configured: bool\n    source: str  # \"database\", \"environment\", \"not_configured\"\n    masked_value: Optional[str] = None\n    is_override: bool = False\n    validation_status: Optional[str] = None\n    last_validated_at: Optional[str] = None\n    updated_at: Optional[str] = None\n\n\nclass SystemKeyUpdate(BaseModel):\n    \"\"\"Request to update a system API key.\"\"\"\n\n    value: str = Field(..., min_length=1, description=\"The API key value\")\n\n\nclass SystemKeySummary(BaseModel):\n    \"\"\"Summary of all system API keys.\"\"\"\n\n    total: int\n    configured: int\n    overridden: int\n    keys: list[SystemKeyInfo]\n\n\n@router.get(\"/api-keys/summary\", response_model=dict)\nasync def get_system_keys_summary(\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Get summary of all system API keys.\n\n    Returns configuration status for all known integrations.\n    Requires admin role.\n    \"\"\"\n    from app.services.system_key_service import system_key_service\n\n    keys = system_key_service.list_all_keys(db)\n\n    configured = sum(1 for k in keys if k[\"is_configured\"])\n    overridden = sum(1 for k in keys if k[\"is_override\"])\n\n    return success_response(\n        SystemKeySummary(\n            total=len(keys),\n            configured=configured,\n            overridden=overridden,\n            keys=[SystemKeyInfo(**k) for k in keys],\n        ).model_dump()\n    )\n\n\n@router.get(\"/{integration_id}/api-key\", response_model=dict)\nasync def get_system_key_info(\n    integration_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Get information about a system API key.\n\n    Returns configuration status without exposing the actual value.\n    Requires admin role.\n    \"\"\"\n    from app.services.system_key_service import system_key_service\n\n    info = system_key_service.get_key_info(db, integration_id)\n    return success_response(SystemKeyInfo(**info).model_dump())\n\n\n@router.put(\"/{integration_id}/api-key\", response_model=dict)\nasync def set_system_key(\n    integration_id: str,\n    update: SystemKeyUpdate,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Set or update a system API key.\n\n    Creates a database override for the environment variable.\n    The key is encrypted before storage.\n    Requires admin role.\n    \"\"\"\n    from app.services.system_key_service import system_key_service\n\n    # Only allow actual admin role (not viewer)\n    if admin_user.admin_role != \"admin\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Only admins can modify API keys\",\n        )\n\n    try:\n        system_key_service.set_key(\n            db=db,\n            integration_id=integration_id,\n            value=update.value,\n            user_id=admin_user.id,\n        )\n\n        # Log audit event\n        log_audit_event(\n            db,\n            action=\"system_key_updated\",\n            user_id=str(admin_user.id),\n            user_email=admin_user.email,\n            resource_type=\"system_api_key\",\n            resource_id=integration_id,\n            success=True,\n            details=json.dumps({\"source\": \"database\"}),\n        )\n\n        info = system_key_service.get_key_info(db, integration_id)\n        return success_response(\n            {\n                \"message\": f\"API key for {integration_id} updated successfully\",\n                \"key\": SystemKeyInfo(**info).model_dump(),\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to set system key for {integration_id}: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update API key\",\n        )\n\n\n@router.delete(\"/{integration_id}/api-key\", response_model=dict)\nasync def clear_system_key_override(\n    integration_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Clear the database override for a system API key.\n\n    Reverts to using the environment variable value.\n    Requires admin role.\n    \"\"\"\n    from app.services.system_key_service import system_key_service\n\n    # Only allow actual admin role (not viewer)\n    if admin_user.admin_role != \"admin\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Only admins can modify API keys\",\n        )\n\n    cleared = system_key_service.clear_override(db, integration_id)\n\n    if cleared:\n        # Log audit event\n        log_audit_event(\n            db,\n            action=\"system_key_override_cleared\",\n            user_id=str(admin_user.id),\n            user_email=admin_user.email,\n            resource_type=\"system_api_key\",\n            resource_id=integration_id,\n            success=True,\n            details=json.dumps({\"reverted_to\": \"environment\"}),\n        )\n\n    info = system_key_service.get_key_info(db, integration_id)\n    return success_response(\n        {\n            \"message\": f\"Override cleared for {integration_id}, now using environment value\",\n            \"key\": SystemKeyInfo(**info).model_dump(),\n        }\n    )\n\n\n@router.post(\"/{integration_id}/api-key/validate\", response_model=dict)\nasync def validate_system_key(\n    integration_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Validate a system API key by testing the connection.\n\n    Updates the validation status in the database.\n    Requires admin role.\n    \"\"\"\n    from app.services.system_key_service import system_key_service\n\n    # Get the current key value\n    key_value = system_key_service.get_key(db, integration_id)\n\n    if not key_value:\n        system_key_service.update_validation_status(db, integration_id, \"not_configured\")\n        return success_response(\n            {\n                \"valid\": False,\n                \"status\": \"not_configured\",\n                \"message\": f\"No API key configured for {integration_id}\",\n            }\n        )\n\n    # Validate based on integration type\n    valid = False\n    message = \"Validation not implemented\"\n\n    try:\n        if integration_id == \"openai\":\n            # Test OpenAI API\n            resp = httpx.get(\n                \"https://api.openai.com/v1/models\",\n                headers={\"Authorization\": f\"Bearer {key_value}\"},\n                timeout=10.0,\n            )\n            valid = resp.status_code == 200\n            message = \"OpenAI API key is valid\" if valid else f\"OpenAI returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"elevenlabs\":\n            # Test ElevenLabs API\n            resp = httpx.get(\n                \"https://api.elevenlabs.io/v1/user\",\n                headers={\"xi-api-key\": key_value},\n                timeout=10.0,\n            )\n            valid = resp.status_code == 200\n            message = \"ElevenLabs API key is valid\" if valid else f\"ElevenLabs returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"deepgram\":\n            # Test Deepgram API\n            resp = httpx.get(\n                \"https://api.deepgram.com/v1/projects\",\n                headers={\"Authorization\": f\"Token {key_value}\"},\n                timeout=10.0,\n            )\n            valid = resp.status_code == 200\n            message = \"Deepgram API key is valid\" if valid else f\"Deepgram returned HTTP {resp.status_code}\"\n\n        elif integration_id == \"pubmed\":\n            # PubMed key validation (enhanced rate limits with key)\n            resp = httpx.get(\n                f\"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi?retmode=json&api_key={key_value}\",\n                timeout=10.0,\n            )\n            valid = resp.status_code == 200\n            message = \"PubMed API key is valid\" if valid else f\"PubMed returned HTTP {resp.status_code}\"\n\n        else:\n            # For other integrations, just mark as \"assumed valid\" since we can't test\n            valid = True\n            message = f\"Key for {integration_id} assumed valid (no validation endpoint)\"\n\n    except Exception as e:\n        message = f\"Validation failed: {str(e)}\"\n\n    # Update status\n    status_value = \"valid\" if valid else \"invalid\"\n    system_key_service.update_validation_status(db, integration_id, status_value)\n\n    # Log audit event\n    log_audit_event(\n        db,\n        action=\"system_key_validated\",\n        user_id=str(admin_user.id),\n        user_email=admin_user.email,\n        resource_type=\"system_api_key\",\n        resource_id=integration_id,\n        success=valid,\n        details=json.dumps({\"status\": status_value, \"message\": message}),\n    )\n\n    return success_response(\n        {\n            \"valid\": valid,\n            \"status\": status_value,\n            \"message\": message,\n        }\n    )\n"
}
