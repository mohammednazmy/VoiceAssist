{
  "path": "services/api-gateway/app/api/admin_tools.py",
  "language": "python",
  "size": 34317,
  "last_modified": "2025-12-05T03:07:13.125Z",
  "lines": 1020,
  "content": "\"\"\"Admin Tools API endpoints (Sprint 6A - Tools Admin).\n\nProvides admin endpoints for managing AI assistant tools:\n- GET /api/admin/tools - List all registered tools with status\n- GET /api/admin/tools/{tool_name} - Get tool details and config\n- PATCH /api/admin/tools/{tool_name} - Update tool config (admin only)\n- GET /api/admin/tools/logs - Tool invocation logs with filters\n- GET /api/admin/tools/analytics - Tool usage analytics\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Literal, Optional\n\nfrom app.api.admin_panel import log_audit_event\nfrom app.core.api_envelope import success_response\nfrom app.core.database import get_db, redis_client\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/tools\", tags=[\"admin\", \"tools\"])\n\n# Redis keys\nREDIS_TOOLS_CONFIG_KEY = \"voiceassist:tools:config\"\nREDIS_TOOLS_LOGS_KEY = \"voiceassist:tools:logs\"\nREDIS_TOOLS_ANALYTICS_KEY = \"voiceassist:tools:analytics\"\n\n# Tool categories\nTOOL_CATEGORIES = [\n    \"calendar\",\n    \"file\",\n    \"medical\",\n    \"calculation\",\n    \"search\",\n    \"email\",\n    \"integration\",\n]\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass ToolStatus(BaseModel):\n    \"\"\"Tool status information.\"\"\"\n\n    tool_name: str\n    display_name: str\n    description: str\n    enabled: bool\n    category: Literal[\"calendar\", \"file\", \"medical\", \"calculation\", \"search\", \"email\", \"integration\"]\n    total_calls_24h: int = 0\n    success_rate: float = 0.0\n    avg_duration_ms: float = 0.0\n    last_error: Optional[str] = None\n    last_error_at: Optional[str] = None\n    phi_enabled: bool = False\n    requires_confirmation: bool = False\n\n\nclass ToolConfiguration(BaseModel):\n    \"\"\"Tool configuration.\"\"\"\n\n    tool_name: str\n    enabled: bool = True\n    timeout_seconds: int = 30\n    rate_limit_per_user: int = 100\n    rate_limit_window_seconds: int = 3600\n    requires_confirmation: bool = False\n    phi_enabled: bool = False\n    custom_settings: Dict[str, Any] = Field(default_factory=dict)\n\n\nclass ToolConfigUpdate(BaseModel):\n    \"\"\"Update model for tool configuration.\"\"\"\n\n    enabled: Optional[bool] = None\n    timeout_seconds: Optional[int] = Field(None, ge=1, le=300)\n    rate_limit_per_user: Optional[int] = Field(None, ge=1, le=10000)\n    rate_limit_window_seconds: Optional[int] = Field(None, ge=60, le=86400)\n    requires_confirmation: Optional[bool] = None\n    phi_enabled: Optional[bool] = None\n    custom_settings: Optional[Dict[str, Any]] = None\n\n\nclass ToolInvocationLog(BaseModel):\n    \"\"\"Tool invocation log entry.\"\"\"\n\n    id: str\n    tool_name: str\n    user_email: str\n    session_id: str\n    call_id: str\n    arguments: Dict[str, Any] = Field(default_factory=dict)\n    status: Literal[\"completed\", \"failed\", \"timeout\", \"cancelled\"]\n    duration_ms: int\n    phi_detected: bool = False\n    confirmation_required: bool = False\n    user_confirmed: Optional[bool] = None\n    error_code: Optional[str] = None\n    error_message: Optional[str] = None\n    created_at: str\n\n\nclass ToolAnalyticsSummary(BaseModel):\n    \"\"\"Tool analytics summary.\"\"\"\n\n    tool_name: str\n    total_calls: int\n    success_count: int\n    failure_count: int\n    timeout_count: int\n    cancelled_count: int\n    avg_duration_ms: float\n    p95_duration_ms: float\n    phi_detected_count: int\n    confirmation_required_count: int\n\n\n# ============================================================================\n# Tool Registry - Defines available tools\n# ============================================================================\n\n# Default tool definitions\nDEFAULT_TOOLS: Dict[str, Dict[str, Any]] = {\n    \"calendar_create_event\": {\n        \"display_name\": \"Create Calendar Event\",\n        \"description\": \"Create a new event in the user's calendar\",\n        \"category\": \"calendar\",\n        \"enabled\": True,\n        \"requires_confirmation\": True,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"calendar_list_events\": {\n        \"display_name\": \"List Calendar Events\",\n        \"description\": \"List upcoming events from the user's calendar\",\n        \"category\": \"calendar\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 15,\n        \"rate_limit_per_user\": 100,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"calendar_update_event\": {\n        \"display_name\": \"Update Calendar Event\",\n        \"description\": \"Update an existing calendar event\",\n        \"category\": \"calendar\",\n        \"enabled\": True,\n        \"requires_confirmation\": True,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"calendar_delete_event\": {\n        \"display_name\": \"Delete Calendar Event\",\n        \"description\": \"Delete an event from the calendar\",\n        \"category\": \"calendar\",\n        \"enabled\": True,\n        \"requires_confirmation\": True,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 15,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"file_search\": {\n        \"display_name\": \"Search Files\",\n        \"description\": \"Search for files in user's Nextcloud storage\",\n        \"category\": \"file\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 100,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"file_read\": {\n        \"display_name\": \"Read File\",\n        \"description\": \"Read content from a file in Nextcloud\",\n        \"category\": \"file\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 60,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"file_upload\": {\n        \"display_name\": \"Upload File\",\n        \"description\": \"Upload a file to Nextcloud storage\",\n        \"category\": \"file\",\n        \"enabled\": True,\n        \"requires_confirmation\": True,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 120,\n        \"rate_limit_per_user\": 20,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"medical_search\": {\n        \"display_name\": \"Medical Knowledge Search\",\n        \"description\": \"Search the medical knowledge base for relevant information\",\n        \"category\": \"medical\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 200,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"medical_drug_lookup\": {\n        \"display_name\": \"Drug Information Lookup\",\n        \"description\": \"Look up drug information, interactions, and dosages\",\n        \"category\": \"medical\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 100,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"medical_calculator\": {\n        \"display_name\": \"Medical Calculator\",\n        \"description\": \"Calculate medical scores and formulas (BMI, GFR, etc.)\",\n        \"category\": \"calculation\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 10,\n        \"rate_limit_per_user\": 200,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"pubmed_search\": {\n        \"display_name\": \"PubMed Search\",\n        \"description\": \"Search PubMed for medical literature\",\n        \"category\": \"search\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 60,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"uptodate_search\": {\n        \"display_name\": \"UpToDate Search\",\n        \"description\": \"Search UpToDate clinical decision support\",\n        \"category\": \"search\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": False,\n        \"timeout_seconds\": 60,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"email_send\": {\n        \"display_name\": \"Send Email\",\n        \"description\": \"Send an email on behalf of the user\",\n        \"category\": \"email\",\n        \"enabled\": True,\n        \"requires_confirmation\": True,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 20,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"email_draft\": {\n        \"display_name\": \"Draft Email\",\n        \"description\": \"Create a draft email for user review\",\n        \"category\": \"email\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 30,\n        \"rate_limit_per_user\": 50,\n        \"rate_limit_window_seconds\": 3600,\n    },\n    \"contact_search\": {\n        \"display_name\": \"Search Contacts\",\n        \"description\": \"Search user's contacts in CardDAV\",\n        \"category\": \"integration\",\n        \"enabled\": True,\n        \"requires_confirmation\": False,\n        \"phi_enabled\": True,\n        \"timeout_seconds\": 15,\n        \"rate_limit_per_user\": 100,\n        \"rate_limit_window_seconds\": 3600,\n    },\n}\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\n\ndef get_tool_config(tool_name: str) -> ToolConfiguration:\n    \"\"\"Get configuration for a specific tool.\"\"\"\n    try:\n        config_data = redis_client.hget(REDIS_TOOLS_CONFIG_KEY, tool_name)\n        if config_data:\n            if isinstance(config_data, bytes):\n                config_data = config_data.decode(\"utf-8\")\n            stored = json.loads(config_data)\n            return ToolConfiguration(tool_name=tool_name, **stored)\n    except Exception as e:\n        logger.warning(f\"Failed to get tool config from Redis: {e}\")\n\n    # Return default config if not in Redis\n    if tool_name in DEFAULT_TOOLS:\n        defaults = DEFAULT_TOOLS[tool_name]\n        return ToolConfiguration(\n            tool_name=tool_name,\n            enabled=defaults.get(\"enabled\", True),\n            timeout_seconds=defaults.get(\"timeout_seconds\", 30),\n            rate_limit_per_user=defaults.get(\"rate_limit_per_user\", 100),\n            rate_limit_window_seconds=defaults.get(\"rate_limit_window_seconds\", 3600),\n            requires_confirmation=defaults.get(\"requires_confirmation\", False),\n            phi_enabled=defaults.get(\"phi_enabled\", False),\n            custom_settings={},\n        )\n\n    raise ValueError(f\"Unknown tool: {tool_name}\")\n\n\ndef save_tool_config(tool_name: str, config: ToolConfiguration) -> None:\n    \"\"\"Save tool configuration to Redis.\"\"\"\n    try:\n        config_dict = config.model_dump(exclude={\"tool_name\"})\n        redis_client.hset(REDIS_TOOLS_CONFIG_KEY, tool_name, json.dumps(config_dict))\n    except Exception as e:\n        logger.warning(f\"Failed to save tool config to Redis: {e}\")\n\n\ndef get_all_tools() -> List[Dict[str, Any]]:\n    \"\"\"Get all tools with their status and config.\"\"\"\n    tools = []\n    for tool_name, defaults in DEFAULT_TOOLS.items():\n        try:\n            config = get_tool_config(tool_name)\n            analytics = get_tool_analytics_24h(tool_name)\n\n            tools.append(\n                {\n                    \"tool_name\": tool_name,\n                    \"display_name\": defaults[\"display_name\"],\n                    \"description\": defaults[\"description\"],\n                    \"category\": defaults[\"category\"],\n                    \"enabled\": config.enabled,\n                    \"total_calls_24h\": analytics.get(\"total_calls\", 0),\n                    \"success_rate\": analytics.get(\"success_rate\", 0.0),\n                    \"avg_duration_ms\": analytics.get(\"avg_duration_ms\", 0.0),\n                    \"last_error\": analytics.get(\"last_error\"),\n                    \"last_error_at\": analytics.get(\"last_error_at\"),\n                    \"phi_enabled\": config.phi_enabled,\n                    \"requires_confirmation\": config.requires_confirmation,\n                }\n            )\n        except Exception as e:\n            logger.warning(f\"Failed to get tool {tool_name}: {e}\")\n            tools.append(\n                {\n                    \"tool_name\": tool_name,\n                    \"display_name\": defaults[\"display_name\"],\n                    \"description\": defaults[\"description\"],\n                    \"category\": defaults[\"category\"],\n                    \"enabled\": defaults.get(\"enabled\", True),\n                    \"total_calls_24h\": 0,\n                    \"success_rate\": 0.0,\n                    \"avg_duration_ms\": 0.0,\n                    \"last_error\": None,\n                    \"last_error_at\": None,\n                    \"phi_enabled\": defaults.get(\"phi_enabled\", False),\n                    \"requires_confirmation\": defaults.get(\"requires_confirmation\", False),\n                }\n            )\n\n    return tools\n\n\ndef get_tool_analytics_24h(tool_name: str) -> Dict[str, Any]:\n    \"\"\"Get 24-hour analytics for a specific tool.\"\"\"\n    try:\n        analytics_key = f\"{REDIS_TOOLS_ANALYTICS_KEY}:{tool_name}\"\n        data = redis_client.get(analytics_key)\n        if data:\n            if isinstance(data, bytes):\n                data = data.decode(\"utf-8\")\n            return json.loads(data)\n    except Exception as e:\n        logger.warning(f\"Failed to get tool analytics from Redis: {e}\")\n\n    return {\n        \"total_calls\": 0,\n        \"success_count\": 0,\n        \"failure_count\": 0,\n        \"timeout_count\": 0,\n        \"cancelled_count\": 0,\n        \"success_rate\": 0.0,\n        \"avg_duration_ms\": 0.0,\n        \"p95_duration_ms\": 0.0,\n        \"phi_detected_count\": 0,\n        \"confirmation_required_count\": 0,\n        \"last_error\": None,\n        \"last_error_at\": None,\n    }\n\n\ndef get_tool_logs(\n    tool_name: Optional[str] = None,\n    status: Optional[str] = None,\n    limit: int = 50,\n    offset: int = 0,\n) -> List[Dict[str, Any]]:\n    \"\"\"Get tool invocation logs with filters.\"\"\"\n    try:\n        # Get logs from Redis list (most recent first)\n        logs_data = redis_client.lrange(REDIS_TOOLS_LOGS_KEY, 0, 999)  # Get up to 1000 logs\n        logs = []\n\n        for log_entry in logs_data:\n            if isinstance(log_entry, bytes):\n                log_entry = log_entry.decode(\"utf-8\")\n            log = json.loads(log_entry)\n\n            # Apply filters\n            if tool_name and log.get(\"tool_name\") != tool_name:\n                continue\n            if status and log.get(\"status\") != status:\n                continue\n\n            # Redact PHI from arguments\n            if log.get(\"arguments\"):\n                log[\"arguments\"] = _redact_phi_from_args(log[\"arguments\"])\n\n            logs.append(log)\n\n        # Apply pagination\n        return logs[offset : offset + limit]\n    except Exception as e:\n        logger.warning(f\"Failed to get tool logs from Redis: {e}\")\n        return []\n\n\ndef _redact_phi_from_args(args: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Redact potential PHI from tool arguments.\"\"\"\n    phi_keys = [\n        \"patient\",\n        \"name\",\n        \"email\",\n        \"phone\",\n        \"ssn\",\n        \"dob\",\n        \"address\",\n        \"medical_record\",\n        \"mrn\",\n    ]\n    redacted = {}\n    for key, value in args.items():\n        if any(phi_key in key.lower() for phi_key in phi_keys):\n            redacted[key] = \"[REDACTED]\"\n        elif isinstance(value, dict):\n            redacted[key] = _redact_phi_from_args(value)\n        elif isinstance(value, str) and len(value) > 100:\n            redacted[key] = value[:50] + \"...[TRUNCATED]\"\n        else:\n            redacted[key] = value\n    return redacted\n\n\ndef log_tool_invocation(\n    tool_name: str,\n    user_email: str,\n    session_id: str,\n    call_id: str,\n    arguments: Dict[str, Any],\n    status: str,\n    duration_ms: int,\n    phi_detected: bool = False,\n    confirmation_required: bool = False,\n    user_confirmed: Optional[bool] = None,\n    error_code: Optional[str] = None,\n    error_message: Optional[str] = None,\n) -> None:\n    \"\"\"Log a tool invocation to Redis.\"\"\"\n    try:\n        log_entry = {\n            \"id\": call_id,\n            \"tool_name\": tool_name,\n            \"user_email\": user_email,\n            \"session_id\": session_id,\n            \"call_id\": call_id,\n            \"arguments\": arguments,\n            \"status\": status,\n            \"duration_ms\": duration_ms,\n            \"phi_detected\": phi_detected,\n            \"confirmation_required\": confirmation_required,\n            \"user_confirmed\": user_confirmed,\n            \"error_code\": error_code,\n            \"error_message\": error_message,\n            \"created_at\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        }\n\n        # Add to logs list (prepend for most recent first)\n        redis_client.lpush(REDIS_TOOLS_LOGS_KEY, json.dumps(log_entry))\n\n        # Trim to keep only last 10000 entries\n        redis_client.ltrim(REDIS_TOOLS_LOGS_KEY, 0, 9999)\n\n        # Update analytics counters\n        _update_tool_analytics(\n            tool_name,\n            status,\n            duration_ms,\n            phi_detected,\n            confirmation_required,\n            error_message,\n        )\n\n    except Exception as e:\n        logger.warning(f\"Failed to log tool invocation: {e}\")\n\n\ndef _update_tool_analytics(\n    tool_name: str,\n    status: str,\n    duration_ms: int,\n    phi_detected: bool,\n    confirmation_required: bool,\n    error_message: Optional[str] = None,\n) -> None:\n    \"\"\"Update tool analytics counters in Redis.\"\"\"\n    try:\n        analytics_key = f\"{REDIS_TOOLS_ANALYTICS_KEY}:{tool_name}\"\n        analytics = get_tool_analytics_24h(tool_name)\n\n        analytics[\"total_calls\"] = analytics.get(\"total_calls\", 0) + 1\n\n        if status == \"completed\":\n            analytics[\"success_count\"] = analytics.get(\"success_count\", 0) + 1\n        elif status == \"failed\":\n            analytics[\"failure_count\"] = analytics.get(\"failure_count\", 0) + 1\n            analytics[\"last_error\"] = error_message\n            analytics[\"last_error_at\"] = datetime.now(timezone.utc).isoformat() + \"Z\"\n        elif status == \"timeout\":\n            analytics[\"timeout_count\"] = analytics.get(\"timeout_count\", 0) + 1\n        elif status == \"cancelled\":\n            analytics[\"cancelled_count\"] = analytics.get(\"cancelled_count\", 0) + 1\n\n        if phi_detected:\n            analytics[\"phi_detected_count\"] = analytics.get(\"phi_detected_count\", 0) + 1\n\n        if confirmation_required:\n            analytics[\"confirmation_required_count\"] = analytics.get(\"confirmation_required_count\", 0) + 1\n\n        # Update averages\n        total = analytics[\"total_calls\"]\n        current_avg = analytics.get(\"avg_duration_ms\", 0.0)\n        analytics[\"avg_duration_ms\"] = ((current_avg * (total - 1)) + duration_ms) / total\n\n        # Calculate success rate\n        if total > 0:\n            analytics[\"success_rate\"] = analytics.get(\"success_count\", 0) / total\n\n        # Store with 24h TTL\n        redis_client.setex(analytics_key, 86400, json.dumps(analytics))\n\n    except Exception as e:\n        logger.warning(f\"Failed to update tool analytics: {e}\")\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"\")\nasync def list_tools(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    category: Optional[str] = Query(None, description=\"Filter by category\"),\n    enabled: Optional[bool] = Query(None, description=\"Filter by enabled status\"),\n) -> Dict:\n    \"\"\"List all registered tools with status.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    tools = get_all_tools()\n\n    # Apply filters\n    if category:\n        tools = [t for t in tools if t[\"category\"] == category]\n    if enabled is not None:\n        tools = [t for t in tools if t[\"enabled\"] == enabled]\n\n    # Sort by category then name\n    tools.sort(key=lambda t: (t[\"category\"], t[\"tool_name\"]))\n\n    # Calculate summary stats\n    total_calls_24h = sum(t[\"total_calls_24h\"] for t in tools)\n    enabled_count = sum(1 for t in tools if t[\"enabled\"])\n\n    data = {\n        \"tools\": tools,\n        \"total\": len(tools),\n        \"enabled_count\": enabled_count,\n        \"disabled_count\": len(tools) - enabled_count,\n        \"total_calls_24h\": total_calls_24h,\n        \"categories\": list(set(t[\"category\"] for t in tools)),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/logs\")\nasync def get_tool_invocation_logs(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    tool_name: Optional[str] = Query(None, description=\"Filter by tool name\"),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    limit: int = Query(50, ge=1, le=500),\n    offset: int = Query(0, ge=0),\n) -> Dict:\n    \"\"\"Get tool invocation logs with filters.\n\n    Available to admin and viewer roles.\n    PHI is redacted from arguments.\n    \"\"\"\n    logs = get_tool_logs(tool_name=tool_name, status=status, limit=limit, offset=offset)\n\n    data = {\n        \"logs\": logs,\n        \"count\": len(logs),\n        \"limit\": limit,\n        \"offset\": offset,\n        \"filters\": {\n            \"tool_name\": tool_name,\n            \"status\": status,\n        },\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/analytics\")\nasync def get_tools_analytics(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get aggregated tool usage analytics.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    analytics_list = []\n\n    for tool_name in DEFAULT_TOOLS.keys():\n        analytics = get_tool_analytics_24h(tool_name)\n        analytics_list.append(\n            {\n                \"tool_name\": tool_name,\n                \"display_name\": DEFAULT_TOOLS[tool_name][\"display_name\"],\n                \"category\": DEFAULT_TOOLS[tool_name][\"category\"],\n                **analytics,\n            }\n        )\n\n    # Sort by total calls descending\n    analytics_list.sort(key=lambda x: x.get(\"total_calls\", 0), reverse=True)\n\n    # Calculate totals\n    total_calls = sum(a.get(\"total_calls\", 0) for a in analytics_list)\n    total_success = sum(a.get(\"success_count\", 0) for a in analytics_list)\n    total_failures = sum(a.get(\"failure_count\", 0) for a in analytics_list)\n    total_phi = sum(a.get(\"phi_detected_count\", 0) for a in analytics_list)\n\n    # Category breakdown\n    category_stats = {}\n    for a in analytics_list:\n        cat = a[\"category\"]\n        if cat not in category_stats:\n            category_stats[cat] = {\"calls\": 0, \"success\": 0, \"failures\": 0}\n        category_stats[cat][\"calls\"] += a.get(\"total_calls\", 0)\n        category_stats[cat][\"success\"] += a.get(\"success_count\", 0)\n        category_stats[cat][\"failures\"] += a.get(\"failure_count\", 0)\n\n    data = {\n        \"tools\": analytics_list,\n        \"summary\": {\n            \"total_calls\": total_calls,\n            \"total_success\": total_success,\n            \"total_failures\": total_failures,\n            \"total_phi_detected\": total_phi,\n            \"overall_success_rate\": (total_success / total_calls if total_calls > 0 else 0.0),\n        },\n        \"by_category\": category_stats,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/{tool_name}\")\nasync def get_tool_details(\n    request: Request,\n    tool_name: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get details and configuration for a specific tool.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    if tool_name not in DEFAULT_TOOLS:\n        raise HTTPException(status_code=404, detail=f\"Tool not found: {tool_name}\")\n\n    defaults = DEFAULT_TOOLS[tool_name]\n    config = get_tool_config(tool_name)\n    analytics = get_tool_analytics_24h(tool_name)\n\n    data = {\n        \"tool_name\": tool_name,\n        \"display_name\": defaults[\"display_name\"],\n        \"description\": defaults[\"description\"],\n        \"category\": defaults[\"category\"],\n        \"config\": config.model_dump(),\n        \"analytics\": analytics,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.patch(\"/{tool_name}\")\nasync def update_tool_config(\n    request: Request,\n    tool_name: str,\n    config_update: ToolConfigUpdate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Update configuration for a specific tool.\n\n    Only admin users can modify tool configuration.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    if tool_name not in DEFAULT_TOOLS:\n        raise HTTPException(status_code=404, detail=f\"Tool not found: {tool_name}\")\n\n    # Get current config\n    current_config = get_tool_config(tool_name)\n    original_config = current_config.model_dump()\n\n    # Apply updates\n    update_data = config_update.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        if value is not None:\n            setattr(current_config, field, value)\n\n    # Save updated config\n    save_tool_config(tool_name, current_config)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"tools.config.update\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"tool_config\",\n        resource_id=tool_name,\n        success=True,\n        details=json.dumps({\"original\": original_config, \"updated\": update_data}),\n        request=request,\n    )\n\n    logger.info(\n        f\"Admin {current_admin_user.email} updated tool configuration for {tool_name}\",\n        extra={\n            \"admin_id\": current_admin_user.id,\n            \"tool_name\": tool_name,\n            \"changes\": update_data,\n        },\n    )\n\n    defaults = DEFAULT_TOOLS[tool_name]\n    data = {\n        \"tool_name\": tool_name,\n        \"display_name\": defaults[\"display_name\"],\n        \"description\": defaults[\"description\"],\n        \"category\": defaults[\"category\"],\n        \"config\": current_config.model_dump(),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Database-backed Analytics Endpoints (using tool_invocation_logs table)\n# ============================================================================\n\n\n@router.get(\"/analytics/db\")\nasync def get_db_analytics(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    days: int = Query(30, ge=1, le=365, description=\"Number of days to analyze\"),\n) -> Dict:\n    \"\"\"Get comprehensive tool analytics from database logs.\n\n    This endpoint queries the tool_invocation_logs table for\n    historical analytics data with customizable time range.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    from datetime import timedelta\n\n    from app.core.database import get_async_db\n    from app.services.tools import tool_analytics_service\n\n    # Get async db session\n    async for db_session in get_async_db():\n        try:\n            start_date = datetime.utcnow() - timedelta(days=days)\n            end_date = datetime.utcnow()\n\n            # Get summary statistics\n            summary = await tool_analytics_service.get_tool_usage_summary(\n                db_session=db_session,\n                start_date=start_date,\n                end_date=end_date,\n            )\n\n            # Get tool breakdown\n            tool_breakdown = await tool_analytics_service.get_tool_breakdown(\n                db_session=db_session,\n                start_date=start_date,\n                end_date=end_date,\n            )\n\n            # Get mode comparison\n            mode_comparison = await tool_analytics_service.get_mode_comparison(\n                db_session=db_session,\n                start_date=start_date,\n                end_date=end_date,\n            )\n\n            data = {\n                \"summary\": summary,\n                \"by_tool\": tool_breakdown,\n                \"by_mode\": mode_comparison,\n                \"days_analyzed\": days,\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            }\n\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n        finally:\n            await db_session.close()\n\n\n@router.get(\"/analytics/db/trend\")\nasync def get_db_analytics_trend(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    days: int = Query(30, ge=1, le=365, description=\"Number of days\"),\n    tool_name: Optional[str] = Query(None, description=\"Filter by tool name\"),\n) -> Dict:\n    \"\"\"Get daily trend data for tool usage.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    from app.core.database import get_async_db\n    from app.services.tools import tool_analytics_service\n\n    async for db_session in get_async_db():\n        try:\n            trend = await tool_analytics_service.get_daily_trend(\n                db_session=db_session,\n                days=days,\n                tool_name=tool_name,\n            )\n\n            data = {\n                \"trend\": trend,\n                \"days\": days,\n                \"tool_name\": tool_name,\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            }\n\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n        finally:\n            await db_session.close()\n\n\n@router.get(\"/analytics/db/errors\")\nasync def get_db_error_analysis(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    days: int = Query(7, ge=1, le=30, description=\"Number of days\"),\n    limit: int = Query(20, ge=1, le=100, description=\"Max errors to return\"),\n) -> Dict:\n    \"\"\"Get error analysis from tool invocation logs.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    from datetime import timedelta\n\n    from app.core.database import get_async_db\n    from app.services.tools import tool_analytics_service\n\n    async for db_session in get_async_db():\n        try:\n            start_date = datetime.utcnow() - timedelta(days=days)\n\n            errors = await tool_analytics_service.get_error_analysis(\n                db_session=db_session,\n                start_date=start_date,\n                limit=limit,\n            )\n\n            data = {\n                \"errors\": errors,\n                \"days\": days,\n                \"limit\": limit,\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            }\n\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n        finally:\n            await db_session.close()\n\n\n@router.get(\"/analytics/db/invocations\")\nasync def get_db_recent_invocations(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(50, ge=1, le=200, description=\"Max invocations to return\"),\n    tool_name: Optional[str] = Query(None, description=\"Filter by tool name\"),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n) -> Dict:\n    \"\"\"Get recent tool invocations for monitoring.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    from app.core.database import get_async_db\n    from app.services.tools import tool_analytics_service\n\n    async for db_session in get_async_db():\n        try:\n            invocations = await tool_analytics_service.get_recent_invocations(\n                db_session=db_session,\n                limit=limit,\n                tool_name=tool_name,\n                status=status,\n            )\n\n            data = {\n                \"invocations\": invocations,\n                \"limit\": limit,\n                \"filters\": {\"tool_name\": tool_name, \"status\": status},\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            }\n\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n        finally:\n            await db_session.close()\n\n\n@router.get(\"/analytics/db/user/{user_id}\")\nasync def get_db_user_tool_activity(\n    request: Request,\n    user_id: str,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    days: int = Query(30, ge=1, le=365, description=\"Number of days\"),\n) -> Dict:\n    \"\"\"Get tool usage activity for a specific user.\n\n    Available to admin and viewer roles.\n    \"\"\"\n    from datetime import timedelta\n\n    from app.core.database import get_async_db\n    from app.services.tools import tool_analytics_service\n\n    async for db_session in get_async_db():\n        try:\n            start_date = datetime.utcnow() - timedelta(days=days)\n\n            activity = await tool_analytics_service.get_user_activity(\n                db_session=db_session,\n                user_id=user_id,\n                start_date=start_date,\n            )\n\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(activity, trace_id=trace_id)\n        finally:\n            await db_session.close()\n"
}
