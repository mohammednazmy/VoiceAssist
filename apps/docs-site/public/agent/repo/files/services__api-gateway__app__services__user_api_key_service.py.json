{
  "path": "services/api-gateway/app/services/user_api_key_service.py",
  "language": "python",
  "size": 6619,
  "last_modified": "2025-11-29T04:27:21.983Z",
  "lines": 230,
  "content": "\"\"\"\nUser API Key Service for programmatic access to VoiceAssist API.\n\nProvides secure key generation, hashing, and validation for user-generated API keys.\n\"\"\"\n\nimport secrets\nfrom datetime import datetime, timedelta, timezone\nfrom typing import List, Optional, Tuple\nfrom uuid import UUID\n\nfrom app.models.user import User\nfrom app.models.user_api_key import UserAPIKey\nfrom passlib.context import CryptContext\nfrom sqlalchemy.orm import Session\n\n# Password context for hashing API keys (same as password hashing)\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# API key prefix\nKEY_PREFIX = \"va_k_\"\n\n\nclass UserAPIKeyService:\n    \"\"\"\n    Service for managing user-generated API keys.\n\n    Keys are hashed with bcrypt for secure storage.\n    The full key is only returned once at creation time.\n    \"\"\"\n\n    def generate_key(self) -> Tuple[str, str]:\n        \"\"\"\n        Generate a new API key.\n\n        Returns:\n            Tuple of (full_key, key_prefix)\n            - full_key: Complete key to give to user (shown once)\n            - key_prefix: First 12 chars for display/identification\n        \"\"\"\n        # Generate 32 random URL-safe characters\n        random_part = secrets.token_urlsafe(24)  # ~32 chars after encoding\n        full_key = f\"{KEY_PREFIX}{random_part}\"\n\n        # Store first 12 chars as prefix for identification\n        key_prefix = full_key[:12]\n\n        return full_key, key_prefix\n\n    def hash_key(self, key: str) -> str:\n        \"\"\"Hash an API key for secure storage.\"\"\"\n        return pwd_context.hash(key)\n\n    def verify_key(self, plain_key: str, hashed_key: str) -> bool:\n        \"\"\"Verify a plain API key against its hash.\"\"\"\n        return pwd_context.verify(plain_key, hashed_key)\n\n    def create_key(\n        self,\n        db: Session,\n        user_id: UUID,\n        name: str,\n        expires_in_days: Optional[int] = None,\n        scopes: Optional[List[str]] = None,\n    ) -> Tuple[UserAPIKey, str]:\n        \"\"\"\n        Create a new API key for a user.\n\n        Args:\n            db: Database session\n            user_id: User ID\n            name: User-provided name for the key\n            expires_in_days: Optional expiration (None = never expires)\n            scopes: Optional list of permission scopes\n\n        Returns:\n            Tuple of (UserAPIKey record, full_key)\n            Note: full_key is only available at creation time!\n        \"\"\"\n        full_key, key_prefix = self.generate_key()\n        key_hash = self.hash_key(full_key)\n\n        expires_at = None\n        if expires_in_days:\n            expires_at = datetime.now(timezone.utc) + timedelta(days=expires_in_days)\n\n        api_key = UserAPIKey(\n            user_id=user_id,\n            key_prefix=key_prefix,\n            key_hash=key_hash,\n            name=name,\n            scopes=scopes or [],\n            expires_at=expires_at,\n        )\n\n        db.add(api_key)\n        db.commit()\n        db.refresh(api_key)\n\n        return api_key, full_key\n\n    def validate_key(\n        self,\n        db: Session,\n        plain_key: str,\n        update_last_used: bool = True,\n        ip_address: Optional[str] = None,\n    ) -> Optional[User]:\n        \"\"\"\n        Validate an API key and return the associated user.\n\n        Args:\n            db: Database session\n            plain_key: The API key provided by the client\n            update_last_used: Whether to update last_used_at timestamp\n            ip_address: Client IP address for tracking\n\n        Returns:\n            User if key is valid, None otherwise\n        \"\"\"\n        if not plain_key or not plain_key.startswith(KEY_PREFIX):\n            return None\n\n        # Extract prefix for lookup\n        key_prefix = plain_key[:12]\n\n        # Find all non-revoked keys with this prefix\n        api_keys = (\n            db.query(UserAPIKey)\n            .filter(\n                UserAPIKey.key_prefix == key_prefix,\n                UserAPIKey.is_revoked.is_(False),\n            )\n            .all()\n        )\n\n        for api_key in api_keys:\n            # Check expiration\n            if api_key.expires_at and datetime.now(timezone.utc) > api_key.expires_at:\n                continue\n\n            # Verify the hash\n            if self.verify_key(plain_key, api_key.key_hash):\n                # Update last used info\n                if update_last_used:\n                    api_key.last_used_at = datetime.now(timezone.utc)\n                    if ip_address:\n                        api_key.last_used_ip = ip_address\n                    db.commit()\n\n                # Load and return the user\n                user = db.query(User).filter(User.id == api_key.user_id).first()\n                return user\n\n        return None\n\n    def revoke_key(self, db: Session, key_id: UUID, user_id: UUID) -> bool:\n        \"\"\"\n        Revoke an API key.\n\n        Args:\n            db: Database session\n            key_id: ID of the key to revoke\n            user_id: ID of the user (for ownership verification)\n\n        Returns:\n            True if revoked, False if not found or not owned by user\n        \"\"\"\n        api_key = (\n            db.query(UserAPIKey)\n            .filter(\n                UserAPIKey.id == key_id,\n                UserAPIKey.user_id == user_id,\n            )\n            .first()\n        )\n\n        if not api_key:\n            return False\n\n        api_key.is_revoked = True\n        api_key.revoked_at = datetime.now(timezone.utc)\n        db.commit()\n\n        return True\n\n    def list_user_keys(\n        self,\n        db: Session,\n        user_id: UUID,\n        include_revoked: bool = False,\n    ) -> List[UserAPIKey]:\n        \"\"\"\n        List all API keys for a user.\n\n        Args:\n            db: Database session\n            user_id: User ID\n            include_revoked: Whether to include revoked keys\n\n        Returns:\n            List of UserAPIKey records (without the actual key values)\n        \"\"\"\n        query = db.query(UserAPIKey).filter(UserAPIKey.user_id == user_id)\n\n        if not include_revoked:\n            query = query.filter(UserAPIKey.is_revoked.is_(False))\n\n        return query.order_by(UserAPIKey.created_at.desc()).all()\n\n    def get_key_by_id(\n        self,\n        db: Session,\n        key_id: UUID,\n        user_id: UUID,\n    ) -> Optional[UserAPIKey]:\n        \"\"\"Get a specific API key by ID (with ownership verification).\"\"\"\n        return (\n            db.query(UserAPIKey)\n            .filter(\n                UserAPIKey.id == key_id,\n                UserAPIKey.user_id == user_id,\n            )\n            .first()\n        )\n\n\n# Global instance\nuser_api_key_service = UserAPIKeyService()\n"
}
