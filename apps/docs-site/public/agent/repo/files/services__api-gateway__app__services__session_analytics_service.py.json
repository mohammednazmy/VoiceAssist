{
  "path": "services/api-gateway/app/services/session_analytics_service.py",
  "language": "python",
  "size": 22618,
  "last_modified": "2025-12-05T03:07:13.134Z",
  "lines": 709,
  "content": "\"\"\"\nSession Analytics Service - Voice Session Performance Analytics\n\nPhase 10: Frontend Integration - Analytics and metrics collection.\n\nFeatures:\n- Real-time session metrics tracking\n- Latency measurements (STT, LLM, TTS)\n- Voice interaction quality metrics\n- Turn-taking analysis\n- Emotion tracking summaries\n- Dictation productivity metrics\n\"\"\"\n\nimport statistics\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Enums and Types\n# ==============================================================================\n\n\nclass SessionPhase(str, Enum):\n    \"\"\"Phase of a voice session.\"\"\"\n\n    CONNECTING = \"connecting\"\n    INITIALIZING = \"initializing\"\n    ACTIVE = \"active\"\n    PAUSED = \"paused\"\n    ENDING = \"ending\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n\n\nclass InteractionType(str, Enum):\n    \"\"\"Type of voice interaction.\"\"\"\n\n    USER_UTTERANCE = \"user_utterance\"\n    AI_RESPONSE = \"ai_response\"\n    TOOL_CALL = \"tool_call\"\n    BARGE_IN = \"barge_in\"\n    BACKCHANNEL = \"backchannel\"\n    FILLER = \"filler\"\n    REPAIR = \"repair\"\n    COMMAND = \"command\"\n\n\nclass MetricType(str, Enum):\n    \"\"\"Type of metric being tracked.\"\"\"\n\n    LATENCY = \"latency\"\n    QUALITY = \"quality\"\n    COUNT = \"count\"\n    DURATION = \"duration\"\n    RATE = \"rate\"\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\n@dataclass\nclass LatencyMetrics:\n    \"\"\"Latency metrics for a session.\"\"\"\n\n    # STT latency (speech end to transcript)\n    stt_latencies_ms: List[float] = field(default_factory=list)\n    stt_avg_ms: float = 0.0\n    stt_p50_ms: float = 0.0\n    stt_p95_ms: float = 0.0\n\n    # LLM latency (transcript to first token)\n    llm_latencies_ms: List[float] = field(default_factory=list)\n    llm_avg_ms: float = 0.0\n    llm_p50_ms: float = 0.0\n    llm_p95_ms: float = 0.0\n\n    # TTS latency (response to first audio)\n    tts_latencies_ms: List[float] = field(default_factory=list)\n    tts_avg_ms: float = 0.0\n    tts_p50_ms: float = 0.0\n    tts_p95_ms: float = 0.0\n\n    # End-to-end latency (speech end to first audio)\n    e2e_latencies_ms: List[float] = field(default_factory=list)\n    e2e_avg_ms: float = 0.0\n    e2e_p50_ms: float = 0.0\n    e2e_p95_ms: float = 0.0\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"stt\": {\n                \"avg_ms\": self.stt_avg_ms,\n                \"p50_ms\": self.stt_p50_ms,\n                \"p95_ms\": self.stt_p95_ms,\n                \"samples\": len(self.stt_latencies_ms),\n            },\n            \"llm\": {\n                \"avg_ms\": self.llm_avg_ms,\n                \"p50_ms\": self.llm_p50_ms,\n                \"p95_ms\": self.llm_p95_ms,\n                \"samples\": len(self.llm_latencies_ms),\n            },\n            \"tts\": {\n                \"avg_ms\": self.tts_avg_ms,\n                \"p50_ms\": self.tts_p50_ms,\n                \"p95_ms\": self.tts_p95_ms,\n                \"samples\": len(self.tts_latencies_ms),\n            },\n            \"e2e\": {\n                \"avg_ms\": self.e2e_avg_ms,\n                \"p50_ms\": self.e2e_p50_ms,\n                \"p95_ms\": self.e2e_p95_ms,\n                \"samples\": len(self.e2e_latencies_ms),\n            },\n        }\n\n\n@dataclass\nclass InteractionMetrics:\n    \"\"\"Interaction counts and rates for a session.\"\"\"\n\n    user_utterance_count: int = 0\n    ai_response_count: int = 0\n    tool_call_count: int = 0\n    barge_in_count: int = 0\n    backchannel_count: int = 0\n    filler_count: int = 0\n    repair_count: int = 0\n    command_count: int = 0\n\n    # Word counts\n    user_word_count: int = 0\n    ai_word_count: int = 0\n\n    # Durations (ms)\n    total_user_speaking_ms: float = 0.0\n    total_ai_speaking_ms: float = 0.0\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"counts\": {\n                \"user_utterances\": self.user_utterance_count,\n                \"ai_responses\": self.ai_response_count,\n                \"tool_calls\": self.tool_call_count,\n                \"barge_ins\": self.barge_in_count,\n                \"backchannels\": self.backchannel_count,\n                \"fillers\": self.filler_count,\n                \"repairs\": self.repair_count,\n                \"commands\": self.command_count,\n            },\n            \"words\": {\n                \"user\": self.user_word_count,\n                \"ai\": self.ai_word_count,\n            },\n            \"speaking_time_ms\": {\n                \"user\": self.total_user_speaking_ms,\n                \"ai\": self.total_ai_speaking_ms,\n            },\n        }\n\n\n@dataclass\nclass QualityMetrics:\n    \"\"\"Quality and accuracy metrics for a session.\"\"\"\n\n    # STT confidence scores\n    stt_confidence_scores: List[float] = field(default_factory=list)\n    stt_avg_confidence: float = 0.0\n\n    # AI response confidence\n    ai_confidence_scores: List[float] = field(default_factory=list)\n    ai_avg_confidence: float = 0.0\n\n    # Emotion detection\n    emotions_detected: Dict[str, int] = field(default_factory=dict)\n    avg_valence: float = 0.0\n    avg_arousal: float = 0.0\n\n    # Turn-taking quality\n    smooth_transitions: int = 0\n    interrupted_transitions: int = 0\n    overlap_events: int = 0\n\n    # Repair rate (lower is better)\n    clarification_requests: int = 0\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"stt_confidence\": {\n                \"avg\": self.stt_avg_confidence,\n                \"samples\": len(self.stt_confidence_scores),\n            },\n            \"ai_confidence\": {\n                \"avg\": self.ai_avg_confidence,\n                \"samples\": len(self.ai_confidence_scores),\n            },\n            \"emotion\": {\n                \"detected\": self.emotions_detected,\n                \"avg_valence\": self.avg_valence,\n                \"avg_arousal\": self.avg_arousal,\n            },\n            \"turn_taking\": {\n                \"smooth\": self.smooth_transitions,\n                \"interrupted\": self.interrupted_transitions,\n                \"overlaps\": self.overlap_events,\n            },\n            \"repairs\": self.clarification_requests,\n        }\n\n\n@dataclass\nclass DictationMetrics:\n    \"\"\"Dictation-specific metrics for a session.\"\"\"\n\n    note_type: Optional[str] = None\n    sections_used: List[str] = field(default_factory=list)\n    total_words_dictated: int = 0\n    commands_executed: int = 0\n    commands_failed: int = 0\n    formatting_corrections: int = 0\n    abbreviations_expanded: int = 0\n    phi_alerts: int = 0\n    dictation_duration_ms: float = 0.0\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"note_type\": self.note_type,\n            \"sections_used\": self.sections_used,\n            \"words_dictated\": self.total_words_dictated,\n            \"commands\": {\n                \"executed\": self.commands_executed,\n                \"failed\": self.commands_failed,\n            },\n            \"formatting_corrections\": self.formatting_corrections,\n            \"abbreviations_expanded\": self.abbreviations_expanded,\n            \"phi_alerts\": self.phi_alerts,\n            \"duration_ms\": self.dictation_duration_ms,\n        }\n\n\n@dataclass\nclass SessionAnalytics:\n    \"\"\"Complete analytics for a voice session.\"\"\"\n\n    session_id: str\n    user_id: Optional[str]\n    phase: SessionPhase = SessionPhase.CONNECTING\n    mode: str = \"conversation\"  # conversation or dictation\n\n    # Timestamps\n    started_at: datetime = field(default_factory=datetime.utcnow)\n    ended_at: Optional[datetime] = None\n    duration_ms: float = 0.0\n\n    # Metrics\n    latency: LatencyMetrics = field(default_factory=LatencyMetrics)\n    interactions: InteractionMetrics = field(default_factory=InteractionMetrics)\n    quality: QualityMetrics = field(default_factory=QualityMetrics)\n    dictation: DictationMetrics = field(default_factory=DictationMetrics)\n\n    # Errors\n    error_count: int = 0\n    errors: List[Dict[str, Any]] = field(default_factory=list)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"session_id\": self.session_id,\n            \"user_id\": self.user_id,\n            \"phase\": self.phase.value,\n            \"mode\": self.mode,\n            \"timing\": {\n                \"started_at\": self.started_at.isoformat(),\n                \"ended_at\": self.ended_at.isoformat() if self.ended_at else None,\n                \"duration_ms\": self.duration_ms,\n            },\n            \"latency\": self.latency.to_dict(),\n            \"interactions\": self.interactions.to_dict(),\n            \"quality\": self.quality.to_dict(),\n            \"dictation\": self.dictation.to_dict() if self.mode == \"dictation\" else None,\n            \"errors\": {\n                \"count\": self.error_count,\n                \"details\": self.errors[-10:],  # Last 10 errors\n            },\n        }\n\n\n# ==============================================================================\n# Session Analytics Service\n# ==============================================================================\n\n\nclass SessionAnalyticsService:\n    \"\"\"\n    Service for tracking voice session analytics.\n\n    Collects and aggregates metrics during voice sessions,\n    provides real-time analytics updates to frontend,\n    and stores session summaries for reporting.\n\n    Usage:\n        analytics = SessionAnalyticsService()\n\n        # Start tracking a session\n        session = analytics.create_session(\"session_123\", \"user_456\")\n\n        # Record events\n        analytics.record_latency(session.session_id, \"stt\", 120.5)\n        analytics.record_interaction(session.session_id, InteractionType.USER_UTTERANCE)\n        analytics.record_emotion(session.session_id, \"happy\", 0.8, 0.6)\n\n        # Get current analytics\n        current = analytics.get_session_analytics(session.session_id)\n\n        # End session\n        summary = analytics.end_session(session.session_id)\n    \"\"\"\n\n    def __init__(self):\n        self._sessions: Dict[str, SessionAnalytics] = {}\n        self._message_callbacks: Dict[str, Callable] = {}\n        self._analytics_interval_ms = 5000  # Send analytics update every 5s\n\n    def create_session(\n        self,\n        session_id: str,\n        user_id: Optional[str] = None,\n        mode: str = \"conversation\",\n        on_analytics_update: Optional[Callable] = None,\n    ) -> SessionAnalytics:\n        \"\"\"\n        Create a new analytics session.\n\n        Args:\n            session_id: Unique session identifier\n            user_id: User ID (optional)\n            mode: Session mode (conversation or dictation)\n            on_analytics_update: Callback for real-time updates\n\n        Returns:\n            SessionAnalytics object\n        \"\"\"\n        analytics = SessionAnalytics(\n            session_id=session_id,\n            user_id=user_id,\n            mode=mode,\n            phase=SessionPhase.INITIALIZING,\n        )\n\n        self._sessions[session_id] = analytics\n\n        if on_analytics_update:\n            self._message_callbacks[session_id] = on_analytics_update\n\n        logger.info(f\"Created analytics session: {session_id}, mode={mode}\")\n        return analytics\n\n    def set_session_active(self, session_id: str) -> None:\n        \"\"\"Mark session as active.\"\"\"\n        if session_id in self._sessions:\n            self._sessions[session_id].phase = SessionPhase.ACTIVE\n            logger.debug(f\"Session {session_id} is now active\")\n\n    def record_latency(\n        self,\n        session_id: str,\n        latency_type: str,\n        latency_ms: float,\n    ) -> None:\n        \"\"\"\n        Record a latency measurement.\n\n        Args:\n            session_id: Session identifier\n            latency_type: Type of latency (stt, llm, tts, e2e)\n            latency_ms: Latency in milliseconds\n        \"\"\"\n        if session_id not in self._sessions:\n            return\n\n        analytics = self._sessions[session_id]\n        latency = analytics.latency\n\n        if latency_type == \"stt\":\n            latency.stt_latencies_ms.append(latency_ms)\n            self._update_latency_stats(latency.stt_latencies_ms, \"stt\", latency)\n        elif latency_type == \"llm\":\n            latency.llm_latencies_ms.append(latency_ms)\n            self._update_latency_stats(latency.llm_latencies_ms, \"llm\", latency)\n        elif latency_type == \"tts\":\n            latency.tts_latencies_ms.append(latency_ms)\n            self._update_latency_stats(latency.tts_latencies_ms, \"tts\", latency)\n        elif latency_type == \"e2e\":\n            latency.e2e_latencies_ms.append(latency_ms)\n            self._update_latency_stats(latency.e2e_latencies_ms, \"e2e\", latency)\n\n        logger.debug(f\"[Analytics] {latency_type} latency: {latency_ms:.1f}ms\")\n\n    def _update_latency_stats(\n        self,\n        values: List[float],\n        prefix: str,\n        latency: LatencyMetrics,\n    ) -> None:\n        \"\"\"Update latency statistics.\"\"\"\n        if not values:\n            return\n\n        avg = statistics.mean(values)\n        sorted_vals = sorted(values)\n        p50 = sorted_vals[len(sorted_vals) // 2]\n        p95_idx = int(len(sorted_vals) * 0.95)\n        p95 = sorted_vals[min(p95_idx, len(sorted_vals) - 1)]\n\n        setattr(latency, f\"{prefix}_avg_ms\", round(avg, 1))\n        setattr(latency, f\"{prefix}_p50_ms\", round(p50, 1))\n        setattr(latency, f\"{prefix}_p95_ms\", round(p95, 1))\n\n    def record_interaction(\n        self,\n        session_id: str,\n        interaction_type: InteractionType,\n        word_count: int = 0,\n        duration_ms: float = 0.0,\n    ) -> None:\n        \"\"\"\n        Record an interaction event.\n\n        Args:\n            session_id: Session identifier\n            interaction_type: Type of interaction\n            word_count: Number of words (if applicable)\n            duration_ms: Duration in milliseconds (if applicable)\n        \"\"\"\n        if session_id not in self._sessions:\n            return\n\n        interactions = self._sessions[session_id].interactions\n\n        if interaction_type == InteractionType.USER_UTTERANCE:\n            interactions.user_utterance_count += 1\n            interactions.user_word_count += word_count\n            interactions.total_user_speaking_ms += duration_ms\n        elif interaction_type == InteractionType.AI_RESPONSE:\n            interactions.ai_response_count += 1\n            interactions.ai_word_count += word_count\n            interactions.total_ai_speaking_ms += duration_ms\n        elif interaction_type == InteractionType.TOOL_CALL:\n            interactions.tool_call_count += 1\n        elif interaction_type == InteractionType.BARGE_IN:\n            interactions.barge_in_count += 1\n        elif interaction_type == InteractionType.BACKCHANNEL:\n            interactions.backchannel_count += 1\n        elif interaction_type == InteractionType.FILLER:\n            interactions.filler_count += 1\n        elif interaction_type == InteractionType.REPAIR:\n            interactions.repair_count += 1\n        elif interaction_type == InteractionType.COMMAND:\n            interactions.command_count += 1\n\n        logger.debug(f\"[Analytics] Interaction: {interaction_type.value}\")\n\n    def record_stt_confidence(\n        self,\n        session_id: str,\n        confidence: float,\n    ) -> None:\n        \"\"\"Record STT confidence score.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        quality = self._sessions[session_id].quality\n        quality.stt_confidence_scores.append(confidence)\n        quality.stt_avg_confidence = statistics.mean(quality.stt_confidence_scores)\n\n    def record_ai_confidence(\n        self,\n        session_id: str,\n        confidence: float,\n    ) -> None:\n        \"\"\"Record AI response confidence score.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        quality = self._sessions[session_id].quality\n        quality.ai_confidence_scores.append(confidence)\n        quality.ai_avg_confidence = statistics.mean(quality.ai_confidence_scores)\n\n    def record_emotion(\n        self,\n        session_id: str,\n        emotion: str,\n        valence: float,\n        arousal: float,\n    ) -> None:\n        \"\"\"Record detected emotion.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        quality = self._sessions[session_id].quality\n\n        # Track emotion counts\n        if emotion not in quality.emotions_detected:\n            quality.emotions_detected[emotion] = 0\n        quality.emotions_detected[emotion] += 1\n\n        # Update average valence/arousal (simple moving average)\n        n = sum(quality.emotions_detected.values())\n        quality.avg_valence = (quality.avg_valence * (n - 1) + valence) / n\n        quality.avg_arousal = (quality.avg_arousal * (n - 1) + arousal) / n\n\n    def record_turn_taking(\n        self,\n        session_id: str,\n        smooth: bool = True,\n        overlap: bool = False,\n    ) -> None:\n        \"\"\"Record turn-taking event.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        quality = self._sessions[session_id].quality\n\n        if overlap:\n            quality.overlap_events += 1\n        elif smooth:\n            quality.smooth_transitions += 1\n        else:\n            quality.interrupted_transitions += 1\n\n    def record_repair(\n        self,\n        session_id: str,\n    ) -> None:\n        \"\"\"Record a clarification/repair request.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        self._sessions[session_id].quality.clarification_requests += 1\n        self._sessions[session_id].interactions.repair_count += 1\n\n    def record_dictation_event(\n        self,\n        session_id: str,\n        event_type: str,\n        data: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"\n        Record a dictation-specific event.\n\n        Args:\n            session_id: Session identifier\n            event_type: Type of dictation event\n            data: Additional event data\n        \"\"\"\n        if session_id not in self._sessions:\n            return\n\n        dictation = self._sessions[session_id].dictation\n        data = data or {}\n\n        if event_type == \"note_type_set\":\n            dictation.note_type = data.get(\"note_type\")\n        elif event_type == \"section_used\":\n            section = data.get(\"section\")\n            if section and section not in dictation.sections_used:\n                dictation.sections_used.append(section)\n        elif event_type == \"words_added\":\n            dictation.total_words_dictated += data.get(\"count\", 0)\n        elif event_type == \"command_executed\":\n            dictation.commands_executed += 1\n        elif event_type == \"command_failed\":\n            dictation.commands_failed += 1\n        elif event_type == \"formatting_correction\":\n            dictation.formatting_corrections += 1\n        elif event_type == \"abbreviation_expanded\":\n            dictation.abbreviations_expanded += data.get(\"count\", 1)\n        elif event_type == \"phi_alert\":\n            dictation.phi_alerts += 1\n\n    def record_error(\n        self,\n        session_id: str,\n        error_type: str,\n        message: str,\n        recoverable: bool = True,\n    ) -> None:\n        \"\"\"Record an error.\"\"\"\n        if session_id not in self._sessions:\n            return\n\n        analytics = self._sessions[session_id]\n        analytics.error_count += 1\n        analytics.errors.append(\n            {\n                \"type\": error_type,\n                \"message\": message,\n                \"recoverable\": recoverable,\n                \"timestamp\": datetime.utcnow().isoformat(),\n            }\n        )\n\n        if not recoverable:\n            analytics.phase = SessionPhase.ERROR\n\n    def get_session_analytics(\n        self,\n        session_id: str,\n    ) -> Optional[SessionAnalytics]:\n        \"\"\"Get current analytics for a session.\"\"\"\n        return self._sessions.get(session_id)\n\n    def get_analytics_summary(\n        self,\n        session_id: str,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Get analytics summary as a dictionary.\"\"\"\n        analytics = self._sessions.get(session_id)\n        if not analytics:\n            return None\n\n        # Update duration\n        if analytics.phase == SessionPhase.ACTIVE:\n            analytics.duration_ms = (datetime.utcnow() - analytics.started_at).total_seconds() * 1000\n\n        return analytics.to_dict()\n\n    async def send_analytics_update(\n        self,\n        session_id: str,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Generate and send an analytics update.\n\n        Returns the analytics data that was sent.\n        \"\"\"\n        summary = self.get_analytics_summary(session_id)\n        if not summary:\n            return None\n\n        # Call the registered callback if any\n        if session_id in self._message_callbacks:\n            try:\n                callback = self._message_callbacks[session_id]\n                await callback(summary)\n            except Exception as e:\n                logger.warning(f\"Analytics callback error: {e}\")\n\n        return summary\n\n    def end_session(\n        self,\n        session_id: str,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        End a session and return final analytics.\n\n        Args:\n            session_id: Session identifier\n\n        Returns:\n            Final analytics summary\n        \"\"\"\n        if session_id not in self._sessions:\n            return None\n\n        analytics = self._sessions[session_id]\n        analytics.phase = SessionPhase.COMPLETED\n        analytics.ended_at = datetime.utcnow()\n        analytics.duration_ms = (analytics.ended_at - analytics.started_at).total_seconds() * 1000\n\n        # Update dictation duration if applicable\n        if analytics.mode == \"dictation\":\n            analytics.dictation.dictation_duration_ms = analytics.duration_ms\n\n        summary = analytics.to_dict()\n\n        # Cleanup\n        if session_id in self._message_callbacks:\n            del self._message_callbacks[session_id]\n\n        logger.info(\n            f\"Session {session_id} ended: duration={analytics.duration_ms:.0f}ms, \"\n            f\"utterances={analytics.interactions.user_utterance_count}, \"\n            f\"e2e_avg={analytics.latency.e2e_avg_ms:.0f}ms\"\n        )\n\n        return summary\n\n    def remove_session(self, session_id: str) -> None:\n        \"\"\"Remove a session from tracking.\"\"\"\n        if session_id in self._sessions:\n            del self._sessions[session_id]\n        if session_id in self._message_callbacks:\n            del self._message_callbacks[session_id]\n\n\n# Global service instance\nsession_analytics_service = SessionAnalyticsService()\n"
}
