{
  "path": "services/api-gateway/app/services/language_detection_service.py",
  "language": "python",
  "size": 14972,
  "last_modified": "2025-12-05T03:06:37.806Z",
  "lines": 462,
  "content": "\"\"\"\nLanguage Detection Service - Code-switching and language identification\n\nVoice Mode v4 - Phase 2 Integration\n\nProvides real-time language detection for:\n- Automatic language identification from text/audio\n- Code-switching detection (mixing languages)\n- Language confidence scoring\n- Integration with STT and TTS for language-appropriate processing\n\"\"\"\n\nimport asyncio\nimport logging\nimport re\nfrom collections import Counter\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Tuple\n\nlogger = logging.getLogger(__name__)\n\n\nclass SupportedLanguage(Enum):\n    \"\"\"Supported languages for detection.\"\"\"\n    ENGLISH = \"en\"\n    ARABIC = \"ar\"\n    SPANISH = \"es\"\n    FRENCH = \"fr\"\n    GERMAN = \"de\"\n    CHINESE = \"zh\"\n    HINDI = \"hi\"\n    URDU = \"ur\"\n    PORTUGUESE = \"pt\"\n    ITALIAN = \"it\"\n    JAPANESE = \"ja\"\n    KOREAN = \"ko\"\n    RUSSIAN = \"ru\"\n    TURKISH = \"tr\"\n    UNKNOWN = \"unknown\"\n\n\n@dataclass\nclass LanguageDetectionResult:\n    \"\"\"Result of language detection.\"\"\"\n    primary_language: SupportedLanguage\n    confidence: float  # 0.0 to 1.0\n    detected_languages: Dict[SupportedLanguage, float]  # All detected with scores\n    is_code_switched: bool  # Multiple languages detected\n    segments: List[\"LanguageSegment\"] = field(default_factory=list)\n    detection_method: str = \"rule_based\"\n\n\n@dataclass\nclass LanguageSegment:\n    \"\"\"A segment of text with detected language.\"\"\"\n    text: str\n    language: SupportedLanguage\n    confidence: float\n    start_idx: int\n    end_idx: int\n\n\n@dataclass\nclass LanguageDetectionConfig:\n    \"\"\"Configuration for language detection.\"\"\"\n    # Detection thresholds\n    min_confidence_threshold: float = 0.6\n    code_switch_threshold: float = 0.2  # Min secondary language ratio\n\n    # Feature flags\n    enable_code_switch_detection: bool = True\n    enable_script_detection: bool = True\n    enable_statistical_detection: bool = True\n\n    # Supported languages\n    supported_languages: List[SupportedLanguage] = field(\n        default_factory=lambda: [\n            SupportedLanguage.ENGLISH,\n            SupportedLanguage.ARABIC,\n            SupportedLanguage.SPANISH,\n            SupportedLanguage.FRENCH,\n            SupportedLanguage.GERMAN,\n            SupportedLanguage.HINDI,\n            SupportedLanguage.URDU,\n            SupportedLanguage.CHINESE,\n        ]\n    )\n\n    # Default language when uncertain\n    default_language: SupportedLanguage = SupportedLanguage.ENGLISH\n\n\n# Unicode script ranges for script-based detection\nSCRIPT_RANGES = {\n    SupportedLanguage.ARABIC: [\n        (0x0600, 0x06FF),  # Arabic\n        (0x0750, 0x077F),  # Arabic Supplement\n        (0x08A0, 0x08FF),  # Arabic Extended-A\n        (0xFB50, 0xFDFF),  # Arabic Presentation Forms-A\n        (0xFE70, 0xFEFF),  # Arabic Presentation Forms-B\n    ],\n    SupportedLanguage.CHINESE: [\n        (0x4E00, 0x9FFF),  # CJK Unified Ideographs\n        (0x3400, 0x4DBF),  # CJK Extension A\n    ],\n    SupportedLanguage.HINDI: [\n        (0x0900, 0x097F),  # Devanagari\n        (0xA8E0, 0xA8FF),  # Devanagari Extended\n    ],\n    SupportedLanguage.URDU: [\n        (0x0600, 0x06FF),  # Arabic (Urdu uses Arabic script)\n        (0x0750, 0x077F),  # Arabic Supplement\n    ],\n    SupportedLanguage.JAPANESE: [\n        (0x3040, 0x309F),  # Hiragana\n        (0x30A0, 0x30FF),  # Katakana\n    ],\n    SupportedLanguage.KOREAN: [\n        (0xAC00, 0xD7AF),  # Hangul Syllables\n        (0x1100, 0x11FF),  # Hangul Jamo\n    ],\n    SupportedLanguage.RUSSIAN: [\n        (0x0400, 0x04FF),  # Cyrillic\n        (0x0500, 0x052F),  # Cyrillic Supplement\n    ],\n}\n\n# Common words for statistical detection (top 20 per language)\nCOMMON_WORDS = {\n    SupportedLanguage.ENGLISH: {\n        'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been',\n        'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',\n        'can', 'could', 'should', 'may', 'might', 'must', 'shall',\n        'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from',\n        'this', 'that', 'these', 'those', 'it', 'its', 'what', 'which'\n    },\n    SupportedLanguage.SPANISH: {\n        'el', 'la', 'los', 'las', 'un', 'una', 'es', 'son', 'está',\n        'están', 'de', 'en', 'que', 'y', 'a', 'por', 'con', 'para',\n        'no', 'se', 'su', 'sus', 'pero', 'si', 'como', 'más', 'muy'\n    },\n    SupportedLanguage.FRENCH: {\n        'le', 'la', 'les', 'un', 'une', 'est', 'sont', 'de', 'du',\n        'des', 'en', 'que', 'et', 'à', 'pour', 'avec', 'dans', 'sur',\n        'ne', 'pas', 'se', 'ce', 'qui', 'plus', 'très', 'bien', 'fait'\n    },\n    SupportedLanguage.GERMAN: {\n        'der', 'die', 'das', 'ein', 'eine', 'ist', 'sind', 'war',\n        'und', 'in', 'zu', 'den', 'von', 'mit', 'auf', 'für', 'nicht',\n        'es', 'sich', 'auch', 'als', 'an', 'noch', 'nach', 'wie'\n    },\n    SupportedLanguage.ITALIAN: {\n        'il', 'la', 'i', 'le', 'un', 'una', 'è', 'sono', 'di', 'del',\n        'della', 'in', 'che', 'e', 'a', 'per', 'con', 'da', 'non',\n        'si', 'su', 'come', 'più', 'molto', 'anche', 'ma', 'se'\n    },\n    SupportedLanguage.PORTUGUESE: {\n        'o', 'a', 'os', 'as', 'um', 'uma', 'é', 'são', 'de', 'do',\n        'da', 'em', 'que', 'e', 'para', 'com', 'não', 'se', 'por',\n        'mais', 'como', 'muito', 'também', 'mas', 'seu', 'sua'\n    },\n}\n\n\nclass LanguageDetectionService:\n    \"\"\"\n    Service for detecting languages and code-switching in text.\n\n    Uses multiple detection strategies:\n    1. Script detection (Unicode ranges)\n    2. Statistical word frequency\n    3. Character n-gram analysis\n    \"\"\"\n\n    def __init__(self, config: Optional[LanguageDetectionConfig] = None):\n        self.config = config or LanguageDetectionConfig()\n        self._initialized = False\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize the service.\"\"\"\n        if self._initialized:\n            return\n\n        logger.info(\n            \"Initializing LanguageDetectionService\",\n            extra={\n                \"supported_languages\": [l.value for l in self.config.supported_languages],\n                \"code_switch_enabled\": self.config.enable_code_switch_detection,\n            }\n        )\n\n        self._initialized = True\n\n    async def detect(self, text: str) -> LanguageDetectionResult:\n        \"\"\"\n        Detect language(s) in text.\n\n        Args:\n            text: Text to analyze\n\n        Returns:\n            LanguageDetectionResult with detected languages\n        \"\"\"\n        if not text or not text.strip():\n            return LanguageDetectionResult(\n                primary_language=self.config.default_language,\n                confidence=0.0,\n                detected_languages={},\n                is_code_switched=False,\n                detection_method=\"empty_input\"\n            )\n\n        # Collect scores from different methods\n        scores: Dict[SupportedLanguage, float] = {}\n\n        # 1. Script-based detection\n        if self.config.enable_script_detection:\n            script_scores = self._detect_by_script(text)\n            for lang, score in script_scores.items():\n                scores[lang] = scores.get(lang, 0) + score * 0.5\n\n        # 2. Statistical word frequency\n        if self.config.enable_statistical_detection:\n            word_scores = self._detect_by_words(text)\n            for lang, score in word_scores.items():\n                scores[lang] = scores.get(lang, 0) + score * 0.5\n\n        # Determine primary language\n        if scores:\n            primary = max(scores.items(), key=lambda x: x[1])\n            primary_language = primary[0]\n            confidence = min(primary[1], 1.0)\n        else:\n            primary_language = self.config.default_language\n            confidence = 0.0\n\n        # Check for code-switching\n        is_code_switched = False\n        if self.config.enable_code_switch_detection and len(scores) > 1:\n            total = sum(scores.values())\n            if total > 0:\n                sorted_scores = sorted(scores.items(), key=lambda x: x[1], reverse=True)\n                if len(sorted_scores) > 1:\n                    secondary_ratio = sorted_scores[1][1] / total\n                    is_code_switched = secondary_ratio >= self.config.code_switch_threshold\n\n        # Detect segments if code-switched\n        segments = []\n        if is_code_switched:\n            segments = self._detect_segments(text)\n\n        return LanguageDetectionResult(\n            primary_language=primary_language,\n            confidence=confidence,\n            detected_languages=scores,\n            is_code_switched=is_code_switched,\n            segments=segments,\n            detection_method=\"hybrid\"\n        )\n\n    def _detect_by_script(self, text: str) -> Dict[SupportedLanguage, float]:\n        \"\"\"Detect languages by Unicode script ranges.\"\"\"\n        char_counts: Dict[SupportedLanguage, int] = Counter()\n        total_chars = 0\n\n        for char in text:\n            code_point = ord(char)\n\n            # Skip ASCII letters (ambiguous)\n            if 0x0041 <= code_point <= 0x007A:\n                continue\n\n            # Skip whitespace and punctuation\n            if char.isspace() or not char.isalnum():\n                continue\n\n            total_chars += 1\n\n            for lang, ranges in SCRIPT_RANGES.items():\n                if lang in self.config.supported_languages:\n                    for start, end in ranges:\n                        if start <= code_point <= end:\n                            char_counts[lang] += 1\n                            break\n\n        # Convert to ratios\n        scores = {}\n        if total_chars > 0:\n            for lang, count in char_counts.items():\n                scores[lang] = count / total_chars\n\n        return scores\n\n    def _detect_by_words(self, text: str) -> Dict[SupportedLanguage, float]:\n        \"\"\"Detect languages by common word frequency.\"\"\"\n        # Tokenize (simple whitespace split)\n        words = re.findall(r'\\b\\w+\\b', text.lower())\n\n        if not words:\n            return {}\n\n        word_counts: Dict[SupportedLanguage, int] = Counter()\n\n        for word in words:\n            for lang, common in COMMON_WORDS.items():\n                if lang in self.config.supported_languages:\n                    if word in common:\n                        word_counts[lang] += 1\n\n        # Convert to ratios\n        total_matches = sum(word_counts.values())\n        scores = {}\n        if total_matches > 0:\n            for lang, count in word_counts.items():\n                scores[lang] = count / total_matches\n\n        return scores\n\n    def _detect_segments(self, text: str) -> List[LanguageSegment]:\n        \"\"\"Detect language segments in code-switched text.\"\"\"\n        segments = []\n\n        # Simple segmentation by sentence\n        sentences = re.split(r'[.!?]+', text)\n\n        current_idx = 0\n        for sentence in sentences:\n            if not sentence.strip():\n                current_idx += len(sentence) + 1\n                continue\n\n            # Detect language for this segment\n            script_scores = self._detect_by_script(sentence)\n            word_scores = self._detect_by_words(sentence)\n\n            # Combine scores\n            combined = {}\n            for lang in set(list(script_scores.keys()) + list(word_scores.keys())):\n                combined[lang] = (\n                    script_scores.get(lang, 0) * 0.5 +\n                    word_scores.get(lang, 0) * 0.5\n                )\n\n            if combined:\n                best = max(combined.items(), key=lambda x: x[1])\n                lang = best[0]\n                confidence = min(best[1], 1.0)\n            else:\n                lang = self.config.default_language\n                confidence = 0.0\n\n            start_idx = text.find(sentence.strip(), current_idx)\n            end_idx = start_idx + len(sentence.strip())\n\n            segments.append(LanguageSegment(\n                text=sentence.strip(),\n                language=lang,\n                confidence=confidence,\n                start_idx=start_idx,\n                end_idx=end_idx\n            ))\n\n            current_idx = end_idx + 1\n\n        return segments\n\n    def detect_script(self, text: str) -> Optional[SupportedLanguage]:\n        \"\"\"\n        Quick script-only detection for single characters or short text.\n\n        Args:\n            text: Text to check\n\n        Returns:\n            Detected language or None\n        \"\"\"\n        for char in text:\n            code_point = ord(char)\n\n            for lang, ranges in SCRIPT_RANGES.items():\n                for start, end in ranges:\n                    if start <= code_point <= end:\n                        return lang\n\n        return None\n\n    def is_rtl(self, language: SupportedLanguage) -> bool:\n        \"\"\"Check if a language is right-to-left.\"\"\"\n        return language in [\n            SupportedLanguage.ARABIC,\n            SupportedLanguage.URDU,\n        ]\n\n    def get_tts_language_code(self, language: SupportedLanguage) -> str:\n        \"\"\"\n        Get TTS provider language code.\n\n        Args:\n            language: Detected language\n\n        Returns:\n            Language code for TTS (e.g., 'en-US', 'ar-SA')\n        \"\"\"\n        mapping = {\n            SupportedLanguage.ENGLISH: \"en-US\",\n            SupportedLanguage.ARABIC: \"ar-SA\",\n            SupportedLanguage.SPANISH: \"es-ES\",\n            SupportedLanguage.FRENCH: \"fr-FR\",\n            SupportedLanguage.GERMAN: \"de-DE\",\n            SupportedLanguage.CHINESE: \"zh-CN\",\n            SupportedLanguage.HINDI: \"hi-IN\",\n            SupportedLanguage.URDU: \"ur-PK\",\n            SupportedLanguage.PORTUGUESE: \"pt-BR\",\n            SupportedLanguage.ITALIAN: \"it-IT\",\n            SupportedLanguage.JAPANESE: \"ja-JP\",\n            SupportedLanguage.KOREAN: \"ko-KR\",\n            SupportedLanguage.RUSSIAN: \"ru-RU\",\n            SupportedLanguage.TURKISH: \"tr-TR\",\n        }\n        return mapping.get(language, \"en-US\")\n\n    def get_stt_language_code(self, language: SupportedLanguage) -> str:\n        \"\"\"\n        Get STT provider language code.\n\n        Args:\n            language: Detected language\n\n        Returns:\n            Language code for STT\n        \"\"\"\n        # Most STT providers use BCP-47 codes\n        return self.get_tts_language_code(language)\n\n\n# Singleton instance\n_language_detection_service: Optional[LanguageDetectionService] = None\n\n\ndef get_language_detection_service() -> LanguageDetectionService:\n    \"\"\"Get or create the singleton LanguageDetectionService instance.\"\"\"\n    global _language_detection_service\n    if _language_detection_service is None:\n        _language_detection_service = LanguageDetectionService()\n    return _language_detection_service\n\n\nasync def detect_language(text: str) -> LanguageDetectionResult:\n    \"\"\"\n    Convenience function for language detection.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        LanguageDetectionResult\n    \"\"\"\n    service = get_language_detection_service()\n    await service.initialize()\n    return await service.detect(text)\n"
}
