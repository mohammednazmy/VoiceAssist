{
  "path": "apps/web-app/src/components/voice/SpeakerAttributedTranscript.tsx",
  "language": "typescript",
  "size": 10174,
  "last_modified": "2025-12-04T22:09:55.012Z",
  "lines": 317,
  "content": "/**\n * SpeakerAttributedTranscript - Multi-Speaker Transcript Display\n *\n * Displays transcripts with speaker attribution from the speaker\n * diarization service. Part of Voice Mode v4.1 Phase 3.\n *\n * Features:\n * - Color-coded speaker indicators\n * - Speaker name labels and legend\n * - Timestamp display for each segment\n * - Current speaker highlighting\n * - Confidence indicators\n * - Auto-scroll to latest segment\n *\n * Reference: docs/voice/speaker-diarization-service.md\n */\n\nimport { useRef, useEffect, useMemo } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Tooltip } from \"../ui/Tooltip\";\n\nexport interface SpeakerSegment {\n  /** Speaker identifier (e.g., \"SPEAKER_00\") */\n  speakerId: string;\n  /** Transcript text for this segment */\n  text: string;\n  /** Segment start time in milliseconds */\n  startMs: number;\n  /** Segment end time in milliseconds */\n  endMs: number;\n  /** Detection confidence (0-1) */\n  confidence: number;\n}\n\nexport interface SpeakerProfile {\n  /** Speaker identifier */\n  speakerId: string;\n  /** Display name (user-assigned or auto-generated) */\n  name?: string;\n  /** Total speaking time in milliseconds */\n  totalSpeakingMs?: number;\n}\n\ninterface SpeakerAttributedTranscriptProps {\n  /** List of speaker segments with transcripts */\n  segments: SpeakerSegment[];\n  /** Map of speaker IDs to profiles */\n  speakerProfiles: Map<string, SpeakerProfile>;\n  /** Currently speaking speaker ID */\n  currentSpeaker?: string;\n  /** Whether to show speaker legend */\n  showLegend?: boolean;\n  /** Whether to show timestamps */\n  showTimestamps?: boolean;\n  /** Whether to show confidence indicators */\n  showConfidence?: boolean;\n  /** Whether to auto-scroll to latest segment */\n  autoScroll?: boolean;\n  /** Callback when a speaker name is clicked (for editing) */\n  onSpeakerClick?: (speakerId: string) => void;\n  /** Custom class name */\n  className?: string;\n}\n\nconst SPEAKER_COLORS = [\n  {\n    bg: \"bg-blue-100 dark:bg-blue-900/30\",\n    text: \"text-blue-700 dark:text-blue-300\",\n    border: \"border-blue-300 dark:border-blue-700\",\n  },\n  {\n    bg: \"bg-green-100 dark:bg-green-900/30\",\n    text: \"text-green-700 dark:text-green-300\",\n    border: \"border-green-300 dark:border-green-700\",\n  },\n  {\n    bg: \"bg-purple-100 dark:bg-purple-900/30\",\n    text: \"text-purple-700 dark:text-purple-300\",\n    border: \"border-purple-300 dark:border-purple-700\",\n  },\n  {\n    bg: \"bg-orange-100 dark:bg-orange-900/30\",\n    text: \"text-orange-700 dark:text-orange-300\",\n    border: \"border-orange-300 dark:border-orange-700\",\n  },\n];\n\nfunction getSpeakerColorIndex(speakerId: string): number {\n  // Extract number from speaker ID (e.g., \"SPEAKER_01\" -> 1)\n  const match = speakerId.match(/(\\d+)$/);\n  const index = match ? parseInt(match[1], 10) : 0;\n  return index % SPEAKER_COLORS.length;\n}\n\nfunction formatTime(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}:${remainingSeconds.toString().padStart(2, \"0\")}`;\n}\n\nexport function SpeakerAttributedTranscript({\n  segments,\n  speakerProfiles,\n  currentSpeaker,\n  showLegend = true,\n  showTimestamps = true,\n  showConfidence = false,\n  autoScroll = true,\n  onSpeakerClick,\n  className,\n}: SpeakerAttributedTranscriptProps) {\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n\n  // Auto-scroll to latest segment\n  useEffect(() => {\n    if (autoScroll && scrollContainerRef.current) {\n      scrollContainerRef.current.scrollTop =\n        scrollContainerRef.current.scrollHeight;\n    }\n  }, [segments, autoScroll]);\n\n  // Get unique speakers from segments\n  const uniqueSpeakers = useMemo(() => {\n    const speakerIds = new Set(segments.map((s) => s.speakerId));\n    return Array.from(speakerIds);\n  }, [segments]);\n\n  const getSpeakerName = (speakerId: string): string => {\n    const profile = speakerProfiles.get(speakerId);\n    return profile?.name || speakerId.replace(\"SPEAKER_\", \"Speaker \");\n  };\n\n  if (segments.length === 0) {\n    return (\n      <div\n        className={cn(\n          \"flex items-center justify-center p-8\",\n          \"text-neutral-500 dark:text-neutral-400\",\n          \"bg-neutral-50 dark:bg-neutral-800/50 rounded-lg\",\n          className,\n        )}\n      >\n        <div className=\"text-center\">\n          <div className=\"text-lg mb-1\">No transcript yet</div>\n          <div className=\"text-sm\">Speak to start the conversation</div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn(\"speaker-transcript\", className)}>\n      {/* Speaker Legend */}\n      {showLegend && uniqueSpeakers.length > 1 && (\n        <div className=\"flex flex-wrap gap-2 mb-4\">\n          {uniqueSpeakers.map((speakerId) => {\n            const colorIndex = getSpeakerColorIndex(speakerId);\n            const colors = SPEAKER_COLORS[colorIndex];\n            const profile = speakerProfiles.get(speakerId);\n\n            return (\n              <Tooltip\n                key={speakerId}\n                content={\n                  <div>\n                    <div>{speakerId}</div>\n                    {profile?.totalSpeakingMs && (\n                      <div>\n                        Speaking time: {formatTime(profile.totalSpeakingMs)}\n                      </div>\n                    )}\n                  </div>\n                }\n              >\n                <button\n                  className={cn(\n                    \"flex items-center gap-1.5 px-2 py-1 rounded-full text-xs\",\n                    \"border transition-all\",\n                    colors.bg,\n                    colors.text,\n                    colors.border,\n                    currentSpeaker === speakerId &&\n                      \"ring-2 ring-blue-500 ring-offset-1\",\n                    onSpeakerClick && \"cursor-pointer hover:opacity-80\",\n                  )}\n                  onClick={() => onSpeakerClick?.(speakerId)}\n                  type=\"button\"\n                >\n                  <span\n                    className={cn(\n                      \"w-2 h-2 rounded-full\",\n                      currentSpeaker === speakerId && \"animate-pulse\",\n                      colors.bg.replace(\"bg-\", \"bg-\").replace(\"/30\", \"\"),\n                    )}\n                    style={{\n                      backgroundColor:\n                        colorIndex === 0\n                          ? \"#3b82f6\"\n                          : colorIndex === 1\n                            ? \"#22c55e\"\n                            : colorIndex === 2\n                              ? \"#a855f7\"\n                              : \"#f97316\",\n                    }}\n                  />\n                  <span className=\"font-medium\">\n                    {getSpeakerName(speakerId)}\n                  </span>\n                </button>\n              </Tooltip>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Transcript Segments */}\n      <div\n        ref={scrollContainerRef}\n        className=\"space-y-3 max-h-96 overflow-y-auto\"\n      >\n        {segments.map((segment, index) => {\n          const colorIndex = getSpeakerColorIndex(segment.speakerId);\n          const colors = SPEAKER_COLORS[colorIndex];\n          const isCurrentSpeaker = segment.speakerId === currentSpeaker;\n\n          return (\n            <div\n              key={`${segment.speakerId}-${segment.startMs}-${index}`}\n              className={cn(\"flex gap-3\", isCurrentSpeaker && \"animate-pulse\")}\n            >\n              {/* Speaker Avatar */}\n              <div\n                className={cn(\n                  \"flex-shrink-0 w-8 h-8 rounded-full\",\n                  \"flex items-center justify-center\",\n                  \"text-xs font-medium\",\n                  colors.bg,\n                  colors.text,\n                  colors.border,\n                  \"border\",\n                )}\n              >\n                {segment.speakerId.replace(\"SPEAKER_\", \"\")}\n              </div>\n\n              {/* Content */}\n              <div className=\"flex-1 min-w-0\">\n                {/* Header with speaker name and timestamp */}\n                <div className=\"flex items-center gap-2 mb-1\">\n                  <span className={cn(\"text-xs font-medium\", colors.text)}>\n                    {getSpeakerName(segment.speakerId)}\n                  </span>\n\n                  {showTimestamps && (\n                    <span className=\"text-xs text-neutral-400\">\n                      {formatTime(segment.startMs)} -{\" \"}\n                      {formatTime(segment.endMs)}\n                    </span>\n                  )}\n\n                  {showConfidence && (\n                    <Tooltip\n                      content={`Confidence: ${Math.round(segment.confidence * 100)}%`}\n                    >\n                      <span\n                        className={cn(\n                          \"w-1.5 h-1.5 rounded-full\",\n                          segment.confidence > 0.8\n                            ? \"bg-green-500\"\n                            : segment.confidence > 0.5\n                              ? \"bg-yellow-500\"\n                              : \"bg-red-500\",\n                        )}\n                      />\n                    </Tooltip>\n                  )}\n                </div>\n\n                {/* Transcript text */}\n                <div className=\"text-sm text-neutral-900 dark:text-neutral-100\">\n                  {segment.text}\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\n/**\n * Hook to manage speaker diarization state\n */\nexport function useSpeakerDiarization() {\n  // In production, this would connect to the diarization WebSocket\n  // For now, return demo state\n\n  const segments: SpeakerSegment[] = [];\n  const speakerProfiles = new Map<string, SpeakerProfile>();\n  const currentSpeaker: string | undefined = undefined;\n  const isProcessing = false;\n\n  return {\n    segments,\n    speakerProfiles,\n    currentSpeaker,\n    isProcessing,\n    addSegment: (_segment: SpeakerSegment) => {},\n    updateSpeakerName: (_speakerId: string, _name: string) => {},\n    clearSegments: () => {},\n  };\n}\n\nexport default SpeakerAttributedTranscript;\n"
}
