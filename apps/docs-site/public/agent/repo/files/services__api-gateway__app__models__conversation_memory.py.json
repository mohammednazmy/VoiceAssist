{
  "path": "services/api-gateway/app/models/conversation_memory.py",
  "language": "python",
  "size": 10729,
  "last_modified": "2025-12-04T12:32:40.270Z",
  "lines": 283,
  "content": "\"\"\"\nConversation Memory Models for Voice Mode Intelligence\n\nThese models support multi-tier memory for natural conversations:\n\n1. ConversationMemory - Short-term memory within a session\n   - Active conversation context\n   - Recent topics and entities\n   - Emotional state tracking\n\n2. UserContext - Medium-term memory across sessions\n   - User preferences learned from interactions\n   - Recurring topics of interest\n   - Communication style preferences\n\n3. UserSpeechProfile - Long-term speech patterns\n   - Average WPM and speech pace\n   - Pause patterns for turn-taking optimization\n   - Preferred response timing\n\nPhase: Voice Mode Intelligence Enhancement - Phase 4\n\"\"\"\n\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict\n\nfrom app.core.database import Base\nfrom sqlalchemy import Boolean, Column, DateTime, Float, ForeignKey, Integer, String, Text\nfrom sqlalchemy.dialects.postgresql import JSONB, UUID\nfrom sqlalchemy.orm import relationship\n\n\nclass ConversationMemory(Base):\n    \"\"\"\n    Short-term memory for active conversation context.\n\n    Stores recent context within a voice session for:\n    - Topic continuity\n    - Entity tracking (people, places, medical terms mentioned)\n    - Emotional state progression\n    - Reference resolution\n\n    Retained for the duration of a session + 24 hours for follow-up.\n    \"\"\"\n\n    __tablename__ = \"conversation_memory\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    session_id = Column(UUID(as_uuid=True), ForeignKey(\"sessions.id\"), nullable=False, index=True)\n    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"), nullable=False, index=True)\n\n    # Memory type: \"topic\", \"entity\", \"emotion\", \"reference\", \"context\"\n    memory_type = Column(String(50), nullable=False, index=True)\n\n    # Memory content\n    key = Column(String(255), nullable=False)  # e.g., \"current_topic\", \"mentioned_person\"\n    value = Column(Text, nullable=False)  # The actual memory value\n    memory_metadata = Column(\n        \"metadata\", JSONB, default=dict\n    )  # Additional context (confidence, source, etc.) - renamed to avoid SQLAlchemy reserved 'metadata'\n\n    # Relevance tracking\n    relevance_score = Column(Float, default=1.0)  # Decays over time\n    access_count = Column(Integer, default=1)  # How often this memory was accessed\n    last_accessed = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n\n    # Timestamps\n    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    expires_at = Column(DateTime(timezone=True), nullable=True)  # Auto-cleanup\n\n    # Relationships\n    user = relationship(\"User\", backref=\"conversation_memories\")\n\n    def __repr__(self):\n        return f\"<ConversationMemory(type={self.memory_type}, key={self.key})>\"\n\n    def decay_relevance(self, decay_rate: float = 0.1) -> None:\n        \"\"\"Decay relevance score over time.\"\"\"\n        self.relevance_score = max(0.0, self.relevance_score - decay_rate)\n        self.last_accessed = datetime.now(timezone.utc)\n\n    def access(self) -> None:\n        \"\"\"Mark memory as accessed, boosting relevance.\"\"\"\n        self.access_count += 1\n        self.relevance_score = min(1.0, self.relevance_score + 0.1)\n        self.last_accessed = datetime.now(timezone.utc)\n\n\nclass UserContext(Base):\n    \"\"\"\n    Medium-term context learned from user interactions.\n\n    Stores persistent context about the user such as:\n    - Topics they frequently discuss\n    - Their knowledge level on subjects\n    - Communication preferences (formal/casual, detailed/brief)\n    - Recurring concerns or questions\n\n    Updated after each session, retained indefinitely.\n    \"\"\"\n\n    __tablename__ = \"user_context\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"), nullable=False, index=True)\n\n    # Context category: \"interest\", \"knowledge\", \"preference\", \"concern\", \"history\"\n    category = Column(String(50), nullable=False, index=True)\n\n    # Context content\n    key = Column(String(255), nullable=False)  # e.g., \"medical_topics\", \"preferred_detail_level\"\n    value = Column(Text, nullable=False)\n    confidence = Column(Float, default=0.5)  # How confident are we in this context\n    context_metadata = Column(\"metadata\", JSONB, default=dict)  # Renamed to avoid SQLAlchemy reserved 'metadata'\n\n    # Learning tracking\n    observation_count = Column(Integer, default=1)  # Times we've observed this\n    last_confirmed = Column(DateTime(timezone=True), nullable=True)  # User confirmed this\n    contradicted = Column(Boolean, default=False)  # User contradicted this\n\n    # Timestamps\n    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at = Column(\n        DateTime(timezone=True),\n        default=lambda: datetime.now(timezone.utc),\n        onupdate=lambda: datetime.now(timezone.utc),\n    )\n\n    # Relationships\n    user = relationship(\"User\", backref=\"user_contexts\")\n\n    # Unique constraint on user + category + key\n    __table_args__ = (\n        # Each user can only have one entry per category+key combination\n        {\"extend_existing\": True},\n    )\n\n    def __repr__(self):\n        return f\"<UserContext(category={self.category}, key={self.key}, conf={self.confidence:.2f})>\"\n\n    def reinforce(self, boost: float = 0.1) -> None:\n        \"\"\"Reinforce this context when observed again.\"\"\"\n        self.observation_count += 1\n        self.confidence = min(1.0, self.confidence + boost)\n        self.updated_at = datetime.now(timezone.utc)\n\n    def contradict(self) -> None:\n        \"\"\"Mark as contradicted, reducing confidence.\"\"\"\n        self.contradicted = True\n        self.confidence = max(0.0, self.confidence - 0.3)\n        self.updated_at = datetime.now(timezone.utc)\n\n\nclass UserSpeechProfile(Base):\n    \"\"\"\n    Long-term speech pattern profile for a user.\n\n    Stores learned speech characteristics for:\n    - Optimal response timing (based on user's pace)\n    - Turn-taking calibration\n    - Backchannel frequency preferences\n    - Barge-in sensitivity\n\n    Updated incrementally after voice sessions.\n    \"\"\"\n\n    __tablename__ = \"user_speech_profiles\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    user_id = Column(\n        UUID(as_uuid=True),\n        ForeignKey(\"users.id\"),\n        nullable=False,\n        unique=True,\n        index=True,\n    )\n\n    # Speech rate metrics\n    avg_words_per_minute = Column(Float, default=140.0)  # Average WPM\n    wpm_std_deviation = Column(Float, default=20.0)  # Variance in WPM\n    min_observed_wpm = Column(Float, nullable=True)\n    max_observed_wpm = Column(Float, nullable=True)\n\n    # Pause patterns\n    avg_pause_duration_ms = Column(Integer, default=300)  # Average pause\n    typical_thinking_pause_ms = Column(Integer, default=800)  # Thinking pauses\n    turn_yield_threshold_ms = Column(Integer, default=1500)  # When user yields turn\n\n    # Response timing preferences (learned)\n    preferred_response_delay_ms = Column(Integer, default=200)  # How long to wait\n    backchannel_frequency = Column(Float, default=0.3)  # 0-1, how often to backchannel\n    barge_in_sensitivity = Column(Float, default=0.5)  # 0-1, how sensitive\n\n    # Voice characteristics (if voice auth enabled)\n    voice_embedding = Column(JSONB, nullable=True)  # Voice fingerprint\n    speaker_confidence = Column(Float, nullable=True)\n\n    # Learning metadata\n    total_voice_sessions = Column(Integer, default=0)\n    total_utterances = Column(Integer, default=0)\n    total_voice_minutes = Column(Float, default=0.0)\n    last_voice_session = Column(DateTime(timezone=True), nullable=True)\n\n    # Timestamps\n    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at = Column(\n        DateTime(timezone=True),\n        default=lambda: datetime.now(timezone.utc),\n        onupdate=lambda: datetime.now(timezone.utc),\n    )\n\n    # Relationships\n    user = relationship(\"User\", backref=\"speech_profile\", uselist=False)\n\n    def __repr__(self):\n        return f\"<UserSpeechProfile(user={self.user_id}, wpm={self.avg_words_per_minute:.0f})>\"\n\n    def update_from_session(\n        self,\n        wpm: float,\n        avg_pause_ms: float,\n        utterance_count: int,\n        session_duration_min: float,\n    ) -> None:\n        \"\"\"\n        Update profile with data from a completed voice session.\n\n        Uses exponential moving average for smooth updates.\n        \"\"\"\n        # Exponential moving average weight\n        alpha = 0.1 if self.total_voice_sessions > 10 else 0.3\n\n        # Update WPM\n        old_wpm = self.avg_words_per_minute\n        self.avg_words_per_minute = (1 - alpha) * old_wpm + alpha * wpm\n\n        # Update min/max\n        if self.min_observed_wpm is None or wpm < self.min_observed_wpm:\n            self.min_observed_wpm = wpm\n        if self.max_observed_wpm is None or wpm > self.max_observed_wpm:\n            self.max_observed_wpm = wpm\n\n        # Update pause duration\n        if avg_pause_ms > 0:\n            self.avg_pause_duration_ms = int((1 - alpha) * self.avg_pause_duration_ms + alpha * avg_pause_ms)\n\n        # Update counters\n        self.total_voice_sessions += 1\n        self.total_utterances += utterance_count\n        self.total_voice_minutes += session_duration_min\n        self.last_voice_session = datetime.now(timezone.utc)\n\n    def get_optimal_response_timing(self) -> Dict[str, Any]:\n        \"\"\"\n        Get optimal response timing parameters for this user.\n\n        Returns dict with recommended values for:\n        - response_delay_ms: Time to wait before responding\n        - backchannel_interval_s: How often to interject verbal cues\n        - barge_in_threshold: Energy threshold for interruption\n        \"\"\"\n        # Faster speakers prefer quicker responses\n        wpm_factor = max(0.5, min(1.5, 140 / self.avg_words_per_minute))\n\n        return {\n            \"response_delay_ms\": int(self.preferred_response_delay_ms * wpm_factor),\n            \"backchannel_interval_s\": max(3, int(10 * (1 - self.backchannel_frequency))),\n            \"barge_in_threshold\": self.barge_in_sensitivity,\n            \"turn_yield_ms\": self.turn_yield_threshold_ms,\n        }\n\n    @classmethod\n    def get_or_create(cls, db_session, user_id: uuid.UUID) -> \"UserSpeechProfile\":\n        \"\"\"Get existing profile or create new one with defaults.\"\"\"\n        profile = db_session.query(cls).filter(cls.user_id == user_id).first()\n        if not profile:\n            profile = cls(user_id=user_id)\n            db_session.add(profile)\n            db_session.commit()\n            db_session.refresh(profile)\n        return profile\n"
}
