{
  "path": "services/api-gateway/app/services/user_flag_override_service.py",
  "language": "python",
  "size": 30328,
  "last_modified": "2025-12-05T03:07:13.135Z",
  "lines": 919,
  "content": "\"\"\"User Flag Override Service (Phase 4).\n\nManages per-user feature flag overrides for:\n- Beta testing with select users\n- Debugging with forced flag states\n- Personalized feature experiences\n\nOverride Resolution Priority:\n1. User-specific override (if enabled and not expired)\n2. User targeting rules (from Phase 2)\n3. Scheduled variant changes (from Phase 3)\n4. Default flag value\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional\nfrom uuid import UUID\n\nfrom app.core.database import SessionLocal\nfrom app.core.metrics import (\n    flag_override_resolutions_total,\n    flag_user_overrides_active_total,\n    flag_user_overrides_bulk_total,\n    flag_user_overrides_expired_total,\n    flag_user_overrides_total,\n)\nfrom app.models.user_feature_flag import UserFeatureFlag\nfrom sqlalchemy import and_, delete, select, update\nfrom sqlalchemy.orm import Session\n\nlogger = logging.getLogger(__name__)\n\n\nclass UserFlagOverrideService:\n    \"\"\"Service for managing user-specific feature flag overrides.\n\n    Provides CRUD operations and resolution logic for user overrides.\n    Integrates with the existing FeatureFlagService for flag evaluation.\n    \"\"\"\n\n    def __init__(self, redis_client=None):\n        \"\"\"Initialize the service.\n\n        Args:\n            redis_client: Optional Redis client for caching overrides\n        \"\"\"\n        self.redis_client = redis_client\n        self._cache_prefix = \"user_flag_override:\"\n        self._cache_ttl = 300  # 5 minutes\n\n    async def get_user_overrides(\n        self,\n        user_id: UUID,\n        db: Optional[Session] = None,\n        include_expired: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"Get all flag overrides for a user.\n\n        Args:\n            user_id: The user's UUID\n            db: Optional database session\n            include_expired: Whether to include expired overrides\n\n        Returns:\n            Dictionary mapping flag_name to override details\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            query = select(UserFeatureFlag).where(UserFeatureFlag.user_id == user_id)\n\n            if not include_expired:\n                query = query.where(\n                    (UserFeatureFlag.expires_at.is_(None)) | (UserFeatureFlag.expires_at > datetime.now(timezone.utc))\n                )\n\n            result = db.execute(query)\n            overrides = result.scalars().all()\n\n            return {override.flag_name: override.to_dict() for override in overrides if override.enabled}\n\n        except Exception as e:\n            logger.error(f\"Failed to get user overrides for {user_id}: {e}\")\n            return {}\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_override(\n        self,\n        user_id: UUID,\n        flag_name: str,\n        db: Optional[Session] = None,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a specific override for a user and flag.\n\n        Args:\n            user_id: The user's UUID\n            flag_name: Name of the feature flag\n            db: Optional database session\n\n        Returns:\n            Override details or None if not found\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            result = db.execute(\n                select(UserFeatureFlag).where(\n                    and_(\n                        UserFeatureFlag.user_id == user_id,\n                        UserFeatureFlag.flag_name == flag_name,\n                    )\n                )\n            )\n            override = result.scalar_one_or_none()\n\n            if override:\n                return override.to_dict()\n            return None\n\n        except Exception as e:\n            logger.error(f\"Failed to get override {flag_name} for user {user_id}: {e}\")\n            return None\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def set_override(\n        self,\n        user_id: UUID,\n        flag_name: str,\n        value: Any,\n        created_by: str,\n        enabled: bool = True,\n        reason: Optional[str] = None,\n        expires_at: Optional[datetime] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        updated_by: Optional[str] = None,\n        db: Optional[Session] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Create or update an override for a user.\n\n        Args:\n            user_id: The user's UUID\n            flag_name: Name of the feature flag\n            value: The override value (JSON-serializable)\n            created_by: Admin email/ID creating the override\n            enabled: Whether the override is active\n            reason: Audit reason for the override\n            expires_at: Optional expiration datetime\n            metadata: Additional metadata (ticket number, experiment ID, etc.)\n            updated_by: Admin email/ID updating the override (for updates)\n            db: Optional database session\n\n        Returns:\n            The created/updated override details\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            # Check if override already exists\n            result = db.execute(\n                select(UserFeatureFlag).where(\n                    and_(\n                        UserFeatureFlag.user_id == user_id,\n                        UserFeatureFlag.flag_name == flag_name,\n                    )\n                )\n            )\n            existing = result.scalar_one_or_none()\n\n            if existing:\n                # Update existing override\n                existing.value = value\n                existing.enabled = enabled\n                existing.reason = reason\n                existing.expires_at = expires_at\n                existing.override_metadata = metadata\n                existing.updated_at = datetime.utcnow()\n                existing.updated_by = updated_by or created_by  # Track who modified\n                # Keep original created_by for audit trail\n                db.commit()\n                db.refresh(existing)\n                override = existing\n                logger.info(f\"Updated override for user {user_id}, flag {flag_name} by {updated_by or created_by}\")\n                # Emit update metric\n                flag_user_overrides_total.labels(flag_name=flag_name, action=\"update\").inc()\n            else:\n                # Create new override\n                override = UserFeatureFlag(\n                    user_id=user_id,\n                    flag_name=flag_name,\n                    value=value,\n                    enabled=enabled,\n                    reason=reason,\n                    created_by=created_by,\n                    expires_at=expires_at,\n                    override_metadata=metadata,\n                )\n                db.add(override)\n                db.commit()\n                db.refresh(override)\n                logger.info(f\"Created override for user {user_id}, flag {flag_name} by {created_by}\")\n                # Emit create metric\n                flag_user_overrides_total.labels(flag_name=flag_name, action=\"create\").inc()\n\n            # Invalidate cache\n            await self._invalidate_cache(user_id, flag_name)\n\n            return override.to_dict()\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed to set override {flag_name} for user {user_id}: {e}\")\n            raise\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def remove_override(\n        self,\n        user_id: UUID,\n        flag_name: str,\n        db: Optional[Session] = None,\n    ) -> bool:\n        \"\"\"Remove an override for a user.\n\n        Args:\n            user_id: The user's UUID\n            flag_name: Name of the feature flag\n            db: Optional database session\n\n        Returns:\n            True if override was removed, False if not found\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            result = db.execute(\n                delete(UserFeatureFlag).where(\n                    and_(\n                        UserFeatureFlag.user_id == user_id,\n                        UserFeatureFlag.flag_name == flag_name,\n                    )\n                )\n            )\n            db.commit()\n\n            if result.rowcount > 0:\n                logger.info(f\"Removed override for user {user_id}, flag {flag_name}\")\n                await self._invalidate_cache(user_id, flag_name)\n                # Emit delete metric\n                flag_user_overrides_total.labels(flag_name=flag_name, action=\"delete\").inc()\n                return True\n\n            return False\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed to remove override {flag_name} for user {user_id}: {e}\")\n            raise\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_flag_value_for_user(\n        self,\n        flag_name: str,\n        user_id: UUID,\n        default: Any = None,\n        db: Optional[Session] = None,\n    ) -> Any:\n        \"\"\"Get the effective flag value for a user, considering overrides.\n\n        This method checks for user overrides first, returning the override\n        value if one exists and is active/not expired.\n\n        Args:\n            flag_name: Name of the feature flag\n            user_id: The user's UUID\n            default: Default value if no override found\n            db: Optional database session\n\n        Returns:\n            The override value or default\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            # Check cache first\n            cached = await self._get_from_cache(user_id, flag_name)\n            if cached is not None:\n                return cached\n\n            # Query database\n            result = db.execute(\n                select(UserFeatureFlag).where(\n                    and_(\n                        UserFeatureFlag.user_id == user_id,\n                        UserFeatureFlag.flag_name == flag_name,\n                        UserFeatureFlag.enabled.is_(True),\n                        (UserFeatureFlag.expires_at.is_(None))\n                        | (UserFeatureFlag.expires_at > datetime.now(timezone.utc)),\n                    )\n                )\n            )\n            override = result.scalar_one_or_none()\n\n            if override:\n                value = override.value\n                await self._set_cache(user_id, flag_name, value)\n                return value\n\n            return default\n\n        except Exception as e:\n            logger.error(f\"Failed to get flag value {flag_name} for user {user_id}: {e}\")\n            return default\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def cleanup_expired_overrides(\n        self,\n        db: Optional[Session] = None,\n    ) -> int:\n        \"\"\"Remove expired overrides from the database.\n\n        Should be called periodically by a background task.\n\n        Args:\n            db: Optional database session\n\n        Returns:\n            Number of expired overrides removed\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            # First get the flag names of expired overrides for metrics\n            expired_flags = (\n                db.execute(\n                    select(UserFeatureFlag.flag_name).where(\n                        and_(\n                            UserFeatureFlag.expires_at.isnot(None),\n                            UserFeatureFlag.expires_at < datetime.now(timezone.utc),\n                        )\n                    )\n                )\n                .scalars()\n                .all()\n            )\n\n            # Now delete them\n            result = db.execute(\n                delete(UserFeatureFlag).where(\n                    and_(\n                        UserFeatureFlag.expires_at.isnot(None),\n                        UserFeatureFlag.expires_at < datetime.now(timezone.utc),\n                    )\n                )\n            )\n            db.commit()\n\n            count = result.rowcount\n            if count > 0:\n                logger.info(f\"Cleaned up {count} expired user flag overrides\")\n                # Emit expired metrics per flag\n                for flag_name in expired_flags:\n                    flag_user_overrides_expired_total.labels(flag_name=flag_name).inc()\n\n            return count\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed to cleanup expired overrides: {e}\")\n            return 0\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def list_overrides_for_flag(\n        self,\n        flag_name: str,\n        db: Optional[Session] = None,\n        limit: int = 100,\n        offset: int = 0,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"List all user overrides for a specific flag.\n\n        Args:\n            flag_name: Name of the feature flag\n            db: Optional database session\n            limit: Maximum number of results\n            offset: Pagination offset\n\n        Returns:\n            List of override details\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            result = db.execute(\n                select(UserFeatureFlag)\n                .where(UserFeatureFlag.flag_name == flag_name)\n                .order_by(UserFeatureFlag.created_at.desc())\n                .limit(limit)\n                .offset(offset)\n            )\n            overrides = result.scalars().all()\n\n            return [override.to_dict() for override in overrides]\n\n        except Exception as e:\n            logger.error(f\"Failed to list overrides for flag {flag_name}: {e}\")\n            return []\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def count_overrides_for_flag(\n        self,\n        flag_name: str,\n        db: Optional[Session] = None,\n    ) -> int:\n        \"\"\"Count total user overrides for a flag.\n\n        Args:\n            flag_name: Name of the feature flag\n            db: Optional database session\n\n        Returns:\n            Total count of overrides\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            from sqlalchemy import func\n\n            result = db.execute(select(func.count(UserFeatureFlag.id)).where(UserFeatureFlag.flag_name == flag_name))\n            return result.scalar() or 0\n\n        except Exception as e:\n            logger.error(f\"Failed to count overrides for flag {flag_name}: {e}\")\n            return 0\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def toggle_override(\n        self,\n        user_id: UUID,\n        flag_name: str,\n        enabled: bool,\n        updated_by: Optional[str] = None,\n        db: Optional[Session] = None,\n    ) -> bool:\n        \"\"\"Toggle an override's enabled state.\n\n        Args:\n            user_id: The user's UUID\n            flag_name: Name of the feature flag\n            enabled: New enabled state\n            updated_by: Admin who toggled the override\n            db: Optional database session\n\n        Returns:\n            True if successful, False if override not found\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            values = {\"enabled\": enabled, \"updated_at\": datetime.utcnow()}\n            if updated_by:\n                values[\"updated_by\"] = updated_by\n\n            result = db.execute(\n                update(UserFeatureFlag)\n                .where(\n                    and_(\n                        UserFeatureFlag.user_id == user_id,\n                        UserFeatureFlag.flag_name == flag_name,\n                    )\n                )\n                .values(**values)\n            )\n            db.commit()\n\n            if result.rowcount > 0:\n                await self._invalidate_cache(user_id, flag_name)\n                return True\n\n            return False\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed to toggle override {flag_name} for user {user_id}: {e}\")\n            raise\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_all_flags_for_user(\n        self,\n        user_id: UUID,\n        db: Optional[Session] = None,\n    ) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get all feature flags for a user with resolution source.\n\n        Returns all flags with their effective values and the source\n        of the value (override, segmentation, scheduled, or default).\n\n        Args:\n            user_id: The user's UUID\n            db: Optional database session\n\n        Returns:\n            Dictionary mapping flag_name to:\n            {\n                \"value\": effective value,\n                \"enabled\": bool,\n                \"source\": \"override\" | \"segmentation\" | \"scheduled\" | \"default\",\n                \"override_details\": {...} | None\n            }\n        \"\"\"\n        from app.services.feature_flags import feature_flag_service\n\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            # Get all flags\n            flags = await feature_flag_service.list_flags(db)\n\n            # Get user overrides\n            overrides = await self.get_user_overrides(user_id, db, include_expired=False)\n\n            result = {}\n            for flag in flags:\n                flag_name = flag.name\n                flag_dict = flag.to_dict()\n\n                # Check if user has an active override\n                if flag_name in overrides:\n                    override = overrides[flag_name]\n                    source = \"override\"\n                    result[flag_name] = {\n                        \"value\": override.get(\"value\"),\n                        \"enabled\": override.get(\"enabled\", True),\n                        \"source\": source,\n                        \"override_details\": override,\n                        \"flag_type\": flag_dict.get(\"flag_type\"),\n                    }\n                # TODO: Check segmentation rules (Phase 2)\n                # TODO: Check scheduled changes (Phase 3)\n                else:\n                    # Default flag value\n                    source = \"default\"\n                    result[flag_name] = {\n                        \"value\": flag_dict.get(\"value\") or flag_dict.get(\"default_value\"),\n                        \"enabled\": flag_dict.get(\"enabled\", False),\n                        \"source\": source,\n                        \"override_details\": None,\n                        \"flag_type\": flag_dict.get(\"flag_type\"),\n                    }\n\n                # Emit resolution metric\n                flag_override_resolutions_total.labels(flag_name=flag_name, source=source).inc()\n\n            return result\n\n        except Exception as e:\n            logger.error(f\"Failed to get all flags for user {user_id}: {e}\")\n            return {}\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def bulk_set_overrides(\n        self,\n        overrides: List[Dict[str, Any]],\n        created_by: str,\n        db: Optional[Session] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Create or update multiple overrides in a single transaction.\n\n        Args:\n            overrides: List of override specs, each containing:\n                - user_id: UUID\n                - flag_name: str\n                - value: Any\n                - enabled: bool (optional, default True)\n                - reason: str (optional)\n                - expires_at: datetime (optional)\n                - metadata: dict (optional)\n            created_by: Admin creating the overrides\n            db: Optional database session\n\n        Returns:\n            {\n                \"created\": int,\n                \"updated\": int,\n                \"failed\": int,\n                \"errors\": [...]\n            }\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        results = {\"created\": 0, \"updated\": 0, \"failed\": 0, \"errors\": []}\n\n        try:\n            for override_spec in overrides:\n                try:\n                    user_id = override_spec.get(\"user_id\")\n                    flag_name = override_spec.get(\"flag_name\")\n\n                    if not user_id or not flag_name:\n                        results[\"failed\"] += 1\n                        results[\"errors\"].append(\"Missing user_id or flag_name in override spec\")\n                        continue\n\n                    # Check if exists\n                    existing = db.execute(\n                        select(UserFeatureFlag).where(\n                            and_(\n                                UserFeatureFlag.user_id == user_id,\n                                UserFeatureFlag.flag_name == flag_name,\n                            )\n                        )\n                    ).scalar_one_or_none()\n\n                    if existing:\n                        # Update\n                        existing.value = override_spec.get(\"value\")\n                        existing.enabled = override_spec.get(\"enabled\", True)\n                        existing.reason = override_spec.get(\"reason\")\n                        existing.expires_at = override_spec.get(\"expires_at\")\n                        existing.override_metadata = override_spec.get(\"metadata\")\n                        existing.updated_at = datetime.utcnow()\n                        existing.updated_by = created_by\n                        results[\"updated\"] += 1\n                    else:\n                        # Create\n                        new_override = UserFeatureFlag(\n                            user_id=user_id,\n                            flag_name=flag_name,\n                            value=override_spec.get(\"value\"),\n                            enabled=override_spec.get(\"enabled\", True),\n                            reason=override_spec.get(\"reason\"),\n                            created_by=created_by,\n                            expires_at=override_spec.get(\"expires_at\"),\n                            override_metadata=override_spec.get(\"metadata\"),\n                        )\n                        db.add(new_override)\n                        results[\"created\"] += 1\n\n                    # Invalidate cache\n                    await self._invalidate_cache(user_id, flag_name)\n\n                except Exception as e:\n                    results[\"failed\"] += 1\n                    results[\"errors\"].append(str(e))\n\n            db.commit()\n            logger.info(\n                f\"Bulk override: {results['created']} created, \"\n                f\"{results['updated']} updated, {results['failed']} failed \"\n                f\"by {created_by}\"\n            )\n\n            # Emit bulk operation metric\n            if results[\"created\"] > 0 or results[\"updated\"] > 0:\n                flag_user_overrides_bulk_total.labels(action=\"create\").inc()\n\n            return results\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed bulk override operation: {e}\")\n            raise\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def bulk_delete_overrides(\n        self,\n        user_ids: List[UUID],\n        flag_name: Optional[str] = None,\n        db: Optional[Session] = None,\n    ) -> int:\n        \"\"\"Delete overrides for multiple users.\n\n        Args:\n            user_ids: List of user UUIDs\n            flag_name: Optional flag name filter (delete only for this flag)\n            db: Optional database session\n\n        Returns:\n            Number of overrides deleted\n        \"\"\"\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            query = delete(UserFeatureFlag).where(UserFeatureFlag.user_id.in_(user_ids))\n\n            if flag_name:\n                query = query.where(UserFeatureFlag.flag_name == flag_name)\n\n            result = db.execute(query)\n            db.commit()\n\n            # Invalidate caches\n            for user_id in user_ids:\n                if flag_name:\n                    await self._invalidate_cache(user_id, flag_name)\n                # Note: If no flag_name, we'd need to invalidate all flags for user\n                # This is simplified - in production, consider a user-level cache key\n\n            count = result.rowcount\n            logger.info(f\"Bulk deleted {count} overrides for {len(user_ids)} users\")\n\n            # Emit bulk delete metric\n            if count > 0:\n                flag_user_overrides_bulk_total.labels(action=\"delete\").inc()\n\n            return count\n\n        except Exception as e:\n            db.rollback()\n            logger.error(f\"Failed bulk delete operation: {e}\")\n            raise\n        finally:\n            if should_close_db:\n                db.close()\n\n    async def get_override_stats(\n        self,\n        db: Optional[Session] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Get statistics about user flag overrides.\n\n        Returns:\n            {\n                \"total_overrides\": int,\n                \"active_overrides\": int,\n                \"expired_overrides\": int,\n                \"overrides_by_flag\": {flag_name: count},\n                \"users_with_overrides\": int\n            }\n        \"\"\"\n        from sqlalchemy import func\n\n        should_close_db = False\n        if db is None:\n            db = SessionLocal()\n            should_close_db = True\n\n        try:\n            now = datetime.now(timezone.utc)\n\n            # Total overrides\n            total = db.execute(select(func.count(UserFeatureFlag.id))).scalar() or 0\n\n            # Active overrides (enabled and not expired)\n            active = (\n                db.execute(\n                    select(func.count(UserFeatureFlag.id)).where(\n                        and_(\n                            UserFeatureFlag.enabled.is_(True),\n                            (UserFeatureFlag.expires_at.is_(None)) | (UserFeatureFlag.expires_at > now),\n                        )\n                    )\n                ).scalar()\n                or 0\n            )\n\n            # Expired overrides\n            expired = (\n                db.execute(\n                    select(func.count(UserFeatureFlag.id)).where(\n                        and_(\n                            UserFeatureFlag.expires_at.isnot(None),\n                            UserFeatureFlag.expires_at <= now,\n                        )\n                    )\n                ).scalar()\n                or 0\n            )\n\n            # Overrides by flag (total)\n            by_flag_result = db.execute(\n                select(\n                    UserFeatureFlag.flag_name,\n                    func.count(UserFeatureFlag.id).label(\"count\"),\n                ).group_by(UserFeatureFlag.flag_name)\n            ).all()\n            overrides_by_flag = {row.flag_name: row.count for row in by_flag_result}\n\n            # Active overrides by flag (for gauge metrics)\n            active_by_flag_result = db.execute(\n                select(\n                    UserFeatureFlag.flag_name,\n                    func.count(UserFeatureFlag.id).label(\"count\"),\n                )\n                .where(\n                    and_(\n                        UserFeatureFlag.enabled.is_(True),\n                        (UserFeatureFlag.expires_at.is_(None)) | (UserFeatureFlag.expires_at > now),\n                    )\n                )\n                .group_by(UserFeatureFlag.flag_name)\n            ).all()\n\n            # Update active overrides gauge per flag\n            for row in active_by_flag_result:\n                flag_user_overrides_active_total.labels(flag_name=row.flag_name).set(row.count)\n\n            # Unique users with overrides\n            users_count = db.execute(select(func.count(func.distinct(UserFeatureFlag.user_id)))).scalar() or 0\n\n            return {\n                \"total_overrides\": total,\n                \"active_overrides\": active,\n                \"expired_overrides\": expired,\n                \"overrides_by_flag\": overrides_by_flag,\n                \"users_with_overrides\": users_count,\n            }\n\n        except Exception as e:\n            logger.error(f\"Failed to get override stats: {e}\")\n            return {}\n        finally:\n            if should_close_db:\n                db.close()\n\n    # Cache helpers\n    async def _get_from_cache(self, user_id: UUID, flag_name: str) -> Optional[Any]:\n        \"\"\"Get override value from Redis cache.\"\"\"\n        if not self.redis_client:\n            return None\n\n        try:\n            import json\n\n            key = f\"{self._cache_prefix}{user_id}:{flag_name}\"\n            data = self.redis_client.get(key)\n            if data:\n                return json.loads(data)\n            return None\n        except Exception:\n            return None\n\n    async def _set_cache(self, user_id: UUID, flag_name: str, value: Any) -> None:\n        \"\"\"Set override value in Redis cache.\"\"\"\n        if not self.redis_client:\n            return\n\n        try:\n            import json\n\n            key = f\"{self._cache_prefix}{user_id}:{flag_name}\"\n            self.redis_client.setex(key, self._cache_ttl, json.dumps(value))\n        except Exception:\n            pass\n\n    async def _invalidate_cache(self, user_id: UUID, flag_name: str) -> None:\n        \"\"\"Invalidate cached override value.\"\"\"\n        if not self.redis_client:\n            return\n\n        try:\n            key = f\"{self._cache_prefix}{user_id}:{flag_name}\"\n            self.redis_client.delete(key)\n        except Exception:\n            pass\n\n\n# Singleton instance\nuser_flag_override_service = UserFlagOverrideService()\n"
}
