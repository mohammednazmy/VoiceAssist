{
  "path": "services/api-gateway/app/api/calendar_connections.py",
  "language": "python",
  "size": 20623,
  "last_modified": "2025-12-04T11:26:47.479Z",
  "lines": 641,
  "content": "\"\"\"\nCalendar Connections API\n\nUser-facing endpoints for managing calendar integrations\n(Google, Microsoft, Apple iCloud, Nextcloud).\n\"\"\"\n\nfrom typing import Literal, Optional\n\nfrom app.core.api_envelope import success_response\nfrom app.core.config import settings\nfrom app.core.database import get_async_db\nfrom app.core.dependencies import get_current_user\nfrom app.core.logging import get_logger\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel, Field\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n# Import OAuth service for calendar connections\ntry:\n    from app.services.tools.oauth_service import CalendarProvider, oauth_service\n\n    OAUTH_AVAILABLE = True\nexcept ImportError:\n    OAUTH_AVAILABLE = False\n\nlogger = get_logger(__name__)\nrouter = APIRouter(prefix=\"/api/user/calendars\", tags=[\"user\", \"calendars\"])\nlimiter = Limiter(key_func=get_remote_address)\n\n\n# Pydantic models for request/response\nclass CalendarConnectionResponse(BaseModel):\n    \"\"\"Response model for a calendar connection.\"\"\"\n\n    id: str\n    provider: str\n    provider_display_name: str\n    status: str\n    caldav_url: Optional[str] = None\n    last_sync_at: Optional[str] = None\n    connected_at: Optional[str] = None\n    error_message: Optional[str] = None\n\n\nclass CalDAVConnectionRequest(BaseModel):\n    \"\"\"Request model for CalDAV connection.\"\"\"\n\n    provider: Literal[\"apple\", \"nextcloud\", \"caldav\"]\n    caldav_url: str = Field(..., description=\"CalDAV server URL\")\n    username: str = Field(..., description=\"CalDAV username\")\n    password: str = Field(..., description=\"CalDAV password or app-specific password\")\n    connection_name: Optional[str] = Field(None, description=\"Friendly name for this connection\")\n\n\nclass OAuthCallbackRequest(BaseModel):\n    \"\"\"Request model for OAuth callback.\"\"\"\n\n    code: str = Field(..., description=\"Authorization code from OAuth provider\")\n    state: str = Field(..., description=\"CSRF state token\")\n\n\n@router.get(\"/connections\")\n@limiter.limit(\"30/minute\")\nasync def list_calendar_connections(\n    request: Request,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    List all calendar connections for the current user.\n\n    Returns a list of connected calendars including status and provider info.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar integration is not available\",\n        )\n\n    try:\n        connections = await oauth_service.get_user_connections(\n            user_id=str(current_user.id),\n            db_session=db,\n        )\n        return success_response(connections)\n    except Exception as e:\n        logger.error(\n            \"list_calendar_connections_failed\",\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to retrieve calendar connections\",\n        )\n\n\n@router.get(\"/oauth/{provider}/authorize\")\n@limiter.limit(\"10/minute\")\nasync def calendar_oauth_authorize(\n    request: Request,\n    provider: Literal[\"google\", \"microsoft\"],\n    connection_name: Optional[str] = None,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Get OAuth authorization URL for connecting a calendar.\n\n    This is different from login OAuth - it requests calendar-specific scopes.\n\n    - **provider**: \"google\" or \"microsoft\"\n    - **connection_name**: Optional friendly name for this calendar connection\n\n    Returns a URL to redirect the user to for authorization.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar OAuth is not available\",\n        )\n\n    # Check if provider is configured\n    client_id = oauth_service.get_client_id(provider)\n    if not client_id:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=f\"{provider.title()} calendar integration is not configured\",\n        )\n\n    try:\n        # Generate callback URL using forwarded headers or fallback to ALLOWED_ORIGINS\n        forwarded_proto = request.headers.get(\"x-forwarded-proto\", \"https\")\n        forwarded_host = request.headers.get(\"x-forwarded-host\") or request.headers.get(\"host\")\n\n        if forwarded_host and \"localhost\" not in forwarded_host and \"voiceassist\" not in forwarded_host:\n            base_url = f\"{forwarded_proto}://{forwarded_host}\"\n        else:\n            # Fallback to first allowed origin (should be the primary domain)\n            allowed_origins = settings.ALLOWED_ORIGINS.split(\",\") if settings.ALLOWED_ORIGINS else []\n            # Prefer dev.asimo.io or first https origin\n            base_url = next(\n                (o.strip() for o in allowed_origins if \"dev.asimo.io\" in o),\n                next(\n                    (o.strip() for o in allowed_origins if o.strip().startswith(\"https\")),\n                    str(request.base_url).rstrip(\"/\"),\n                ),\n            )\n\n        callback_url = f\"{base_url}/api/user/calendars/oauth/callback\"\n\n        logger.info(\n            \"calendar_oauth_redirect_uri\",\n            base_url=base_url,\n            callback_url=callback_url,\n            forwarded_host=forwarded_host,\n        )\n\n        provider_enum = CalendarProvider.GOOGLE if provider == \"google\" else CalendarProvider.MICROSOFT\n\n        auth_url = await oauth_service.get_authorization_url(\n            provider=provider_enum,\n            user_id=str(current_user.id),\n            redirect_uri=callback_url,\n            db_session=db,\n            connection_name=connection_name,\n        )\n\n        logger.info(\n            \"calendar_oauth_authorize_url_generated\",\n            provider=provider,\n            user_id=str(current_user.id),\n        )\n\n        return success_response({\"url\": auth_url, \"provider\": provider})\n\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        )\n    except Exception as e:\n        logger.error(\n            \"calendar_oauth_authorize_failed\",\n            provider=provider,\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to generate authorization URL\",\n        )\n\n\n@router.get(\"/oauth/callback\")\n@limiter.limit(\"10/minute\")\nasync def calendar_oauth_callback_get(\n    request: Request,\n    code: str,\n    state: str,\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Handle OAuth callback (GET request from provider redirect).\n\n    This endpoint receives the authorization code and state from the OAuth provider\n    after the user authorizes access to their calendar.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar OAuth is not available\",\n        )\n\n    try:\n        result = await oauth_service.handle_callback(\n            code=code,\n            state=state,\n            db_session=db,\n        )\n\n        logger.info(\n            \"calendar_oauth_callback_success\",\n            provider=result.get(\"provider\"),\n            user_id=result.get(\"user_id\", \"\")[:8],\n        )\n\n        # Determine frontend URL from forwarded headers or config\n        forwarded_proto = request.headers.get(\"x-forwarded-proto\", \"https\")\n        forwarded_host = request.headers.get(\"x-forwarded-host\") or request.headers.get(\"host\")\n\n        if forwarded_host and \"localhost\" not in forwarded_host and \"voiceassist\" not in forwarded_host:\n            frontend_url = f\"{forwarded_proto}://{forwarded_host}\"\n        else:\n            # Fallback to ALLOWED_ORIGINS, preferring dev.asimo.io\n            allowed_origins = settings.ALLOWED_ORIGINS.split(\",\") if settings.ALLOWED_ORIGINS else []\n            frontend_url = next(\n                (o.strip() for o in allowed_origins if \"dev.asimo.io\" in o),\n                next(\n                    (o.strip() for o in allowed_origins if o.strip().startswith(\"https\")),\n                    \"https://dev.asimo.io\",\n                ),\n            )\n\n        # Redirect to integrations page with success status\n        redirect_url = f\"{frontend_url}/integrations?connected={result.get('provider')}\"\n        logger.info(\"calendar_oauth_redirecting\", redirect_url=redirect_url)\n        return RedirectResponse(url=redirect_url, status_code=302)\n\n    except ValueError as e:\n        logger.warning(\n            \"calendar_oauth_callback_invalid_state\",\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        )\n    except Exception as e:\n        logger.error(\n            \"calendar_oauth_callback_failed\",\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to complete calendar connection\",\n        )\n\n\n@router.post(\"/caldav/connect\")\n@limiter.limit(\"5/minute\")\nasync def connect_caldav_calendar(\n    request: Request,\n    connection: CalDAVConnectionRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Connect a CalDAV calendar (Apple iCloud, Nextcloud, or generic CalDAV).\n\n    For Apple iCloud:\n    - Use `https://caldav.icloud.com/` as the caldav_url\n    - Generate an app-specific password at appleid.apple.com\n\n    For Nextcloud:\n    - Use `https://your-nextcloud.com/remote.php/dav/` as the caldav_url\n    - Use your Nextcloud credentials or app password\n\n    The connection will be tested before being saved.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar integration is not available\",\n        )\n\n    try:\n        # Map string provider to enum\n        provider_map = {\n            \"apple\": CalendarProvider.APPLE,\n            \"nextcloud\": CalendarProvider.NEXTCLOUD,\n            \"caldav\": CalendarProvider.CALDAV,\n        }\n        provider_enum = provider_map.get(connection.provider)\n        if not provider_enum:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid provider: {connection.provider}\",\n            )\n\n        result = await oauth_service.connect_caldav(\n            user_id=str(current_user.id),\n            provider=provider_enum,\n            caldav_url=connection.caldav_url,\n            username=connection.username,\n            password=connection.password,\n            db_session=db,\n            connection_name=connection.connection_name,\n        )\n\n        if not result.get(\"success\"):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=result.get(\"error\", \"Failed to connect calendar\"),\n            )\n\n        logger.info(\n            \"caldav_calendar_connected\",\n            provider=connection.provider,\n            user_id=str(current_user.id),\n        )\n\n        return success_response(\n            {\n                \"success\": True,\n                \"provider\": connection.provider,\n                \"message\": f\"{connection.provider.title()} calendar connected successfully\",\n            }\n        )\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\n            \"caldav_connect_failed\",\n            provider=connection.provider,\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to connect calendar\",\n        )\n\n\n@router.delete(\"/connections/{connection_id}\")\n@limiter.limit(\"10/minute\")\nasync def disconnect_calendar(\n    request: Request,\n    connection_id: str,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Disconnect (remove) a calendar connection.\n\n    This revokes stored credentials and removes the connection.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar integration is not available\",\n        )\n\n    try:\n        # First verify the connection belongs to this user\n        connections = await oauth_service.get_user_connections(\n            user_id=str(current_user.id),\n            db_session=db,\n        )\n\n        connection_ids = [c[\"id\"] for c in connections]\n        if connection_id not in connection_ids:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Calendar connection not found\",\n            )\n\n        success = await oauth_service.disconnect(\n            connection_id=connection_id,\n            db_session=db,\n        )\n\n        if not success:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Calendar connection not found\",\n            )\n\n        logger.info(\n            \"calendar_disconnected\",\n            connection_id=connection_id,\n            user_id=str(current_user.id),\n        )\n\n        return success_response({\"success\": True, \"message\": \"Calendar disconnected\"})\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\n            \"calendar_disconnect_failed\",\n            connection_id=connection_id,\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to disconnect calendar\",\n        )\n\n\n@router.post(\"/connections/{connection_id}/set-default\")\n@limiter.limit(\"10/minute\")\nasync def set_default_calendar(\n    request: Request,\n    connection_id: str,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Set a calendar connection as the default.\n\n    The default calendar is used when the AI assistant creates events\n    without specifying which calendar to use.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar integration is not available\",\n        )\n\n    try:\n        # First verify the connection belongs to this user\n        connections = await oauth_service.get_user_connections(\n            user_id=str(current_user.id),\n            db_session=db,\n        )\n\n        connection_ids = [c[\"id\"] for c in connections]\n        if connection_id not in connection_ids:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Calendar connection not found\",\n            )\n\n        success = await oauth_service.set_default_connection(\n            user_id=str(current_user.id),\n            connection_id=connection_id,\n            db_session=db,\n        )\n\n        if not success:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to update default calendar\",\n            )\n\n        logger.info(\n            \"default_calendar_updated\",\n            connection_id=connection_id,\n            user_id=str(current_user.id),\n        )\n\n        return success_response({\"success\": True, \"message\": \"Default calendar updated\"})\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\n            \"set_default_calendar_failed\",\n            connection_id=connection_id,\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update default calendar\",\n        )\n\n\n@router.post(\"/connections/{connection_id}/test\")\n@limiter.limit(\"5/minute\")\nasync def test_calendar_connection(\n    request: Request,\n    connection_id: str,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_async_db),\n):\n    \"\"\"\n    Test a calendar connection.\n\n    Verifies that the stored credentials are still valid and can access the calendar.\n    \"\"\"\n    if not OAUTH_AVAILABLE:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Calendar integration is not available\",\n        )\n\n    try:\n        # First verify the connection belongs to this user\n        connections = await oauth_service.get_user_connections(\n            user_id=str(current_user.id),\n            db_session=db,\n        )\n\n        connection_ids = [c[\"id\"] for c in connections]\n        if connection_id not in connection_ids:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Calendar connection not found\",\n            )\n\n        result = await oauth_service.test_connection(\n            connection_id=connection_id,\n            db_session=db,\n        )\n\n        if result.get(\"success\"):\n            return success_response(\n                {\n                    \"success\": True,\n                    \"message\": \"Connection test successful\",\n                }\n            )\n        else:\n            return success_response(\n                {\n                    \"success\": False,\n                    \"error\": result.get(\"error\", \"Connection test failed\"),\n                }\n            )\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\n            \"calendar_test_failed\",\n            connection_id=connection_id,\n            user_id=str(current_user.id),\n            error=str(e),\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to test calendar connection\",\n        )\n\n\n@router.get(\"/providers\")\nasync def list_available_providers():\n    \"\"\"\n    List available calendar providers and their configuration status.\n\n    Returns which calendar providers are configured and available for connection.\n    \"\"\"\n    providers = []\n\n    # Google Calendar\n    google_configured = (\n        bool(settings.GOOGLE_CLIENT_ID and settings.GOOGLE_CLIENT_SECRET)\n        if hasattr(settings, \"GOOGLE_CLIENT_ID\")\n        else False\n    )\n    providers.append(\n        {\n            \"id\": \"google\",\n            \"name\": \"Google Calendar\",\n            \"auth_type\": \"oauth\",\n            \"configured\": google_configured,\n            \"description\": \"Connect your Google Calendar for event management\",\n        }\n    )\n\n    # Microsoft Outlook\n    microsoft_configured = (\n        bool(settings.MICROSOFT_CLIENT_ID and settings.MICROSOFT_CLIENT_SECRET)\n        if hasattr(settings, \"MICROSOFT_CLIENT_ID\")\n        else False\n    )\n    providers.append(\n        {\n            \"id\": \"microsoft\",\n            \"name\": \"Microsoft Outlook\",\n            \"auth_type\": \"oauth\",\n            \"configured\": microsoft_configured,\n            \"description\": \"Connect your Outlook Calendar for event management\",\n        }\n    )\n\n    # Apple iCloud (CalDAV - always available if service is up)\n    providers.append(\n        {\n            \"id\": \"apple\",\n            \"name\": \"Apple iCloud\",\n            \"auth_type\": \"caldav\",\n            \"configured\": OAUTH_AVAILABLE,\n            \"description\": \"Connect your iCloud Calendar using an app-specific password\",\n            \"setup_url\": \"https://support.apple.com/en-us/HT204397\",\n        }\n    )\n\n    # Nextcloud (CalDAV - always available if service is up)\n    providers.append(\n        {\n            \"id\": \"nextcloud\",\n            \"name\": \"Nextcloud\",\n            \"auth_type\": \"caldav\",\n            \"configured\": OAUTH_AVAILABLE,\n            \"description\": \"Connect your Nextcloud Calendar\",\n        }\n    )\n\n    # Generic CalDAV\n    providers.append(\n        {\n            \"id\": \"caldav\",\n            \"name\": \"Other CalDAV\",\n            \"auth_type\": \"caldav\",\n            \"configured\": OAUTH_AVAILABLE,\n            \"description\": \"Connect any CalDAV-compatible calendar server\",\n        }\n    )\n\n    return success_response({\"providers\": providers})\n"
}
