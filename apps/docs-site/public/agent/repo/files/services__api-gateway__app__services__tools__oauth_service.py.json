{
  "path": "services/api-gateway/app/services/tools/oauth_service.py",
  "language": "python",
  "size": 27028,
  "last_modified": "2025-12-04T11:27:01.587Z",
  "lines": 789,
  "content": "\"\"\"\nOAuth Service for VoiceAssist Calendar Integration\n\nHandles OAuth flows for Google Calendar and Microsoft Outlook,\nas well as CalDAV credential management for Apple iCloud and Nextcloud.\n\"\"\"\n\nimport logging\nimport os\nimport secrets\nfrom datetime import datetime, timedelta, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom urllib.parse import urlencode\n\nimport httpx\nfrom cryptography.fernet import Fernet\nfrom sqlalchemy import text\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\n\nclass CalendarProvider(str, Enum):\n    \"\"\"Supported calendar providers.\"\"\"\n\n    GOOGLE = \"google\"\n    MICROSOFT = \"microsoft\"\n    APPLE = \"apple\"\n    NEXTCLOUD = \"nextcloud\"\n    CALDAV = \"caldav\"\n\n\nclass OAuthService:\n    \"\"\"\n    Handles OAuth flows and credential management for calendar providers.\n\n    Responsibilities:\n    - Generate OAuth authorization URLs\n    - Exchange authorization codes for tokens\n    - Refresh expired tokens\n    - Encrypt/decrypt stored tokens\n    - Manage CalDAV credentials\n    \"\"\"\n\n    # OAuth configuration for each provider\n    OAUTH_CONFIGS = {\n        CalendarProvider.GOOGLE: {\n            \"auth_url\": \"https://accounts.google.com/o/oauth2/v2/auth\",\n            \"token_url\": \"https://oauth2.googleapis.com/token\",\n            \"scopes\": [\n                \"https://www.googleapis.com/auth/calendar\",\n                \"https://www.googleapis.com/auth/calendar.events\",\n            ],\n        },\n        CalendarProvider.MICROSOFT: {\n            \"auth_url\": \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\",\n            \"token_url\": \"https://login.microsoftonline.com/common/oauth2/v2.0/token\",\n            \"scopes\": [\n                \"https://graph.microsoft.com/Calendars.ReadWrite\",\n                \"offline_access\",\n            ],\n        },\n    }\n\n    def __init__(self):\n        \"\"\"Initialize OAuth service with encryption key.\"\"\"\n        self._encryption_key = self._get_encryption_key()\n        if self._encryption_key:\n            self._cipher = Fernet(self._encryption_key)\n        else:\n            self._cipher = None\n            logger.warning(\"No CALENDAR_ENCRYPTION_KEY set - token encryption disabled\")\n\n    def _get_encryption_key(self) -> Optional[bytes]:\n        \"\"\"Get the encryption key from environment.\"\"\"\n        key = os.environ.get(\"CALENDAR_ENCRYPTION_KEY\")\n        if key:\n            return key.encode() if isinstance(key, str) else key\n        return None\n\n    def get_client_id(self, provider: str) -> str:\n        \"\"\"Get OAuth client ID for a provider.\"\"\"\n        if provider == \"google\":\n            return os.environ.get(\"GOOGLE_CLIENT_ID\", \"\")\n        elif provider == \"microsoft\":\n            return os.environ.get(\"MICROSOFT_CLIENT_ID\", \"\")\n        return \"\"\n\n    def get_client_secret(self, provider: str) -> str:\n        \"\"\"Get OAuth client secret for a provider.\"\"\"\n        if provider == \"google\":\n            return os.environ.get(\"GOOGLE_CLIENT_SECRET\", \"\")\n        elif provider == \"microsoft\":\n            return os.environ.get(\"MICROSOFT_CLIENT_SECRET\", \"\")\n        return \"\"\n\n    def _encrypt(self, data: str) -> str:\n        \"\"\"Encrypt a string using Fernet.\"\"\"\n        if not self._cipher:\n            return data  # No encryption if key not set\n        return self._cipher.encrypt(data.encode()).decode()\n\n    def _decrypt(self, encrypted_data: str) -> Optional[str]:\n        \"\"\"Decrypt a string using Fernet.\n\n        Returns:\n            Decrypted string, or None if decryption fails.\n        \"\"\"\n        if not self._cipher:\n            return encrypted_data\n        try:\n            return self._cipher.decrypt(encrypted_data.encode()).decode()\n        except Exception:\n            # Invalid token format or decryption error\n            return None\n\n    async def get_authorization_url(\n        self,\n        provider: CalendarProvider,\n        user_id: str,\n        redirect_uri: str,\n        db_session: AsyncSession,\n        connection_name: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Generate OAuth authorization URL with CSRF state.\n\n        Args:\n            provider: Calendar provider (google or microsoft)\n            user_id: User identifier\n            redirect_uri: Where to redirect after authorization\n            db_session: Database session\n            connection_name: Optional friendly name for the connection\n\n        Returns:\n            Authorization URL to redirect user to\n        \"\"\"\n        if provider not in [CalendarProvider.GOOGLE, CalendarProvider.MICROSOFT]:\n            raise ValueError(f\"OAuth not supported for provider: {provider}\")\n\n        config = self.OAUTH_CONFIGS[provider]\n\n        # Generate CSRF state token\n        state = secrets.token_urlsafe(32)\n\n        # Store state in database\n        await db_session.execute(\n            text(\n                \"\"\"\n                INSERT INTO oauth_states (state, user_id, provider, redirect_uri, connection_name)\n                VALUES (:state, :user_id, :provider, :redirect_uri, :connection_name)\n            \"\"\"\n            ),\n            {\n                \"state\": state,\n                \"user_id\": user_id,\n                \"provider\": provider.value,\n                \"redirect_uri\": redirect_uri,\n                \"connection_name\": connection_name,\n            },\n        )\n        await db_session.commit()\n\n        # Build authorization URL\n        params = {\n            \"client_id\": self.get_client_id(provider.value),\n            \"redirect_uri\": os.environ.get(\"OAUTH_REDIRECT_URI\", redirect_uri),\n            \"scope\": \" \".join(config[\"scopes\"]),\n            \"state\": state,\n            \"response_type\": \"code\",\n            \"access_type\": \"offline\",  # For refresh token\n            \"prompt\": \"consent\",\n        }\n\n        return f\"{config['auth_url']}?{urlencode(params)}\"\n\n    async def handle_callback(\n        self,\n        code: str,\n        state: str,\n        db_session: AsyncSession,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Handle OAuth callback - exchange code for tokens.\n\n        Args:\n            code: Authorization code from provider\n            state: CSRF state token\n            db_session: Database session\n\n        Returns:\n            Dict with success status and provider info\n        \"\"\"\n        # Validate state\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                SELECT user_id, provider, redirect_uri, connection_name\n                FROM oauth_states\n                WHERE state = :state AND expires_at > now()\n            \"\"\"\n            ),\n            {\"state\": state},\n        )\n        state_record = result.fetchone()\n\n        if not state_record:\n            raise ValueError(\"Invalid or expired OAuth state\")\n\n        user_id = state_record.user_id\n        provider = CalendarProvider(state_record.provider)\n        connection_name = state_record.connection_name\n\n        # Delete used state\n        await db_session.execute(\n            text(\"DELETE FROM oauth_states WHERE state = :state\"),\n            {\"state\": state},\n        )\n\n        # Exchange code for tokens\n        config = self.OAUTH_CONFIGS[provider]\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                config[\"token_url\"],\n                data={\n                    \"client_id\": self.get_client_id(provider.value),\n                    \"client_secret\": self.get_client_secret(provider.value),\n                    \"code\": code,\n                    \"grant_type\": \"authorization_code\",\n                    \"redirect_uri\": os.environ.get(\"OAUTH_REDIRECT_URI\", state_record.redirect_uri),\n                },\n            )\n            response.raise_for_status()\n            tokens = response.json()\n\n        # Encrypt tokens\n        access_token_encrypted = self._encrypt(tokens[\"access_token\"])\n        refresh_token_encrypted = self._encrypt(tokens.get(\"refresh_token\", \"\"))\n\n        # Calculate token expiry\n        expires_in = tokens.get(\"expires_in\", 3600)\n        token_expires_at = datetime.now(timezone.utc) + timedelta(seconds=expires_in)\n\n        # Store or update connection\n        await db_session.execute(\n            text(\n                \"\"\"\n                INSERT INTO user_calendar_connections\n                (user_id, provider, provider_display_name, access_token_encrypted,\n                 refresh_token_encrypted, token_expires_at, status, scopes)\n                VALUES (:user_id, :provider, :display_name, :access_token, :refresh_token,\n                        :expires_at, 'connected', :scopes)\n                ON CONFLICT (user_id, provider, caldav_url)\n                DO UPDATE SET\n                    access_token_encrypted = :access_token,\n                    refresh_token_encrypted = :refresh_token,\n                    token_expires_at = :expires_at,\n                    status = 'connected',\n                    error_message = NULL,\n                    updated_at = now()\n            \"\"\"\n            ),\n            {\n                \"user_id\": user_id,\n                \"provider\": provider.value,\n                \"display_name\": connection_name or f\"{provider.value.title()} Calendar\",\n                \"access_token\": access_token_encrypted,\n                \"refresh_token\": refresh_token_encrypted,\n                \"expires_at\": token_expires_at,\n                \"scopes\": config[\"scopes\"],\n            },\n        )\n        await db_session.commit()\n\n        logger.info(f\"Successfully connected {provider.value} calendar for user {user_id[:8]}...\")\n\n        return {\n            \"success\": True,\n            \"provider\": provider.value,\n            \"user_id\": user_id,\n        }\n\n    async def connect_caldav(\n        self,\n        user_id: str,\n        provider: CalendarProvider,\n        caldav_url: str,\n        username: str,\n        password: str,\n        db_session: AsyncSession,\n        connection_name: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Store CalDAV credentials for Apple iCloud or Nextcloud.\n\n        Args:\n            user_id: User identifier\n            provider: Calendar provider (apple, nextcloud, or caldav)\n            caldav_url: CalDAV server URL\n            username: CalDAV username\n            password: CalDAV password (or app-specific password)\n            db_session: Database session\n            connection_name: Optional friendly name\n\n        Returns:\n            Dict with success status\n        \"\"\"\n        # Test connection first\n        try:\n            from app.services.caldav_service import CalDAVService\n\n            caldav = CalDAVService(url=caldav_url, username=username, password=password)\n            # Try to list calendars to verify connection\n            await caldav.test_connection()\n        except Exception as e:\n            logger.warning(f\"CalDAV connection test failed: {e}\")\n            return {\n                \"success\": False,\n                \"error\": f\"Connection test failed: {str(e)}\",\n            }\n\n        # Encrypt credentials\n        password_encrypted = self._encrypt(password)\n\n        # Store connection\n        await db_session.execute(\n            text(\n                \"\"\"\n                INSERT INTO user_calendar_connections\n                (user_id, provider, provider_display_name, caldav_url,\n                 caldav_username, caldav_password_encrypted, status)\n                VALUES (:user_id, :provider, :display_name, :caldav_url,\n                        :username, :password, 'connected')\n                ON CONFLICT (user_id, provider, caldav_url)\n                DO UPDATE SET\n                    caldav_username = :username,\n                    caldav_password_encrypted = :password,\n                    status = 'connected',\n                    error_message = NULL,\n                    updated_at = now()\n            \"\"\"\n            ),\n            {\n                \"user_id\": user_id,\n                \"provider\": provider.value,\n                \"display_name\": connection_name or f\"{provider.value.title()} Calendar\",\n                \"caldav_url\": caldav_url,\n                \"username\": username,\n                \"password\": password_encrypted,\n            },\n        )\n        await db_session.commit()\n\n        logger.info(f\"Successfully connected {provider.value} CalDAV calendar for user {user_id[:8]}...\")\n\n        return {\n            \"success\": True,\n            \"provider\": provider.value,\n        }\n\n    async def get_decrypted_tokens(\n        self,\n        connection_id: str,\n        db_session: Optional[AsyncSession],\n    ) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Get decrypted OAuth tokens for a connection.\n        Automatically refreshes expired tokens if a refresh token is available.\n\n        Args:\n            connection_id: Calendar connection ID\n            db_session: Database session\n\n        Returns:\n            Dict with access_token and refresh_token, or None\n        \"\"\"\n        if not db_session:\n            return None\n\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                SELECT access_token_encrypted, refresh_token_encrypted, token_expires_at, provider\n                FROM user_calendar_connections\n                WHERE id = :id\n            \"\"\"\n            ),\n            {\"id\": connection_id},\n        )\n        row = result.fetchone()\n\n        if not row or not row.access_token_encrypted:\n            return None\n\n        access_token = self._decrypt(row.access_token_encrypted)\n        refresh_token = self._decrypt(row.refresh_token_encrypted) if row.refresh_token_encrypted else None\n\n        # Check if token needs refresh (with 5 minute buffer)\n        buffer_time = timedelta(minutes=5)\n        if row.token_expires_at and row.token_expires_at < datetime.now(timezone.utc) + buffer_time:\n            if refresh_token:\n                logger.info(f\"Token expired for connection {connection_id}, attempting refresh...\")\n                try:\n                    new_tokens = await self._refresh_oauth_token(\n                        provider=row.provider,\n                        refresh_token=refresh_token,\n                        connection_id=connection_id,\n                        db_session=db_session,\n                    )\n                    if new_tokens:\n                        access_token = new_tokens[\"access_token\"]\n                        if new_tokens.get(\"refresh_token\"):\n                            refresh_token = new_tokens[\"refresh_token\"]\n                        logger.info(f\"Successfully refreshed token for connection {connection_id}\")\n                except Exception as e:\n                    logger.error(f\"Failed to refresh token for connection {connection_id}: {e}\")\n                    # Return the old token anyway - it might still work for a few seconds\n            else:\n                logger.warning(f\"Token expired for connection {connection_id} but no refresh token available\")\n\n        return {\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n        }\n\n    async def _refresh_oauth_token(\n        self,\n        provider: str,\n        refresh_token: str,\n        connection_id: str,\n        db_session: AsyncSession,\n    ) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Refresh an expired OAuth token.\n\n        Args:\n            provider: Calendar provider (google or microsoft)\n            refresh_token: The refresh token\n            connection_id: Connection ID to update\n            db_session: Database session\n\n        Returns:\n            Dict with new access_token (and optionally new refresh_token), or None\n        \"\"\"\n        try:\n            provider_enum = CalendarProvider(provider)\n        except ValueError:\n            logger.error(f\"Unknown provider for token refresh: {provider}\")\n            return None\n\n        if provider_enum not in self.OAUTH_CONFIGS:\n            logger.error(f\"OAuth not supported for provider: {provider}\")\n            return None\n\n        config = self.OAUTH_CONFIGS[provider_enum]\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                config[\"token_url\"],\n                data={\n                    \"client_id\": self.get_client_id(provider),\n                    \"client_secret\": self.get_client_secret(provider),\n                    \"refresh_token\": refresh_token,\n                    \"grant_type\": \"refresh_token\",\n                },\n            )\n            response.raise_for_status()\n            tokens = response.json()\n\n        # Encrypt new tokens\n        access_token_encrypted = self._encrypt(tokens[\"access_token\"])\n        # Some providers return a new refresh token, some don't\n        new_refresh_token = tokens.get(\"refresh_token\")\n        refresh_token_encrypted = self._encrypt(new_refresh_token) if new_refresh_token else None\n\n        # Calculate new token expiry\n        expires_in = tokens.get(\"expires_in\", 3600)\n        token_expires_at = datetime.now(timezone.utc) + timedelta(seconds=expires_in)\n\n        # Update the connection with new tokens\n        if refresh_token_encrypted:\n            await db_session.execute(\n                text(\n                    \"\"\"\n                    UPDATE user_calendar_connections\n                    SET access_token_encrypted = :access_token,\n                        refresh_token_encrypted = :refresh_token,\n                        token_expires_at = :expires_at,\n                        status = 'connected',\n                        error_message = NULL,\n                        updated_at = now()\n                    WHERE id = :id\n                \"\"\"\n                ),\n                {\n                    \"access_token\": access_token_encrypted,\n                    \"refresh_token\": refresh_token_encrypted,\n                    \"expires_at\": token_expires_at,\n                    \"id\": connection_id,\n                },\n            )\n        else:\n            await db_session.execute(\n                text(\n                    \"\"\"\n                    UPDATE user_calendar_connections\n                    SET access_token_encrypted = :access_token,\n                        token_expires_at = :expires_at,\n                        status = 'connected',\n                        error_message = NULL,\n                        updated_at = now()\n                    WHERE id = :id\n                \"\"\"\n                ),\n                {\n                    \"access_token\": access_token_encrypted,\n                    \"expires_at\": token_expires_at,\n                    \"id\": connection_id,\n                },\n            )\n        await db_session.commit()\n\n        return {\n            \"access_token\": tokens[\"access_token\"],\n            \"refresh_token\": new_refresh_token or refresh_token,\n        }\n\n    async def get_caldav_credentials(\n        self,\n        connection_id: str,\n        db_session: Optional[AsyncSession],\n    ) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Get decrypted CalDAV credentials for a connection.\n\n        Args:\n            connection_id: Calendar connection ID\n            db_session: Database session\n\n        Returns:\n            Dict with url, username, password, or None\n        \"\"\"\n        if not db_session:\n            return None\n\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                SELECT caldav_url, caldav_username, caldav_password_encrypted\n                FROM user_calendar_connections\n                WHERE id = :id AND status = 'connected'\n            \"\"\"\n            ),\n            {\"id\": connection_id},\n        )\n        row = result.fetchone()\n\n        if not row or not row.caldav_url:\n            return None\n\n        return {\n            \"url\": row.caldav_url,\n            \"username\": row.caldav_username,\n            \"password\": (self._decrypt(row.caldav_password_encrypted) if row.caldav_password_encrypted else None),\n        }\n\n    async def get_user_connections(\n        self,\n        user_id: str,\n        db_session: AsyncSession,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get all calendar connections for a user.\n\n        Args:\n            user_id: User identifier\n            db_session: Database session\n\n        Returns:\n            List of connection dictionaries\n        \"\"\"\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                SELECT id, provider, provider_display_name, status, caldav_url,\n                       last_sync_at, connected_at, error_message, token_expires_at, is_default\n                FROM user_calendar_connections\n                WHERE user_id = :user_id\n                ORDER BY connected_at\n            \"\"\"\n            ),\n            {\"user_id\": user_id},\n        )\n        rows = result.fetchall()\n\n        now = datetime.now(timezone.utc)\n        return [\n            {\n                \"id\": str(row.id),\n                \"provider\": row.provider,\n                \"provider_display_name\": row.provider_display_name,\n                \"status\": row.status,\n                \"is_active\": row.status == \"connected\" and (row.token_expires_at is None or row.token_expires_at > now),\n                \"is_default\": row.is_default or False,\n                \"caldav_url\": row.caldav_url,\n                \"last_sync_at\": (row.last_sync_at.isoformat() if row.last_sync_at else None),\n                \"connected_at\": (row.connected_at.isoformat() if row.connected_at else None),\n                \"error_message\": row.error_message,\n            }\n            for row in rows\n        ]\n\n    async def disconnect(\n        self,\n        connection_id: str,\n        db_session: AsyncSession,\n    ) -> bool:\n        \"\"\"\n        Disconnect (delete) a calendar connection.\n\n        Args:\n            connection_id: Calendar connection ID\n            db_session: Database session\n\n        Returns:\n            True if deleted, False otherwise\n        \"\"\"\n        result = await db_session.execute(\n            text(\"DELETE FROM user_calendar_connections WHERE id = :id\"),\n            {\"id\": connection_id},\n        )\n        await db_session.commit()\n\n        return result.rowcount > 0\n\n    async def set_default_connection(\n        self,\n        user_id: str,\n        connection_id: str,\n        db_session: AsyncSession,\n    ) -> bool:\n        \"\"\"\n        Set a calendar connection as the default for a user.\n\n        This first clears any existing default, then sets the specified\n        connection as the new default.\n\n        Args:\n            user_id: User's ID\n            connection_id: Connection ID to set as default\n            db_session: Database session\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        # First, clear existing default for this user\n        await db_session.execute(\n            text(\n                \"\"\"\n                UPDATE user_calendar_connections\n                SET is_default = FALSE\n                WHERE user_id = :user_id AND is_default = TRUE\n            \"\"\"\n            ),\n            {\"user_id\": user_id},\n        )\n\n        # Set the new default\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                UPDATE user_calendar_connections\n                SET is_default = TRUE\n                WHERE id = :id AND user_id = :user_id\n            \"\"\"\n            ),\n            {\"id\": connection_id, \"user_id\": user_id},\n        )\n        await db_session.commit()\n\n        return result.rowcount > 0\n\n    async def test_connection(\n        self,\n        connection_id: str,\n        db_session: AsyncSession,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Test a calendar connection.\n\n        Args:\n            connection_id: Calendar connection ID\n            db_session: Database session\n\n        Returns:\n            Dict with test results\n        \"\"\"\n        result = await db_session.execute(\n            text(\n                \"\"\"\n                SELECT provider, caldav_url\n                FROM user_calendar_connections\n                WHERE id = :id\n            \"\"\"\n            ),\n            {\"id\": connection_id},\n        )\n        row = result.fetchone()\n\n        if not row:\n            return {\"success\": False, \"error\": \"Connection not found\"}\n\n        provider = row.provider\n\n        try:\n            if provider in [\"google\", \"microsoft\"]:\n                # Test OAuth connection by listing calendars\n                tokens = await self.get_decrypted_tokens(connection_id, db_session)\n                if not tokens:\n                    return {\"success\": False, \"error\": \"No valid tokens\"}\n\n                # Simple API test\n                if provider == \"google\":\n                    async with httpx.AsyncClient() as client:\n                        resp = await client.get(\n                            \"https://www.googleapis.com/calendar/v3/users/me/calendarList\",\n                            headers={\"Authorization\": f\"Bearer {tokens['access_token']}\"},\n                        )\n                        resp.raise_for_status()\n                elif provider == \"microsoft\":\n                    async with httpx.AsyncClient() as client:\n                        resp = await client.get(\n                            \"https://graph.microsoft.com/v1.0/me/calendars\",\n                            headers={\"Authorization\": f\"Bearer {tokens['access_token']}\"},\n                        )\n                        resp.raise_for_status()\n\n            else:\n                # Test CalDAV connection\n                creds = await self.get_caldav_credentials(connection_id, db_session)\n                if not creds:\n                    return {\"success\": False, \"error\": \"No CalDAV credentials\"}\n\n                from app.services.caldav_service import CalDAVService\n\n                caldav = CalDAVService(\n                    url=creds[\"url\"],\n                    username=creds[\"username\"],\n                    password=creds[\"password\"],\n                )\n                await caldav.test_connection()\n\n            # Update last sync time\n            await db_session.execute(\n                text(\n                    \"\"\"\n                    UPDATE user_calendar_connections\n                    SET last_sync_at = now(), status = 'connected', error_message = NULL\n                    WHERE id = :id\n                \"\"\"\n                ),\n                {\"id\": connection_id},\n            )\n            await db_session.commit()\n\n            return {\"success\": True}\n\n        except Exception as e:\n            # Update connection status with error\n            await db_session.execute(\n                text(\n                    \"\"\"\n                    UPDATE user_calendar_connections\n                    SET status = 'error', error_message = :error\n                    WHERE id = :id\n                \"\"\"\n                ),\n                {\"id\": connection_id, \"error\": str(e)[:500]},\n            )\n            await db_session.commit()\n\n            return {\"success\": False, \"error\": str(e)}\n\n\n# Global singleton instance\noauth_service = OAuthService()\n"
}
