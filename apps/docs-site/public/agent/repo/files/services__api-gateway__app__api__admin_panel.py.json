{
  "path": "services/api-gateway/app/api/admin_panel.py",
  "language": "python",
  "size": 55256,
  "last_modified": "2025-12-04T11:26:48.029Z",
  "lines": 1611,
  "content": "\"\"\"Admin Panel API endpoints (Phase 7 + Phase 8.3 + Phase 8 Improvements).\n\nProvides system summary information for the Admin Panel dashboard.\n\nPhase 7: Basic summary endpoint\nPhase 8.3: WebSocket status, user management, metrics, audit logs\nPhase 8 Improvements:\n- Database-backed audit logs (persistent)\n- Redis-backed WebSocket session tracking (distributed)\n- Optimized database queries (aggregated)\n- Redis caching for metrics\n- Audit logging for all admin actions\n\nNOTE: This file is being refactored into the app/api/admin/ module.\nSchemas and utilities have been moved to:\n- app/api/admin/schemas.py\n- app/api/admin/utils.py\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport csv\nimport io\nimport json\nimport logging\nimport secrets\nimport uuid\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, Literal, Optional\n\nfrom app.api.admin.schemas import PasswordResetRequest, UserInviteRequest, UserUpdate\nfrom app.api.admin.utils import (\n    METRICS_CACHE_TTL,\n    REDIS_METRICS_CACHE_KEY,\n    enforce_admin_action_rate_limit,\n    get_active_websocket_count,\n    get_all_websocket_sessions,\n    log_audit_event,\n    resolve_admin_role,\n    unregister_websocket_session,\n)\nfrom app.core.api_envelope import error_response, success_response\nfrom app.core.database import get_db, get_db_pool_stats, get_redis_pool_stats, redis_client\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.audit_log import AuditLog\nfrom app.models.user import User\nfrom app.services.admin_audit_log_service import admin_audit_log_service\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, WebSocket, WebSocketDisconnect\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom pydantic import BaseModel\nfrom sqlalchemy import Date, cast, desc, func\nfrom sqlalchemy.orm import Session\nfrom starlette.websockets import WebSocketState\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/panel\", tags=[\"admin\", \"panel\"])\n\n\n# ============================================================================\n# System Summary Endpoint\n# ============================================================================\n\n\n@router.get(\"/summary\")\nasync def get_system_summary(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Return a simple system summary for the admin dashboard.\"\"\"\n    total_users = db.query(User).count()\n    active_users = db.query(User).filter(User.is_active.is_(True)).count()\n    admin_users = db.query(User).filter(User.is_admin.is_(True)).count()\n\n    data = {\n        \"total_users\": total_users,\n        \"active_users\": active_users,\n        \"admin_users\": admin_users,\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# WebSocket Status Monitoring\n# ============================================================================\n\n\n@router.get(\"/websocket-status\")\nasync def get_websocket_status(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Return WebSocket connection status for admin dashboard.\"\"\"\n    # Get pool stats\n    try:\n        db_stats = get_db_pool_stats()\n        redis_stats = get_redis_pool_stats()\n    except Exception:\n        db_stats = {\"size\": 0, \"checked_out\": 0, \"checked_in\": 0}\n        redis_stats = {\"max_connections\": 0, \"in_use_connections\": 0}\n\n    # Get sessions from Redis\n    sessions = get_all_websocket_sessions()\n\n    # Count connections by type\n    connections_by_type = {\"chat\": 0, \"voice\": 0, \"other\": 0}\n    for session_info in sessions.values():\n        conn_type = session_info.get(\"type\", \"other\")\n        if conn_type in connections_by_type:\n            connections_by_type[conn_type] += 1\n        else:\n            connections_by_type[\"other\"] += 1\n\n    # Get recent connections (last 10)\n    recent_connections = sorted(\n        [{\"session_id\": sid, **info} for sid, info in sessions.items()],\n        key=lambda x: x.get(\"connected_at\", \"\"),\n        reverse=True,\n    )[:10]\n\n    data = {\n        \"active_connections\": len(sessions),\n        \"connections_by_type\": connections_by_type,\n        \"recent_connections\": recent_connections,\n        \"pool_stats\": {\n            \"database\": db_stats,\n            \"redis\": redis_stats,\n        },\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# User Management CRUD (with Audit Logging)\n# ============================================================================\n\n\n@router.get(\"/users\")\nasync def list_users(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    offset: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    search: Optional[str] = Query(None),\n    is_active: Optional[bool] = Query(None),\n    is_admin: Optional[bool] = Query(None),\n) -> Dict:\n    \"\"\"List users with pagination and filtering.\"\"\"\n    query = db.query(User)\n\n    # Apply filters\n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter((User.email.ilike(search_term)) | (User.full_name.ilike(search_term)))\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    if is_admin is not None:\n        query = query.filter(User.is_admin == is_admin)\n\n    # Get total count\n    total = query.count()\n\n    # Apply pagination and ordering\n    users = query.order_by(desc(User.created_at)).offset(offset).limit(limit).all()\n\n    # Convert to response format\n    user_list = [\n        {\n            \"id\": str(user.id),\n            \"email\": user.email,\n            \"full_name\": user.full_name,\n            \"is_admin\": user.is_admin,\n            \"admin_role\": user.admin_role,\n            \"is_active\": user.is_active,\n            \"created_at\": user.created_at.isoformat() if user.created_at else None,\n            \"last_login\": user.last_login.isoformat() if user.last_login else None,\n        }\n        for user in users\n    ]\n\n    data = {\n        \"users\": user_list,\n        \"total\": total,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/users/{user_id}\")\nasync def get_user(\n    request: Request,\n    user_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get a single user by ID.\"\"\"\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    data = {\n        \"id\": str(user.id),\n        \"email\": user.email,\n        \"full_name\": user.full_name,\n        \"is_admin\": user.is_admin,\n        \"admin_role\": user.admin_role,\n        \"is_active\": user.is_active,\n        \"created_at\": user.created_at.isoformat() if user.created_at else None,\n        \"last_login\": user.last_login.isoformat() if user.last_login else None,\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.put(\"/users/{user_id}\")\nasync def update_user(\n    request: Request,\n    user_id: str,\n    user_update: UserUpdate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Update a user's information.\"\"\"\n    ensure_admin_privileges(current_admin_user)\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    update_data = user_update.model_dump(exclude_unset=True)\n    incoming_role = update_data.pop(\"admin_role\", None)\n    incoming_admin_flag = update_data.pop(\"is_admin\", None)\n    desired_role = resolve_admin_role(user.admin_role, incoming_admin_flag, incoming_role)\n\n    # Prevent admin from demoting themselves\n    if str(user.id) == str(current_admin_user.id) and desired_role != \"admin\":\n        raise HTTPException(status_code=400, detail=\"Cannot remove your own admin privileges\")\n\n    # Capture original values for audit\n    original_values = {\n        \"email\": user.email,\n        \"full_name\": user.full_name,\n        \"is_admin\": user.is_admin,\n        \"admin_role\": user.admin_role,\n        \"is_active\": user.is_active,\n    }\n\n    # Update fields\n    update_data = user_update.model_dump(exclude_unset=True)\n    action_reason = update_data.pop(\"action_reason\", None)\n\n    try:\n        rate_limit_info = None\n        if \"is_admin\" in update_data and update_data[\"is_admin\"] != user.is_admin:\n            rate_limit_info = enforce_admin_action_rate_limit(request, action=\"role-change\")\n        if \"is_active\" in update_data and update_data[\"is_active\"] is False:\n            rate_limit_info = enforce_admin_action_rate_limit(request, action=\"account-deactivate\")\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    for field, value in update_data.items():\n        setattr(user, field, value)\n\n    user.admin_role = desired_role\n    user.is_admin = desired_role == \"admin\"\n\n    db.commit()\n    db.refresh(user)\n\n    # Log audit event\n    audit_updates = {\n        **update_data,\n        \"admin_role\": user.admin_role,\n        \"is_admin\": user.is_admin,\n    }\n    log_audit_event(\n        db=db,\n        action=\"user.update\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"user\",\n        resource_id=user_id,\n        success=True,\n        details=json.dumps(\n            {\n                \"original\": original_values,\n                \"updated\": audit_updates,\n                \"reason\": action_reason,\n            }\n        ),\n        request=request,\n    )\n\n    if user.admin_role != original_values[\"admin_role\"]:\n        admin_audit_log_service.log_action(\n            db=db,\n            actor=current_admin_user,\n            action=\"user.role_change\",\n            target_type=\"user\",\n            target_id=user_id,\n            success=True,\n            metadata={\n                \"from\": original_values[\"admin_role\"],\n                \"to\": user.admin_role,\n            },\n            request=request,\n        )\n\n    data = {\n        \"id\": str(user.id),\n        \"email\": user.email,\n        \"full_name\": user.full_name,\n        \"is_admin\": user.is_admin,\n        \"admin_role\": user.admin_role,\n        \"is_active\": user.is_active,\n        \"created_at\": user.created_at.isoformat() if user.created_at else None,\n        \"last_login\": user.last_login.isoformat() if user.last_login else None,\n    }\n\n    # surface rate limit metadata when applicable\n    if \"rate_limit_info\" in locals() and rate_limit_info:\n        data[\"rate_limit\"] = rate_limit_info\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.delete(\"/users/{user_id}\")\nasync def delete_user(\n    request: Request,\n    user_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Delete a user (soft delete by deactivating).\"\"\"\n    ensure_admin_privileges(current_admin_user)\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Prevent admin from deleting themselves\n    if str(user.id) == str(current_admin_user.id):\n        raise HTTPException(status_code=400, detail=\"Cannot delete your own account\")\n\n    # Capture user email for audit before deactivation\n    target_email = user.email\n\n    try:\n        # Increased rate limit: 20 deletes per 5 minutes (was 5/60s default)\n        rate_limit_info = enforce_admin_action_rate_limit(request, action=\"account-deactivate\", calls=20, period=300)\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    # Soft delete - deactivate the user\n    user.is_active = False\n    db.commit()\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"user.deactivate\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"user\",\n        resource_id=user_id,\n        success=True,\n        details=json.dumps({\"deactivated_user_email\": target_email}),\n        request=request,\n    )\n\n    data = {\n        \"message\": \"User deactivated successfully\",\n        \"user_id\": user_id,\n        \"rate_limit\": rate_limit_info,\n    }\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\nclass PermanentDeleteRequest(BaseModel):\n    \"\"\"Request model for permanent user deletion.\"\"\"\n\n    confirm_email: str  # Must match user's email for confirmation\n    reason: Optional[str] = None\n\n\n@router.delete(\"/users/{user_id}/permanent\")\nasync def permanent_delete_user(\n    request: Request,\n    user_id: str,\n    delete_request: PermanentDeleteRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Permanently delete a user and all associated data.\n\n    This action is IRREVERSIBLE. All user data will be permanently removed:\n    - User account\n    - Sessions and messages\n    - Audit logs (user reference will be anonymized)\n    - Any other associated data\n\n    Requires email confirmation to prevent accidental deletion.\n    \"\"\"\n    from app.models.message import Message\n    from app.models.session import Session as DBSession\n\n    ensure_admin_privileges(current_admin_user)\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Prevent admin from deleting themselves\n    if str(user.id) == str(current_admin_user.id):\n        raise HTTPException(status_code=400, detail=\"Cannot delete your own account\")\n\n    # Require email confirmation\n    if delete_request.confirm_email.lower() != user.email.lower():\n        raise HTTPException(\n            status_code=400,\n            detail=\"Email confirmation does not match. Please enter the user's email to confirm deletion.\",\n        )\n\n    # Rate limit permanent delete actions (stricter limit)\n    try:\n        rate_limit_info = enforce_admin_action_rate_limit(request, action=\"permanent-delete\", calls=3, period=300)\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n\n    # Capture user info for audit before deletion\n    deleted_user_info = {\n        \"email\": user.email,\n        \"full_name\": user.full_name,\n        \"admin_role\": user.admin_role,\n        \"created_at\": user.created_at.isoformat() if user.created_at else None,\n    }\n\n    # Count associated data for reporting\n    session_count = 0\n    message_count = 0\n    try:\n        session_count = db.query(func.count(DBSession.id)).filter(DBSession.user_id == user_id).scalar() or 0\n        message_count = db.query(func.count(Message.id)).filter(Message.user_id == user_id).scalar() or 0\n    except Exception as e:\n        logger.warning(f\"Could not count user data: {e}\")\n\n    # Anonymize audit logs (preserve the audit trail but remove user reference)\n    try:\n        db.query(AuditLog).filter(AuditLog.user_id == user_id).update(\n            {\n                \"user_id\": None,\n                \"user_email\": f\"[DELETED:{user_id[:8]}]\",\n            },\n            synchronize_session=False,\n        )\n    except Exception as e:\n        logger.warning(f\"Could not anonymize audit logs: {e}\")\n\n    # Delete associated sessions and messages (cascade delete)\n    try:\n        # Delete messages first (they reference sessions)\n        db.query(Message).filter(Message.user_id == user_id).delete(synchronize_session=False)\n        # Delete sessions\n        db.query(DBSession).filter(DBSession.user_id == user_id).delete(synchronize_session=False)\n    except Exception as e:\n        logger.warning(f\"Error deleting user data: {e}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=500,\n            detail=\"Failed to delete user data. Please try again.\",\n        )\n\n    # Delete the user\n    try:\n        db.delete(user)\n        db.commit()\n    except Exception as e:\n        logger.error(f\"Failed to delete user: {e}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=500,\n            detail=\"Failed to delete user. Please try again.\",\n        )\n\n    # Log audit event (with anonymized user info)\n    log_audit_event(\n        db=db,\n        action=\"user.permanent_delete\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"user\",\n        resource_id=user_id,\n        success=True,\n        details=json.dumps(\n            {\n                \"deleted_user\": deleted_user_info,\n                \"sessions_deleted\": session_count,\n                \"messages_deleted\": message_count,\n                \"reason\": delete_request.reason,\n            }\n        ),\n        request=request,\n    )\n\n    return success_response(\n        {\n            \"message\": \"User permanently deleted\",\n            \"user_id\": user_id,\n            \"deleted_data\": {\n                \"sessions\": session_count,\n                \"messages\": message_count,\n            },\n            \"rate_limit\": rate_limit_info,\n        },\n        trace_id=trace_id,\n    )\n\n\ndef generate_temporary_password(length: int = 16) -> str:\n    \"\"\"Generate a secure temporary password with mixed characters.\"\"\"\n    alphabet = \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789!@#$%^&*\"\n    return \"\".join(secrets.choice(alphabet) for _ in range(length))\n\n\ndef generate_secure_token(length: int = 32) -> str:\n    \"\"\"Generate a cryptographically secure token.\"\"\"\n    return secrets.token_urlsafe(length)\n\n\n@router.post(\"/users/{user_id}/reset-password\")\nasync def reset_user_password(\n    request: Request,\n    user_id: str,\n    reset_request: PasswordResetRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Reset a user's password (admin action).\n\n    Two methods available:\n    - \"temporary\": Generate a temporary password that user must change on next login\n    - \"email\": Send a password reset email with a secure link\n    \"\"\"\n    from app.core.config import settings\n    from app.services.email_service import send_password_reset_email, send_temporary_password_email\n    from passlib.context import CryptContext\n\n    ensure_admin_privileges(current_admin_user)\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Prevent resetting own password through admin panel\n    if str(user.id) == str(current_admin_user.id):\n        raise HTTPException(\n            status_code=400,\n            detail=\"Use the account settings page to change your own password\",\n        )\n\n    # Rate limit password reset actions\n    try:\n        enforce_admin_action_rate_limit(request, action=\"password-reset\", calls=10, period=300)\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n    if reset_request.method == \"temporary\":\n        # Generate temporary password\n        temp_password = generate_temporary_password()\n        user.hashed_password = pwd_context.hash(temp_password)\n        user.must_change_password = True\n        user.password_reset_token = None\n        user.password_reset_token_expires_at = None\n        db.commit()\n\n        # Log audit event\n        log_audit_event(\n            db=db,\n            action=\"user.password_reset\",\n            user_id=str(current_admin_user.id),\n            user_email=current_admin_user.email,\n            resource_type=\"user\",\n            resource_id=user_id,\n            success=True,\n            details=json.dumps({\"method\": \"temporary\", \"notify_user\": reset_request.notify_user}),\n            request=request,\n        )\n\n        # Optionally send email with temporary password\n        email_sent = False\n        if reset_request.notify_user:\n            email_sent = await send_temporary_password_email(user.email, temp_password)\n\n        return success_response(\n            {\n                \"success\": True,\n                \"method\": \"temporary\",\n                \"temporary_password\": temp_password,\n                \"email_sent\": email_sent,\n                \"message\": \"User must change password on next login\",\n            },\n            trace_id=trace_id,\n        )\n\n    else:  # email method\n        # Generate reset token with 24-hour expiry\n        reset_token = generate_secure_token()\n        user.password_reset_token = reset_token\n        user.password_reset_token_expires_at = datetime.now(timezone.utc) + timedelta(hours=24)\n        db.commit()\n\n        # Build reset link\n        reset_link = f\"{settings.ADMIN_PANEL_URL}/reset-password?token={reset_token}\"\n\n        # Log audit event\n        log_audit_event(\n            db=db,\n            action=\"user.password_reset\",\n            user_id=str(current_admin_user.id),\n            user_email=current_admin_user.email,\n            resource_type=\"user\",\n            resource_id=user_id,\n            success=True,\n            details=json.dumps({\"method\": \"email\"}),\n            request=request,\n        )\n\n        # Send reset email\n        email_sent = await send_password_reset_email(user.email, reset_link)\n\n        return success_response(\n            {\n                \"success\": True,\n                \"method\": \"email\",\n                \"email_sent\": email_sent,\n                \"message\": (\"Password reset email sent\" if email_sent else \"Failed to send email\"),\n            },\n            trace_id=trace_id,\n        )\n\n\n@router.post(\"/users/invite\")\nasync def invite_user(\n    request: Request,\n    invite_request: UserInviteRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Invite a new user via email.\n\n    Creates a user account with a pending invitation. The user will receive\n    an email with a link to set their password and activate their account.\n    \"\"\"\n    from app.core.config import settings\n    from app.services.email_service import send_invitation_email\n\n    ensure_admin_privileges(current_admin_user)\n\n    # Check if email already exists\n    existing_user = db.query(User).filter(User.email == invite_request.email).first()\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"User with this email already exists\")\n\n    # Rate limit invitation actions\n    try:\n        enforce_admin_action_rate_limit(request, action=\"user-invite\", calls=20, period=300)\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n\n    # Generate invitation token with 7-day expiry\n    invitation_token = generate_secure_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(days=7)\n\n    # Create user with pending invitation\n    new_user = User(\n        email=invite_request.email,\n        full_name=invite_request.full_name or \"\",\n        hashed_password=None,  # No password until invitation is accepted\n        is_active=False,  # Inactive until invitation is accepted\n        is_admin=invite_request.admin_role == \"admin\",\n        admin_role=invite_request.admin_role,\n        invitation_token=invitation_token,\n        invitation_token_expires_at=expires_at,\n        invitation_sent_at=datetime.now(timezone.utc),\n        invited_by_id=current_admin_user.id,\n    )\n\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"user.invite\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"user\",\n        resource_id=str(new_user.id),\n        success=True,\n        details=json.dumps(\n            {\n                \"invited_email\": invite_request.email,\n                \"role\": invite_request.admin_role,\n                \"send_email\": invite_request.send_email,\n            }\n        ),\n        request=request,\n    )\n\n    # Build invitation link\n    invitation_link = f\"{settings.ADMIN_PANEL_URL}/accept-invitation?token={invitation_token}\"\n\n    # Send invitation email\n    email_sent = False\n    if invite_request.send_email:\n        inviter_name = current_admin_user.full_name or current_admin_user.email\n        email_sent = await send_invitation_email(\n            to=invite_request.email,\n            inviter_name=inviter_name,\n            invitation_link=invitation_link,\n            expires_in_days=7,\n        )\n\n    return success_response(\n        {\n            \"success\": True,\n            \"user_id\": str(new_user.id),\n            \"email\": new_user.email,\n            \"invitation_link\": invitation_link,\n            \"email_sent\": email_sent,\n            \"expires_at\": expires_at.isoformat(),\n        },\n        trace_id=trace_id,\n    )\n\n\n@router.post(\"/users/{user_id}/resend-invitation\")\nasync def resend_invitation(\n    request: Request,\n    user_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Resend an invitation email to a pending user.\"\"\"\n    from app.core.config import settings\n    from app.services.email_service import send_invitation_email\n\n    ensure_admin_privileges(current_admin_user)\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    if user.is_active:\n        raise HTTPException(status_code=400, detail=\"User has already accepted invitation\")\n\n    if not user.invitation_token:\n        raise HTTPException(status_code=400, detail=\"User was not invited via email\")\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n\n    # Generate new invitation token with fresh 7-day expiry\n    new_token = generate_secure_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(days=7)\n\n    user.invitation_token = new_token\n    user.invitation_token_expires_at = expires_at\n    user.invitation_sent_at = datetime.now(timezone.utc)\n    db.commit()\n\n    # Build invitation link\n    invitation_link = f\"{settings.ADMIN_PANEL_URL}/accept-invitation?token={new_token}\"\n\n    # Send invitation email\n    inviter_name = current_admin_user.full_name or current_admin_user.email\n    email_sent = await send_invitation_email(\n        to=user.email,\n        inviter_name=inviter_name,\n        invitation_link=invitation_link,\n        expires_in_days=7,\n    )\n\n    # Log audit event\n    log_audit_event(\n        db=db,\n        action=\"user.resend_invitation\",\n        user_id=str(current_admin_user.id),\n        user_email=current_admin_user.email,\n        resource_type=\"user\",\n        resource_id=user_id,\n        success=True,\n        details=json.dumps({\"email_sent\": email_sent}),\n        request=request,\n    )\n\n    return success_response(\n        {\n            \"success\": True,\n            \"email_sent\": email_sent,\n            \"expires_at\": expires_at.isoformat(),\n            \"message\": \"Invitation resent\" if email_sent else \"Failed to send email\",\n        },\n        trace_id=trace_id,\n    )\n\n\n# ============================================================================\n# Bulk Operations\n# ============================================================================\n\n\nclass BulkOperationRequest(BaseModel):\n    \"\"\"Request model for bulk user operations.\"\"\"\n\n    user_ids: list[str]\n    action: Literal[\"activate\", \"deactivate\", \"set_role\"]\n    role: Optional[Literal[\"user\", \"admin\", \"viewer\"]] = None  # Required for set_role action\n    reason: Optional[str] = None\n\n\n@router.post(\"/users/bulk\")\nasync def bulk_user_operation(\n    request: Request,\n    bulk_request: BulkOperationRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Perform bulk operations on multiple users.\n\n    Supported actions:\n    - \"activate\": Activate multiple user accounts\n    - \"deactivate\": Deactivate multiple user accounts (soft delete)\n    - \"set_role\": Set the role for multiple users (requires 'role' field)\n\n    Returns a summary of successful and failed operations.\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    # Validate request\n    if not bulk_request.user_ids:\n        raise HTTPException(status_code=400, detail=\"No user IDs provided\")\n\n    if len(bulk_request.user_ids) > 50:\n        raise HTTPException(status_code=400, detail=\"Maximum 50 users per bulk operation\")\n\n    if bulk_request.action == \"set_role\" and not bulk_request.role:\n        raise HTTPException(status_code=400, detail=\"Role is required for set_role action\")\n\n    # Rate limit bulk operations\n    try:\n        rate_limit_info = enforce_admin_action_rate_limit(request, action=\"bulk-operation\", calls=10, period=300)\n    except HTTPException as exc:\n        if exc.status_code == 429:\n            detail = exc.detail if isinstance(exc.detail, dict) else {}\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return JSONResponse(\n                status_code=429,\n                content=error_response(\n                    code=detail.get(\"code\", \"RATE_LIMITED\"),\n                    message=detail.get(\"message\", \"Rate limit exceeded\"),\n                    details={\"rate_limit\": detail.get(\"rate_limit\")},\n                    request_id=trace_id,\n                ),\n            )\n        raise\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    admin_user_id = str(current_admin_user.id)\n\n    # Track results\n    results = {\n        \"successful\": [],\n        \"failed\": [],\n        \"skipped\": [],\n    }\n\n    for user_id in bulk_request.user_ids:\n        try:\n            # Prevent self-modification\n            if user_id == admin_user_id:\n                results[\"skipped\"].append(\n                    {\n                        \"user_id\": user_id,\n                        \"reason\": \"Cannot modify your own account\",\n                    }\n                )\n                continue\n\n            user = db.query(User).filter(User.id == user_id).first()\n            if not user:\n                results[\"failed\"].append(\n                    {\n                        \"user_id\": user_id,\n                        \"reason\": \"User not found\",\n                    }\n                )\n                continue\n\n            # Capture original values for audit\n            original_values = {\n                \"is_active\": user.is_active,\n                \"is_admin\": user.is_admin,\n                \"admin_role\": user.admin_role,\n            }\n\n            # Perform the action\n            if bulk_request.action == \"activate\":\n                if user.is_active:\n                    results[\"skipped\"].append(\n                        {\n                            \"user_id\": user_id,\n                            \"email\": user.email,\n                            \"reason\": \"Already active\",\n                        }\n                    )\n                    continue\n                user.is_active = True\n\n            elif bulk_request.action == \"deactivate\":\n                if not user.is_active:\n                    results[\"skipped\"].append(\n                        {\n                            \"user_id\": user_id,\n                            \"email\": user.email,\n                            \"reason\": \"Already inactive\",\n                        }\n                    )\n                    continue\n                user.is_active = False\n\n            elif bulk_request.action == \"set_role\":\n                if user.admin_role == bulk_request.role:\n                    results[\"skipped\"].append(\n                        {\n                            \"user_id\": user_id,\n                            \"email\": user.email,\n                            \"reason\": f\"Already has role '{bulk_request.role}'\",\n                        }\n                    )\n                    continue\n                user.admin_role = bulk_request.role\n                user.is_admin = bulk_request.role == \"admin\"\n\n            db.commit()\n\n            # Log audit event\n            log_audit_event(\n                db=db,\n                action=f\"user.bulk_{bulk_request.action}\",\n                user_id=admin_user_id,\n                user_email=current_admin_user.email,\n                resource_type=\"user\",\n                resource_id=user_id,\n                success=True,\n                details=json.dumps(\n                    {\n                        \"original\": original_values,\n                        \"action\": bulk_request.action,\n                        \"new_role\": (bulk_request.role if bulk_request.action == \"set_role\" else None),\n                        \"reason\": bulk_request.reason,\n                    }\n                ),\n                request=request,\n            )\n\n            results[\"successful\"].append(\n                {\n                    \"user_id\": user_id,\n                    \"email\": user.email,\n                }\n            )\n\n        except Exception as e:\n            logger.warning(f\"Bulk operation failed for user {user_id}: {e}\")\n            db.rollback()\n            results[\"failed\"].append(\n                {\n                    \"user_id\": user_id,\n                    \"reason\": str(e),\n                }\n            )\n\n    return success_response(\n        {\n            \"action\": bulk_request.action,\n            \"total_requested\": len(bulk_request.user_ids),\n            \"successful\": len(results[\"successful\"]),\n            \"failed\": len(results[\"failed\"]),\n            \"skipped\": len(results[\"skipped\"]),\n            \"results\": results,\n            \"rate_limit\": rate_limit_info,\n        },\n        trace_id=trace_id,\n    )\n\n\ndef _parse_audit_details(log: AuditLog) -> Dict:\n    \"\"\"Extract structured audit details from an AuditLog entry.\"\"\"\n\n    if not log.additional_data:\n        return {}\n\n    raw_details = log.additional_data\n    if isinstance(raw_details, dict) and \"details\" in raw_details:\n        raw_details = raw_details.get(\"details\")\n\n    if isinstance(raw_details, str):\n        try:\n            raw_details = json.loads(raw_details)\n        except json.JSONDecodeError:\n            return {\"details\": raw_details}\n\n    return raw_details if isinstance(raw_details, dict) else {}\n\n\n@router.get(\"/users/{user_id}/role-history\")\nasync def get_role_history(\n    request: Request,\n    user_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(20, ge=1, le=100),\n) -> Dict:\n    \"\"\"Return role assignment history for a user based on audit logs.\"\"\"\n\n    logs = (\n        db.query(AuditLog)\n        .filter(\n            AuditLog.resource_type == \"user\",\n            AuditLog.resource_id == user_id,\n            AuditLog.action == \"user.update\",\n        )\n        .order_by(desc(AuditLog.timestamp))\n        .limit(limit)\n        .all()\n    )\n\n    history = []\n    for log in logs:\n        details = _parse_audit_details(log)\n        original = details.get(\"original\", {}) if isinstance(details, dict) else {}\n        updated = details.get(\"updated\", {}) if isinstance(details, dict) else {}\n\n        if \"is_admin\" not in original and \"is_admin\" not in updated:\n            continue\n\n        from_role = \"admin\" if original.get(\"is_admin\") else \"user\"\n        to_role = \"admin\" if updated.get(\"is_admin\", original.get(\"is_admin\")) else \"user\"\n\n        if from_role == to_role:\n            continue\n\n        history.append(\n            {\n                \"id\": str(log.id),\n                \"changed_at\": log.timestamp.isoformat() if log.timestamp else None,\n                \"actor\": log.user_email or \"unknown\",\n                \"from_role\": from_role,\n                \"to_role\": to_role,\n                \"reason\": details.get(\"reason\") or \"Role updated by admin\",\n                \"trace_id\": log.request_id,\n            }\n        )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response({\"history\": history}, trace_id=trace_id)\n\n\n@router.get(\"/users/{user_id}/lock-reasons\")\nasync def get_lock_reasons(\n    request: Request,\n    user_id: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(20, ge=1, le=100),\n) -> Dict:\n    \"\"\"Return account lock/unlock reasons for a user.\"\"\"\n\n    logs = (\n        db.query(AuditLog)\n        .filter(\n            AuditLog.resource_type == \"user\",\n            AuditLog.resource_id == user_id,\n            AuditLog.action.in_([\"user.update\", \"user.deactivate\"]),\n        )\n        .order_by(desc(AuditLog.timestamp))\n        .limit(limit)\n        .all()\n    )\n\n    events = []\n    for log in logs:\n        details = _parse_audit_details(log)\n        original = details.get(\"original\", {}) if isinstance(details, dict) else {}\n        updated = details.get(\"updated\", {}) if isinstance(details, dict) else {}\n\n        status_change = None\n        if log.action == \"user.deactivate\":\n            status_change = False\n        elif \"is_active\" in original or \"is_active\" in updated:\n            prev_active = original.get(\"is_active\")\n            new_active = updated.get(\"is_active\", prev_active)\n            if prev_active != new_active:\n                status_change = new_active\n\n        if status_change is None:\n            continue\n\n        events.append(\n            {\n                \"id\": str(log.id),\n                \"timestamp\": log.timestamp.isoformat() if log.timestamp else None,\n                \"actor\": log.user_email or \"unknown\",\n                \"status\": \"unlocked\" if status_change else \"locked\",\n                \"reason\": details.get(\"reason\") or details.get(\"details\") or \"Admin status change\",\n                \"trace_id\": log.request_id,\n            }\n        )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response({\"events\": events}, trace_id=trace_id)\n\n\n# ============================================================================\n# System Metrics (Optimized Queries + Redis Caching)\n# ============================================================================\n\n\ndef _fetch_metrics_from_db(db: Session, days: int) -> Dict:\n    \"\"\"Fetch metrics from database using optimized aggregated queries.\"\"\"\n    now = datetime.now(timezone.utc)\n    start_date = now - timedelta(days=days)\n\n    # Optimized: Single aggregated query for daily registrations\n    registration_query = (\n        db.query(\n            cast(User.created_at, Date).label(\"date\"),\n            func.count(User.id).label(\"count\"),\n        )\n        .filter(User.created_at >= start_date)\n        .group_by(cast(User.created_at, Date))\n        .order_by(cast(User.created_at, Date))\n        .all()\n    )\n\n    # Optimized: Single aggregated query for daily active users\n    active_query = (\n        db.query(\n            cast(User.last_login, Date).label(\"date\"),\n            func.count(User.id).label(\"count\"),\n        )\n        .filter(User.last_login >= start_date)\n        .group_by(cast(User.last_login, Date))\n        .order_by(cast(User.last_login, Date))\n        .all()\n    )\n\n    # Convert to dict for easy lookup\n    reg_by_date = {str(row.date): row.count for row in registration_query}\n    active_by_date = {str(row.date): row.count for row in active_query}\n\n    # Build daily arrays with all dates\n    daily_registrations = []\n    daily_active_users = []\n    for i in range(days - 1, -1, -1):\n        date = (now - timedelta(days=i)).date()\n        date_str = str(date)\n        daily_registrations.append({\"date\": date_str, \"count\": reg_by_date.get(date_str, 0)})\n        daily_active_users.append({\"date\": date_str, \"count\": active_by_date.get(date_str, 0)})\n\n    # User distribution (single query with aggregates)\n    total_users = db.query(func.count(User.id)).scalar() or 0\n    admin_users = db.query(func.count(User.id)).filter(User.is_admin.is_(True)).scalar() or 0\n    active_users = db.query(func.count(User.id)).filter(User.is_active.is_(True)).scalar() or 0\n\n    return {\n        \"daily_registrations\": daily_registrations,\n        \"daily_active_users\": daily_active_users,\n        \"user_distribution\": {\n            \"total\": total_users,\n            \"active\": active_users,\n            \"inactive\": total_users - active_users,\n            \"admins\": admin_users,\n            \"regular\": total_users - admin_users,\n        },\n        \"period_days\": days,\n        \"timestamp\": now.isoformat() + \"Z\",\n    }\n\n\n@router.get(\"/metrics\")\nasync def get_system_metrics(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    days: int = Query(7, ge=1, le=90),\n) -> Dict:\n    \"\"\"Return system metrics for dashboard charts with caching.\"\"\"\n    cache_key = f\"{REDIS_METRICS_CACHE_KEY}:{days}\"\n\n    # Try to get from cache\n    try:\n        cached = redis_client.get(cache_key)\n        if cached:\n            data = json.loads(cached)\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data, trace_id=trace_id)\n    except Exception as e:\n        logger.debug(f\"Cache miss or error: {e}\")\n\n    # Fetch from database\n    data = _fetch_metrics_from_db(db, days)\n\n    # Cache the result\n    try:\n        redis_client.setex(cache_key, METRICS_CACHE_TTL, json.dumps(data))\n    except Exception as e:\n        logger.debug(f\"Failed to cache metrics: {e}\")\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n# ============================================================================\n# Audit Log Viewer (Database-backed)\n# ============================================================================\n\n\n@router.get(\"/audit-logs\")\nasync def get_audit_logs(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    offset: int = Query(0, ge=0),\n    limit: int = Query(50, ge=1, le=200),\n    level: Optional[str] = Query(None),\n    action: Optional[str] = Query(None),\n) -> Dict:\n    \"\"\"Return audit log entries with filtering and pagination from database.\"\"\"\n    query = db.query(AuditLog)\n\n    # Apply filters\n    if action:\n        query = query.filter(AuditLog.action.ilike(f\"%{action}%\"))\n\n    # Sort by timestamp descending (most recent first)\n    query = query.order_by(desc(AuditLog.timestamp))\n\n    # Get total count\n    total = query.count()\n\n    # Apply pagination\n    logs = query.offset(offset).limit(limit).all()\n\n    # Convert to response format\n    log_list = []\n    for log in logs:\n        # Determine level based on success\n        log_level = \"info\" if log.success else \"error\"\n        if level and log_level != level:\n            continue\n\n        details = None\n        if log.additional_data:\n            details = (\n                log.additional_data.get(\"details\")\n                if isinstance(log.additional_data, dict)\n                else str(log.additional_data)\n            )\n\n        log_list.append(\n            {\n                \"timestamp\": log.timestamp.isoformat() if log.timestamp else None,\n                \"level\": log_level,\n                \"action\": log.action,\n                \"user_id\": str(log.user_id) if log.user_id else None,\n                \"user_email\": log.user_email,\n                \"resource_type\": log.resource_type,\n                \"resource_id\": log.resource_id,\n                \"success\": log.success,\n                \"details\": details,\n            }\n        )\n\n    data = {\n        \"logs\": log_list,\n        \"total\": total,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data, trace_id=trace_id)\n\n\n@router.get(\"/audit-logs/export\")\nasync def export_audit_logs(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n    action: Optional[str] = Query(None),\n    limit: int = Query(500, ge=1, le=2000),\n):\n    \"\"\"Export recent admin audit activity as CSV for compliance.\"\"\"\n\n    query = db.query(AuditLog)\n    if action:\n        query = query.filter(AuditLog.action.ilike(f\"%{action}%\"))\n\n    logs = query.order_by(desc(AuditLog.timestamp)).limit(limit).all()\n\n    output = io.StringIO()\n    writer = csv.writer(output)\n    writer.writerow(\n        [\n            \"timestamp\",\n            \"action\",\n            \"user_email\",\n            \"resource_type\",\n            \"resource_id\",\n            \"success\",\n            \"details\",\n            \"trace_id\",\n        ]\n    )\n\n    for log in logs:\n        details = _parse_audit_details(log)\n        writer.writerow(\n            [\n                log.timestamp.isoformat() if log.timestamp else \"\",\n                log.action,\n                log.user_email or \"\",\n                log.resource_type or \"\",\n                log.resource_id or \"\",\n                \"success\" if log.success else \"error\",\n                json.dumps(details) if details else \"\",\n                log.request_id or \"\",\n            ]\n        )\n\n    output.seek(0)\n    filename = f\"admin-audit-{datetime.now(timezone.utc).date()}.csv\"\n    headers = {\"Content-Disposition\": f\"attachment; filename={filename}\"}\n    return StreamingResponse(\n        output,\n        media_type=\"text/csv\",\n        headers=headers,\n    )\n\n\n# ============================================================================\n# Admin WebSocket for Real-time Updates\n# ============================================================================\n\n# Track connected admin WebSocket sessions\n_admin_ws_connections: Dict[str, WebSocket] = {}\n\n\n@router.websocket(\"/ws\")\nasync def admin_websocket(websocket: WebSocket):\n    \"\"\"WebSocket endpoint for real-time admin panel updates.\n\n    Provides:\n    - Heartbeat/ping-pong to keep connection alive\n    - Real-time metric updates (every 10 seconds)\n    - System event notifications via Redis pub/sub\n    - Live events (sessions, conversations, voice, etc.)\n    \"\"\"\n    await websocket.accept()\n\n    connection_id = str(uuid.uuid4())\n    _admin_ws_connections[connection_id] = websocket\n\n    logger.info(f\"Admin WebSocket connected: {connection_id}\")\n\n    # Send initial connection confirmation\n    await websocket.send_json(\n        {\n            \"type\": \"connected\",\n            \"payload\": {\n                \"connection_id\": connection_id,\n                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n            },\n        }\n    )\n\n    try:\n        # Start background tasks\n        update_task = asyncio.create_task(_send_periodic_updates(websocket, connection_id))\n        redis_task = asyncio.create_task(_subscribe_to_admin_events(websocket, connection_id))\n\n        # Main message loop\n        while True:\n            try:\n                data = await asyncio.wait_for(websocket.receive_json(), timeout=60.0)\n\n                # Handle ping/pong\n                if data.get(\"type\") == \"ping\":\n                    await websocket.send_json(\n                        {\n                            \"type\": \"pong\",\n                            \"payload\": {\"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\"},\n                        }\n                    )\n\n                # Handle event subscription\n                elif data.get(\"type\") == \"subscribe\":\n                    event_types = data.get(\"payload\", {}).get(\"event_types\", [])\n                    await websocket.send_json(\n                        {\n                            \"type\": \"subscribed\",\n                            \"payload\": {\n                                \"event_types\": event_types,\n                                \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n                            },\n                        }\n                    )\n\n            except asyncio.TimeoutError:\n                # Send heartbeat on timeout\n                if websocket.client_state == WebSocketState.CONNECTED:\n                    await websocket.send_json(\n                        {\n                            \"type\": \"heartbeat\",\n                            \"payload\": {\"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\"},\n                        }\n                    )\n\n    except WebSocketDisconnect:\n        logger.info(f\"Admin WebSocket disconnected: {connection_id}\")\n    except Exception as e:\n        logger.error(f\"Admin WebSocket error for {connection_id}: {e}\")\n    finally:\n        update_task.cancel()\n        redis_task.cancel()\n        _admin_ws_connections.pop(connection_id, None)\n        register_websocket_session_cleanup(connection_id)\n\n\nasync def _send_periodic_updates(websocket: WebSocket, connection_id: str):\n    \"\"\"Send periodic metric updates to connected admin clients.\"\"\"\n    try:\n        while True:\n            await asyncio.sleep(10)  # Update every 10 seconds\n\n            if websocket.client_state != WebSocketState.CONNECTED:\n                break\n\n            try:\n                # Get current stats\n                active_sessions = get_active_websocket_count()\n                db_stats = get_db_pool_stats()\n                redis_stats = get_redis_pool_stats()\n\n                await websocket.send_json(\n                    {\n                        \"type\": \"metrics_update\",\n                        \"payload\": {\n                            \"active_websocket_sessions\": active_sessions,\n                            \"database_pool\": db_stats,\n                            \"redis_pool\": redis_stats,\n                            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n                        },\n                    }\n                )\n            except Exception as e:\n                logger.warning(f\"Failed to send metrics update to {connection_id}: {e}\")\n                break\n\n    except asyncio.CancelledError:\n        pass\n\n\nasync def _subscribe_to_admin_events(websocket: WebSocket, connection_id: str):\n    \"\"\"Subscribe to Redis pub/sub for real-time admin events.\"\"\"\n    from app.services.admin_event_publisher import ADMIN_EVENTS_CHANNEL\n\n    try:\n        redis = redis_client\n        if not redis:\n            logger.warning(f\"Redis not available for admin events subscription: {connection_id}\")\n            return\n\n        # Create a pubsub connection\n        pubsub = redis.pubsub()\n        await pubsub.subscribe(ADMIN_EVENTS_CHANNEL)\n\n        logger.debug(f\"Admin WebSocket {connection_id} subscribed to events channel\")\n\n        # Listen for messages\n        async for message in pubsub.listen():\n            if websocket.client_state != WebSocketState.CONNECTED:\n                break\n\n            if message[\"type\"] == \"message\":\n                try:\n                    # Parse the event data\n                    event_data = json.loads(message[\"data\"])\n\n                    # Forward to WebSocket client\n                    await websocket.send_json(\n                        {\n                            \"type\": \"admin_event\",\n                            \"payload\": event_data,\n                        }\n                    )\n                except json.JSONDecodeError:\n                    logger.warning(f\"Invalid JSON in admin event: {message['data']}\")\n                except Exception as e:\n                    logger.warning(f\"Failed to forward admin event to {connection_id}: {e}\")\n\n    except asyncio.CancelledError:\n        pass\n    except Exception as e:\n        logger.error(f\"Error in admin events subscription for {connection_id}: {e}\")\n    finally:\n        try:\n            await pubsub.unsubscribe(ADMIN_EVENTS_CHANNEL)\n            await pubsub.close()\n        except Exception:\n            pass\n\n\ndef register_websocket_session_cleanup(session_id: str):\n    \"\"\"Clean up WebSocket session from tracking.\"\"\"\n    try:\n        unregister_websocket_session(session_id)\n    except Exception as e:\n        logger.warning(f\"Failed to cleanup WebSocket session {session_id}: {e}\")\n"
}
