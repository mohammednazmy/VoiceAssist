{
  "path": "services/api-gateway/app/services/phi_telemetry.py",
  "language": "python",
  "size": 14337,
  "last_modified": "2025-12-04T21:30:58.283Z",
  "lines": 423,
  "content": "\"\"\"\nPHI Telemetry Service for Voice Mode v4.1\n\nProvides telemetry hooks for PHI-aware STT routing, enabling:\n- Frontend visibility into current PHI mode status\n- Real-time routing decision broadcasting\n- Audit logging for compliance\n- Metrics collection for observability\n\nPart of Voice Mode Enhancement Plan v4.1 - Phase 2\nReference: docs/voice/phi-aware-stt-routing.md\n\nRouting Order (most secure to fastest):\n1. LOCAL (on-device Whisper) - PHI score >= 0.7 or explicit prior PHI\n2. HYBRID (cloud with redaction) - PHI score 0.3-0.7\n3. CLOUD (standard cloud STT) - PHI score < 0.3\n\"\"\"\n\nimport logging\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass PHIRoutingMode(str, Enum):\n    \"\"\"PHI routing modes for STT processing.\"\"\"\n\n    LOCAL = \"local\"  # On-device Whisper - most secure\n    HYBRID = \"hybrid\"  # Cloud with PHI redaction\n    CLOUD = \"cloud\"  # Standard cloud STT - fastest\n\n\nclass PHITelemetryEventType(str, Enum):\n    \"\"\"Types of PHI telemetry events.\"\"\"\n\n    ROUTING_DECISION = \"routing_decision\"\n    PHI_DETECTED = \"phi_detected\"\n    MODE_CHANGE = \"mode_change\"\n    SESSION_START = \"session_start\"\n    SESSION_END = \"session_end\"\n\n\n@dataclass\nclass PHIRoutingState:\n    \"\"\"Current PHI routing state for a session.\"\"\"\n\n    session_id: str\n    current_mode: PHIRoutingMode\n    phi_score: float\n    phi_entities: List[str] = field(default_factory=list)\n    is_medical_context: bool = False\n    has_prior_phi: bool = False\n    routing_reason: str = \"\"\n    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    def to_frontend_state(self) -> Dict[str, Any]:\n        \"\"\"Convert to frontend-consumable state.\"\"\"\n        return {\n            \"sessionId\": self.session_id,\n            \"phiMode\": self.current_mode.value,\n            \"phiScore\": round(self.phi_score, 2),\n            \"isSecureMode\": self.current_mode in (PHIRoutingMode.LOCAL, PHIRoutingMode.HYBRID),\n            \"hasPriorPhi\": self.has_prior_phi,\n            \"isMedicalContext\": self.is_medical_context,\n            \"routingReason\": self.routing_reason,\n            \"indicatorColor\": self._get_indicator_color(),\n            \"indicatorIcon\": self._get_indicator_icon(),\n            \"tooltip\": self._get_tooltip(),\n        }\n\n    def _get_indicator_color(self) -> str:\n        \"\"\"Get UI indicator color based on routing mode.\"\"\"\n        colors = {\n            PHIRoutingMode.LOCAL: \"green\",  # Most secure\n            PHIRoutingMode.HYBRID: \"yellow\",  # Moderate security\n            PHIRoutingMode.CLOUD: \"blue\",  # Standard\n        }\n        return colors.get(self.current_mode, \"gray\")\n\n    def _get_indicator_icon(self) -> str:\n        \"\"\"Get UI indicator icon based on routing mode.\"\"\"\n        icons = {\n            PHIRoutingMode.LOCAL: \"shield\",  # Secure local processing\n            PHIRoutingMode.HYBRID: \"lock\",  # Protected with redaction\n            PHIRoutingMode.CLOUD: \"cloud\",  # Cloud processing\n        }\n        return icons.get(self.current_mode, \"question\")\n\n    def _get_tooltip(self) -> str:\n        \"\"\"Get tooltip text for UI indicator.\"\"\"\n        tooltips = {\n            PHIRoutingMode.LOCAL: \"Secure local processing - PHI protected on device\",\n            PHIRoutingMode.HYBRID: \"Sensitive content detected - using redacted cloud processing\",\n            PHIRoutingMode.CLOUD: \"Using cloud transcription\",\n        }\n        return tooltips.get(self.current_mode, \"Processing audio\")\n\n\n@dataclass\nclass PHITelemetryEvent:\n    \"\"\"A PHI telemetry event for logging and streaming.\"\"\"\n\n    event_type: PHITelemetryEventType\n    session_id: str\n    timestamp: datetime\n    data: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"eventType\": self.event_type.value,\n            \"sessionId\": self.session_id,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"data\": self.data,\n        }\n\n\nclass PHITelemetryService:\n    \"\"\"\n    Service for PHI routing telemetry and frontend visibility.\n\n    Provides:\n    - Session state tracking\n    - Event broadcasting to subscribed listeners\n    - Metrics collection\n    - Audit logging\n\n    Usage:\n        telemetry = PHITelemetryService()\n\n        # Subscribe to routing updates\n        telemetry.subscribe(session_id, callback_fn)\n\n        # Update routing state\n        telemetry.update_routing_state(session_id, state)\n\n        # Get current state for frontend\n        state = telemetry.get_frontend_state(session_id)\n    \"\"\"\n\n    def __init__(self, event_bus=None):\n        self._session_states: Dict[str, PHIRoutingState] = {}\n        self._subscribers: Dict[str, List[Callable]] = {}\n        self._event_bus = event_bus\n        self._metrics_enabled = True\n\n    def set_event_bus(self, event_bus) -> None:\n        \"\"\"Set event bus for cross-service communication.\"\"\"\n        self._event_bus = event_bus\n\n    # =========================================================================\n    # Session State Management\n    # =========================================================================\n\n    def init_session(\n        self,\n        session_id: str,\n        is_medical_context: bool = False,\n    ) -> PHIRoutingState:\n        \"\"\"\n        Initialize PHI routing state for a new session.\n\n        Args:\n            session_id: Unique session identifier\n            is_medical_context: Whether this is a medical context session\n\n        Returns:\n            Initial PHIRoutingState\n        \"\"\"\n        initial_mode = PHIRoutingMode.HYBRID if is_medical_context else PHIRoutingMode.CLOUD\n        initial_score = 0.4 if is_medical_context else 0.0\n\n        state = PHIRoutingState(\n            session_id=session_id,\n            current_mode=initial_mode,\n            phi_score=initial_score,\n            is_medical_context=is_medical_context,\n            routing_reason=\"session_initialized\",\n        )\n\n        self._session_states[session_id] = state\n\n        # Emit session start event\n        self._emit_event(\n            PHITelemetryEvent(\n                event_type=PHITelemetryEventType.SESSION_START,\n                session_id=session_id,\n                timestamp=datetime.now(timezone.utc),\n                data=state.to_frontend_state(),\n            )\n        )\n\n        logger.info(\n            \"PHI session initialized\",\n            extra={\n                \"session_id\": session_id,\n                \"initial_mode\": initial_mode.value,\n                \"is_medical_context\": is_medical_context,\n            },\n        )\n\n        return state\n\n    def update_routing_state(\n        self,\n        session_id: str,\n        mode: PHIRoutingMode,\n        phi_score: float,\n        phi_entities: Optional[List[str]] = None,\n        routing_reason: str = \"\",\n        has_prior_phi: bool = False,\n    ) -> PHIRoutingState:\n        \"\"\"\n        Update PHI routing state for a session.\n\n        Args:\n            session_id: Session identifier\n            mode: New routing mode\n            phi_score: PHI probability score (0.0-1.0)\n            phi_entities: List of detected PHI entity types\n            routing_reason: Reason for routing decision\n            has_prior_phi: Whether session has prior PHI detected\n\n        Returns:\n            Updated PHIRoutingState\n        \"\"\"\n        # Get or create state\n        state = self._session_states.get(session_id)\n        if not state:\n            state = self.init_session(session_id)\n\n        # Track mode changes\n        previous_mode = state.current_mode\n        mode_changed = previous_mode != mode\n\n        # Update state\n        state.current_mode = mode\n        state.phi_score = phi_score\n        state.phi_entities = phi_entities or []\n        state.routing_reason = routing_reason\n        state.has_prior_phi = has_prior_phi or state.has_prior_phi\n        state.last_updated = datetime.now(timezone.utc)\n\n        self._session_states[session_id] = state\n\n        # Emit routing decision event\n        self._emit_event(\n            PHITelemetryEvent(\n                event_type=PHITelemetryEventType.ROUTING_DECISION,\n                session_id=session_id,\n                timestamp=datetime.now(timezone.utc),\n                data={\n                    **state.to_frontend_state(),\n                    \"previousMode\": previous_mode.value,\n                    \"modeChanged\": mode_changed,\n                },\n            )\n        )\n\n        # Emit mode change event if mode changed\n        if mode_changed:\n            self._emit_event(\n                PHITelemetryEvent(\n                    event_type=PHITelemetryEventType.MODE_CHANGE,\n                    session_id=session_id,\n                    timestamp=datetime.now(timezone.utc),\n                    data={\n                        \"fromMode\": previous_mode.value,\n                        \"toMode\": mode.value,\n                        \"reason\": routing_reason,\n                    },\n                )\n            )\n\n            logger.info(\n                \"PHI routing mode changed\",\n                extra={\n                    \"session_id\": session_id,\n                    \"from_mode\": previous_mode.value,\n                    \"to_mode\": mode.value,\n                    \"phi_score\": phi_score,\n                    \"reason\": routing_reason,\n                },\n            )\n\n        # Emit PHI detected event if high score\n        if phi_score >= 0.7 and phi_entities:\n            self._emit_event(\n                PHITelemetryEvent(\n                    event_type=PHITelemetryEventType.PHI_DETECTED,\n                    session_id=session_id,\n                    timestamp=datetime.now(timezone.utc),\n                    data={\n                        \"phiScore\": phi_score,\n                        \"phiEntities\": phi_entities,\n                        \"routingMode\": mode.value,\n                    },\n                )\n            )\n\n        return state\n\n    def get_state(self, session_id: str) -> Optional[PHIRoutingState]:\n        \"\"\"Get current PHI routing state for a session.\"\"\"\n        return self._session_states.get(session_id)\n\n    def get_frontend_state(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get frontend-consumable state for a session.\"\"\"\n        state = self._session_states.get(session_id)\n        if state:\n            return state.to_frontend_state()\n        return None\n\n    def end_session(self, session_id: str) -> None:\n        \"\"\"Clean up session state.\"\"\"\n        state = self._session_states.pop(session_id, None)\n        self._subscribers.pop(session_id, None)\n\n        if state:\n            self._emit_event(\n                PHITelemetryEvent(\n                    event_type=PHITelemetryEventType.SESSION_END,\n                    session_id=session_id,\n                    timestamp=datetime.now(timezone.utc),\n                    data={\n                        \"finalMode\": state.current_mode.value,\n                        \"hadPhi\": state.has_prior_phi,\n                        \"finalScore\": state.phi_score,\n                    },\n                )\n            )\n\n        logger.info(f\"PHI session ended: {session_id}\")\n\n    # =========================================================================\n    # Subscription Management\n    # =========================================================================\n\n    def subscribe(\n        self,\n        session_id: str,\n        callback: Callable[[PHITelemetryEvent], None],\n    ) -> None:\n        \"\"\"\n        Subscribe to PHI routing updates for a session.\n\n        Args:\n            session_id: Session to subscribe to\n            callback: Function to call with telemetry events\n        \"\"\"\n        if session_id not in self._subscribers:\n            self._subscribers[session_id] = []\n        self._subscribers[session_id].append(callback)\n\n    def unsubscribe(\n        self,\n        session_id: str,\n        callback: Callable[[PHITelemetryEvent], None],\n    ) -> None:\n        \"\"\"Unsubscribe from PHI routing updates.\"\"\"\n        if session_id in self._subscribers:\n            try:\n                self._subscribers[session_id].remove(callback)\n            except ValueError:\n                pass\n\n    def _emit_event(self, event: PHITelemetryEvent) -> None:\n        \"\"\"Emit event to all subscribers and event bus.\"\"\"\n        # Notify session subscribers\n        session_callbacks = self._subscribers.get(event.session_id, [])\n        for callback in session_callbacks:\n            try:\n                callback(event)\n            except Exception as e:\n                logger.error(f\"Error in PHI telemetry callback: {e}\")\n\n        # Emit to event bus if available\n        if self._event_bus:\n            try:\n                if hasattr(self._event_bus, \"publish_event_sync\"):\n                    self._event_bus.publish_event_sync(\n                        event_type=f\"phi.{event.event_type.value}\",\n                        data=event.to_dict(),\n                        session_id=event.session_id,\n                        source_engine=\"phi_telemetry\",\n                    )\n            except Exception as e:\n                logger.debug(f\"Event bus emit failed: {e}\")\n\n        # Collect metrics\n        if self._metrics_enabled:\n            self._record_metrics(event)\n\n    def _record_metrics(self, event: PHITelemetryEvent) -> None:\n        \"\"\"Record Prometheus metrics for telemetry event.\"\"\"\n        try:\n            from app.core.metrics import phi_routing_counter, phi_score_histogram\n\n            if event.event_type == PHITelemetryEventType.ROUTING_DECISION:\n                mode = event.data.get(\"phiMode\", \"unknown\")\n                phi_routing_counter.labels(routing=mode).inc()\n\n                score = event.data.get(\"phiScore\", 0.0)\n                phi_score_histogram.observe(score)\n\n        except ImportError:\n            pass  # Metrics not available\n\n\n# Singleton instance\n_phi_telemetry_service: Optional[PHITelemetryService] = None\n\n\ndef get_phi_telemetry_service() -> PHITelemetryService:\n    \"\"\"Get or create PHI telemetry service instance.\"\"\"\n    global _phi_telemetry_service\n    if _phi_telemetry_service is None:\n        _phi_telemetry_service = PHITelemetryService()\n    return _phi_telemetry_service\n"
}
