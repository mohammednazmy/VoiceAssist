{
  "path": "services/api-gateway/app/api/admin_system.py",
  "language": "python",
  "size": 17811,
  "last_modified": "2025-12-04T11:26:46.377Z",
  "lines": 573,
  "content": "\"\"\"Admin System API endpoints (Sprint 4 - System Management).\n\nProvides admin endpoints for:\n- System resource monitoring (disk, memory, CPU)\n- Backup status and controls\n- Maintenance mode management\n- System configuration\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport os\nimport shutil\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.api_envelope import success_response\nfrom app.core.database import get_db, redis_client\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/system\", tags=[\"admin\", \"system\"])\n\n# Redis keys\nREDIS_MAINTENANCE_KEY = \"voiceassist:system:maintenance_mode\"\nREDIS_BACKUP_STATUS_KEY = \"voiceassist:system:backup_status\"\nREDIS_RESOURCE_CACHE_KEY = \"voiceassist:admin:resources\"\nRESOURCE_CACHE_TTL = 30  # 30 seconds\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass ResourceMetrics(BaseModel):\n    \"\"\"System resource metrics.\"\"\"\n\n    disk_total_gb: float\n    disk_used_gb: float\n    disk_free_gb: float\n    disk_usage_percent: float\n    memory_total_gb: float\n    memory_used_gb: float\n    memory_free_gb: float\n    memory_usage_percent: float\n    cpu_count: int\n    cpu_usage_percent: float\n    load_average_1m: float\n    load_average_5m: float\n    load_average_15m: float\n\n\nclass BackupStatus(BaseModel):\n    \"\"\"Backup status information.\"\"\"\n\n    last_backup_at: Optional[str]\n    last_backup_result: str  # \"success\", \"failed\", \"in_progress\", \"unknown\"\n    backup_destination: str\n    schedule: str\n    retention_days: int\n    next_scheduled_at: Optional[str]\n    backup_size_mb: Optional[float]\n\n\nclass BackupHistoryEntry(BaseModel):\n    \"\"\"Backup history entry.\"\"\"\n\n    id: str\n    started_at: str\n    completed_at: Optional[str]\n    status: str  # \"success\", \"failed\", \"in_progress\"\n    size_bytes: Optional[int]\n    backup_type: str  # \"full\", \"incremental\"\n    error_message: Optional[str]\n\n\nclass MaintenanceStatus(BaseModel):\n    \"\"\"Maintenance mode status.\"\"\"\n\n    enabled: bool\n    started_at: Optional[str]\n    started_by: Optional[str]\n    message: Optional[str]\n    estimated_end: Optional[str]\n\n\nclass MaintenanceRequest(BaseModel):\n    \"\"\"Request to enable maintenance mode.\"\"\"\n\n    message: Optional[str] = \"System is under maintenance\"\n    estimated_duration_minutes: Optional[int] = 30\n\n\nclass SystemHealthStatus(BaseModel):\n    \"\"\"Overall system health status.\"\"\"\n\n    status: str  # \"healthy\", \"degraded\", \"unhealthy\"\n    uptime_seconds: int\n    services: Dict[str, str]  # service_name -> status\n    last_checked_at: str\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\n\ndef _get_disk_usage(path: str = \"/\") -> Dict[str, float]:\n    \"\"\"Get disk usage statistics.\"\"\"\n    try:\n        usage = shutil.disk_usage(path)\n        total_gb = usage.total / (1024**3)\n        used_gb = usage.used / (1024**3)\n        free_gb = usage.free / (1024**3)\n        percent = (usage.used / usage.total) * 100\n        return {\n            \"total_gb\": round(total_gb, 2),\n            \"used_gb\": round(used_gb, 2),\n            \"free_gb\": round(free_gb, 2),\n            \"percent\": round(percent, 1),\n        }\n    except Exception as e:\n        logger.warning(f\"Failed to get disk usage: {e}\")\n        return {\"total_gb\": 0, \"used_gb\": 0, \"free_gb\": 0, \"percent\": 0}\n\n\ndef _get_memory_usage() -> Dict[str, float]:\n    \"\"\"Get memory usage statistics.\"\"\"\n    try:\n        # Read from /proc/meminfo on Linux\n        with open(\"/proc/meminfo\", \"r\") as f:\n            meminfo = {}\n            for line in f:\n                parts = line.split()\n                if len(parts) >= 2:\n                    key = parts[0].rstrip(\":\")\n                    value = int(parts[1])  # in KB\n                    meminfo[key] = value\n\n        total_kb = meminfo.get(\"MemTotal\", 0)\n        free_kb = meminfo.get(\"MemFree\", 0)\n        available_kb = meminfo.get(\"MemAvailable\", free_kb)\n        _buffers_kb = meminfo.get(\"Buffers\", 0)  # noqa: F841\n        _cached_kb = meminfo.get(\"Cached\", 0)  # noqa: F841\n\n        # Used = Total - Available (more accurate than Total - Free)\n        used_kb = total_kb - available_kb\n\n        total_gb = total_kb / (1024**2)\n        used_gb = used_kb / (1024**2)\n        free_gb = available_kb / (1024**2)\n        percent = (used_kb / total_kb) * 100 if total_kb > 0 else 0\n\n        return {\n            \"total_gb\": round(total_gb, 2),\n            \"used_gb\": round(used_gb, 2),\n            \"free_gb\": round(free_gb, 2),\n            \"percent\": round(percent, 1),\n        }\n    except Exception as e:\n        logger.warning(f\"Failed to get memory usage: {e}\")\n        return {\"total_gb\": 0, \"used_gb\": 0, \"free_gb\": 0, \"percent\": 0}\n\n\ndef _get_cpu_usage() -> Dict[str, Any]:\n    \"\"\"Get CPU usage statistics.\"\"\"\n    try:\n        cpu_count = os.cpu_count() or 1\n\n        # Get load average\n        load_avg = os.getloadavg()\n\n        # Estimate CPU usage from 1-minute load average\n        cpu_percent = min((load_avg[0] / cpu_count) * 100, 100)\n\n        return {\n            \"count\": cpu_count,\n            \"percent\": round(cpu_percent, 1),\n            \"load_1m\": round(load_avg[0], 2),\n            \"load_5m\": round(load_avg[1], 2),\n            \"load_15m\": round(load_avg[2], 2),\n        }\n    except Exception as e:\n        logger.warning(f\"Failed to get CPU usage: {e}\")\n        return {\"count\": 1, \"percent\": 0, \"load_1m\": 0, \"load_5m\": 0, \"load_15m\": 0}\n\n\ndef _get_backup_status_from_redis() -> Dict[str, Any]:\n    \"\"\"Get backup status from Redis.\"\"\"\n    try:\n        cached = redis_client.get(REDIS_BACKUP_STATUS_KEY)\n        if cached:\n            return json.loads(cached)\n    except Exception as e:\n        logger.warning(f\"Failed to get backup status from Redis: {e}\")\n\n    # Return default status\n    return {\n        \"last_backup_at\": None,\n        \"last_backup_result\": \"unknown\",\n        \"backup_destination\": \"local\",\n        \"schedule\": \"Daily at 2:00 AM UTC\",\n        \"retention_days\": 30,\n        \"next_scheduled_at\": None,\n        \"backup_size_mb\": None,\n    }\n\n\ndef _get_uptime_seconds() -> int:\n    \"\"\"Get system uptime in seconds.\"\"\"\n    try:\n        with open(\"/proc/uptime\", \"r\") as f:\n            uptime = float(f.readline().split()[0])\n            return int(uptime)\n    except Exception:\n        return 0\n\n\n# ============================================================================\n# Resource Monitoring Endpoints\n# ============================================================================\n\n\n@router.get(\"/resources\")\nasync def get_system_resources(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get system resource metrics (disk, memory, CPU).\"\"\"\n\n    # Try cache first\n    try:\n        cached = redis_client.get(REDIS_RESOURCE_CACHE_KEY)\n        if cached:\n            trace_id = getattr(request.state, \"trace_id\", None)\n            return success_response(data=json.loads(cached), trace_id=trace_id)\n    except Exception:\n        pass\n\n    # Get fresh metrics\n    disk = _get_disk_usage()\n    memory = _get_memory_usage()\n    cpu = _get_cpu_usage()\n\n    metrics = ResourceMetrics(\n        disk_total_gb=disk[\"total_gb\"],\n        disk_used_gb=disk[\"used_gb\"],\n        disk_free_gb=disk[\"free_gb\"],\n        disk_usage_percent=disk[\"percent\"],\n        memory_total_gb=memory[\"total_gb\"],\n        memory_used_gb=memory[\"used_gb\"],\n        memory_free_gb=memory[\"free_gb\"],\n        memory_usage_percent=memory[\"percent\"],\n        cpu_count=cpu[\"count\"],\n        cpu_usage_percent=cpu[\"percent\"],\n        load_average_1m=cpu[\"load_1m\"],\n        load_average_5m=cpu[\"load_5m\"],\n        load_average_15m=cpu[\"load_15m\"],\n    )\n\n    response_data = {\n        **metrics.model_dump(),\n        \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    # Cache for 30 seconds\n    try:\n        redis_client.setex(REDIS_RESOURCE_CACHE_KEY, RESOURCE_CACHE_TTL, json.dumps(response_data))\n    except Exception:\n        pass\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data=response_data, trace_id=trace_id)\n\n\n@router.get(\"/health\")\nasync def get_system_health(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get overall system health status.\"\"\"\n\n    # Check various services\n    services = {}\n\n    # Check Redis\n    try:\n        redis_client.ping()\n        services[\"redis\"] = \"healthy\"\n    except Exception:\n        services[\"redis\"] = \"unhealthy\"\n\n    # Check database (basic connectivity)\n    try:\n        from app.core.database import engine\n\n        with engine.connect() as conn:\n            conn.execute(\"SELECT 1\")\n        services[\"database\"] = \"healthy\"\n    except Exception:\n        services[\"database\"] = \"unhealthy\"\n\n    # Determine overall status\n    unhealthy_count = sum(1 for s in services.values() if s == \"unhealthy\")\n    if unhealthy_count == 0:\n        overall_status = \"healthy\"\n    elif unhealthy_count < len(services):\n        overall_status = \"degraded\"\n    else:\n        overall_status = \"unhealthy\"\n\n    health = SystemHealthStatus(\n        status=overall_status,\n        uptime_seconds=_get_uptime_seconds(),\n        services=services,\n        last_checked_at=datetime.now(timezone.utc).isoformat() + \"Z\",\n    )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(data=health.model_dump(), trace_id=trace_id)\n\n\n# ============================================================================\n# Backup Management Endpoints\n# ============================================================================\n\n\n@router.get(\"/backup/status\")\nasync def get_backup_status(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get current backup configuration and status.\"\"\"\n\n    status_data = _get_backup_status_from_redis()\n    status = BackupStatus(**status_data)\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            **status.model_dump(),\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n\n\n@router.get(\"/backup/history\")\nasync def get_backup_history(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n    limit: int = Query(10, ge=1, le=50),\n) -> Dict:\n    \"\"\"Get backup history.\"\"\"\n\n    # In production, this would query actual backup logs\n    # For now, return mock data structure\n    history: List[Dict[str, Any]] = []\n\n    # Generate some example history entries\n    now = datetime.now(timezone.utc)\n    for i in range(min(limit, 5)):\n        backup_time = now - timedelta(days=i)\n        history.append(\n            BackupHistoryEntry(\n                id=f\"backup-{backup_time.strftime('%Y%m%d')}\",\n                started_at=backup_time.replace(hour=2, minute=0).isoformat() + \"Z\",\n                completed_at=backup_time.replace(hour=2, minute=15).isoformat() + \"Z\",\n                status=\"success\",\n                size_bytes=524288000 + (i * 10485760),  # ~500MB + variance\n                backup_type=\"full\" if i % 7 == 0 else \"incremental\",\n                error_message=None,\n            ).model_dump()\n        )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            \"history\": history,\n            \"total\": len(history),\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n\n\n@router.post(\"/backup/trigger\")\nasync def trigger_backup(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n    backup_type: str = Query(\"full\", regex=\"^(full|incremental)$\"),\n) -> Dict:\n    \"\"\"Trigger a manual backup (admin only).\"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    # Update backup status to in_progress\n    backup_id = f\"backup-{datetime.now(timezone.utc).strftime('%Y%m%d-%H%M%S')}\"\n    status = {\n        \"last_backup_at\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        \"last_backup_result\": \"in_progress\",\n        \"backup_id\": backup_id,\n        \"backup_type\": backup_type,\n        \"triggered_by\": current_admin_user.email,\n    }\n\n    try:\n        redis_client.setex(REDIS_BACKUP_STATUS_KEY, 86400, json.dumps(status))\n    except Exception as e:\n        logger.warning(f\"Failed to update backup status: {e}\")\n\n    logger.info(\n        \"backup_triggered\",\n        extra={\n            \"admin_user_id\": str(current_admin_user.id),\n            \"backup_id\": backup_id,\n            \"backup_type\": backup_type,\n        },\n    )\n\n    # In production, this would trigger the actual backup process\n    # For now, return success with the backup ID\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            \"message\": \"Backup triggered successfully\",\n            \"backup_id\": backup_id,\n            \"backup_type\": backup_type,\n            \"status\": \"in_progress\",\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n\n\n# ============================================================================\n# Maintenance Mode Endpoints\n# ============================================================================\n\n\n@router.get(\"/maintenance\")\nasync def get_maintenance_status(\n    request: Request,\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"Get current maintenance mode status.\"\"\"\n\n    try:\n        cached = redis_client.get(REDIS_MAINTENANCE_KEY)\n        if cached:\n            status_data = json.loads(cached)\n            status = MaintenanceStatus(**status_data)\n        else:\n            status = MaintenanceStatus(\n                enabled=False,\n                started_at=None,\n                started_by=None,\n                message=None,\n                estimated_end=None,\n            )\n    except Exception:\n        status = MaintenanceStatus(\n            enabled=False,\n            started_at=None,\n            started_by=None,\n            message=None,\n            estimated_end=None,\n        )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            **status.model_dump(),\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n\n\n@router.post(\"/maintenance/enable\")\nasync def enable_maintenance_mode(\n    request: Request,\n    maintenance_request: MaintenanceRequest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Enable maintenance mode (admin only).\"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    now = datetime.now(timezone.utc)\n    estimated_end = None\n    if maintenance_request.estimated_duration_minutes:\n        estimated_end = (now + timedelta(minutes=maintenance_request.estimated_duration_minutes)).isoformat() + \"Z\"\n\n    status = MaintenanceStatus(\n        enabled=True,\n        started_at=now.isoformat() + \"Z\",\n        started_by=current_admin_user.email,\n        message=maintenance_request.message,\n        estimated_end=estimated_end,\n    )\n\n    try:\n        # Store maintenance status in Redis\n        redis_client.set(REDIS_MAINTENANCE_KEY, json.dumps(status.model_dump()))\n    except Exception as e:\n        logger.error(f\"Failed to enable maintenance mode: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to enable maintenance mode\")\n\n    logger.warning(\n        \"maintenance_mode_enabled\",\n        extra={\n            \"admin_user_id\": str(current_admin_user.id),\n            \"admin_email\": current_admin_user.email,\n            \"maintenance_message\": maintenance_request.message,\n            \"estimated_duration_minutes\": maintenance_request.estimated_duration_minutes,\n        },\n    )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            **status.model_dump(),\n            \"action\": \"enabled\",\n            \"timestamp\": now.isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n\n\n@router.post(\"/maintenance/disable\")\nasync def disable_maintenance_mode(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_user),\n) -> Dict:\n    \"\"\"Disable maintenance mode (admin only).\"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        redis_client.delete(REDIS_MAINTENANCE_KEY)\n    except Exception as e:\n        logger.error(f\"Failed to disable maintenance mode: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to disable maintenance mode\")\n\n    logger.info(\n        \"maintenance_mode_disabled\",\n        extra={\n            \"admin_user_id\": str(current_admin_user.id),\n            \"admin_email\": current_admin_user.email,\n        },\n    )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        data={\n            \"enabled\": False,\n            \"action\": \"disabled\",\n            \"disabled_by\": current_admin_user.email,\n            \"timestamp\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        },\n        trace_id=trace_id,\n    )\n"
}
