{
  "path": "services/api-gateway/app/services/adaptive_quality_service.py",
  "language": "python",
  "size": 28694,
  "last_modified": "2025-12-05T03:07:13.132Z",
  "lines": 845,
  "content": "\"\"\"\nAdaptive Quality Service - Voice Mode v4.1 Phase 3\n\nDynamically adjusts voice processing quality based on network conditions\nand system load to maintain optimal user experience.\n\nFeatures:\n- Real-time network condition monitoring\n- Adaptive STT/TTS quality levels\n- Graceful degradation strategies\n- Load-based feature toggling\n- Latency budget management\n\nReference: docs/voice/phase3-implementation-plan.md\n\nFeature Flag: backend.voice_v4_adaptive_quality\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional, Tuple\n\nfrom app.core.config import settings\nfrom app.core.feature_flags import feature_flag_service\n\nlogger = logging.getLogger(__name__)\n\n\n# ==============================================================================\n# Quality Levels and Presets\n# ==============================================================================\n\n\nclass QualityLevel(str, Enum):\n    \"\"\"Voice processing quality levels.\"\"\"\n\n    ULTRA = \"ultra\"  # Maximum quality, higher latency\n    HIGH = \"high\"  # High quality, balanced latency\n    MEDIUM = \"medium\"  # Standard quality, optimized latency\n    LOW = \"low\"  # Reduced quality, minimum latency\n    MINIMAL = \"minimal\"  # Emergency fallback, fastest\n\n\nclass NetworkCondition(str, Enum):\n    \"\"\"Detected network condition.\"\"\"\n\n    EXCELLENT = \"excellent\"  # <50ms RTT, >10 Mbps\n    GOOD = \"good\"  # 50-150ms RTT, 2-10 Mbps\n    FAIR = \"fair\"  # 150-300ms RTT, 0.5-2 Mbps\n    POOR = \"poor\"  # 300-500ms RTT, <0.5 Mbps\n    CRITICAL = \"critical\"  # >500ms RTT or frequent drops\n\n\nclass DegradationType(str, Enum):\n    \"\"\"Types of quality degradation.\"\"\"\n\n    STT_MODEL_DOWNGRADE = \"stt_model_downgrade\"\n    TTS_MODEL_DOWNGRADE = \"tts_model_downgrade\"\n    AUDIO_BITRATE_REDUCE = \"audio_bitrate_reduce\"\n    SAMPLE_RATE_REDUCE = \"sample_rate_reduce\"\n    CONTEXT_LENGTH_REDUCE = \"context_length_reduce\"\n    FEATURE_DISABLE = \"feature_disable\"\n    RESPONSE_TRUNCATE = \"response_truncate\"\n    CACHE_FALLBACK = \"cache_fallback\"\n\n\n@dataclass\nclass QualitySettings:\n    \"\"\"Quality settings for a specific level.\"\"\"\n\n    level: QualityLevel\n    stt_model: str\n    tts_model: str\n    audio_bitrate_kbps: int\n    sample_rate_hz: int\n    max_context_tokens: int\n    max_response_tokens: int\n    enable_speaker_diarization: bool\n    enable_sentiment_analysis: bool\n    enable_language_detection: bool\n    target_latency_ms: int\n    description: str\n\n\n# Quality presets\nQUALITY_PRESETS: Dict[QualityLevel, QualitySettings] = {\n    QualityLevel.ULTRA: QualitySettings(\n        level=QualityLevel.ULTRA,\n        stt_model=\"whisper-large-v3\",\n        tts_model=\"eleven_turbo_v2\",\n        audio_bitrate_kbps=128,\n        sample_rate_hz=48000,\n        max_context_tokens=8000,\n        max_response_tokens=2000,\n        enable_speaker_diarization=True,\n        enable_sentiment_analysis=True,\n        enable_language_detection=True,\n        target_latency_ms=800,\n        description=\"Maximum quality for premium experience\",\n    ),\n    QualityLevel.HIGH: QualitySettings(\n        level=QualityLevel.HIGH,\n        stt_model=\"whisper-1\",\n        tts_model=\"eleven_turbo_v2\",\n        audio_bitrate_kbps=96,\n        sample_rate_hz=24000,\n        max_context_tokens=6000,\n        max_response_tokens=1500,\n        enable_speaker_diarization=True,\n        enable_sentiment_analysis=True,\n        enable_language_detection=True,\n        target_latency_ms=600,\n        description=\"High quality with balanced latency\",\n    ),\n    QualityLevel.MEDIUM: QualitySettings(\n        level=QualityLevel.MEDIUM,\n        stt_model=\"whisper-1\",\n        tts_model=\"tts-1\",\n        audio_bitrate_kbps=64,\n        sample_rate_hz=16000,\n        max_context_tokens=4000,\n        max_response_tokens=1000,\n        enable_speaker_diarization=False,\n        enable_sentiment_analysis=True,\n        enable_language_detection=True,\n        target_latency_ms=500,\n        description=\"Standard quality optimized for latency\",\n    ),\n    QualityLevel.LOW: QualitySettings(\n        level=QualityLevel.LOW,\n        stt_model=\"whisper-1\",\n        tts_model=\"tts-1\",\n        audio_bitrate_kbps=48,\n        sample_rate_hz=16000,\n        max_context_tokens=2000,\n        max_response_tokens=500,\n        enable_speaker_diarization=False,\n        enable_sentiment_analysis=False,\n        enable_language_detection=False,\n        target_latency_ms=400,\n        description=\"Reduced quality for poor connections\",\n    ),\n    QualityLevel.MINIMAL: QualitySettings(\n        level=QualityLevel.MINIMAL,\n        stt_model=\"whisper-1\",\n        tts_model=\"tts-1\",\n        audio_bitrate_kbps=32,\n        sample_rate_hz=8000,\n        max_context_tokens=1000,\n        max_response_tokens=250,\n        enable_speaker_diarization=False,\n        enable_sentiment_analysis=False,\n        enable_language_detection=False,\n        target_latency_ms=300,\n        description=\"Emergency fallback mode\",\n    ),\n}\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\n@dataclass\nclass NetworkMetrics:\n    \"\"\"Network performance metrics.\"\"\"\n\n    rtt_ms: float  # Round-trip time\n    bandwidth_kbps: float  # Estimated bandwidth\n    packet_loss_pct: float  # Packet loss percentage\n    jitter_ms: float  # Jitter\n    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    @property\n    def condition(self) -> NetworkCondition:\n        \"\"\"Determine network condition from metrics.\"\"\"\n        if self.rtt_ms < 50 and self.packet_loss_pct < 0.1:\n            return NetworkCondition.EXCELLENT\n        elif self.rtt_ms < 150 and self.packet_loss_pct < 1:\n            return NetworkCondition.GOOD\n        elif self.rtt_ms < 300 and self.packet_loss_pct < 5:\n            return NetworkCondition.FAIR\n        elif self.rtt_ms < 500 and self.packet_loss_pct < 10:\n            return NetworkCondition.POOR\n        else:\n            return NetworkCondition.CRITICAL\n\n\n@dataclass\nclass LatencyBudget:\n    \"\"\"Latency budget tracking for voice pipeline.\"\"\"\n\n    total_budget_ms: int\n    stt_budget_ms: int\n    llm_budget_ms: int\n    tts_budget_ms: int\n    network_budget_ms: int\n\n    # Actual measurements\n    stt_actual_ms: float = 0\n    llm_actual_ms: float = 0\n    tts_actual_ms: float = 0\n    network_actual_ms: float = 0\n\n    @property\n    def total_actual_ms(self) -> float:\n        return self.stt_actual_ms + self.llm_actual_ms + self.tts_actual_ms + self.network_actual_ms\n\n    @property\n    def remaining_ms(self) -> float:\n        return self.total_budget_ms - self.total_actual_ms\n\n    @property\n    def is_exceeded(self) -> bool:\n        return self.total_actual_ms > self.total_budget_ms\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"totalBudgetMs\": self.total_budget_ms,\n            \"totalActualMs\": round(self.total_actual_ms, 2),\n            \"remainingMs\": round(self.remaining_ms, 2),\n            \"isExceeded\": self.is_exceeded,\n            \"components\": {\n                \"stt\": {\"budget\": self.stt_budget_ms, \"actual\": round(self.stt_actual_ms, 2)},\n                \"llm\": {\"budget\": self.llm_budget_ms, \"actual\": round(self.llm_actual_ms, 2)},\n                \"tts\": {\"budget\": self.tts_budget_ms, \"actual\": round(self.tts_actual_ms, 2)},\n                \"network\": {\"budget\": self.network_budget_ms, \"actual\": round(self.network_actual_ms, 2)},\n            },\n        }\n\n\n@dataclass\nclass DegradationEvent:\n    \"\"\"Record of a quality degradation event.\"\"\"\n\n    degradation_type: DegradationType\n    from_level: QualityLevel\n    to_level: QualityLevel\n    reason: str\n    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    session_id: Optional[str] = None\n\n\n@dataclass\nclass QualityState:\n    \"\"\"Current quality state for a session.\"\"\"\n\n    session_id: str\n    current_level: QualityLevel\n    current_settings: QualitySettings\n    network_condition: NetworkCondition\n    degradations: List[DegradationEvent] = field(default_factory=list)\n    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"sessionId\": self.session_id,\n            \"currentLevel\": self.current_level.value,\n            \"networkCondition\": self.network_condition.value,\n            \"targetLatencyMs\": self.current_settings.target_latency_ms,\n            \"degradationCount\": len(self.degradations),\n            \"lastUpdated\": self.last_updated.isoformat(),\n        }\n\n\n# ==============================================================================\n# Adaptive Quality Service\n# ==============================================================================\n\n\nclass AdaptiveQualityService:\n    \"\"\"\n    Service for adaptive voice processing quality management.\n\n    Monitors network conditions and system load to dynamically adjust\n    processing quality for optimal user experience.\n\n    Usage:\n        service = AdaptiveQualityService()\n\n        # Initialize session with quality state\n        state = await service.init_session(session_id, initial_level=QualityLevel.HIGH)\n\n        # Update based on network metrics\n        state = await service.update_network_metrics(session_id, metrics)\n\n        # Get current settings for processing\n        settings = service.get_current_settings(session_id)\n\n        # Record latency for budget tracking\n        service.record_latency(session_id, component=\"stt\", latency_ms=150)\n    \"\"\"\n\n    def __init__(self):\n        self._sessions: Dict[str, QualityState] = {}\n        self._network_history: Dict[str, List[NetworkMetrics]] = {}\n        self._latency_budgets: Dict[str, LatencyBudget] = {}\n        self._quality_change_callbacks: List[Callable] = []\n        self._lock = asyncio.Lock()\n        self._initialized = False\n\n    async def initialize(self) -> bool:\n        \"\"\"Initialize the adaptive quality service.\"\"\"\n        if self._initialized:\n            return True\n\n        async with self._lock:\n            if self._initialized:\n                return True\n\n            try:\n                # Check feature flag\n                if not await feature_flag_service.is_enabled(\n                    \"backend.voice_v4_adaptive_quality\"\n                ):\n                    logger.info(\"Adaptive quality feature flag is disabled\")\n                    # Still allow basic operation\n                    self._initialized = True\n                    return True\n\n                self._initialized = True\n                logger.info(\"Adaptive quality service initialized\")\n                return True\n\n            except Exception as e:\n                logger.error(f\"Failed to initialize adaptive quality service: {e}\")\n                return False\n\n    async def init_session(\n        self,\n        session_id: str,\n        initial_level: QualityLevel = QualityLevel.HIGH,\n        user_preference: Optional[QualityLevel] = None,\n    ) -> QualityState:\n        \"\"\"\n        Initialize quality state for a session.\n\n        Args:\n            session_id: Voice session ID\n            initial_level: Starting quality level\n            user_preference: User's preferred quality level (overrides initial)\n\n        Returns:\n            QualityState for the session.\n        \"\"\"\n        level = user_preference or initial_level\n        settings = QUALITY_PRESETS[level]\n\n        state = QualityState(\n            session_id=session_id,\n            current_level=level,\n            current_settings=settings,\n            network_condition=NetworkCondition.GOOD,  # Assume good until measured\n        )\n\n        # Create latency budget\n        budget = LatencyBudget(\n            total_budget_ms=settings.target_latency_ms,\n            stt_budget_ms=int(settings.target_latency_ms * 0.25),  # 25% for STT\n            llm_budget_ms=int(settings.target_latency_ms * 0.35),  # 35% for LLM\n            tts_budget_ms=int(settings.target_latency_ms * 0.25),  # 25% for TTS\n            network_budget_ms=int(settings.target_latency_ms * 0.15),  # 15% for network\n        )\n\n        async with self._lock:\n            self._sessions[session_id] = state\n            self._network_history[session_id] = []\n            self._latency_budgets[session_id] = budget\n\n        logger.info(\n            f\"Quality session initialized\",\n            extra={\n                \"session_id\": session_id,\n                \"level\": level.value,\n                \"target_latency_ms\": settings.target_latency_ms,\n            },\n        )\n\n        return state\n\n    async def update_network_metrics(\n        self,\n        session_id: str,\n        metrics: NetworkMetrics,\n    ) -> QualityState:\n        \"\"\"\n        Update network metrics and potentially adjust quality.\n\n        Args:\n            session_id: Voice session ID\n            metrics: Current network metrics\n\n        Returns:\n            Updated QualityState.\n        \"\"\"\n        state = self._sessions.get(session_id)\n        if not state:\n            state = await self.init_session(session_id)\n\n        # Add to history\n        history = self._network_history.get(session_id, [])\n        history.append(metrics)\n        if len(history) > 20:\n            history = history[-20:]\n        self._network_history[session_id] = history\n\n        # Determine if quality adjustment needed\n        new_condition = metrics.condition\n        old_condition = state.network_condition\n\n        if new_condition != old_condition:\n            state.network_condition = new_condition\n\n            # Map network condition to quality level\n            condition_to_level = {\n                NetworkCondition.EXCELLENT: QualityLevel.ULTRA,\n                NetworkCondition.GOOD: QualityLevel.HIGH,\n                NetworkCondition.FAIR: QualityLevel.MEDIUM,\n                NetworkCondition.POOR: QualityLevel.LOW,\n                NetworkCondition.CRITICAL: QualityLevel.MINIMAL,\n            }\n\n            target_level = condition_to_level[new_condition]\n\n            # Only downgrade, never upgrade mid-session unless significantly better\n            if self._should_change_quality(state.current_level, target_level, history):\n                await self._change_quality(state, target_level, f\"network_{new_condition.value}\")\n\n        state.last_updated = datetime.now(timezone.utc)\n        return state\n\n    def _should_change_quality(\n        self,\n        current: QualityLevel,\n        target: QualityLevel,\n        history: List[NetworkMetrics],\n    ) -> bool:\n        \"\"\"Determine if quality change is warranted.\"\"\"\n        if len(history) < 3:\n            return False\n\n        # Get quality level values (lower = better quality)\n        levels = list(QualityLevel)\n        current_idx = levels.index(current)\n        target_idx = levels.index(target)\n\n        # Downgrade more readily than upgrade\n        if target_idx > current_idx:  # Downgrade\n            # Check if recent metrics consistently poor\n            recent = history[-3:]\n            poor_count = sum(1 for m in recent if m.condition.value in [\"poor\", \"critical\"])\n            return poor_count >= 2\n\n        elif target_idx < current_idx:  # Upgrade\n            # Require sustained good conditions to upgrade\n            recent = history[-5:]\n            if len(recent) < 5:\n                return False\n            good_count = sum(1 for m in recent if m.condition.value in [\"excellent\", \"good\"])\n            return good_count >= 4\n\n        return False\n\n    async def _change_quality(\n        self,\n        state: QualityState,\n        new_level: QualityLevel,\n        reason: str,\n    ) -> None:\n        \"\"\"Change quality level and record degradation.\"\"\"\n        old_level = state.current_level\n        new_settings = QUALITY_PRESETS[new_level]\n\n        # Record degradation event\n        event = DegradationEvent(\n            degradation_type=DegradationType.STT_MODEL_DOWNGRADE,  # Primary degradation\n            from_level=old_level,\n            to_level=new_level,\n            reason=reason,\n            session_id=state.session_id,\n        )\n        state.degradations.append(event)\n\n        # Update state\n        state.current_level = new_level\n        state.current_settings = new_settings\n        state.last_updated = datetime.now(timezone.utc)\n\n        # Update latency budget\n        budget = LatencyBudget(\n            total_budget_ms=new_settings.target_latency_ms,\n            stt_budget_ms=int(new_settings.target_latency_ms * 0.25),\n            llm_budget_ms=int(new_settings.target_latency_ms * 0.35),\n            tts_budget_ms=int(new_settings.target_latency_ms * 0.25),\n            network_budget_ms=int(new_settings.target_latency_ms * 0.15),\n        )\n        self._latency_budgets[state.session_id] = budget\n\n        logger.info(\n            \"Quality level changed\",\n            extra={\n                \"session_id\": state.session_id,\n                \"from_level\": old_level.value,\n                \"to_level\": new_level.value,\n                \"reason\": reason,\n            },\n        )\n\n        # Notify callbacks\n        for callback in self._quality_change_callbacks:\n            try:\n                callback(state, event)\n            except Exception as e:\n                logger.error(f\"Quality change callback error: {e}\")\n\n    def record_latency(\n        self,\n        session_id: str,\n        component: str,\n        latency_ms: float,\n    ) -> Optional[LatencyBudget]:\n        \"\"\"\n        Record latency for a pipeline component.\n\n        Args:\n            session_id: Voice session ID\n            component: Component name (\"stt\", \"llm\", \"tts\", \"network\")\n            latency_ms: Measured latency in milliseconds\n\n        Returns:\n            Updated LatencyBudget or None if session not found.\n        \"\"\"\n        budget = self._latency_budgets.get(session_id)\n        if not budget:\n            return None\n\n        if component == \"stt\":\n            budget.stt_actual_ms = latency_ms\n        elif component == \"llm\":\n            budget.llm_actual_ms = latency_ms\n        elif component == \"tts\":\n            budget.tts_actual_ms = latency_ms\n        elif component == \"network\":\n            budget.network_actual_ms = latency_ms\n\n        # Check if budget exceeded and trigger degradation if needed\n        if budget.is_exceeded:\n            state = self._sessions.get(session_id)\n            if state:\n                # Find next lower quality level\n                levels = list(QualityLevel)\n                current_idx = levels.index(state.current_level)\n                if current_idx < len(levels) - 1:\n                    asyncio.create_task(\n                        self._change_quality(\n                            state,\n                            levels[current_idx + 1],\n                            f\"latency_budget_exceeded_{component}\",\n                        )\n                    )\n\n        return budget\n\n    def get_current_settings(self, session_id: str) -> Optional[QualitySettings]:\n        \"\"\"Get current quality settings for a session.\"\"\"\n        state = self._sessions.get(session_id)\n        if state:\n            return state.current_settings\n        return None\n\n    def get_quality_state(self, session_id: str) -> Optional[QualityState]:\n        \"\"\"Get current quality state for a session.\"\"\"\n        return self._sessions.get(session_id)\n\n    def get_latency_budget(self, session_id: str) -> Optional[LatencyBudget]:\n        \"\"\"Get latency budget for a session.\"\"\"\n        return self._latency_budgets.get(session_id)\n\n    def on_quality_change(self, callback: Callable[[QualityState, DegradationEvent], None]) -> None:\n        \"\"\"Register callback for quality change events.\"\"\"\n        self._quality_change_callbacks.append(callback)\n\n    async def end_session(self, session_id: str) -> Optional[QualityState]:\n        \"\"\"\n        End a quality tracking session.\n\n        Returns:\n            Final QualityState with degradation history.\n        \"\"\"\n        async with self._lock:\n            state = self._sessions.pop(session_id, None)\n            self._network_history.pop(session_id, None)\n            self._latency_budgets.pop(session_id, None)\n\n            if state:\n                logger.info(\n                    \"Quality session ended\",\n                    extra={\n                        \"session_id\": session_id,\n                        \"final_level\": state.current_level.value,\n                        \"degradation_count\": len(state.degradations),\n                    },\n                )\n\n            return state\n\n\n# ==============================================================================\n# Load Testing Utilities\n# ==============================================================================\n\n\n@dataclass\nclass LoadTestResult:\n    \"\"\"Result of a load test run.\"\"\"\n\n    test_name: str\n    concurrent_sessions: int\n    duration_seconds: float\n    total_requests: int\n    successful_requests: int\n    failed_requests: int\n    avg_latency_ms: float\n    p50_latency_ms: float\n    p95_latency_ms: float\n    p99_latency_ms: float\n    degradations_triggered: int\n    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    @property\n    def success_rate(self) -> float:\n        if self.total_requests == 0:\n            return 0.0\n        return self.successful_requests / self.total_requests * 100\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"testName\": self.test_name,\n            \"concurrentSessions\": self.concurrent_sessions,\n            \"durationSeconds\": round(self.duration_seconds, 2),\n            \"totalRequests\": self.total_requests,\n            \"successfulRequests\": self.successful_requests,\n            \"failedRequests\": self.failed_requests,\n            \"successRate\": round(self.success_rate, 2),\n            \"avgLatencyMs\": round(self.avg_latency_ms, 2),\n            \"p50LatencyMs\": round(self.p50_latency_ms, 2),\n            \"p95LatencyMs\": round(self.p95_latency_ms, 2),\n            \"p99LatencyMs\": round(self.p99_latency_ms, 2),\n            \"degradationsTriggered\": self.degradations_triggered,\n            \"timestamp\": self.timestamp.isoformat(),\n        }\n\n\nclass LoadTestRunner:\n    \"\"\"\n    Load testing utility for voice pipeline.\n\n    Simulates concurrent voice sessions to test quality degradation\n    and system behavior under load.\n    \"\"\"\n\n    def __init__(self, quality_service: AdaptiveQualityService):\n        self.quality_service = quality_service\n        self._results: List[LoadTestResult] = []\n\n    async def run_concurrent_session_test(\n        self,\n        num_sessions: int,\n        duration_seconds: int = 60,\n        requests_per_second: int = 10,\n    ) -> LoadTestResult:\n        \"\"\"\n        Run concurrent session load test.\n\n        Args:\n            num_sessions: Number of concurrent sessions\n            duration_seconds: Test duration\n            requests_per_second: Target RPS per session\n\n        Returns:\n            LoadTestResult with metrics.\n        \"\"\"\n        import random\n        import statistics\n\n        latencies: List[float] = []\n        successful = 0\n        failed = 0\n        degradation_count = 0\n\n        start_time = time.monotonic()\n        session_ids = []\n\n        # Initialize sessions\n        for i in range(num_sessions):\n            session_id = f\"loadtest-{i}-{int(time.time())}\"\n            await self.quality_service.init_session(session_id)\n            session_ids.append(session_id)\n\n        # Track degradations\n        def on_degradation(state: QualityState, event: DegradationEvent):\n            nonlocal degradation_count\n            degradation_count += 1\n\n        self.quality_service.on_quality_change(on_degradation)\n\n        try:\n            while time.monotonic() - start_time < duration_seconds:\n                tasks = []\n\n                for session_id in session_ids:\n                    # Simulate request with random latency\n                    async def simulate_request(sid: str):\n                        nonlocal successful, failed, latencies\n\n                        try:\n                            # Simulate varying network conditions\n                            rtt = random.gauss(100, 50)\n                            rtt = max(10, min(800, rtt))\n\n                            metrics = NetworkMetrics(\n                                rtt_ms=rtt,\n                                bandwidth_kbps=random.gauss(5000, 2000),\n                                packet_loss_pct=random.expovariate(5) * 2,\n                                jitter_ms=random.gauss(10, 5),\n                            )\n\n                            await self.quality_service.update_network_metrics(sid, metrics)\n\n                            # Simulate processing latency\n                            processing_time = random.gauss(200, 50)\n                            await asyncio.sleep(processing_time / 1000)\n\n                            latencies.append(rtt + processing_time)\n                            successful += 1\n\n                        except Exception:\n                            failed += 1\n\n                    tasks.append(simulate_request(session_id))\n\n                await asyncio.gather(*tasks)\n                await asyncio.sleep(1.0 / requests_per_second)\n\n        finally:\n            # Cleanup sessions\n            for session_id in session_ids:\n                await self.quality_service.end_session(session_id)\n\n        # Calculate results\n        duration = time.monotonic() - start_time\n\n        if latencies:\n            sorted_latencies = sorted(latencies)\n            avg_latency = statistics.mean(latencies)\n            p50 = sorted_latencies[int(len(sorted_latencies) * 0.5)]\n            p95 = sorted_latencies[int(len(sorted_latencies) * 0.95)]\n            p99 = sorted_latencies[int(len(sorted_latencies) * 0.99)]\n        else:\n            avg_latency = p50 = p95 = p99 = 0\n\n        result = LoadTestResult(\n            test_name=f\"concurrent_sessions_{num_sessions}\",\n            concurrent_sessions=num_sessions,\n            duration_seconds=duration,\n            total_requests=successful + failed,\n            successful_requests=successful,\n            failed_requests=failed,\n            avg_latency_ms=avg_latency,\n            p50_latency_ms=p50,\n            p95_latency_ms=p95,\n            p99_latency_ms=p99,\n            degradations_triggered=degradation_count,\n        )\n\n        self._results.append(result)\n        return result\n\n    async def run_degradation_test(\n        self,\n        session_id: str,\n        simulate_poor_network: bool = True,\n    ) -> List[DegradationEvent]:\n        \"\"\"\n        Test quality degradation behavior.\n\n        Args:\n            session_id: Session to test\n            simulate_poor_network: Whether to simulate degrading network\n\n        Returns:\n            List of degradation events triggered.\n        \"\"\"\n        state = await self.quality_service.init_session(session_id, QualityLevel.HIGH)\n\n        if simulate_poor_network:\n            # Gradually degrade network conditions\n            conditions = [\n                (100, 5000, 0.1),  # Good\n                (200, 2000, 2),  # Fair\n                (400, 500, 8),  # Poor\n                (600, 100, 15),  # Critical\n            ]\n\n            for rtt, bw, loss in conditions:\n                for _ in range(5):  # Multiple samples per condition\n                    metrics = NetworkMetrics(\n                        rtt_ms=rtt,\n                        bandwidth_kbps=bw,\n                        packet_loss_pct=loss,\n                        jitter_ms=rtt * 0.1,\n                    )\n                    await self.quality_service.update_network_metrics(session_id, metrics)\n                    await asyncio.sleep(0.1)\n\n        state = self.quality_service.get_quality_state(session_id)\n        await self.quality_service.end_session(session_id)\n\n        return state.degradations if state else []\n\n\n# ==============================================================================\n# Singleton Instance\n# ==============================================================================\n\n_adaptive_quality_service: Optional[AdaptiveQualityService] = None\n\n\ndef get_adaptive_quality_service() -> AdaptiveQualityService:\n    \"\"\"Get or create adaptive quality service instance.\"\"\"\n    global _adaptive_quality_service\n    if _adaptive_quality_service is None:\n        _adaptive_quality_service = AdaptiveQualityService()\n    return _adaptive_quality_service\n\n\ndef get_load_test_runner() -> LoadTestRunner:\n    \"\"\"Get load test runner instance.\"\"\"\n    return LoadTestRunner(get_adaptive_quality_service())\n"
}
