{
  "path": "services/api-gateway/app/api/external_medical.py",
  "language": "python",
  "size": 24779,
  "last_modified": "2025-12-04T11:26:48.308Z",
  "lines": 721,
  "content": "\"\"\"\nExternal Medical Integrations API\n\nEndpoints for:\n- UpToDate clinical decision support\n- Enhanced PubMed literature search\n- Medical calculators\n\"\"\"\n\nfrom typing import Any, Dict, List, Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom pydantic import BaseModel, Field\n\nfrom ..services.medical_calculators import CalculatorResult, MedicalCalculators, Sex, list_calculators\nfrom ..services.pubmed_enhanced_service import ArticleType, DateRange, EnhancedPubMedService\nfrom ..services.uptodate_service import Specialty, UpToDateService\n\nrouter = APIRouter(prefix=\"/external-medical\", tags=[\"external-medical\"])\n\n# Singleton instances\n_uptodate_service: Optional[UpToDateService] = None\n_pubmed_service: Optional[EnhancedPubMedService] = None\n\n\ndef get_uptodate_service() -> UpToDateService:\n    \"\"\"Get or create UpToDate service instance.\"\"\"\n    global _uptodate_service\n    if _uptodate_service is None:\n        _uptodate_service = UpToDateService()\n    return _uptodate_service\n\n\ndef get_pubmed_service() -> EnhancedPubMedService:\n    \"\"\"Get or create PubMed service instance.\"\"\"\n    global _pubmed_service\n    if _pubmed_service is None:\n        _pubmed_service = EnhancedPubMedService()\n    return _pubmed_service\n\n\n# =============================================================================\n# REQUEST/RESPONSE MODELS\n# =============================================================================\n\n\n# UpToDate Models\nclass UpToDateSearchRequest(BaseModel):\n    \"\"\"Request for UpToDate topic search.\"\"\"\n\n    query: str = Field(..., min_length=1, description=\"Search query\")\n    max_results: int = Field(10, ge=1, le=50, description=\"Maximum results\")\n    specialty: Optional[str] = Field(None, description=\"Filter by specialty\")\n\n\nclass UpToDateTopicRequest(BaseModel):\n    \"\"\"Request for UpToDate topic content.\"\"\"\n\n    topic_id: str = Field(..., description=\"Topic ID\")\n    section: Optional[str] = Field(None, description=\"Specific section\")\n\n\nclass DrugInteractionRequest(BaseModel):\n    \"\"\"Request for drug interaction check.\"\"\"\n\n    drugs: List[str] = Field(..., min_items=2, description=\"List of drug names\")\n\n\n# PubMed Models\nclass PubMedSearchRequest(BaseModel):\n    \"\"\"Request for PubMed search.\"\"\"\n\n    query: str = Field(..., min_length=1, description=\"Search query\")\n    max_results: int = Field(20, ge=1, le=100, description=\"Maximum results\")\n    article_types: Optional[List[str]] = Field(None, description=\"Article type filters\")\n    date_from: Optional[str] = Field(None, description=\"Start date (YYYY/MM/DD)\")\n    date_to: Optional[str] = Field(None, description=\"End date (YYYY/MM/DD)\")\n    include_abstract: bool = Field(True, description=\"Include abstracts\")\n    sort_by: str = Field(\"relevance\", description=\"Sort order: relevance or date\")\n\n\nclass PubMedArticleRequest(BaseModel):\n    \"\"\"Request for PubMed article details.\"\"\"\n\n    pmid: str = Field(..., description=\"PubMed ID\")\n\n\nclass ClinicalTrialSearchRequest(BaseModel):\n    \"\"\"Request for clinical trial search.\"\"\"\n\n    condition: str = Field(..., description=\"Medical condition\")\n    intervention: Optional[str] = Field(None, description=\"Intervention filter\")\n    status: Optional[List[str]] = Field(None, description=\"Trial status filters\")\n    max_results: int = Field(20, ge=1, le=100, description=\"Maximum results\")\n\n\n# Calculator Models\nclass CalculatorInputRequest(BaseModel):\n    \"\"\"Generic calculator input request.\"\"\"\n\n    calculator_name: str = Field(..., description=\"Name of calculator to use\")\n    parameters: Dict[str, Any] = Field(..., description=\"Calculator parameters\")\n\n\nclass CHA2DS2VAScRequest(BaseModel):\n    \"\"\"CHA2DS2-VASc calculator request.\"\"\"\n\n    age: int = Field(..., ge=0, le=120, description=\"Patient age\")\n    sex: str = Field(..., description=\"male or female\")\n    chf: bool = Field(False, description=\"Congestive heart failure\")\n    hypertension: bool = Field(False, description=\"Hypertension\")\n    stroke_tia_history: bool = Field(False, description=\"Prior stroke/TIA\")\n    vascular_disease: bool = Field(False, description=\"Vascular disease\")\n    diabetes: bool = Field(False, description=\"Diabetes\")\n\n\nclass CKDEPIRequest(BaseModel):\n    \"\"\"CKD-EPI eGFR calculator request.\"\"\"\n\n    creatinine: float = Field(..., gt=0, description=\"Serum creatinine (mg/dL)\")\n    age: int = Field(..., ge=18, le=120, description=\"Patient age\")\n    sex: str = Field(..., description=\"male or female\")\n\n\nclass MELDNaRequest(BaseModel):\n    \"\"\"MELD-Na calculator request.\"\"\"\n\n    bilirubin: float = Field(..., gt=0, description=\"Total bilirubin (mg/dL)\")\n    inr: float = Field(..., gt=0, description=\"INR\")\n    creatinine: float = Field(..., gt=0, description=\"Serum creatinine (mg/dL)\")\n    sodium: float = Field(..., gt=0, description=\"Serum sodium (mEq/L)\")\n    dialysis_twice_past_week: bool = Field(False, description=\"Dialysis ≥2x/week\")\n\n\nclass SOFARequest(BaseModel):\n    \"\"\"SOFA score calculator request.\"\"\"\n\n    pao2_fio2: float = Field(..., gt=0, description=\"PaO2/FiO2 ratio\")\n    platelets: float = Field(..., gt=0, description=\"Platelets (10^3/μL)\")\n    bilirubin: float = Field(..., ge=0, description=\"Bilirubin (mg/dL)\")\n    cardiovascular: int = Field(..., ge=0, le=4, description=\"CV score 0-4\")\n    gcs: int = Field(..., ge=3, le=15, description=\"Glasgow Coma Scale\")\n    creatinine: float = Field(..., gt=0, description=\"Creatinine (mg/dL)\")\n    urine_output_24h: Optional[float] = Field(None, description=\"24h urine (mL)\")\n\n\nclass BMIRequest(BaseModel):\n    \"\"\"BMI calculator request.\"\"\"\n\n    weight: float = Field(..., gt=0, description=\"Weight (kg)\")\n    height: float = Field(..., gt=0, description=\"Height (cm)\")\n\n\nclass AnionGapRequest(BaseModel):\n    \"\"\"Anion gap calculator request.\"\"\"\n\n    sodium: float = Field(..., description=\"Sodium (mEq/L)\")\n    chloride: float = Field(..., description=\"Chloride (mEq/L)\")\n    bicarbonate: float = Field(..., description=\"Bicarbonate (mEq/L)\")\n    albumin: Optional[float] = Field(None, description=\"Albumin (g/dL)\")\n\n\n# =============================================================================\n# UPTODATE ENDPOINTS\n# =============================================================================\n\n\n@router.post(\"/uptodate/search\", response_model=List[dict])\nasync def search_uptodate(\n    request: UpToDateSearchRequest,\n    service: UpToDateService = Depends(get_uptodate_service),\n):\n    \"\"\"\n    Search UpToDate topics.\n\n    Returns list of relevant topics with summaries.\n    \"\"\"\n    try:\n        specialty = None\n        if request.specialty:\n            try:\n                specialty = Specialty(request.specialty.lower())\n            except ValueError:\n                pass\n\n        topics = await service.search_topics(query=request.query, max_results=request.max_results, specialty=specialty)\n\n        return [\n            {\n                \"topic_id\": t.topic_id,\n                \"title\": t.title,\n                \"url\": t.url,\n                \"summary\": t.summary,\n                \"specialty\": t.specialty,\n                \"last_updated\": t.last_updated.isoformat() if t.last_updated else None,\n                \"sections\": t.sections,\n            }\n            for t in topics\n        ]\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/uptodate/topic\", response_model=dict)\nasync def get_uptodate_topic(\n    request: UpToDateTopicRequest,\n    service: UpToDateService = Depends(get_uptodate_service),\n):\n    \"\"\"\n    Get full content of an UpToDate topic.\n\n    Returns detailed topic content including sections and references.\n    \"\"\"\n    try:\n        content = await service.get_topic_content(topic_id=request.topic_id, section=request.section)\n\n        if not content:\n            raise HTTPException(status_code=404, detail=\"Topic not found\")\n\n        return {\n            \"topic_id\": content.topic_id,\n            \"title\": content.title,\n            \"content_html\": content.content_html,\n            \"content_text\": content.content_text,\n            \"sections\": content.sections,\n            \"references\": content.references,\n            \"last_updated\": (content.last_updated.isoformat() if content.last_updated else None),\n            \"authors\": content.authors,\n            \"editors\": content.editors,\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/uptodate/drug-interactions\", response_model=dict)\nasync def check_drug_interactions(\n    request: DrugInteractionRequest,\n    service: UpToDateService = Depends(get_uptodate_service),\n):\n    \"\"\"\n    Check for drug-drug interactions.\n\n    Returns interaction severity and clinical recommendations.\n    \"\"\"\n    try:\n        result = await service.check_drug_interactions(request.drugs)\n\n        return {\n            \"drugs_checked\": result.drugs_checked,\n            \"interactions\": [\n                {\n                    \"drug1\": i.drug1,\n                    \"drug2\": i.drug2,\n                    \"severity\": i.severity.value,\n                    \"description\": i.description,\n                    \"mechanism\": i.mechanism,\n                    \"management\": i.management,\n                    \"references\": i.references,\n                }\n                for i in result.interactions\n            ],\n            \"has_severe_interactions\": result.has_severe_interactions,\n            \"summary\": result.summary,\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/uptodate/graphics/{topic_id}\", response_model=List[dict])\nasync def get_topic_graphics(topic_id: str, service: UpToDateService = Depends(get_uptodate_service)):\n    \"\"\"\n    Get medical graphics/images for a topic.\n\n    Returns list of graphics with URLs and descriptions.\n    \"\"\"\n    try:\n        graphics = await service.get_graphics(topic_id)\n\n        return [\n            {\n                \"graphic_id\": g.graphic_id,\n                \"title\": g.title,\n                \"url\": g.url,\n                \"thumbnail_url\": g.thumbnail_url,\n                \"caption\": g.caption,\n                \"graphic_type\": g.graphic_type.value,\n            }\n            for g in graphics\n        ]\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n# =============================================================================\n# PUBMED ENDPOINTS\n# =============================================================================\n\n\n@router.post(\"/pubmed/search\", response_model=dict)\nasync def search_pubmed(\n    request: PubMedSearchRequest,\n    service: EnhancedPubMedService = Depends(get_pubmed_service),\n):\n    \"\"\"\n    Search PubMed with enhanced features.\n\n    Returns articles with abstracts, MeSH terms, and metadata.\n    \"\"\"\n    try:\n        # Convert article types\n        article_types = None\n        if request.article_types:\n            article_types = []\n            for at in request.article_types:\n                try:\n                    article_types.append(ArticleType(at.lower().replace(\" \", \"_\")))\n                except ValueError:\n                    pass\n\n        # Convert date range\n        date_range = None\n        if request.date_from or request.date_to:\n            date_range = DateRange(start=request.date_from, end=request.date_to)\n\n        result = await service.search(\n            query=request.query,\n            max_results=request.max_results,\n            article_types=article_types,\n            date_range=date_range,\n            include_abstract=request.include_abstract,\n            sort_by=request.sort_by,\n        )\n\n        return {\n            \"total_count\": result.total_count,\n            \"query_translation\": result.query_translation,\n            \"articles\": [\n                {\n                    \"pmid\": a.pmid,\n                    \"title\": a.title,\n                    \"authors\": a.authors,\n                    \"journal\": a.journal,\n                    \"publication_date\": a.publication_date,\n                    \"abstract\": a.abstract,\n                    \"doi\": a.doi,\n                    \"pmc_id\": a.pmc_id,\n                    \"mesh_terms\": a.mesh_terms,\n                    \"keywords\": a.keywords,\n                    \"article_type\": a.article_type,\n                    \"citation_count\": a.citation_count,\n                }\n                for a in result.articles\n            ],\n            \"mesh_terms_used\": result.mesh_terms_used,\n            \"suggested_queries\": result.suggested_queries,\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/pubmed/article/{pmid}\", response_model=dict)\nasync def get_pubmed_article(pmid: str, service: EnhancedPubMedService = Depends(get_pubmed_service)):\n    \"\"\"\n    Get detailed information for a specific PubMed article.\n    \"\"\"\n    try:\n        result = await service.search(query=f\"{pmid}[pmid]\", max_results=1, include_abstract=True)\n\n        if not result.articles:\n            raise HTTPException(status_code=404, detail=\"Article not found\")\n\n        article = result.articles[0]\n        return {\n            \"pmid\": article.pmid,\n            \"title\": article.title,\n            \"authors\": article.authors,\n            \"journal\": article.journal,\n            \"publication_date\": article.publication_date,\n            \"abstract\": article.abstract,\n            \"doi\": article.doi,\n            \"pmc_id\": article.pmc_id,\n            \"mesh_terms\": article.mesh_terms,\n            \"keywords\": article.keywords,\n            \"article_type\": article.article_type,\n            \"citation_count\": article.citation_count,\n            \"affiliations\": article.affiliations,\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/pubmed/full-text/{pmid}\")\nasync def get_full_text(pmid: str, service: EnhancedPubMedService = Depends(get_pubmed_service)):\n    \"\"\"\n    Get full text of article from PMC if available.\n    \"\"\"\n    try:\n        text = await service.get_full_text(pmid)\n\n        if not text:\n            raise HTTPException(status_code=404, detail=\"Full text not available in PMC\")\n\n        return {\"pmid\": pmid, \"full_text\": text}\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/pubmed/similar/{pmid}\", response_model=List[dict])\nasync def find_similar_articles(\n    pmid: str,\n    max_results: int = 10,\n    service: EnhancedPubMedService = Depends(get_pubmed_service),\n):\n    \"\"\"\n    Find similar articles using PubMed's related articles feature.\n    \"\"\"\n    try:\n        articles = await service.find_similar_articles(pmid, max_results)\n\n        return [\n            {\n                \"pmid\": a.pmid,\n                \"title\": a.title,\n                \"authors\": a.authors[:3],\n                \"journal\": a.journal,\n                \"publication_date\": a.publication_date,\n                \"abstract\": a.abstract[:500] if a.abstract else None,\n            }\n            for a in articles\n        ]\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/pubmed/citations/{pmid}\", response_model=dict)\nasync def get_citation_network(pmid: str, service: EnhancedPubMedService = Depends(get_pubmed_service)):\n    \"\"\"\n    Get citation network for an article.\n\n    Returns articles that cite this paper and references.\n    \"\"\"\n    try:\n        network = await service.get_citation_network(pmid)\n\n        return {\n            \"pmid\": network.pmid,\n            \"cited_by\": [\n                {\n                    \"pmid\": a.pmid,\n                    \"title\": a.title,\n                    \"authors\": a.authors[:3],\n                    \"publication_date\": a.publication_date,\n                }\n                for a in network.cited_by\n            ],\n            \"references\": [\n                {\n                    \"pmid\": a.pmid,\n                    \"title\": a.title,\n                    \"authors\": a.authors[:3],\n                    \"publication_date\": a.publication_date,\n                }\n                for a in network.references\n            ],\n            \"cited_by_count\": network.cited_by_count,\n            \"references_count\": network.references_count,\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/pubmed/clinical-trials\", response_model=List[dict])\nasync def search_clinical_trials(\n    request: ClinicalTrialSearchRequest,\n    service: EnhancedPubMedService = Depends(get_pubmed_service),\n):\n    \"\"\"\n    Search for clinical trials related to a condition.\n    \"\"\"\n    try:\n        trials = await service.search_clinical_trials(\n            condition=request.condition,\n            intervention=request.intervention,\n            status=request.status,\n            max_results=request.max_results,\n        )\n\n        return [\n            {\n                \"nct_id\": t.nct_id,\n                \"title\": t.title,\n                \"status\": t.status,\n                \"phase\": t.phase,\n                \"conditions\": t.conditions,\n                \"interventions\": t.interventions,\n                \"enrollment\": t.enrollment,\n                \"start_date\": t.start_date,\n                \"completion_date\": t.completion_date,\n                \"locations\": t.locations[:5],\n                \"url\": t.url,\n            }\n            for t in trials\n        ]\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n# =============================================================================\n# MEDICAL CALCULATOR ENDPOINTS\n# =============================================================================\n\n\n@router.get(\"/calculators\", response_model=Dict[str, str])\nasync def list_available_calculators():\n    \"\"\"\n    List all available medical calculators.\n    \"\"\"\n    return list_calculators()\n\n\n@router.post(\"/calculators/cha2ds2-vasc\", response_model=dict)\nasync def calculate_cha2ds2_vasc(request: CHA2DS2VAScRequest):\n    \"\"\"\n    Calculate CHA2DS2-VASc score for stroke risk in atrial fibrillation.\n    \"\"\"\n    try:\n        sex = Sex.MALE if request.sex.lower() == \"male\" else Sex.FEMALE\n\n        result = MedicalCalculators.cha2ds2_vasc(\n            age=request.age,\n            sex=sex,\n            chf=request.chf,\n            hypertension=request.hypertension,\n            stroke_tia_history=request.stroke_tia_history,\n            vascular_disease=request.vascular_disease,\n            diabetes=request.diabetes,\n        )\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/ckd-epi\", response_model=dict)\nasync def calculate_ckd_epi(request: CKDEPIRequest):\n    \"\"\"\n    Calculate eGFR using CKD-EPI 2021 equation (race-free).\n    \"\"\"\n    try:\n        sex = Sex.MALE if request.sex.lower() == \"male\" else Sex.FEMALE\n\n        result = MedicalCalculators.ckd_epi_2021(creatinine=request.creatinine, age=request.age, sex=sex)\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/meld-na\", response_model=dict)\nasync def calculate_meld_na(request: MELDNaRequest):\n    \"\"\"\n    Calculate MELD-Na score for liver disease severity.\n    \"\"\"\n    try:\n        result = MedicalCalculators.meld_na(\n            bilirubin=request.bilirubin,\n            inr=request.inr,\n            creatinine=request.creatinine,\n            sodium=request.sodium,\n            dialysis_twice_past_week=request.dialysis_twice_past_week,\n        )\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/sofa\", response_model=dict)\nasync def calculate_sofa(request: SOFARequest):\n    \"\"\"\n    Calculate SOFA score for organ dysfunction.\n    \"\"\"\n    try:\n        result = MedicalCalculators.sofa(\n            pao2_fio2=request.pao2_fio2,\n            platelets=request.platelets,\n            bilirubin=request.bilirubin,\n            cardiovascular=request.cardiovascular,\n            gcs=request.gcs,\n            creatinine=request.creatinine,\n            urine_output_24h=request.urine_output_24h,\n        )\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/bmi\", response_model=dict)\nasync def calculate_bmi(request: BMIRequest):\n    \"\"\"\n    Calculate Body Mass Index.\n    \"\"\"\n    try:\n        result = MedicalCalculators.bmi(weight=request.weight, height=request.height)\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/anion-gap\", response_model=dict)\nasync def calculate_anion_gap(request: AnionGapRequest):\n    \"\"\"\n    Calculate serum anion gap with optional albumin correction.\n    \"\"\"\n    try:\n        result = MedicalCalculators.anion_gap(\n            sodium=request.sodium,\n            chloride=request.chloride,\n            bicarbonate=request.bicarbonate,\n            albumin=request.albumin,\n        )\n\n        return _format_calculator_result(result)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@router.post(\"/calculators/generic\", response_model=dict)\nasync def calculate_generic(request: CalculatorInputRequest):\n    \"\"\"\n    Generic calculator endpoint - specify calculator name and parameters.\n\n    Use /calculators endpoint to list available calculators.\n    \"\"\"\n    calculator_map = {\n        \"cha2ds2_vasc\": MedicalCalculators.cha2ds2_vasc,\n        \"heart_score\": MedicalCalculators.heart_score,\n        \"wells_dvt\": MedicalCalculators.wells_dvt,\n        \"wells_pe\": MedicalCalculators.wells_pe,\n        \"ckd_epi_2021\": MedicalCalculators.ckd_epi_2021,\n        \"cockcroft_gault\": MedicalCalculators.cockcroft_gault,\n        \"meld_na\": MedicalCalculators.meld_na,\n        \"child_pugh\": MedicalCalculators.child_pugh,\n        \"fib4\": MedicalCalculators.fib4,\n        \"sofa\": MedicalCalculators.sofa,\n        \"qsofa\": MedicalCalculators.qsofa,\n        \"curb65\": MedicalCalculators.curb65,\n        \"news2\": MedicalCalculators.news2,\n        \"bmi\": MedicalCalculators.bmi,\n        \"bsa_dubois\": MedicalCalculators.bsa_dubois,\n        \"anion_gap\": MedicalCalculators.anion_gap,\n        \"corrected_calcium\": MedicalCalculators.corrected_calcium,\n        \"aa_gradient\": MedicalCalculators.aa_gradient,\n        \"ideal_body_weight\": MedicalCalculators.ideal_body_weight,\n        \"adjusted_body_weight\": MedicalCalculators.adjusted_body_weight,\n        \"osmolality_serum\": MedicalCalculators.osmolality_serum,\n    }\n\n    if request.calculator_name not in calculator_map:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Unknown calculator: {request.calculator_name}. \" f\"Available: {list(calculator_map.keys())}\",\n        )\n\n    try:\n        # Convert sex parameter if present\n        params = request.parameters.copy()\n        if \"sex\" in params:\n            params[\"sex\"] = Sex.MALE if params[\"sex\"].lower() == \"male\" else Sex.FEMALE\n\n        calculator_func = calculator_map[request.calculator_name]\n        result = calculator_func(**params)\n\n        return _format_calculator_result(result)\n    except TypeError as e:\n        raise HTTPException(status_code=400, detail=f\"Invalid parameters: {str(e)}\")\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\ndef _format_calculator_result(result: CalculatorResult) -> dict:\n    \"\"\"Format calculator result for API response.\"\"\"\n    return {\n        \"calculator_name\": result.calculator_name,\n        \"score\": result.score,\n        \"unit\": result.unit,\n        \"risk_level\": result.risk_level.value if result.risk_level else None,\n        \"interpretation\": result.interpretation,\n        \"recommendations\": result.recommendations,\n        \"components\": result.components,\n        \"references\": result.references,\n        \"warnings\": result.warnings,\n    }\n\n\n# =============================================================================\n# HEALTH CHECK\n# =============================================================================\n\n\n@router.get(\"/health\")\nasync def health_check():\n    \"\"\"Check health of external medical integration services.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"services\": {\n            \"uptodate\": \"configured\",\n            \"pubmed\": \"available\",\n            \"calculators\": \"available\",\n        },\n        \"calculator_count\": len(list_calculators()),\n    }\n"
}
