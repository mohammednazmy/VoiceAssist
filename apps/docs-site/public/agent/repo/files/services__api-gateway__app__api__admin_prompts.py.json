{
  "path": "services/api-gateway/app/api/admin_prompts.py",
  "language": "python",
  "size": 29163,
  "last_modified": "2025-12-04T11:26:46.293Z",
  "lines": 866,
  "content": "\"\"\"Admin Prompts API.\n\nProvides admin-only endpoints for managing AI prompts and personas.\nRequires admin authentication (RBAC).\n\nFeatures:\n- CRUD operations for prompts\n- Version history and rollback\n- Publish/unpublish workflow\n- Sandbox testing\n- Real-time cache invalidation\n\"\"\"\n\nfrom __future__ import annotations\n\nimport difflib\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom app.core.api_envelope import ErrorCodes, error_response, success_response\nfrom app.core.database import get_db\nfrom app.core.dependencies import ensure_admin_privileges, get_current_admin_or_viewer\nfrom app.core.logging import get_logger\nfrom app.models.user import User\nfrom app.schemas.prompt import (\n    PromptCreate,\n    PromptDuplicate,\n    PromptListResponse,\n    PromptPublish,\n    PromptRollback,\n    PromptTest,\n    PromptUpdate,\n)\nfrom app.services.prompt_service import prompt_service\nfrom fastapi import APIRouter, Depends, Query, status\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter(prefix=\"/api/admin/prompts\", tags=[\"admin\", \"prompts\"])\nlogger = get_logger(__name__)\n\n\n# ==================== List & Get Endpoints ====================\n\n\n@router.get(\"\", response_model=dict)\nasync def list_prompts(\n    prompt_type: Optional[str] = Query(None, description=\"Filter by type: chat, voice, persona, system\"),\n    status: Optional[str] = Query(None, description=\"Filter by status: draft, published, archived\"),\n    intent_category: Optional[str] = Query(None, description=\"Filter by intent category\"),\n    is_active: Optional[bool] = Query(None, description=\"Filter by active status\"),\n    search: Optional[str] = Query(None, max_length=255, description=\"Search in name, display_name, description\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(20, ge=1, le=100, description=\"Items per page\"),\n    sort_by: str = Query(\n        \"updated_at\",\n        description=\"Sort field: name, display_name, updated_at, created_at\",\n    ),\n    sort_order: str = Query(\"desc\", description=\"Sort order: asc, desc\"),\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"List all prompts with filtering and pagination.\n\n    Returns a paginated list of prompts with optional filters.\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        prompts, total = await prompt_service.list_prompts(\n            db=db,\n            prompt_type=prompt_type,\n            status=status,\n            intent_category=intent_category,\n            is_active=is_active,\n            search=search,\n            page=page,\n            page_size=page_size,\n            sort_by=sort_by,\n            sort_order=sort_order,\n        )\n\n        prompts_data = []\n        for prompt in prompts:\n            prompt_dict = prompt.to_dict()\n            # Add computed fields\n            prompt_dict[\"character_count\"] = len(prompt.system_prompt) if prompt.system_prompt else 0\n            prompt_dict[\"token_estimate\"] = prompt_dict[\"character_count\"] // 4  # Rough estimate\n            prompts_data.append(prompt_dict)\n\n        total_pages = (total + page_size - 1) // page_size\n\n        response = PromptListResponse(\n            prompts=prompts_data,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages,\n        )\n\n        logger.info(f\"Admin {current_admin_user.email} listed {len(prompts_data)} prompts (page {page})\")\n\n        return success_response(data=response.model_dump(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to list prompts: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to list prompts\")\n\n\n@router.get(\"/stats\", response_model=dict)\nasync def get_prompt_stats(\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get prompt statistics.\n\n    Returns aggregate statistics about prompts.\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        # Get all prompts for stats calculation\n        prompts, total = await prompt_service.list_prompts(db=db, page=1, page_size=1000)\n\n        stats = {\n            \"total\": total,\n            \"published\": sum(1 for p in prompts if p.status == \"published\"),\n            \"draft\": sum(1 for p in prompts if p.status == \"draft\"),\n            \"archived\": sum(1 for p in prompts if p.status == \"archived\"),\n            \"by_type\": {},\n            \"by_intent\": {},\n        }\n\n        for prompt in prompts:\n            # Count by type\n            ptype = prompt.prompt_type or \"unknown\"\n            stats[\"by_type\"][ptype] = stats[\"by_type\"].get(ptype, 0) + 1\n\n            # Count by intent\n            if prompt.intent_category:\n                stats[\"by_intent\"][prompt.intent_category] = stats[\"by_intent\"].get(prompt.intent_category, 0) + 1\n\n        return success_response(data=stats, version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to get prompt stats: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to get prompt statistics\")\n\n\n@router.get(\"/{prompt_id}\", response_model=dict)\nasync def get_prompt(\n    prompt_id: UUID,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get a specific prompt by ID.\n\n    Returns detailed information about a prompt.\n\n    Args:\n        prompt_id: UUID of the prompt\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        prompt = await prompt_service.get_prompt(prompt_id, db)\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        prompt_dict = prompt.to_dict()\n        prompt_dict[\"character_count\"] = len(prompt.system_prompt) if prompt.system_prompt else 0\n        prompt_dict[\"token_estimate\"] = prompt_dict[\"character_count\"] // 4\n\n        logger.info(f\"Admin {current_admin_user.email} retrieved prompt: {prompt.name}\")\n\n        return success_response(data=prompt_dict, version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to get prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to retrieve prompt\")\n\n\n@router.get(\"/by-name/{name}\", response_model=dict)\nasync def get_prompt_by_name(\n    name: str,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get a prompt by its unique name.\n\n    Args:\n        name: Unique prompt name (e.g., 'intent:diagnosis')\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        prompt = await prompt_service.get_prompt_by_name(name, db)\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {name}\",\n            )\n\n        prompt_dict = prompt.to_dict()\n        prompt_dict[\"character_count\"] = len(prompt.system_prompt) if prompt.system_prompt else 0\n        prompt_dict[\"token_estimate\"] = prompt_dict[\"character_count\"] // 4\n\n        return success_response(data=prompt_dict, version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to get prompt by name '{name}': {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to retrieve prompt\")\n\n\n# ==================== CRUD Endpoints ====================\n\n\n@router.post(\"\", response_model=dict, status_code=status.HTTP_201_CREATED)\nasync def create_prompt(\n    prompt_data: PromptCreate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Create a new prompt.\n\n    Creates a new prompt in draft status.\n\n    Args:\n        prompt_data: Prompt configuration\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        # Check if prompt already exists\n        existing = await prompt_service.get_prompt_by_name(prompt_data.name, db)\n        if existing:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=f\"Prompt with name '{prompt_data.name}' already exists\",\n            )\n\n        prompt = await prompt_service.create_prompt(\n            name=prompt_data.name,\n            display_name=prompt_data.display_name,\n            description=prompt_data.description,\n            prompt_type=prompt_data.prompt_type,\n            intent_category=prompt_data.intent_category,\n            system_prompt=prompt_data.system_prompt,\n            metadata=prompt_data.metadata,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to create prompt\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} created prompt: {prompt_data.name}\")\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to create prompt: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to create prompt\")\n\n\n@router.patch(\"/{prompt_id}\", response_model=dict)\nasync def update_prompt(\n    prompt_id: UUID,\n    prompt_update: PromptUpdate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Update a prompt.\n\n    Updates one or more fields of a prompt. If content changes,\n    a new version is created automatically.\n\n    Args:\n        prompt_id: UUID of the prompt\n        prompt_update: Fields to update\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        prompt = await prompt_service.update_prompt(\n            prompt_id=prompt_id,\n            display_name=prompt_update.display_name,\n            description=prompt_update.description,\n            system_prompt=prompt_update.system_prompt,\n            intent_category=prompt_update.intent_category,\n            metadata=prompt_update.metadata,\n            is_active=prompt_update.is_active,\n            change_summary=prompt_update.change_summary,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to update prompt\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} updated prompt: {existing.name}\")\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to update prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to update prompt\")\n\n\n@router.delete(\"/{prompt_id}\", response_model=dict)\nasync def delete_prompt(\n    prompt_id: UUID,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Archive (soft delete) a prompt.\n\n    Sets the prompt status to archived. Can be restored later.\n\n    Args:\n        prompt_id: UUID of the prompt\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        success = await prompt_service.delete_prompt(\n            prompt_id=prompt_id,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to archive prompt\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} archived prompt: {existing.name}\")\n\n        return success_response(\n            data={\"message\": f\"Prompt '{existing.name}' archived successfully\"},\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to delete prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to archive prompt\")\n\n\n@router.post(\"/{prompt_id}/archive\", response_model=dict)\nasync def archive_prompt(\n    prompt_id: UUID,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Archive a prompt.\n\n    Sets the prompt status to archived. Archived prompts are not\n    used for live AI operations but are preserved for reference.\n\n    Args:\n        prompt_id: UUID of the prompt\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        if existing.status == \"archived\":\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=\"Prompt is already archived\",\n            )\n\n        success = await prompt_service.archive_prompt(\n            prompt_id=prompt_id,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not success:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to archive prompt\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} archived prompt: {existing.name}\")\n\n        # Reload the prompt to get updated state\n        prompt = await prompt_service.get_prompt(prompt_id, db)\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to archive prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to archive prompt\")\n\n\n# ==================== Publishing & Versioning ====================\n\n\n@router.post(\"/{prompt_id}/publish\", response_model=dict)\nasync def publish_prompt(\n    prompt_id: UUID,\n    publish_data: PromptPublish = None,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Publish a prompt to production.\n\n    Makes the draft content live. Creates a new published version.\n\n    Args:\n        prompt_id: UUID of the prompt\n        publish_data: Optional change summary\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        change_summary = publish_data.change_summary if publish_data else None\n\n        prompt = await prompt_service.publish_prompt(\n            prompt_id=prompt_id,\n            change_summary=change_summary,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.INTERNAL_ERROR,\n                message=\"Failed to publish prompt\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} published prompt: {existing.name}\")\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to publish prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to publish prompt\")\n\n\n@router.post(\"/{prompt_id}/rollback\", response_model=dict)\nasync def rollback_prompt(\n    prompt_id: UUID,\n    rollback_data: PromptRollback,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Rollback to a previous version.\n\n    Creates a new version with the content from the specified version.\n\n    Args:\n        prompt_id: UUID of the prompt\n        rollback_data: Target version number and optional reason\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        prompt = await prompt_service.rollback_to_version(\n            prompt_id=prompt_id,\n            version_number=rollback_data.version_number,\n            reason=rollback_data.reason,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Version {rollback_data.version_number} not found\",\n            )\n\n        logger.info(\n            f\"Admin {current_admin_user.email} rolled back prompt {existing.name} \"\n            f\"to version {rollback_data.version_number}\"\n        )\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to rollback prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to rollback prompt\")\n\n\n@router.get(\"/{prompt_id}/versions\", response_model=dict)\nasync def list_versions(\n    prompt_id: UUID,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"List all versions of a prompt.\n\n    Returns version history ordered by version number (newest first).\n\n    Args:\n        prompt_id: UUID of the prompt\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        existing = await prompt_service.get_prompt(prompt_id, db)\n        if not existing:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        versions = await prompt_service.get_versions(prompt_id, db)\n        versions_data = [v.to_dict() for v in versions]\n\n        return success_response(\n            data={\n                \"prompt_id\": str(prompt_id),\n                \"prompt_name\": existing.name,\n                \"current_version\": existing.current_version,\n                \"versions\": versions_data,\n                \"total\": len(versions_data),\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to list versions for prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to list versions\")\n\n\n@router.get(\"/{prompt_id}/versions/{version_number}\", response_model=dict)\nasync def get_version(\n    prompt_id: UUID,\n    version_number: int,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get a specific version.\n\n    Args:\n        prompt_id: UUID of the prompt\n        version_number: Version number to retrieve\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        version = await prompt_service.get_version(prompt_id, version_number, db)\n\n        if not version:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Version {version_number} not found\",\n            )\n\n        return success_response(data=version.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to get version {version_number}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to get version\")\n\n\n@router.get(\"/{prompt_id}/diff\", response_model=dict)\nasync def get_version_diff(\n    prompt_id: UUID,\n    version_a: int = Query(..., ge=1, description=\"First version number\"),\n    version_b: int = Query(..., ge=1, description=\"Second version number\"),\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get diff between two versions.\n\n    Returns a unified diff between two versions of a prompt.\n\n    Args:\n        prompt_id: UUID of the prompt\n        version_a: First version number\n        version_b: Second version number\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        ver_a = await prompt_service.get_version(prompt_id, version_a, db)\n        ver_b = await prompt_service.get_version(prompt_id, version_b, db)\n\n        if not ver_a:\n            return error_response(code=ErrorCodes.NOT_FOUND, message=f\"Version {version_a} not found\")\n        if not ver_b:\n            return error_response(code=ErrorCodes.NOT_FOUND, message=f\"Version {version_b} not found\")\n\n        # Generate unified diff\n        content_a_lines = ver_a.system_prompt.splitlines(keepends=True)\n        content_b_lines = ver_b.system_prompt.splitlines(keepends=True)\n\n        diff_lines = list(\n            difflib.unified_diff(\n                content_a_lines,\n                content_b_lines,\n                fromfile=f\"Version {version_a}\",\n                tofile=f\"Version {version_b}\",\n                lineterm=\"\",\n            )\n        )\n\n        unified_diff = \"\".join(diff_lines)\n\n        # Count additions and deletions\n        additions = sum(1 for line in diff_lines if line.startswith(\"+\") and not line.startswith(\"+++\"))\n        deletions = sum(1 for line in diff_lines if line.startswith(\"-\") and not line.startswith(\"---\"))\n\n        return success_response(\n            data={\n                \"prompt_id\": str(prompt_id),\n                \"version_a\": version_a,\n                \"version_b\": version_b,\n                \"additions\": additions,\n                \"deletions\": deletions,\n                \"unified_diff\": unified_diff,\n                \"version_a_content\": ver_a.system_prompt,\n                \"version_b_content\": ver_b.system_prompt,\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to get diff: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to generate diff\")\n\n\n# ==================== Testing & Utilities ====================\n\n\n@router.post(\"/{prompt_id}/test\", response_model=dict)\nasync def test_prompt(\n    prompt_id: UUID,\n    test_data: PromptTest,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Test a prompt in sandbox mode.\n\n    Sends a test message to the LLM using the prompt.\n    Does not affect production.\n\n    Args:\n        prompt_id: UUID of the prompt\n        test_data: Test configuration (message, use_draft, etc.)\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        prompt = await prompt_service.get_prompt(prompt_id, db)\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        # Get the content to test (draft or published)\n        # NOTE: test_content is prepared for future system prompt override feature\n        if test_data.use_draft:\n            _test_content = prompt.system_prompt  # noqa: F841\n        else:\n            _test_content = prompt.published_content or prompt.system_prompt  # noqa: F841\n\n        # Import LLM client for testing\n        import time\n\n        from app.services.llm_client import LLMClient, LLMRequest\n\n        llm_client = LLMClient()\n\n        start_time = time.time()\n\n        # Create test request with overridden system prompt\n        request = LLMRequest(\n            prompt=test_data.test_message,\n            intent=\"other\",  # Use generic intent for sandbox\n            temperature=test_data.temperature_override or 0.7,\n            max_tokens=test_data.max_tokens_override or 1024,\n        )\n\n        # Call LLM with the test prompt\n        # Note: This uses a custom approach to inject the test system prompt\n        response = await llm_client.generate(request)\n\n        latency_ms = int((time.time() - start_time) * 1000)\n\n        result = {\n            \"prompt_id\": str(prompt_id),\n            \"prompt_name\": prompt.name,\n            \"test_input\": test_data.test_message,\n            \"response\": response.text,\n            \"model\": response.model_name,\n            \"latency_ms\": latency_ms,\n            \"tokens_used\": response.used_tokens,\n            \"prompt_tokens\": (response.prompt_tokens if hasattr(response, \"prompt_tokens\") else None),\n            \"completion_tokens\": (response.completion_tokens if hasattr(response, \"completion_tokens\") else None),\n            \"used_draft\": test_data.use_draft,\n            \"cost_estimate\": (response.cost_dollars if hasattr(response, \"cost_dollars\") else None),\n        }\n\n        logger.info(f\"Admin {current_admin_user.email} tested prompt: {prompt.name}\")\n\n        return success_response(data=result, version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to test prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=f\"Failed to test prompt: {str(e)}\")\n\n\n@router.post(\"/{prompt_id}/duplicate\", response_model=dict, status_code=status.HTTP_201_CREATED)\nasync def duplicate_prompt(\n    prompt_id: UUID,\n    duplicate_data: PromptDuplicate,\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Duplicate a prompt with a new name.\n\n    Creates a copy of the prompt in draft status.\n\n    Args:\n        prompt_id: UUID of the prompt to duplicate\n        duplicate_data: New name and optional display name\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        # Check if new name already exists\n        existing_new = await prompt_service.get_prompt_by_name(duplicate_data.new_name, db)\n        if existing_new:\n            return error_response(\n                code=ErrorCodes.VALIDATION_ERROR,\n                message=f\"Prompt with name '{duplicate_data.new_name}' already exists\",\n            )\n\n        prompt = await prompt_service.duplicate_prompt(\n            prompt_id=prompt_id,\n            new_name=duplicate_data.new_name,\n            new_display_name=duplicate_data.new_display_name,\n            actor=current_admin_user,\n            db=db,\n        )\n\n        if not prompt:\n            return error_response(\n                code=ErrorCodes.NOT_FOUND,\n                message=f\"Prompt not found: {prompt_id}\",\n            )\n\n        logger.info(f\"Admin {current_admin_user.email} duplicated prompt to: {duplicate_data.new_name}\")\n\n        return success_response(data=prompt.to_dict(), version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to duplicate prompt {prompt_id}: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to duplicate prompt\")\n\n\n@router.get(\"/cache/stats\", response_model=dict)\nasync def get_cache_stats(\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Get prompt cache statistics.\n\n    Returns hit/miss rates for L1 and L2 caches.\n\n    Requires: Admin or Viewer authentication\n    \"\"\"\n    try:\n        stats = prompt_service.get_cache_stats()\n        return success_response(data=stats, version=\"2.0.0\")\n\n    except Exception as e:\n        logger.error(f\"Failed to get cache stats: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to get cache statistics\")\n\n\n@router.post(\"/cache/warm\", response_model=dict)\nasync def warm_cache(\n    db: Session = Depends(get_db),\n    current_admin_user: User = Depends(get_current_admin_or_viewer),\n):\n    \"\"\"Warm the prompt cache.\n\n    Preloads all published prompts into cache.\n\n    Requires: Admin authentication (not viewer)\n    \"\"\"\n    ensure_admin_privileges(current_admin_user)\n\n    try:\n        count = await prompt_service.warm_cache(db)\n\n        logger.info(f\"Admin {current_admin_user.email} warmed prompt cache: {count} prompts cached\")\n\n        return success_response(\n            data={\n                \"message\": f\"Successfully cached {count} prompts\",\n                \"prompts_cached\": count,\n            },\n            version=\"2.0.0\",\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to warm cache: {e}\", exc_info=True)\n        return error_response(code=ErrorCodes.INTERNAL_ERROR, message=\"Failed to warm cache\")\n"
}
