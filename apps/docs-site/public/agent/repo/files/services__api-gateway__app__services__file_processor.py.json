{
  "path": "services/api-gateway/app/services/file_processor.py",
  "language": "python",
  "size": 9017,
  "last_modified": "2025-12-04T11:26:56.704Z",
  "lines": 274,
  "content": "\"\"\"\nFile processing service for OCR, text extraction, and document parsing\n\"\"\"\n\nimport mimetypes\nfrom io import BytesIO\nfrom typing import Optional, Tuple\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass FileProcessor:\n    \"\"\"Service for processing uploaded files and extracting text content\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize file processor with optional OCR support\"\"\"\n        self.ocr_available = False\n        try:\n            import pytesseract  # noqa: F401\n\n            self.ocr_available = True\n            logger.info(\"OCR support enabled (pytesseract available)\")\n        except ImportError:\n            logger.warning(\"OCR support disabled (pytesseract not installed)\")\n\n    async def extract_text(\n        self, file_content: bytes, filename: str, mime_type: Optional[str] = None\n    ) -> Tuple[str, dict]:\n        \"\"\"\n        Extract text from a file.\n\n        Args:\n            file_content: File content as bytes\n            filename: Original filename\n            mime_type: MIME type of file\n\n        Returns:\n            Tuple of (extracted_text, metadata_dict)\n        \"\"\"\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(filename)\n\n        metadata = {\n            \"filename\": filename,\n            \"mime_type\": mime_type,\n            \"size_bytes\": len(file_content),\n        }\n\n        try:\n            if mime_type == \"application/pdf\":\n                text, pdf_metadata = await self._extract_from_pdf(file_content)\n                metadata.update(pdf_metadata)\n                return text, metadata\n\n            elif mime_type in [\n                \"image/png\",\n                \"image/jpeg\",\n                \"image/jpg\",\n                \"image/tiff\",\n                \"image/bmp\",\n            ]:\n                text, img_metadata = await self._extract_from_image(file_content)\n                metadata.update(img_metadata)\n                return text, metadata\n\n            elif mime_type == \"text/plain\":\n                text = file_content.decode(\"utf-8\", errors=\"ignore\")\n                return text, metadata\n\n            elif mime_type == \"text/markdown\":\n                text = file_content.decode(\"utf-8\", errors=\"ignore\")\n                metadata[\"format\"] = \"markdown\"\n                return text, metadata\n\n            elif mime_type in [\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/msword\",\n            ]:\n                text, doc_metadata = await self._extract_from_docx(file_content)\n                metadata.update(doc_metadata)\n                return text, metadata\n\n            else:\n                logger.warning(f\"Unsupported file type: {mime_type}\")\n                return \"\", metadata\n\n        except Exception as e:\n            logger.error(f\"Error extracting text from {filename}: {e}\", exc_info=True)\n            metadata[\"error\"] = str(e)\n            return \"\", metadata\n\n    async def _extract_from_pdf(self, file_content: bytes) -> Tuple[str, dict]:\n        \"\"\"Extract text from PDF file\"\"\"\n        try:\n            from PyPDF2 import PdfReader\n        except ImportError:\n            logger.error(\"PyPDF2 not installed. Install with: pip install PyPDF2\")\n            return \"\", {\"error\": \"PDF support not available\"}\n\n        try:\n            pdf_file = BytesIO(file_content)\n            reader = PdfReader(pdf_file)\n\n            metadata = {\n                \"page_count\": len(reader.pages),\n                \"format\": \"pdf\",\n            }\n\n            # Extract PDF metadata\n            if reader.metadata:\n                metadata[\"title\"] = reader.metadata.get(\"/Title\", \"\")\n                metadata[\"author\"] = reader.metadata.get(\"/Author\", \"\")\n                metadata[\"subject\"] = reader.metadata.get(\"/Subject\", \"\")\n\n            # Extract text from all pages\n            text_parts = []\n            for page_num, page in enumerate(reader.pages, 1):\n                try:\n                    page_text = page.extract_text()\n                    if page_text:\n                        text_parts.append(f\"--- Page {page_num} ---\\n{page_text}\")\n                except Exception as e:\n                    logger.warning(f\"Error extracting page {page_num}: {e}\")\n\n            text = \"\\n\\n\".join(text_parts)\n            return text, metadata\n\n        except Exception as e:\n            logger.error(f\"Error processing PDF: {e}\", exc_info=True)\n            return \"\", {\"error\": str(e)}\n\n    async def _extract_from_image(self, file_content: bytes) -> Tuple[str, dict]:\n        \"\"\"Extract text from image using OCR\"\"\"\n        if not self.ocr_available:\n            return \"\", {\"error\": \"OCR not available (pytesseract not installed)\"}\n\n        try:\n            import pytesseract\n            from PIL import Image\n        except ImportError:\n            logger.error(\"Image processing libraries not installed. \" \"Install with: pip install Pillow pytesseract\")\n            return \"\", {\"error\": \"Image processing not available\"}\n\n        try:\n            image = Image.open(BytesIO(file_content))\n\n            metadata = {\n                \"format\": \"image\",\n                \"width\": image.width,\n                \"height\": image.height,\n                \"mode\": image.mode,\n            }\n\n            # Perform OCR\n            text = pytesseract.image_to_string(image)\n            metadata[\"ocr_performed\"] = True\n\n            return text, metadata\n\n        except Exception as e:\n            logger.error(f\"Error processing image: {e}\", exc_info=True)\n            return \"\", {\"error\": str(e)}\n\n    async def _extract_from_docx(self, file_content: bytes) -> Tuple[str, dict]:\n        \"\"\"Extract text from DOCX file\"\"\"\n        try:\n            from docx import Document\n        except ImportError:\n            logger.error(\"python-docx not installed. Install with: pip install python-docx\")\n            return \"\", {\"error\": \"DOCX support not available\"}\n\n        try:\n            doc = Document(BytesIO(file_content))\n\n            metadata = {\n                \"format\": \"docx\",\n                \"paragraph_count\": len(doc.paragraphs),\n            }\n\n            # Extract document properties\n            if doc.core_properties.title:\n                metadata[\"title\"] = doc.core_properties.title\n            if doc.core_properties.author:\n                metadata[\"author\"] = doc.core_properties.author\n\n            # Extract text from paragraphs\n            text_parts = []\n            for para in doc.paragraphs:\n                if para.text.strip():\n                    text_parts.append(para.text)\n\n            # Extract text from tables\n            for table in doc.tables:\n                for row in table.rows:\n                    row_text = [cell.text for cell in row.cells]\n                    text_parts.append(\" | \".join(row_text))\n\n            text = \"\\n\\n\".join(text_parts)\n            return text, metadata\n\n        except Exception as e:\n            logger.error(f\"Error processing DOCX: {e}\", exc_info=True)\n            return \"\", {\"error\": str(e)}\n\n    def get_supported_types(self) -> list:\n        \"\"\"Get list of supported MIME types\"\"\"\n        supported = [\n            \"application/pdf\",\n            \"text/plain\",\n            \"text/markdown\",\n            \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"application/msword\",\n        ]\n\n        if self.ocr_available:\n            supported.extend(\n                [\n                    \"image/png\",\n                    \"image/jpeg\",\n                    \"image/jpg\",\n                    \"image/tiff\",\n                    \"image/bmp\",\n                ]\n            )\n\n        return supported\n\n    async def validate_file(\n        self, file_content: bytes, filename: str, max_size_mb: int = 10\n    ) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        Validate file before processing.\n\n        Args:\n            file_content: File content as bytes\n            filename: Original filename\n            max_size_mb: Maximum file size in MB\n\n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        # Check file size\n        size_mb = len(file_content) / (1024 * 1024)\n        if size_mb > max_size_mb:\n            return False, f\"File too large ({size_mb:.1f}MB). Maximum: {max_size_mb}MB\"\n\n        # Check file type\n        mime_type, _ = mimetypes.guess_type(filename)\n        if mime_type not in self.get_supported_types():\n            return (\n                False,\n                f\"Unsupported file type: {mime_type}. \" f\"Supported types: {', '.join(self.get_supported_types())}\",\n            )\n\n        # Check if file is empty\n        if len(file_content) == 0:\n            return False, \"File is empty\"\n\n        return True, None\n\n\n# Singleton instance\n_file_processor = None\n\n\ndef get_file_processor() -> FileProcessor:\n    \"\"\"Get file processor instance\"\"\"\n    global _file_processor\n    if _file_processor is None:\n        _file_processor = FileProcessor()\n    return _file_processor\n"
}
