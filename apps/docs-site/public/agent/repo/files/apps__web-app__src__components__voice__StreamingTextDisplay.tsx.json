{
  "path": "apps/web-app/src/components/voice/StreamingTextDisplay.tsx",
  "language": "typescript",
  "size": 10258,
  "last_modified": "2025-12-04T21:46:28.146Z",
  "lines": 401,
  "content": "/**\n * StreamingTextDisplay - Phase 3 Voice Mode v4.1\n *\n * Displays streaming text with typewriter effect and RTL support.\n * Optimized for voice assistant responses with natural text flow.\n *\n * Features:\n * - Smooth character-by-character or chunk-based streaming\n * - RTL language auto-detection (Arabic, Hebrew, Farsi, Urdu)\n * - Bidirectional text handling (mixed LTR/RTL content)\n * - Visual cursor indicator\n * - Smooth scroll-to-bottom behavior\n * - Code block and markdown support\n * - Accessible with aria-live regions\n *\n * Reference: docs/voice/phase3-implementation-plan.md\n */\n\nimport { useState, useEffect, useRef, useMemo, useCallback } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { useVoiceSettingsStore } from \"../../stores/voiceSettingsStore\";\n\n// RTL language detection patterns\nconst RTL_LANGUAGES = [\"ar\", \"he\", \"fa\", \"ur\", \"yi\", \"ps\", \"sd\"];\nconst RTL_CHAR_REGEX = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/;\n\ninterface StreamingTextDisplayProps {\n  /** Text content to display (can be partial/streaming) */\n  text: string;\n  /** Whether text is still streaming */\n  isStreaming?: boolean;\n  /** Language code for RTL detection override */\n  languageCode?: string;\n  /** Speed of typewriter effect (chars per second, 0 = instant) */\n  typewriterSpeed?: number;\n  /** Whether to show cursor while streaming */\n  showCursor?: boolean;\n  /** Callback when streaming completes */\n  onStreamComplete?: () => void;\n  /** Custom class name */\n  className?: string;\n  /** Test ID for testing */\n  testId?: string;\n}\n\ntype TextDirection = \"ltr\" | \"rtl\" | \"auto\";\n\ninterface TextSegment {\n  text: string;\n  direction: TextDirection;\n  isCode: boolean;\n}\n\n/**\n * Detect text direction based on content\n */\nfunction detectTextDirection(text: string): TextDirection {\n  if (!text) return \"ltr\";\n\n  // Count RTL and LTR characters\n  let rtlCount = 0;\n  let ltrCount = 0;\n\n  for (const char of text) {\n    if (RTL_CHAR_REGEX.test(char)) {\n      rtlCount++;\n    } else if (/[a-zA-Z]/.test(char)) {\n      ltrCount++;\n    }\n  }\n\n  // If more than 30% RTL, use RTL direction\n  const total = rtlCount + ltrCount;\n  if (total === 0) return \"ltr\";\n\n  return rtlCount / total > 0.3 ? \"rtl\" : \"ltr\";\n}\n\n/**\n * Split text into segments with direction hints for bidirectional support\n */\nfunction segmentText(text: string): TextSegment[] {\n  const segments: TextSegment[] = [];\n  const lines = text.split(\"\\n\");\n\n  let inCodeBlock = false;\n  let codeBuffer = \"\";\n\n  for (const line of lines) {\n    // Check for code block markers\n    if (line.trim().startsWith(\"```\")) {\n      if (inCodeBlock) {\n        // End code block\n        segments.push({\n          text: codeBuffer,\n          direction: \"ltr\", // Code is always LTR\n          isCode: true,\n        });\n        codeBuffer = \"\";\n        inCodeBlock = false;\n      } else {\n        // Start code block\n        inCodeBlock = true;\n      }\n      continue;\n    }\n\n    if (inCodeBlock) {\n      codeBuffer += (codeBuffer ? \"\\n\" : \"\") + line;\n    } else {\n      // Regular text - detect direction per line\n      const direction = detectTextDirection(line);\n      segments.push({\n        text: line,\n        direction,\n        isCode: false,\n      });\n    }\n  }\n\n  // Handle unclosed code block\n  if (codeBuffer) {\n    segments.push({\n      text: codeBuffer,\n      direction: \"ltr\",\n      isCode: true,\n    });\n  }\n\n  return segments;\n}\n\nexport function StreamingTextDisplay({\n  text,\n  isStreaming = false,\n  languageCode,\n  typewriterSpeed = 60, // 60 chars/second\n  showCursor = true,\n  onStreamComplete,\n  className,\n  testId = \"streaming-text-display\",\n}: StreamingTextDisplayProps) {\n  const [displayedLength, setDisplayedLength] = useState(0);\n  const [hasCompletedOnce, setHasCompletedOnce] = useState(false);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const previousTextRef = useRef(text);\n\n  // Get RTL settings from store\n  const { rtlEnabled, rtlAutoDetect } = useVoiceSettingsStore();\n\n  // Determine overall direction\n  const overallDirection = useMemo((): TextDirection => {\n    // Manual RTL override\n    if (rtlEnabled) return \"rtl\";\n\n    // Language code override\n    if (languageCode && RTL_LANGUAGES.includes(languageCode.slice(0, 2).toLowerCase())) {\n      return \"rtl\";\n    }\n\n    // Auto-detect from content\n    if (rtlAutoDetect) {\n      return detectTextDirection(text);\n    }\n\n    return \"ltr\";\n  }, [text, rtlEnabled, rtlAutoDetect, languageCode]);\n\n  // Segment text for bidirectional rendering\n  const segments = useMemo(() => segmentText(text), [text]);\n\n  // Displayed text with typewriter effect\n  const displayedText = useMemo(() => {\n    if (typewriterSpeed === 0 || !isStreaming) {\n      return text;\n    }\n    return text.slice(0, displayedLength);\n  }, [text, displayedLength, typewriterSpeed, isStreaming]);\n\n  // Typewriter effect\n  useEffect(() => {\n    if (typewriterSpeed === 0 || !isStreaming) {\n      setDisplayedLength(text.length);\n      return;\n    }\n\n    // If text grew, animate the new characters\n    if (text.length > previousTextRef.current.length) {\n      // Start from where we left off\n      const interval = setInterval(() => {\n        setDisplayedLength((prev) => {\n          if (prev >= text.length) {\n            clearInterval(interval);\n            return text.length;\n          }\n          return prev + 1;\n        });\n      }, 1000 / typewriterSpeed);\n\n      return () => clearInterval(interval);\n    } else if (text.length < previousTextRef.current.length) {\n      // Text was reset/cleared\n      setDisplayedLength(0);\n    }\n\n    previousTextRef.current = text;\n  }, [text, typewriterSpeed, isStreaming]);\n\n  // Scroll to bottom when content updates\n  useEffect(() => {\n    if (containerRef.current && isStreaming) {\n      containerRef.current.scrollTop = containerRef.current.scrollHeight;\n    }\n  }, [displayedText, isStreaming]);\n\n  // Notify when streaming completes\n  useEffect(() => {\n    if (!isStreaming && displayedLength >= text.length && !hasCompletedOnce && text.length > 0) {\n      setHasCompletedOnce(true);\n      onStreamComplete?.();\n    }\n  }, [isStreaming, displayedLength, text.length, hasCompletedOnce, onStreamComplete]);\n\n  // Reset completion flag when new text starts\n  useEffect(() => {\n    if (isStreaming) {\n      setHasCompletedOnce(false);\n    }\n  }, [isStreaming]);\n\n  // Render a single segment\n  const renderSegment = useCallback(\n    (segment: TextSegment, index: number) => {\n      if (segment.isCode) {\n        return (\n          <pre\n            key={index}\n            className={cn(\n              \"my-2 p-3 bg-neutral-100 dark:bg-neutral-800 rounded-lg\",\n              \"overflow-x-auto font-mono text-sm\",\n              \"text-neutral-800 dark:text-neutral-200\"\n            )}\n            dir=\"ltr\"\n          >\n            <code>{segment.text}</code>\n          </pre>\n        );\n      }\n\n      return (\n        <p\n          key={index}\n          className={cn(\n            \"leading-relaxed\",\n            segment.direction === \"rtl\" && \"text-right\"\n          )}\n          dir={segment.direction}\n        >\n          {segment.text}\n        </p>\n      );\n    },\n    []\n  );\n\n  // If no text, show empty state\n  if (!text && !isStreaming) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\n        \"streaming-text-display\",\n        \"relative overflow-y-auto\",\n        \"text-neutral-900 dark:text-neutral-100\",\n        className\n      )}\n      dir={overallDirection}\n      data-testid={testId}\n      role=\"region\"\n      aria-live=\"polite\"\n      aria-atomic=\"false\"\n      aria-busy={isStreaming}\n    >\n      {/* Displayed Text */}\n      <div className=\"space-y-2\">\n        {segmentText(displayedText).map((segment, index) =>\n          renderSegment(segment, index)\n        )}\n      </div>\n\n      {/* Streaming Cursor */}\n      {isStreaming && showCursor && (\n        <span\n          className={cn(\n            \"inline-block w-0.5 h-5 ml-0.5\",\n            \"bg-blue-500 dark:bg-blue-400\",\n            \"animate-pulse align-text-bottom\",\n            overallDirection === \"rtl\" && \"mr-0.5 ml-0\"\n          )}\n          aria-hidden=\"true\"\n        />\n      )}\n\n      {/* Streaming Indicator */}\n      {isStreaming && (\n        <div\n          className={cn(\n            \"absolute bottom-2 px-2 py-1 rounded-full\",\n            \"bg-blue-100 dark:bg-blue-900/40\",\n            \"text-xs text-blue-600 dark:text-blue-400\",\n            \"flex items-center gap-1\",\n            overallDirection === \"rtl\" ? \"left-2\" : \"right-2\"\n          )}\n        >\n          <span className=\"w-1.5 h-1.5 bg-blue-500 rounded-full animate-pulse\" />\n          <span>Streaming</span>\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * StreamingTextLine - Single line variant for compact displays\n */\ninterface StreamingTextLineProps {\n  text: string;\n  isStreaming?: boolean;\n  className?: string;\n}\n\nexport function StreamingTextLine({\n  text,\n  isStreaming = false,\n  className,\n}: StreamingTextLineProps) {\n  const direction = detectTextDirection(text);\n\n  return (\n    <div\n      className={cn(\n        \"streaming-text-line inline-flex items-baseline\",\n        className\n      )}\n      dir={direction}\n    >\n      <span>{text}</span>\n      {isStreaming && (\n        <span\n          className={cn(\n            \"inline-block w-0.5 h-4 ml-0.5\",\n            \"bg-current opacity-70 animate-pulse\",\n            direction === \"rtl\" && \"mr-0.5 ml-0\"\n          )}\n          aria-hidden=\"true\"\n        />\n      )}\n    </div>\n  );\n}\n\n/**\n * Hook to manage streaming text state\n */\nexport function useStreamingText(initialText = \"\") {\n  const [text, setText] = useState(initialText);\n  const [isStreaming, setIsStreaming] = useState(false);\n\n  const startStreaming = useCallback(() => {\n    setIsStreaming(true);\n  }, []);\n\n  const appendText = useCallback((chunk: string) => {\n    setText((prev) => prev + chunk);\n  }, []);\n\n  const stopStreaming = useCallback(() => {\n    setIsStreaming(false);\n  }, []);\n\n  const reset = useCallback(() => {\n    setText(\"\");\n    setIsStreaming(false);\n  }, []);\n\n  return {\n    text,\n    isStreaming,\n    startStreaming,\n    appendText,\n    stopStreaming,\n    reset,\n    setText,\n  };\n}\n\nexport default StreamingTextDisplay;\n"
}
