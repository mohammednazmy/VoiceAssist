{
  "path": "services/api-gateway/app/api/admin_folders.py",
  "language": "python",
  "size": 21172,
  "last_modified": "2025-12-04T11:26:45.163Z",
  "lines": 673,
  "content": "\"\"\"Admin Folders API endpoints.\n\nProvides comprehensive folder management for the Admin Panel:\n- List all conversation folders across users\n- View folder details and hierarchy\n- Folder organization statistics\n- User folder usage analytics\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional\nfrom uuid import UUID\n\nfrom app.core.api_envelope import error_response, success_response\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_admin_user\nfrom app.models.folder import ConversationFolder\nfrom app.models.session import Session\nfrom app.models.user import User\nfrom app.services.audit_service import AuditService\nfrom fastapi import APIRouter, Depends, Query, Request\nfrom pydantic import BaseModel\nfrom sqlalchemy import desc, func\nfrom sqlalchemy.orm import Session as DBSession\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/folders\", tags=[\"admin\", \"folders\"])\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass FolderInfo(BaseModel):\n    \"\"\"Folder information for admin view.\"\"\"\n\n    id: str\n    user_id: str\n    user_email: Optional[str] = None\n    name: str\n    color: Optional[str] = None\n    icon: Optional[str] = None\n    parent_folder_id: Optional[str] = None\n    parent_folder_name: Optional[str] = None\n    created_at: str\n    conversation_count: int = 0\n    child_folder_count: int = 0\n\n\nclass FolderTreeNode(BaseModel):\n    \"\"\"Folder tree node for hierarchical view.\"\"\"\n\n    id: str\n    name: str\n    color: Optional[str] = None\n    icon: Optional[str] = None\n    conversation_count: int = 0\n    children: List[\"FolderTreeNode\"] = []\n\n\nclass FolderStats(BaseModel):\n    \"\"\"Folder organization statistics.\"\"\"\n\n    total_folders: int = 0\n    total_root_folders: int = 0\n    total_nested_folders: int = 0\n    max_depth: int = 0\n    users_with_folders: int = 0\n    users_without_folders: int = 0\n    avg_folders_per_user: float = 0.0\n    avg_conversations_per_folder: float = 0.0\n    folders_by_depth: Dict[int, int] = {}\n    by_color: Dict[str, int] = {}\n    top_users_by_folders: List[Dict[str, Any]] = []\n    empty_folders: int = 0\n    folders_created_today: int = 0\n    folders_created_this_week: int = 0\n\n\nclass UserFolderSummary(BaseModel):\n    \"\"\"Summary of a user's folder usage.\"\"\"\n\n    user_id: str\n    user_email: str\n    folder_count: int = 0\n    root_folder_count: int = 0\n    max_depth: int = 0\n    total_conversations_in_folders: int = 0\n\n\n# Allow FolderTreeNode to reference itself\nFolderTreeNode.model_rebuild()\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\n\ndef folder_to_info(\n    folder: ConversationFolder,\n    user: Optional[User] = None,\n    parent: Optional[ConversationFolder] = None,\n    conversation_count: int = 0,\n    child_count: int = 0,\n) -> FolderInfo:\n    \"\"\"Convert folder to admin info view.\"\"\"\n    return FolderInfo(\n        id=str(folder.id),\n        user_id=str(folder.user_id),\n        user_email=user.email if user else None,\n        name=folder.name,\n        color=folder.color,\n        icon=folder.icon,\n        parent_folder_id=(str(folder.parent_folder_id) if folder.parent_folder_id else None),\n        parent_folder_name=parent.name if parent else None,\n        created_at=folder.created_at.isoformat() if folder.created_at else \"\",\n        conversation_count=conversation_count,\n        child_folder_count=child_count,\n    )\n\n\ndef get_folder_depth(folder: ConversationFolder, folders_map: Dict[str, ConversationFolder]) -> int:\n    \"\"\"Calculate folder depth in hierarchy.\"\"\"\n    depth = 0\n    current = folder\n    while current.parent_folder_id:\n        depth += 1\n        parent_id = str(current.parent_folder_id)\n        if parent_id not in folders_map:\n            break\n        current = folders_map[parent_id]\n        if depth > 100:  # Prevent infinite loops\n            break\n    return depth\n\n\nasync def log_admin_folder_access(\n    db: DBSession,\n    admin_user: User,\n    action: str,\n    resource_id: Optional[str] = None,\n    request: Optional[Request] = None,\n    details: Optional[Dict] = None,\n) -> None:\n    \"\"\"Log admin folder access for audit.\"\"\"\n    try:\n        await AuditService.log_event(\n            db=db,\n            action=f\"admin_folder_{action}\",\n            success=True,\n            user=admin_user,\n            resource_type=\"folder\",\n            resource_id=resource_id,\n            request=request,\n            metadata=details,\n        )\n    except Exception as e:\n        logger.error(f\"Failed to log folder access: {e}\")\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"\")\nasync def list_folders(\n    limit: int = Query(50, ge=1, le=200),\n    offset: int = Query(0, ge=0),\n    user_id: Optional[str] = Query(None, description=\"Filter by user ID\"),\n    name_search: Optional[str] = Query(None, description=\"Search by folder name\"),\n    root_only: bool = Query(False, description=\"Only show root folders\"),\n    color: Optional[str] = Query(None, description=\"Filter by color\"),\n    created_since: Optional[str] = Query(None, description=\"Filter by creation date (ISO format)\"),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"List all folders with filtering options.\"\"\"\n    try:\n        query = db.query(ConversationFolder)\n\n        # Apply filters\n        if user_id:\n            try:\n                query = query.filter(ConversationFolder.user_id == UUID(user_id))\n            except ValueError:\n                return error_response(\n                    code=\"INVALID_USER_ID\",\n                    message=\"Invalid user ID format\",\n                    status_code=400,\n                )\n\n        if name_search:\n            query = query.filter(ConversationFolder.name.ilike(f\"%{name_search}%\"))\n\n        if root_only:\n            query = query.filter(ConversationFolder.parent_folder_id.is_(None))\n\n        if color:\n            query = query.filter(ConversationFolder.color == color)\n\n        if created_since:\n            try:\n                since_date = datetime.fromisoformat(created_since.replace(\"Z\", \"+00:00\"))\n                query = query.filter(ConversationFolder.created_at >= since_date)\n            except ValueError:\n                return error_response(\n                    code=\"INVALID_DATE\",\n                    message=\"Invalid date format. Use ISO format.\",\n                    status_code=400,\n                )\n\n        # Get total count\n        total = query.count()\n\n        # Get paginated results\n        folders = query.order_by(desc(ConversationFolder.created_at)).offset(offset).limit(limit).all()\n\n        # Get user info and counts\n        user_ids = list(set(f.user_id for f in folders))\n        users = {str(u.id): u for u in db.query(User).filter(User.id.in_(user_ids)).all()}\n\n        # Get parent folders\n        parent_ids = [f.parent_folder_id for f in folders if f.parent_folder_id]\n        parents = {\n            str(p.id): p for p in db.query(ConversationFolder).filter(ConversationFolder.id.in_(parent_ids)).all()\n        }\n\n        # Get conversation counts\n        folder_ids = [f.id for f in folders]\n        conv_counts = dict(\n            db.query(Session.folder_id, func.count(Session.id))\n            .filter(Session.folder_id.in_(folder_ids))\n            .group_by(Session.folder_id)\n            .all()\n        )\n\n        # Get child folder counts\n        child_counts = dict(\n            db.query(ConversationFolder.parent_folder_id, func.count(ConversationFolder.id))\n            .filter(ConversationFolder.parent_folder_id.in_(folder_ids))\n            .group_by(ConversationFolder.parent_folder_id)\n            .all()\n        )\n\n        # Build response\n        folder_list = [\n            folder_to_info(\n                f,\n                users.get(str(f.user_id)),\n                parents.get(str(f.parent_folder_id)) if f.parent_folder_id else None,\n                conv_counts.get(f.id, 0),\n                child_counts.get(f.id, 0),\n            ).model_dump()\n            for f in folders\n        ]\n\n        # Log access\n        await log_admin_folder_access(\n            db=db,\n            admin_user=admin_user,\n            action=\"list\",\n            request=request,\n            details={\"count\": len(folder_list)},\n        )\n\n        return success_response(\n            data={\n                \"folders\": folder_list,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to list folders: {e}\")\n        return error_response(\n            code=\"LIST_ERROR\",\n            message=\"Failed to list folders\",\n            status_code=500,\n        )\n\n\n@router.get(\"/stats\")\nasync def get_folder_stats(\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Get folder organization statistics.\"\"\"\n    try:\n        stats = FolderStats()\n\n        # Total counts\n        stats.total_folders = db.query(ConversationFolder).count()\n        stats.total_root_folders = (\n            db.query(ConversationFolder).filter(ConversationFolder.parent_folder_id.is_(None)).count()\n        )\n        stats.total_nested_folders = stats.total_folders - stats.total_root_folders\n\n        # Get all folders for depth calculations\n        all_folders = db.query(ConversationFolder).all()\n        folders_map = {str(f.id): f for f in all_folders}\n\n        # Calculate depths\n        depths = [get_folder_depth(f, folders_map) for f in all_folders]\n        stats.max_depth = max(depths) if depths else 0\n\n        # Count by depth\n        stats.folders_by_depth = {}\n        for depth in depths:\n            stats.folders_by_depth[depth] = stats.folders_by_depth.get(depth, 0) + 1\n\n        # User statistics\n        total_users = db.query(User).count()\n        users_with = db.query(func.count(func.distinct(ConversationFolder.user_id))).scalar() or 0\n        stats.users_with_folders = users_with\n        stats.users_without_folders = total_users - users_with\n\n        if users_with > 0:\n            stats.avg_folders_per_user = round(stats.total_folders / users_with, 2)\n\n        # Conversation counts\n        total_conversations_in_folders = db.query(Session).filter(Session.folder_id.isnot(None)).count()\n        if stats.total_folders > 0:\n            stats.avg_conversations_per_folder = round(total_conversations_in_folders / stats.total_folders, 2)\n\n        # By color\n        color_counts = (\n            db.query(ConversationFolder.color, func.count(ConversationFolder.id))\n            .filter(ConversationFolder.color.isnot(None))\n            .group_by(ConversationFolder.color)\n            .all()\n        )\n        stats.by_color = {color: count for color, count in color_counts if color}\n\n        # Top users\n        top_users = (\n            db.query(\n                User.id,\n                User.email,\n                func.count(ConversationFolder.id).label(\"folder_count\"),\n            )\n            .join(ConversationFolder, ConversationFolder.user_id == User.id)\n            .group_by(User.id, User.email)\n            .order_by(desc(func.count(ConversationFolder.id)))\n            .limit(10)\n            .all()\n        )\n\n        stats.top_users_by_folders = [\n            {\n                \"user_id\": str(u.id),\n                \"user_email\": u.email,\n                \"folder_count\": u.folder_count,\n            }\n            for u in top_users\n        ]\n\n        # Empty folders (no conversations)\n        folders_with_convs = db.query(func.distinct(Session.folder_id)).filter(Session.folder_id.isnot(None)).subquery()\n        stats.empty_folders = (\n            db.query(ConversationFolder).filter(ConversationFolder.id.notin_(folders_with_convs.select())).count()\n        )\n\n        # Time-based stats\n        now = datetime.now(timezone.utc)\n        today = now.replace(hour=0, minute=0, second=0, microsecond=0)\n        week_ago = today - timedelta(days=7)\n\n        stats.folders_created_today = (\n            db.query(ConversationFolder).filter(ConversationFolder.created_at >= today).count()\n        )\n\n        stats.folders_created_this_week = (\n            db.query(ConversationFolder).filter(ConversationFolder.created_at >= week_ago).count()\n        )\n\n        return success_response(data=stats.model_dump())\n\n    except Exception as e:\n        logger.error(f\"Failed to get folder stats: {e}\")\n        return error_response(\n            code=\"STATS_ERROR\",\n            message=\"Failed to retrieve statistics\",\n            status_code=500,\n        )\n\n\n@router.get(\"/{folder_id}\")\nasync def get_folder(\n    folder_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Get details of a specific folder.\"\"\"\n    try:\n        folder_uuid = UUID(folder_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid folder ID format\",\n            status_code=400,\n        )\n\n    folder = db.query(ConversationFolder).filter(ConversationFolder.id == folder_uuid).first()\n\n    if not folder:\n        return error_response(\n            code=\"NOT_FOUND\",\n            message=\"Folder not found\",\n            status_code=404,\n        )\n\n    # Get user info\n    user = db.query(User).filter(User.id == folder.user_id).first()\n\n    # Get parent folder\n    parent = None\n    if folder.parent_folder_id:\n        parent = db.query(ConversationFolder).filter(ConversationFolder.id == folder.parent_folder_id).first()\n\n    # Get counts\n    conversation_count = db.query(Session).filter(Session.folder_id == folder_uuid).count()\n    child_count = db.query(ConversationFolder).filter(ConversationFolder.parent_folder_id == folder_uuid).count()\n\n    # Get children\n    children = (\n        db.query(ConversationFolder)\n        .filter(ConversationFolder.parent_folder_id == folder_uuid)\n        .order_by(ConversationFolder.name)\n        .all()\n    )\n\n    child_list = [\n        {\n            \"id\": str(c.id),\n            \"name\": c.name,\n            \"color\": c.color,\n            \"icon\": c.icon,\n            \"conversation_count\": db.query(Session).filter(Session.folder_id == c.id).count(),\n        }\n        for c in children\n    ]\n\n    # Get conversations in this folder\n    conversations = (\n        db.query(Session).filter(Session.folder_id == folder_uuid).order_by(desc(Session.updated_at)).limit(20).all()\n    )\n\n    conv_list = [\n        {\n            \"id\": str(s.id),\n            \"title\": s.title,\n            \"updated_at\": s.updated_at.isoformat() if s.updated_at else \"\",\n        }\n        for s in conversations\n    ]\n\n    info = folder_to_info(folder, user, parent, conversation_count, child_count)\n\n    # Log access\n    await log_admin_folder_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"view\",\n        resource_id=folder_id,\n        request=request,\n    )\n\n    return success_response(\n        data={\n            \"folder\": info.model_dump(),\n            \"children\": child_list,\n            \"conversations\": conv_list,\n            \"total_conversations\": conversation_count,\n        }\n    )\n\n\n@router.get(\"/users/{user_id}/folders\")\nasync def get_user_folders(\n    user_id: str,\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Get all folders for a specific user with hierarchy.\"\"\"\n    try:\n        user_uuid = UUID(user_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid user ID format\",\n            status_code=400,\n        )\n\n    # Verify user exists\n    user = db.query(User).filter(User.id == user_uuid).first()\n    if not user:\n        return error_response(\n            code=\"USER_NOT_FOUND\",\n            message=\"User not found\",\n            status_code=404,\n        )\n\n    # Get all user's folders\n    all_folders = (\n        db.query(ConversationFolder)\n        .filter(ConversationFolder.user_id == user_uuid)\n        .order_by(ConversationFolder.name)\n        .all()\n    )\n\n    # Get conversation counts\n    folder_ids = [f.id for f in all_folders]\n    conv_counts = dict(\n        db.query(Session.folder_id, func.count(Session.id))\n        .filter(Session.folder_id.in_(folder_ids))\n        .group_by(Session.folder_id)\n        .all()\n    )\n\n    # Build tree\n    folder_map = {}\n    for f in all_folders:\n        folder_map[str(f.id)] = {\n            \"id\": str(f.id),\n            \"name\": f.name,\n            \"color\": f.color,\n            \"icon\": f.icon,\n            \"parent_folder_id\": str(f.parent_folder_id) if f.parent_folder_id else None,\n            \"conversation_count\": conv_counts.get(f.id, 0),\n            \"created_at\": f.created_at.isoformat() if f.created_at else \"\",\n            \"children\": [],\n        }\n\n    # Build hierarchy\n    root_folders = []\n    for folder in folder_map.values():\n        if folder[\"parent_folder_id\"]:\n            parent = folder_map.get(folder[\"parent_folder_id\"])\n            if parent:\n                parent[\"children\"].append(folder)\n        else:\n            root_folders.append(folder)\n\n    # Calculate summary\n    folders_map = {str(f.id): f for f in all_folders}\n    depths = [get_folder_depth(f, folders_map) for f in all_folders]\n    max_depth = max(depths) if depths else 0\n\n    total_convs = sum(conv_counts.values())\n\n    summary = UserFolderSummary(\n        user_id=str(user.id),\n        user_email=user.email,\n        folder_count=len(all_folders),\n        root_folder_count=len(root_folders),\n        max_depth=max_depth,\n        total_conversations_in_folders=total_convs,\n    )\n\n    # Log access\n    await log_admin_folder_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"list_user_folders\",\n        resource_id=user_id,\n        request=request,\n        details={\"folder_count\": len(all_folders)},\n    )\n\n    return success_response(\n        data={\n            \"summary\": summary.model_dump(),\n            \"folder_tree\": root_folders,\n            \"total_folders\": len(all_folders),\n        }\n    )\n\n\n@router.delete(\"/{folder_id}\")\nasync def delete_folder(\n    folder_id: str,\n    recursive: bool = Query(False, description=\"Delete child folders recursively\"),\n    admin_user: User = Depends(get_current_admin_user),\n    db: DBSession = Depends(get_db),\n    request: Request = None,\n) -> Dict[str, Any]:\n    \"\"\"Delete a folder.\n\n    By default, child folders and conversations are orphaned.\n    Set recursive=true to delete child folders as well.\n    \"\"\"\n    try:\n        folder_uuid = UUID(folder_id)\n    except ValueError:\n        return error_response(\n            code=\"INVALID_ID\",\n            message=\"Invalid folder ID format\",\n            status_code=400,\n        )\n\n    folder = db.query(ConversationFolder).filter(ConversationFolder.id == folder_uuid).first()\n\n    if not folder:\n        return error_response(\n            code=\"NOT_FOUND\",\n            message=\"Folder not found\",\n            status_code=404,\n        )\n\n    deleted_count = 0\n    orphaned_conversations = 0\n\n    if recursive:\n        # Recursively delete child folders\n        def delete_recursive(folder_id: UUID) -> int:\n            count = 0\n            children = db.query(ConversationFolder).filter(ConversationFolder.parent_folder_id == folder_id).all()\n\n            for child in children:\n                count += delete_recursive(child.id)\n                db.delete(child)\n                count += 1\n\n            return count\n\n        deleted_count = delete_recursive(folder_uuid)\n\n    # Count conversations that will be orphaned\n    orphaned_conversations = db.query(Session).filter(Session.folder_id == folder_uuid).count()\n\n    # Delete the folder (sessions will be orphaned due to SET NULL)\n    db.delete(folder)\n    db.commit()\n    deleted_count += 1\n\n    # Log deletion\n    await log_admin_folder_access(\n        db=db,\n        admin_user=admin_user,\n        action=\"delete\",\n        resource_id=folder_id,\n        request=request,\n        details={\n            \"recursive\": recursive,\n            \"deleted_count\": deleted_count,\n            \"orphaned_conversations\": orphaned_conversations,\n        },\n    )\n\n    logger.info(f\"Folder {folder_id} deleted by admin {admin_user.email}\")\n\n    return success_response(\n        data={\n            \"deleted\": True,\n            \"folder_id\": folder_id,\n            \"deleted_count\": deleted_count,\n            \"orphaned_conversations\": orphaned_conversations,\n        },\n        message=f\"Folder deleted successfully. {orphaned_conversations} conversations orphaned.\",\n    )\n"
}
