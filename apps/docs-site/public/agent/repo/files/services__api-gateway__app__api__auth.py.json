{
  "path": "services/api-gateway/app/api/auth.py",
  "language": "python",
  "size": 15999,
  "last_modified": "2025-12-04T11:26:46.839Z",
  "lines": 483,
  "content": "\"\"\"\nAuthentication endpoints for user registration, login, and token management\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom typing import Union\n\nfrom app.core.business_metrics import user_logins_total, user_registrations_total\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.core.security import (\n    create_access_token,\n    create_refresh_token,\n    get_password_hash,\n    get_refresh_token_ttl_seconds,\n    verify_password,\n    verify_token,\n)\nfrom app.models.user import User\nfrom app.schemas.auth import (\n    AcceptInvitationRequest,\n    AcceptInvitationResponse,\n    SessionInfoResponse,\n    TokenRefresh,\n    TokenResponse,\n    TwoFactorRequiredResponse,\n    UserLogin,\n    UserRegister,\n    UserResponse,\n)\nfrom app.services.admin_audit_log_service import admin_audit_log_service\nfrom app.services.session_activity import session_activity_service\nfrom app.services.token_revocation import token_revocation_service\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter(prefix=\"/api/auth\", tags=[\"authentication\"])\nlimiter = Limiter(key_func=get_remote_address)\n\n\n@router.post(\"/register\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(\"5/hour\")  # Strict rate limit for registration\nasync def register(request: Request, user_data: UserRegister, db: Session = Depends(get_db)):\n    \"\"\"\n    Register a new user account\n\n    - **email**: Valid email address (must be unique)\n    - **password**: Password (minimum 8 characters)\n    - **full_name**: User's full name\n\n    Rate limit: 5 registrations per hour per IP\n    \"\"\"\n    # Check if user already exists\n    existing_user = db.query(User).filter(User.email == user_data.email).first()\n    if existing_user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Email already registered\")\n\n    # Create new user\n    hashed_password = get_password_hash(user_data.password)\n    new_user = User(\n        email=user_data.email,\n        full_name=user_data.full_name,\n        hashed_password=hashed_password,\n        is_active=True,\n        is_admin=False,\n        admin_role=\"user\",\n    )\n\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n\n    # Track registration metric (P3.3 - Business Metrics)\n    user_registrations_total.inc()\n\n    return new_user\n\n\n@router.post(\"/login\", response_model=Union[TokenResponse, TwoFactorRequiredResponse])\n@limiter.limit(\"10/minute\")  # Rate limit login attempts\nasync def login(request: Request, login_data: UserLogin, db: Session = Depends(get_db)):\n    \"\"\"\n    Login with email and password to receive JWT tokens\n\n    - **email**: User's email address\n    - **password**: User's password\n\n    Returns short-lived access and refresh tokens (5 min / 60 min by default)\n    If 2FA is enabled, returns a 2FA-required response instead.\n\n    Rate limit: 10 login attempts per minute per IP\n    \"\"\"\n    # Find user by email (optimized with limit)\n    user = db.query(User).filter(User.email == login_data.email).limit(1).first()\n\n    if not user or not verify_password(login_data.password, user.hashed_password):\n        # Log failed login attempt\n        admin_audit_log_service.log_action(\n            db=db,\n            actor=None,\n            action=\"auth.login_failed\",\n            target_type=\"user\",\n            target_id=login_data.email,\n            success=False,\n            metadata={\"reason\": \"invalid_credentials\"},\n            request=request,\n        )\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    if not user.is_active:\n        # Log inactive user login attempt\n        admin_audit_log_service.log_action(\n            db=db,\n            actor=user,\n            action=\"auth.login_failed\",\n            target_type=\"user\",\n            target_id=str(user.id),\n            success=False,\n            metadata={\"reason\": \"inactive_account\"},\n            request=request,\n        )\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User account is inactive\")\n\n    # Check if 2FA is enabled\n    if user.totp_enabled:\n        # Return 2FA required response - tokens will be issued after 2FA verification\n        return TwoFactorRequiredResponse(\n            requires_2fa=True,\n            user_id=str(user.id),\n            message=\"Two-factor authentication required\",\n        )\n\n    # Update last login timestamp\n    user.last_login = datetime.now(timezone.utc)\n    db.commit()\n\n    # Track login metric (P3.3 - Business Metrics)\n    user_logins_total.inc()\n\n    # Log successful login\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=user,\n        action=\"auth.login_success\",\n        target_type=\"user\",\n        target_id=str(user.id),\n        success=True,\n        metadata={\"method\": \"password\"},\n        request=request,\n    )\n\n    token_role = user.admin_role or (\"admin\" if user.is_admin else \"user\")\n    password_epoch = int(\n        user.password_changed_at.replace(tzinfo=timezone.utc).timestamp()\n        if user.password_changed_at.tzinfo is None\n        else user.password_changed_at.timestamp()\n    )\n\n    # Create tokens\n    base_claims = {\n        \"sub\": str(user.id),\n        \"email\": user.email,\n        \"role\": token_role,\n        \"pwd\": password_epoch,\n    }\n    access_token = create_access_token(data=base_claims)\n    refresh_token = create_refresh_token(data=base_claims)\n\n    return TokenResponse(\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=\"bearer\",\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,  # Convert to seconds\n        refresh_expires_in=settings.REFRESH_TOKEN_EXPIRE_MINUTES * 60,\n        role=token_role,\n    )\n\n\n@router.post(\"/refresh\", response_model=TokenResponse)\n@limiter.limit(\"20/minute\")\nasync def refresh_token(\n    request: Request,\n    token_data: TokenRefresh,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Get a new access token using a refresh token\n\n    - **refresh_token**: Valid refresh token\n\n    Returns new access token and refresh token pair\n\n    Rate limit: 20 requests per minute per IP\n    \"\"\"\n    # Verify refresh token\n    payload = verify_token(token_data.refresh_token, token_type=\"refresh\")\n\n    if not payload:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired refresh token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    user_id = payload.get(\"sub\")\n    token_role = payload.get(\"role\")\n    token_iat = payload.get(\"iat\")\n    token_pwd = payload.get(\"pwd\")\n    if not user_id:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid token payload\")\n\n    # Verify user still exists and is active (optimized with limit)\n    user = db.query(User).filter(User.id == user_id).limit(1).first()\n    if not user or not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found or inactive\",\n        )\n\n    if token_role and token_role != user.admin_role:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Refresh token role no longer valid\",\n        )\n\n    if token_iat and user.password_changed_at:\n        pwd_ts = int(\n            user.password_changed_at.replace(tzinfo=timezone.utc).timestamp()\n            if user.password_changed_at.tzinfo is None\n            else user.password_changed_at.timestamp()\n        )\n        if token_iat < pwd_ts or (token_pwd and token_pwd < pwd_ts):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Token issued before last password change\",\n            )\n\n    user_revoked = await token_revocation_service.is_user_revoked(user_id)\n    if user_revoked:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"All user sessions have been revoked - please login again\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    # Create new token pair\n    token_role = user.admin_role or (\"admin\" if user.is_admin else \"user\")\n    password_epoch = int(\n        user.password_changed_at.replace(tzinfo=timezone.utc).timestamp()\n        if user.password_changed_at.tzinfo is None\n        else user.password_changed_at.timestamp()\n    )\n    claims = {\n        \"sub\": str(user.id),\n        \"email\": user.email,\n        \"role\": token_role,\n        \"pwd\": password_epoch,\n    }\n    access_token = create_access_token(data=claims)\n    new_refresh_token = create_refresh_token(data=claims)\n\n    # Rotate refresh token by revoking the one that was just used\n    await token_revocation_service.revoke_token(token_data.refresh_token, ttl_seconds=get_refresh_token_ttl_seconds())\n\n    return TokenResponse(\n        access_token=access_token,\n        refresh_token=new_refresh_token,\n        token_type=\"bearer\",\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n        refresh_expires_in=settings.REFRESH_TOKEN_EXPIRE_MINUTES * 60,\n        role=token_role,\n    )\n\n\n@router.post(\"/logout\")\nasync def logout(\n    request: Request,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Logout current user\n\n    Note: In a stateless JWT system, logout is primarily handled client-side\n    by discarding the tokens. This endpoint exists for consistency and\n    could be extended to maintain a token blacklist in Redis if needed.\n    \"\"\"\n    # Log logout event\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=current_user,\n        action=\"auth.logout\",\n        target_type=\"user\",\n        target_id=str(current_user.id),\n        success=True,\n        request=request,\n    )\n\n    return {\n        \"message\": \"Successfully logged out\",\n        \"detail\": \"Please discard your access and refresh tokens\",\n    }\n\n\n@router.get(\"/me\", response_model=UserResponse)\nasync def get_current_user_info(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current authenticated user's information\n\n    Requires valid access token in Authorization header\n    \"\"\"\n    return current_user\n\n\n@router.get(\"/session\", response_model=SessionInfoResponse)\nasync def get_session_info(\n    request: Request,\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Get session timeout information for the current session.\n\n    Returns timing info that the frontend can use to display\n    session expiration warnings and countdown timers.\n\n    - **absolute_timeout_hours**: Maximum session duration\n    - **inactivity_timeout_minutes**: Timeout after no activity\n    - **absolute_remaining_seconds**: Time until absolute timeout\n    - **inactivity_remaining_seconds**: Time until inactivity timeout\n    - **session_started_at**: When the session was created (ISO format)\n    - **last_activity_at**: Last recorded activity (ISO format)\n    \"\"\"\n    # Extract token_iat from the authorization header\n    auth_header = request.headers.get(\"Authorization\", \"\")\n    if auth_header.startswith(\"Bearer \"):\n        token = auth_header[7:]\n        payload = verify_token(token, token_type=\"access\")\n        token_iat = payload.get(\"iat\") if payload else None\n    else:\n        token_iat = None\n\n    if not token_iat:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Could not extract session info from token\",\n        )\n\n    session_info = await session_activity_service.get_session_info(\n        user_id=str(current_user.id),\n        token_iat=token_iat,\n    )\n\n    return SessionInfoResponse(**session_info)\n\n\n@router.post(\"/accept-invitation\", response_model=AcceptInvitationResponse)\n@limiter.limit(\"10/hour\")\nasync def accept_invitation(\n    request: Request,\n    invitation_data: AcceptInvitationRequest,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Accept an invitation and set up the user account.\n\n    - **token**: The invitation token from the email link\n    - **password**: The new password to set (min 8 characters)\n    - **full_name**: Optional - update full name if provided\n\n    Returns tokens for immediate login on success.\n\n    Rate limit: 10 attempts per hour per IP\n    \"\"\"\n    # Find user by invitation token\n    user = db.query(User).filter(User.invitation_token == invitation_data.token).first()\n\n    if not user:\n        admin_audit_log_service.log_action(\n            db=db,\n            actor=None,\n            action=\"auth.invitation_accept_failed\",\n            target_type=\"invitation\",\n            target_id=invitation_data.token[:8] + \"...\",\n            success=False,\n            metadata={\"reason\": \"invalid_token\"},\n            request=request,\n        )\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid or already used invitation token\",\n        )\n\n    # Check if token has expired\n    if user.invitation_token_expires_at:\n        now = datetime.now(timezone.utc)\n        expires_at = user.invitation_token_expires_at\n        if expires_at.tzinfo is None:\n            expires_at = expires_at.replace(tzinfo=timezone.utc)\n        if now > expires_at:\n            admin_audit_log_service.log_action(\n                db=db,\n                actor=None,\n                action=\"auth.invitation_accept_failed\",\n                target_type=\"user\",\n                target_id=str(user.id),\n                success=False,\n                metadata={\"reason\": \"token_expired\"},\n                request=request,\n            )\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invitation has expired. Please contact an administrator to resend.\",\n            )\n\n    # Set the user's password\n    user.hashed_password = get_password_hash(invitation_data.password)\n    user.password_changed_at = datetime.now(timezone.utc)\n\n    # Update full name if provided\n    if invitation_data.full_name:\n        user.full_name = invitation_data.full_name\n\n    # Activate the user and clear invitation tokens\n    user.is_active = True\n    user.invitation_token = None\n    user.invitation_token_expires_at = None\n\n    # Update last login timestamp\n    user.last_login = datetime.now(timezone.utc)\n\n    db.commit()\n    db.refresh(user)\n\n    # Log successful invitation acceptance\n    admin_audit_log_service.log_action(\n        db=db,\n        actor=user,\n        action=\"auth.invitation_accepted\",\n        target_type=\"user\",\n        target_id=str(user.id),\n        success=True,\n        metadata={\"email\": user.email},\n        request=request,\n    )\n\n    # Track registration metric\n    user_registrations_total.inc()\n\n    # Create tokens for immediate login\n    token_role = user.admin_role or (\"admin\" if user.is_admin else \"user\")\n    password_epoch = int(\n        user.password_changed_at.replace(tzinfo=timezone.utc).timestamp()\n        if user.password_changed_at.tzinfo is None\n        else user.password_changed_at.timestamp()\n    )\n\n    base_claims = {\n        \"sub\": str(user.id),\n        \"email\": user.email,\n        \"role\": token_role,\n        \"pwd\": password_epoch,\n    }\n    access_token = create_access_token(data=base_claims)\n    refresh_token = create_refresh_token(data=base_claims)\n\n    return AcceptInvitationResponse(\n        success=True,\n        message=\"Invitation accepted successfully. You are now logged in.\",\n        user=UserResponse.model_validate(user),\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=\"bearer\",\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n        refresh_expires_in=settings.REFRESH_TOKEN_EXPIRE_MINUTES * 60,\n    )\n"
}
