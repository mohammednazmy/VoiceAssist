{
  "path": "services/api-gateway/app/services/caldav_service.py",
  "language": "python",
  "size": 12211,
  "last_modified": "2025-12-04T11:26:55.792Z",
  "lines": 391,
  "content": "\"\"\"\nCalDAV Integration Service (Phase 6)\n\nProvides calendar operations via CalDAV protocol for Nextcloud Calendar integration.\nImplements basic CRUD operations for calendar events with authentication.\n\nMVP Implementation:\n- Connect to Nextcloud CalDAV endpoint\n- List calendar events within date range\n- Create, update, and delete events\n- Error handling and connection management\n\nFuture enhancements:\n- Google Calendar sync via CalDAV\n- Recurring event support\n- Calendar sharing and permissions\n- Event reminders and notifications\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, List, Optional\n\nimport caldav\nimport vobject\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass CalendarEvent:\n    \"\"\"Represents a calendar event.\"\"\"\n\n    uid: str\n    summary: str\n    description: Optional[str]\n    start: datetime\n    end: datetime\n    location: Optional[str] = None\n    organizer: Optional[str] = None\n    attendees: List[str] = None\n\n    def __post_init__(self):\n        if self.attendees is None:\n            self.attendees = []\n\n\nclass CalDAVService:\n    \"\"\"\n    CalDAV integration service for calendar operations.\n\n    Connects to Nextcloud Calendar (or any CalDAV-compatible server)\n    and provides CRUD operations for events.\n    \"\"\"\n\n    def __init__(self, caldav_url: str, username: str, password: str):\n        \"\"\"\n        Initialize CalDAV service.\n\n        Args:\n            caldav_url: CalDAV server URL (e.g., https://nextcloud.local/remote.php/dav/)\n            username: Calendar user credentials\n            password: Calendar user password\n        \"\"\"\n        self.caldav_url = caldav_url\n        self.username = username\n        self.password = password\n        self.client = None\n        self.principal = None\n\n    def connect(self) -> bool:\n        \"\"\"\n        Establish connection to CalDAV server.\n\n        Returns:\n            True if connection successful, False otherwise\n        \"\"\"\n        try:\n            self.client = caldav.DAVClient(url=self.caldav_url, username=self.username, password=self.password)\n\n            # Get principal (user's calendar root)\n            self.principal = self.client.principal()\n\n            logger.info(f\"Successfully connected to CalDAV server: {self.caldav_url}\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to connect to CalDAV server: {e}\", exc_info=True)\n            return False\n\n    def list_calendars(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        List all calendars for the authenticated user.\n\n        Returns:\n            List of calendar dictionaries with id, name, and description\n        \"\"\"\n        if not self.principal:\n            if not self.connect():\n                return []\n\n        try:\n            calendars = self.principal.calendars()\n\n            calendar_list = []\n            for cal in calendars:\n                calendar_list.append(\n                    {\n                        \"id\": str(cal.url),\n                        \"name\": cal.name,\n                        \"description\": getattr(cal, \"description\", None),\n                    }\n                )\n\n            logger.info(f\"Found {len(calendar_list)} calendars\")\n            return calendar_list\n\n        except Exception as e:\n            logger.error(f\"Error listing calendars: {e}\", exc_info=True)\n            return []\n\n    def get_events(\n        self,\n        calendar_id: Optional[str] = None,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -> List[CalendarEvent]:\n        \"\"\"\n        Retrieve calendar events within a date range.\n\n        Args:\n            calendar_id: Specific calendar to query (None = primary calendar)\n            start_date: Start of date range (None = today)\n            end_date: End of date range (None = 30 days from start)\n\n        Returns:\n            List of CalendarEvent objects\n        \"\"\"\n        if not self.principal:\n            if not self.connect():\n                return []\n\n        try:\n            # Get calendar\n            if calendar_id:\n                calendar = self.client.calendar(url=calendar_id)\n            else:\n                calendars = self.principal.calendars()\n                if not calendars:\n                    logger.warning(\"No calendars found\")\n                    return []\n                calendar = calendars[0]  # Use first calendar as primary\n\n            # Set date range\n            if not start_date:\n                start_date = datetime.now()\n            if not end_date:\n                end_date = start_date + timedelta(days=30)\n\n            # Query events\n            events = calendar.date_search(start=start_date, end=end_date)\n\n            # Parse events\n            calendar_events = []\n            for event in events:\n                try:\n                    vcal = vobject.readOne(event.data)\n                    vevent = vcal.vevent\n\n                    calendar_event = CalendarEvent(\n                        uid=str(vevent.uid.value),\n                        summary=str(vevent.summary.value),\n                        description=(str(vevent.description.value) if hasattr(vevent, \"description\") else None),\n                        start=vevent.dtstart.value,\n                        end=vevent.dtend.value,\n                        location=(str(vevent.location.value) if hasattr(vevent, \"location\") else None),\n                        organizer=(str(vevent.organizer.value) if hasattr(vevent, \"organizer\") else None),\n                        attendees=(\n                            [str(a.value) for a in vevent.attendee_list] if hasattr(vevent, \"attendee_list\") else []\n                        ),\n                    )\n                    calendar_events.append(calendar_event)\n\n                except Exception as e:\n                    logger.warning(f\"Failed to parse event: {e}\")\n                    continue\n\n            logger.info(f\"Retrieved {len(calendar_events)} events\")\n            return calendar_events\n\n        except Exception as e:\n            logger.error(f\"Error retrieving events: {e}\", exc_info=True)\n            return []\n\n    def create_event(\n        self,\n        summary: str,\n        start: datetime,\n        end: datetime,\n        description: Optional[str] = None,\n        location: Optional[str] = None,\n        calendar_id: Optional[str] = None,\n    ) -> Optional[str]:\n        \"\"\"\n        Create a new calendar event.\n\n        Args:\n            summary: Event title\n            start: Event start datetime\n            end: Event end datetime\n            description: Event description\n            location: Event location\n            calendar_id: Target calendar (None = primary)\n\n        Returns:\n            Event UID if successful, None otherwise\n        \"\"\"\n        if not self.principal:\n            if not self.connect():\n                return None\n\n        try:\n            # Get calendar\n            if calendar_id:\n                calendar = self.client.calendar(url=calendar_id)\n            else:\n                calendars = self.principal.calendars()\n                if not calendars:\n                    logger.error(\"No calendars found\")\n                    return None\n                calendar = calendars[0]\n\n            # Create vCal object\n            vcal = vobject.iCalendar()\n            vevent = vcal.add(\"vevent\")\n\n            vevent.add(\"summary\").value = summary\n            vevent.add(\"dtstart\").value = start\n            vevent.add(\"dtend\").value = end\n\n            if description:\n                vevent.add(\"description\").value = description\n            if location:\n                vevent.add(\"location\").value = location\n\n            # Generate UID\n            import uuid\n\n            event_uid = str(uuid.uuid4())\n            vevent.add(\"uid\").value = event_uid\n\n            # Add to calendar\n            calendar.add_event(vcal.serialize())\n\n            logger.info(f\"Created event: {summary} (UID: {event_uid})\")\n            return event_uid\n\n        except Exception as e:\n            logger.error(f\"Error creating event: {e}\", exc_info=True)\n            return None\n\n    def update_event(\n        self,\n        event_uid: str,\n        summary: Optional[str] = None,\n        start: Optional[datetime] = None,\n        end: Optional[datetime] = None,\n        description: Optional[str] = None,\n        location: Optional[str] = None,\n        calendar_id: Optional[str] = None,\n    ) -> bool:\n        \"\"\"\n        Update an existing calendar event.\n\n        Args:\n            event_uid: Unique identifier of event to update\n            summary: New event title\n            start: New start datetime\n            end: New end datetime\n            description: New description\n            location: New location\n            calendar_id: Calendar containing the event\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        if not self.principal:\n            if not self.connect():\n                return False\n\n        try:\n            # Get calendar\n            if calendar_id:\n                calendar = self.client.calendar(url=calendar_id)\n            else:\n                calendars = self.principal.calendars()\n                if not calendars:\n                    return False\n                calendar = calendars[0]\n\n            # Find event by UID\n            events = calendar.events()\n            target_event = None\n\n            for event in events:\n                vcal = vobject.readOne(event.data)\n                if str(vcal.vevent.uid.value) == event_uid:\n                    target_event = event\n                    break\n\n            if not target_event:\n                logger.warning(f\"Event not found: {event_uid}\")\n                return False\n\n            # Update event\n            vcal = vobject.readOne(target_event.data)\n            vevent = vcal.vevent\n\n            if summary:\n                vevent.summary.value = summary\n            if start:\n                vevent.dtstart.value = start\n            if end:\n                vevent.dtend.value = end\n            if description:\n                if hasattr(vevent, \"description\"):\n                    vevent.description.value = description\n                else:\n                    vevent.add(\"description\").value = description\n            if location:\n                if hasattr(vevent, \"location\"):\n                    vevent.location.value = location\n                else:\n                    vevent.add(\"location\").value = location\n\n            # Save changes\n            target_event.data = vcal.serialize()\n            target_event.save()\n\n            logger.info(f\"Updated event: {event_uid}\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"Error updating event: {e}\", exc_info=True)\n            return False\n\n    def delete_event(self, event_uid: str, calendar_id: Optional[str] = None) -> bool:\n        \"\"\"\n        Delete a calendar event.\n\n        Args:\n            event_uid: Unique identifier of event to delete\n            calendar_id: Calendar containing the event\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        if not self.principal:\n            if not self.connect():\n                return False\n\n        try:\n            # Get calendar\n            if calendar_id:\n                calendar = self.client.calendar(url=calendar_id)\n            else:\n                calendars = self.principal.calendars()\n                if not calendars:\n                    return False\n                calendar = calendars[0]\n\n            # Find and delete event\n            events = calendar.events()\n\n            for event in events:\n                vcal = vobject.readOne(event.data)\n                if str(vcal.vevent.uid.value) == event_uid:\n                    event.delete()\n                    logger.info(f\"Deleted event: {event_uid}\")\n                    return True\n\n            logger.warning(f\"Event not found: {event_uid}\")\n            return False\n\n        except Exception as e:\n            logger.error(f\"Error deleting event: {e}\", exc_info=True)\n            return False\n"
}
