{
  "path": "services/api-gateway/app/services/medical_ner_service.py",
  "language": "python",
  "size": 26347,
  "last_modified": "2025-12-04T11:26:58.278Z",
  "lines": 844,
  "content": "\"\"\"\nMedical Named Entity Recognition Service\n\nProvides medical NER using scispacy with UMLS entity linking:\n- Extracts diseases, medications, procedures, anatomical structures\n- Links entities to UMLS concepts (CUI codes)\n- Normalizes to standard ontologies (ICD-10, RxNorm, SNOMED-CT)\n\nThis service enables structured extraction of medical information\nfrom clinical text for downstream processing.\n\"\"\"\n\nimport asyncio\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Tuple\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass EntityType(Enum):\n    \"\"\"Medical entity types\"\"\"\n\n    DISEASE = \"DISEASE\"\n    MEDICATION = \"MEDICATION\"\n    PROCEDURE = \"PROCEDURE\"\n    ANATOMY = \"ANATOMY\"\n    SYMPTOM = \"SYMPTOM\"\n    LAB_TEST = \"LAB_TEST\"\n    GENE = \"GENE\"\n    CHEMICAL = \"CHEMICAL\"\n    ORGANISM = \"ORGANISM\"\n    UNKNOWN = \"UNKNOWN\"\n\n\nclass OntologyType(Enum):\n    \"\"\"Standard medical ontologies\"\"\"\n\n    ICD10 = \"ICD-10\"\n    RXNORM = \"RxNorm\"\n    SNOMED = \"SNOMED-CT\"\n    MESH = \"MeSH\"\n    LOINC = \"LOINC\"\n    ATC = \"ATC\"\n    HGNC = \"HGNC\"\n\n\n@dataclass\nclass UMLSConcept:\n    \"\"\"UMLS Concept representation\"\"\"\n\n    cui: str  # Concept Unique Identifier\n    name: str\n    semantic_types: List[str]\n    score: float\n    definition: Optional[str] = None\n    aliases: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass OntologyMapping:\n    \"\"\"Mapping to a standard ontology\"\"\"\n\n    ontology: OntologyType\n    code: str\n    display_name: str\n    confidence: float\n\n\n@dataclass\nclass MedicalEntity:\n    \"\"\"Extracted medical entity with metadata\"\"\"\n\n    text: str\n    entity_type: EntityType\n    start_char: int\n    end_char: int\n    umls_concepts: List[UMLSConcept] = field(default_factory=list)\n    ontology_mappings: List[OntologyMapping] = field(default_factory=list)\n    negated: bool = False\n    uncertain: bool = False\n    context: Optional[str] = None\n\n\n@dataclass\nclass NERResult:\n    \"\"\"Result of NER extraction\"\"\"\n\n    entities: List[MedicalEntity]\n    text_length: int\n    processing_time_ms: float\n    model_used: str\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n# Mapping from UMLS semantic types to EntityType\nSEMANTIC_TYPE_MAPPING = {\n    # Diseases\n    \"T047\": EntityType.DISEASE,  # Disease or Syndrome\n    \"T048\": EntityType.DISEASE,  # Mental or Behavioral Dysfunction\n    \"T191\": EntityType.DISEASE,  # Neoplastic Process\n    \"T046\": EntityType.DISEASE,  # Pathologic Function\n    \"T184\": EntityType.SYMPTOM,  # Sign or Symptom\n    # Medications\n    \"T121\": EntityType.MEDICATION,  # Pharmacologic Substance\n    \"T200\": EntityType.MEDICATION,  # Clinical Drug\n    \"T195\": EntityType.MEDICATION,  # Antibiotic\n    \"T109\": EntityType.CHEMICAL,  # Organic Chemical\n    \"T131\": EntityType.CHEMICAL,  # Hazardous or Poisonous Substance\n    # Procedures\n    \"T061\": EntityType.PROCEDURE,  # Therapeutic or Preventive Procedure\n    \"T060\": EntityType.PROCEDURE,  # Diagnostic Procedure\n    \"T059\": EntityType.LAB_TEST,  # Laboratory Procedure\n    \"T063\": EntityType.PROCEDURE,  # Molecular Biology Research Technique\n    # Anatomy\n    \"T023\": EntityType.ANATOMY,  # Body Part, Organ, or Organ Component\n    \"T024\": EntityType.ANATOMY,  # Tissue\n    \"T025\": EntityType.ANATOMY,  # Cell\n    \"T026\": EntityType.ANATOMY,  # Cell Component\n    # Genetics\n    \"T028\": EntityType.GENE,  # Gene or Genome\n    \"T116\": EntityType.GENE,  # Amino Acid, Peptide, or Protein\n    # Organisms\n    \"T004\": EntityType.ORGANISM,  # Fungus\n    \"T005\": EntityType.ORGANISM,  # Virus\n    \"T007\": EntityType.ORGANISM,  # Bacterium\n}\n\n\nclass MedicalNERService:\n    \"\"\"\n    Medical Named Entity Recognition using scispacy.\n\n    This service extracts medical entities from clinical text and links\n    them to UMLS concepts. It supports:\n\n    - Entity extraction (diseases, medications, procedures, anatomy)\n    - UMLS concept linking with confidence scores\n    - Ontology normalization (ICD-10, RxNorm, SNOMED-CT)\n    - Negation detection\n    - Abbreviation resolution\n\n    Note: For production use, this requires:\n    - spacy library\n    - scispacy library\n    - en_core_sci_lg model\n    - UMLS linker model\n\n    The service gracefully degrades when models are unavailable.\n    \"\"\"\n\n    def __init__(self, lazy_load: bool = True):\n        \"\"\"\n        Initialize the NER service.\n\n        Args:\n            lazy_load: If True, models are loaded on first use.\n        \"\"\"\n        self._nlp = None\n        self._nlp_loaded = False\n        self._lazy_load = lazy_load\n        self._abbreviation_cache: Dict[str, str] = {}\n        self._concept_cache: Dict[str, UMLSConcept] = {}\n\n        logger.info(\n            \"MedicalNERService initialized\",\n            extra={\"lazy_load\": lazy_load},\n        )\n\n        if not lazy_load:\n            self._load_model()\n\n    def _load_model(self) -> bool:\n        \"\"\"\n        Load the scispacy NER model with UMLS linker.\n\n        Returns:\n            True if model loaded successfully, False otherwise\n        \"\"\"\n        if self._nlp_loaded:\n            return True\n\n        try:\n            import spacy\n\n            logger.info(\"Loading scispacy NER model...\")\n\n            # Load the scientific/medical NER model\n            # Options: en_core_sci_sm, en_core_sci_md, en_core_sci_lg, en_ner_bc5cdr_md\n            self._nlp = spacy.load(\"en_core_sci_lg\")\n\n            # Try to add UMLS entity linker\n            try:\n                from scispacy.linking import EntityLinker  # noqa: F401\n\n                # Add abbreviation detector\n                if \"abbreviation_detector\" not in self._nlp.pipe_names:\n                    from scispacy.abbreviation import AbbreviationDetector  # noqa: F401\n\n                    self._nlp.add_pipe(\"abbreviation_detector\")\n\n                # Add UMLS entity linker\n                if \"scispacy_linker\" not in self._nlp.pipe_names:\n                    self._nlp.add_pipe(\n                        \"scispacy_linker\",\n                        config={\n                            \"resolve_abbreviations\": True,\n                            \"linker_name\": \"umls\",\n                            \"threshold\": 0.7,\n                            \"max_entities_per_mention\": 5,\n                        },\n                    )\n\n                logger.info(\"UMLS entity linker loaded successfully\")\n\n            except ImportError as e:\n                logger.warning(f\"scispacy entity linker not available: {e}. \" \"Entity linking will be disabled.\")\n            except Exception as e:\n                logger.warning(f\"Failed to load UMLS linker: {e}\")\n\n            self._nlp_loaded = True\n            logger.info(\n                \"Medical NER model loaded\",\n                extra={\"pipes\": self._nlp.pipe_names},\n            )\n            return True\n\n        except ImportError as e:\n            logger.warning(\n                f\"Failed to load NER model (missing dependency): {e}\",\n            )\n            return False\n        except OSError as e:\n            logger.warning(\n                f\"Failed to load NER model (model not found): {e}. \"\n                \"Install with: pip install scispacy && \"\n                \"pip install https://s3-us-west-2.amazonaws.com/ai2-s2-scispacy/\"\n                \"releases/v0.5.3/en_core_sci_lg-0.5.3.tar.gz\"\n            )\n            return False\n        except Exception as e:\n            logger.error(f\"Failed to load NER model: {e}\")\n            return False\n\n    def _ensure_model_loaded(self) -> bool:\n        \"\"\"Ensure model is loaded, loading if necessary.\"\"\"\n        if self._nlp_loaded:\n            return True\n        return self._load_model()\n\n    def _get_entity_type(self, semantic_types: List[str]) -> EntityType:\n        \"\"\"\n        Determine entity type from UMLS semantic types.\n\n        Args:\n            semantic_types: List of UMLS semantic type identifiers\n\n        Returns:\n            Mapped EntityType\n        \"\"\"\n        for st in semantic_types:\n            if st in SEMANTIC_TYPE_MAPPING:\n                return SEMANTIC_TYPE_MAPPING[st]\n        return EntityType.UNKNOWN\n\n    def _extract_umls_concepts(self, entity) -> List[UMLSConcept]:\n        \"\"\"\n        Extract UMLS concepts from an entity's knowledge base links.\n\n        Args:\n            entity: spacy entity with kb_ents attribute\n\n        Returns:\n            List of UMLSConcept objects\n        \"\"\"\n        concepts = []\n\n        # Check if entity has knowledge base entities\n        if not hasattr(entity._, \"kb_ents\") or not entity._.kb_ents:\n            return concepts\n\n        for kb_ent in entity._.kb_ents:\n            cui = kb_ent[0]\n            score = kb_ent[1]\n\n            # Check cache first\n            if cui in self._concept_cache:\n                cached = self._concept_cache[cui]\n                concepts.append(\n                    UMLSConcept(\n                        cui=cui,\n                        name=cached.name,\n                        semantic_types=cached.semantic_types,\n                        score=score,\n                        definition=cached.definition,\n                        aliases=cached.aliases,\n                    )\n                )\n                continue\n\n            # Get concept info from linker\n            try:\n                linker = self._nlp.get_pipe(\"scispacy_linker\")\n                kb = linker.kb\n\n                if cui in kb.cui_to_entity:\n                    kb_entity = kb.cui_to_entity[cui]\n                    concept = UMLSConcept(\n                        cui=cui,\n                        name=kb_entity.canonical_name,\n                        semantic_types=list(kb_entity.types),\n                        score=score,\n                        definition=kb_entity.definition,\n                        aliases=list(kb_entity.aliases)[:10],  # Limit aliases\n                    )\n                    # Cache the concept\n                    self._concept_cache[cui] = concept\n                    concepts.append(concept)\n                else:\n                    # Basic concept without full info\n                    concepts.append(\n                        UMLSConcept(\n                            cui=cui,\n                            name=entity.text,\n                            semantic_types=[],\n                            score=score,\n                        )\n                    )\n            except Exception as e:\n                logger.debug(f\"Could not get concept info for {cui}: {e}\")\n                concepts.append(\n                    UMLSConcept(\n                        cui=cui,\n                        name=entity.text,\n                        semantic_types=[],\n                        score=score,\n                    )\n                )\n\n        return concepts\n\n    async def extract_entities(\n        self,\n        text: str,\n        detect_negation: bool = True,\n        min_confidence: float = 0.7,\n    ) -> NERResult:\n        \"\"\"\n        Extract medical entities from text.\n\n        Args:\n            text: Clinical text to process\n            detect_negation: Whether to detect negated entities\n            min_confidence: Minimum confidence for UMLS linking\n\n        Returns:\n            NERResult with extracted entities and metadata\n        \"\"\"\n        import time\n\n        start_time = time.time()\n\n        if not self._ensure_model_loaded():\n            # Return empty result if model not available\n            return NERResult(\n                entities=[],\n                text_length=len(text),\n                processing_time_ms=0,\n                model_used=\"none\",\n                metadata={\"error\": \"NER model not available\"},\n            )\n\n        # Process text with spacy (run in thread pool for async)\n        doc = await asyncio.get_event_loop().run_in_executor(None, self._nlp, text)\n\n        entities = []\n\n        # Check for abbreviations\n        abbreviations = {}\n        if hasattr(doc._, \"abbreviations\"):\n            for abbr in doc._.abbreviations:\n                abbreviations[abbr.text] = str(abbr._.long_form)\n                self._abbreviation_cache[abbr.text] = str(abbr._.long_form)\n\n        # Extract negation spans if available\n        negation_spans: Set[Tuple[int, int]] = set()\n        if detect_negation:\n            negation_spans = self._detect_negation_spans(doc)\n\n        # Process entities\n        for ent in doc.ents:\n            # Extract UMLS concepts\n            umls_concepts = self._extract_umls_concepts(ent)\n\n            # Filter by confidence\n            umls_concepts = [c for c in umls_concepts if c.score >= min_confidence]\n\n            # Determine entity type\n            if umls_concepts:\n                semantic_types = []\n                for concept in umls_concepts:\n                    semantic_types.extend(concept.semantic_types)\n                entity_type = self._get_entity_type(semantic_types)\n            else:\n                entity_type = self._classify_entity_by_label(ent.label_)\n\n            # Check for negation\n            is_negated = self._is_negated(ent, negation_spans)\n\n            # Check for uncertainty\n            is_uncertain = self._is_uncertain(text, ent.start_char, ent.end_char)\n\n            # Get context window\n            context = self._get_context_window(text, ent.start_char, ent.end_char)\n\n            entity = MedicalEntity(\n                text=ent.text,\n                entity_type=entity_type,\n                start_char=ent.start_char,\n                end_char=ent.end_char,\n                umls_concepts=umls_concepts,\n                ontology_mappings=[],  # Will be filled by normalize_entities\n                negated=is_negated,\n                uncertain=is_uncertain,\n                context=context,\n            )\n\n            entities.append(entity)\n\n        processing_time = (time.time() - start_time) * 1000\n\n        return NERResult(\n            entities=entities,\n            text_length=len(text),\n            processing_time_ms=processing_time,\n            model_used=\"en_core_sci_lg\",\n            metadata={\n                \"num_entities\": len(entities),\n                \"abbreviations\": abbreviations,\n                \"negation_detection\": detect_negation,\n            },\n        )\n\n    def _classify_entity_by_label(self, label: str) -> EntityType:\n        \"\"\"\n        Classify entity type based on spacy NER label.\n\n        Args:\n            label: spacy entity label\n\n        Returns:\n            EntityType\n        \"\"\"\n        label_mapping = {\n            \"DISEASE\": EntityType.DISEASE,\n            \"DRUG\": EntityType.MEDICATION,\n            \"CHEMICAL\": EntityType.CHEMICAL,\n            \"GENE\": EntityType.GENE,\n            \"PROTEIN\": EntityType.GENE,\n            \"CELL\": EntityType.ANATOMY,\n            \"ORGANISM\": EntityType.ORGANISM,\n            \"TISSUE\": EntityType.ANATOMY,\n            \"ORGAN\": EntityType.ANATOMY,\n        }\n        return label_mapping.get(label, EntityType.UNKNOWN)\n\n    def _detect_negation_spans(self, doc) -> Set[Tuple[int, int]]:\n        \"\"\"\n        Detect negated spans in the document.\n\n        Uses simple pattern matching for common negation phrases.\n\n        Args:\n            doc: spacy Doc object\n\n        Returns:\n            Set of (start, end) tuples for negated spans\n        \"\"\"\n        negation_spans = set()\n\n        # Common negation triggers\n        negation_triggers = [\n            \"no\",\n            \"not\",\n            \"without\",\n            \"denies\",\n            \"denied\",\n            \"negative\",\n            \"absent\",\n            \"rule out\",\n            \"ruled out\",\n            \"r/o\",\n            \"none\",\n            \"never\",\n            \"no evidence of\",\n            \"no sign of\",\n            \"no history of\",\n        ]\n\n        text_lower = doc.text.lower()\n\n        for trigger in negation_triggers:\n            start = 0\n            while True:\n                idx = text_lower.find(trigger, start)\n                if idx == -1:\n                    break\n\n                # Mark next 50 chars as potentially negated\n                negation_spans.add((idx, min(idx + 50, len(doc.text))))\n                start = idx + 1\n\n        return negation_spans\n\n    def _is_negated(self, entity, negation_spans: Set[Tuple[int, int]]) -> bool:\n        \"\"\"\n        Check if an entity falls within a negation span.\n\n        Args:\n            entity: spacy entity\n            negation_spans: Set of negated spans\n\n        Returns:\n            True if entity is negated\n        \"\"\"\n        for start, end in negation_spans:\n            if start <= entity.start_char <= end:\n                return True\n        return False\n\n    def _is_uncertain(self, text: str, start: int, end: int) -> bool:\n        \"\"\"\n        Check if entity is mentioned with uncertainty.\n\n        Args:\n            text: Full text\n            start: Entity start position\n            end: Entity end position\n\n        Returns:\n            True if entity is uncertain\n        \"\"\"\n        # Check preceding context for uncertainty markers\n        context_start = max(0, start - 50)\n        preceding = text[context_start:start].lower()\n\n        uncertainty_markers = [\n            \"possible\",\n            \"probable\",\n            \"likely\",\n            \"suspected\",\n            \"?\",\n            \"may have\",\n            \"might be\",\n            \"could be\",\n            \"uncertain\",\n            \"questionable\",\n            \"consider\",\n            \"differential\",\n            \"rule out\",\n        ]\n\n        for marker in uncertainty_markers:\n            if marker in preceding:\n                return True\n\n        return False\n\n    def _get_context_window(self, text: str, start: int, end: int, window: int = 50) -> str:\n        \"\"\"\n        Get context window around an entity.\n\n        Args:\n            text: Full text\n            start: Entity start position\n            end: Entity end position\n            window: Number of characters for context\n\n        Returns:\n            Context string\n        \"\"\"\n        context_start = max(0, start - window)\n        context_end = min(len(text), end + window)\n        return text[context_start:context_end]\n\n    async def normalize_entities(\n        self,\n        entities: List[MedicalEntity],\n        ontologies: Optional[List[OntologyType]] = None,\n    ) -> List[MedicalEntity]:\n        \"\"\"\n        Normalize entities to standard medical ontologies.\n\n        Args:\n            entities: List of extracted entities\n            ontologies: Target ontologies for normalization\n\n        Returns:\n            Entities with ontology mappings added\n        \"\"\"\n        if ontologies is None:\n            ontologies = [OntologyType.ICD10, OntologyType.RXNORM, OntologyType.SNOMED]\n\n        normalized_entities = []\n\n        for entity in entities:\n            # Get mappings for each UMLS concept\n            mappings = []\n\n            for concept in entity.umls_concepts:\n                concept_mappings = await self._get_ontology_mappings(concept.cui, concept.semantic_types, ontologies)\n                mappings.extend(concept_mappings)\n\n            # Create new entity with mappings\n            normalized_entity = MedicalEntity(\n                text=entity.text,\n                entity_type=entity.entity_type,\n                start_char=entity.start_char,\n                end_char=entity.end_char,\n                umls_concepts=entity.umls_concepts,\n                ontology_mappings=mappings,\n                negated=entity.negated,\n                uncertain=entity.uncertain,\n                context=entity.context,\n            )\n            normalized_entities.append(normalized_entity)\n\n        return normalized_entities\n\n    async def _get_ontology_mappings(\n        self,\n        cui: str,\n        semantic_types: List[str],\n        ontologies: List[OntologyType],\n    ) -> List[OntologyMapping]:\n        \"\"\"\n        Get ontology mappings for a UMLS CUI.\n\n        This method queries the UMLS Metathesaurus for cross-references\n        to standard ontologies.\n\n        Args:\n            cui: UMLS Concept Unique Identifier\n            semantic_types: UMLS semantic types\n            ontologies: Target ontologies\n\n        Returns:\n            List of ontology mappings\n        \"\"\"\n        mappings = []\n\n        # Determine which ontologies are relevant based on semantic type\n        entity_type = self._get_entity_type(semantic_types)\n\n        relevant_ontologies = self._get_relevant_ontologies(entity_type, ontologies)\n\n        for ontology in relevant_ontologies:\n            # Try to get mapping from cache or API\n            mapping = await self._lookup_ontology_mapping(cui, ontology)\n            if mapping:\n                mappings.append(mapping)\n\n        return mappings\n\n    def _get_relevant_ontologies(self, entity_type: EntityType, requested: List[OntologyType]) -> List[OntologyType]:\n        \"\"\"\n        Get relevant ontologies for an entity type.\n\n        Args:\n            entity_type: Type of medical entity\n            requested: User-requested ontologies\n\n        Returns:\n            Filtered list of relevant ontologies\n        \"\"\"\n        ontology_relevance = {\n            EntityType.DISEASE: [OntologyType.ICD10, OntologyType.SNOMED],\n            EntityType.MEDICATION: [OntologyType.RXNORM, OntologyType.ATC],\n            EntityType.PROCEDURE: [OntologyType.SNOMED, OntologyType.LOINC],\n            EntityType.LAB_TEST: [OntologyType.LOINC],\n            EntityType.ANATOMY: [OntologyType.SNOMED],\n            EntityType.GENE: [OntologyType.HGNC],\n            EntityType.SYMPTOM: [OntologyType.SNOMED],\n        }\n\n        relevant = ontology_relevance.get(entity_type, [OntologyType.SNOMED])\n        return [o for o in requested if o in relevant]\n\n    async def _lookup_ontology_mapping(self, cui: str, ontology: OntologyType) -> Optional[OntologyMapping]:\n        \"\"\"\n        Look up ontology mapping for a CUI.\n\n        In production, this would query the UMLS API or a local database.\n\n        Args:\n            cui: UMLS CUI\n            ontology: Target ontology\n\n        Returns:\n            OntologyMapping if found, None otherwise\n        \"\"\"\n        # Check if we have the UMLS linker with KB\n        if not self._nlp or \"scispacy_linker\" not in self._nlp.pipe_names:\n            return None\n\n        try:\n            linker = self._nlp.get_pipe(\"scispacy_linker\")\n            kb = linker.kb\n\n            if cui not in kb.cui_to_entity:\n                return None\n\n            # The scispacy KB doesn't have direct ontology mappings,\n            # but in production you would query UMLS REST API here\n            # For now, return None to indicate mapping lookup needed\n            return None\n\n        except Exception as e:\n            logger.debug(f\"Could not lookup mapping for {cui}: {e}\")\n            return None\n\n    async def extract_and_normalize(\n        self,\n        text: str,\n        ontologies: Optional[List[OntologyType]] = None,\n        detect_negation: bool = True,\n        min_confidence: float = 0.7,\n    ) -> NERResult:\n        \"\"\"\n        Extract and normalize entities in one call.\n\n        Args:\n            text: Clinical text to process\n            ontologies: Target ontologies for normalization\n            detect_negation: Whether to detect negation\n            min_confidence: Minimum confidence for UMLS linking\n\n        Returns:\n            NERResult with normalized entities\n        \"\"\"\n        result = await self.extract_entities(\n            text,\n            detect_negation=detect_negation,\n            min_confidence=min_confidence,\n        )\n\n        if result.entities:\n            result.entities = await self.normalize_entities(result.entities, ontologies)\n\n        return result\n\n    def get_abbreviation_expansion(self, abbreviation: str) -> Optional[str]:\n        \"\"\"\n        Get the expansion of a medical abbreviation.\n\n        Args:\n            abbreviation: The abbreviation to expand\n\n        Returns:\n            Expanded form if known, None otherwise\n        \"\"\"\n        return self._abbreviation_cache.get(abbreviation)\n\n    def get_concept_info(self, cui: str) -> Optional[UMLSConcept]:\n        \"\"\"\n        Get cached concept information.\n\n        Args:\n            cui: UMLS CUI\n\n        Returns:\n            UMLSConcept if cached, None otherwise\n        \"\"\"\n        return self._concept_cache.get(cui)\n\n    def clear_cache(self):\n        \"\"\"Clear all caches.\"\"\"\n        self._abbreviation_cache.clear()\n        self._concept_cache.clear()\n\n    def to_dict(self, entity: MedicalEntity) -> Dict[str, Any]:\n        \"\"\"\n        Convert MedicalEntity to dictionary for API response.\n\n        Args:\n            entity: MedicalEntity to convert\n\n        Returns:\n            Dictionary representation\n        \"\"\"\n        return {\n            \"text\": entity.text,\n            \"type\": entity.entity_type.value,\n            \"start\": entity.start_char,\n            \"end\": entity.end_char,\n            \"negated\": entity.negated,\n            \"uncertain\": entity.uncertain,\n            \"context\": entity.context,\n            \"umls_concepts\": [\n                {\n                    \"cui\": c.cui,\n                    \"name\": c.name,\n                    \"semantic_types\": c.semantic_types,\n                    \"score\": c.score,\n                    \"definition\": c.definition,\n                    \"aliases\": c.aliases[:5] if c.aliases else [],\n                }\n                for c in entity.umls_concepts\n            ],\n            \"ontology_mappings\": [\n                {\n                    \"ontology\": m.ontology.value,\n                    \"code\": m.code,\n                    \"display_name\": m.display_name,\n                    \"confidence\": m.confidence,\n                }\n                for m in entity.ontology_mappings\n            ],\n        }\n\n    def result_to_dict(self, result: NERResult) -> Dict[str, Any]:\n        \"\"\"\n        Convert NERResult to dictionary for API response.\n\n        Args:\n            result: NERResult to convert\n\n        Returns:\n            Dictionary representation\n        \"\"\"\n        return {\n            \"entities\": [self.to_dict(e) for e in result.entities],\n            \"text_length\": result.text_length,\n            \"processing_time_ms\": result.processing_time_ms,\n            \"model_used\": result.model_used,\n            \"metadata\": result.metadata,\n        }\n\n\n# Global service instance (lazy loaded)\nmedical_ner_service = MedicalNERService(lazy_load=True)\n"
}
