{
  "path": "services/api-gateway/app/api/attachments.py",
  "language": "python",
  "size": 6095,
  "last_modified": "2025-12-04T11:26:46.222Z",
  "lines": 197,
  "content": "\"\"\"\nAPI endpoints for message attachments\n\"\"\"\n\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.attachment import MessageAttachment\nfrom app.models.message import Message\nfrom app.models.user import User\nfrom app.services.storage_service import get_storage_service\nfrom fastapi import APIRouter, Depends, File, HTTPException, UploadFile, status\nfrom fastapi.responses import StreamingResponse\nfrom sqlalchemy.orm import Session\n\nrouter = APIRouter()\n\n\n@router.post(\"/messages/{message_id}/attachments\", status_code=status.HTTP_201_CREATED)\nasync def upload_attachment(\n    message_id: UUID,\n    file: UploadFile = File(...),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Upload a file attachment to a message.\n\n    Args:\n        message_id: Message UUID\n        file: File to upload\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        Attachment metadata\n    \"\"\"\n    storage_service = get_storage_service()\n\n    # Verify message exists and belongs to user's session\n    message = db.query(Message).filter(Message.id == message_id).first()\n    if not message:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Message not found\")\n\n    # Verify user has access to the session\n    # Note: Add session ownership check based on your Session model\n    # session = db.query(Session).filter(Session.id == message.session_id, Session.user_id == current_user.id).first()\n    # if not session:\n    #     raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Access denied\")\n\n    # Validate file type\n    if not storage_service.is_allowed_file_type(file.filename):\n        allowed_types = [\n            \".pdf\",\n            \".txt\",\n            \".md\",\n            \".png\",\n            \".jpg\",\n            \".jpeg\",\n            \".gif\",\n            \".doc\",\n            \".docx\",\n        ]\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"File type not allowed. Allowed: {', '.join(allowed_types)}\",\n        )\n\n    # Validate file size\n    if file.size and file.size > storage_service.get_file_size_limit():\n        max_mb = storage_service.get_file_size_limit() // (1024 * 1024)\n        raise HTTPException(\n            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,\n            detail=f\"File too large. Maximum size: {max_mb}MB\",\n        )\n\n    # Upload file\n    file_url = await storage_service.upload_file(file, str(current_user.id), str(message_id))\n\n    # Create attachment record\n    attachment = MessageAttachment(\n        message_id=message_id,\n        file_name=file.filename,\n        file_type=file.content_type.split(\"/\")[0] if file.content_type else \"unknown\",\n        file_size=file.size or 0,\n        file_url=file_url,\n        mime_type=file.content_type,\n    )\n    db.add(attachment)\n    db.commit()\n    db.refresh(attachment)\n\n    return attachment.to_dict()\n\n\n@router.get(\"/messages/{message_id}/attachments\")\nasync def list_attachments(\n    message_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    List all attachments for a message.\n\n    Args:\n        message_id: Message UUID\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        List of attachment metadata\n    \"\"\"\n    # Verify message exists\n    message = db.query(Message).filter(Message.id == message_id).first()\n    if not message:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Message not found\")\n\n    # Get attachments\n    attachments = db.query(MessageAttachment).filter(MessageAttachment.message_id == message_id).all()\n\n    return [attachment.to_dict() for attachment in attachments]\n\n\n@router.delete(\"/attachments/{attachment_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_attachment(\n    attachment_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Delete an attachment.\n\n    Args:\n        attachment_id: Attachment UUID\n        db: Database session\n        current_user: Authenticated user\n    \"\"\"\n    storage_service = get_storage_service()\n\n    # Get attachment\n    attachment = db.query(MessageAttachment).filter(MessageAttachment.id == attachment_id).first()\n    if not attachment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Attachment not found\")\n\n    # Verify user has access to the message's session\n    # Add ownership verification here\n\n    # Delete file from storage\n    await storage_service.delete_file(attachment.file_url)\n\n    # Delete database record\n    db.delete(attachment)\n    db.commit()\n\n    return None\n\n\n@router.get(\"/attachments/{attachment_id}/download\", response_class=StreamingResponse)\nasync def download_attachment(\n    attachment_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Download an attachment file.\n\n    Args:\n        attachment_id: Attachment UUID\n        db: Database session\n        current_user: Authenticated user\n\n    Returns:\n        File stream\n    \"\"\"\n    storage_service = get_storage_service()\n\n    # Get attachment\n    attachment = db.query(MessageAttachment).filter(MessageAttachment.id == attachment_id).first()\n    if not attachment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Attachment not found\")\n\n    # Verify user has access to the message's session\n    # Add ownership verification here\n\n    # Get file content\n    file_content = await storage_service.get_file(attachment.file_url)\n    if not file_content:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"File not found in storage\")\n\n    # Return file stream\n    return StreamingResponse(\n        iter([file_content]),\n        media_type=attachment.mime_type or \"application/octet-stream\",\n        headers={\"Content-Disposition\": f\"attachment; filename={attachment.file_name}\"},\n    )\n"
}
