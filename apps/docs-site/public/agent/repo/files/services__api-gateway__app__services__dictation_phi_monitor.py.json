{
  "path": "services/api-gateway/app/services/dictation_phi_monitor.py",
  "language": "python",
  "size": 18213,
  "last_modified": "2025-12-04T12:32:40.270Z",
  "lines": 526,
  "content": "\"\"\"\nDictation PHI Monitor - Real-Time PHI Detection\n\nPhase 9: HIPAA compliance monitoring for medical dictation.\n\nFeatures:\n- Real-time PHI detection in dictated text\n- Alert when unexpected PHI spoken outside patient context\n- Pattern-based detection of common PHI types\n- Audit logging of PHI access and handling\n- Support for de-identification recommendations\n\"\"\"\n\nimport re\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Tuple\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Enums and Types\n# ==============================================================================\n\n\nclass PHIType(str, Enum):\n    \"\"\"Types of Protected Health Information.\"\"\"\n\n    NAME = \"name\"\n    DOB = \"date_of_birth\"\n    SSN = \"ssn\"\n    MRN = \"mrn\"\n    PHONE = \"phone\"\n    EMAIL = \"email\"\n    ADDRESS = \"address\"\n    ACCOUNT_NUMBER = \"account_number\"\n    LICENSE_NUMBER = \"license_number\"\n    VEHICLE_ID = \"vehicle_id\"\n    DEVICE_ID = \"device_id\"\n    IP_ADDRESS = \"ip_address\"\n    BIOMETRIC = \"biometric\"\n    PHOTO = \"photo\"\n    DATE = \"date\"  # Dates more specific than year\n    AGE_OVER_89 = \"age_over_89\"\n    OTHER = \"other\"\n\n\nclass PHIAlertLevel(str, Enum):\n    \"\"\"Alert levels for PHI detection.\"\"\"\n\n    INFO = \"info\"  # PHI detected but expected (current patient)\n    WARNING = \"warning\"  # PHI detected, verify context\n    CRITICAL = \"critical\"  # Unexpected PHI, potential breach\n\n\nclass PHIAction(str, Enum):\n    \"\"\"Recommended actions for PHI handling.\"\"\"\n\n    ALLOW = \"allow\"  # PHI is expected and authorized\n    MASK = \"mask\"  # Mask the PHI in display/storage\n    REDACT = \"redact\"  # Remove the PHI entirely\n    ALERT = \"alert\"  # Alert clinician and log\n    BLOCK = \"block\"  # Prevent recording/transmission\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\n@dataclass\nclass PHIMatch:\n    \"\"\"A detected PHI match in text.\"\"\"\n\n    phi_type: PHIType\n    value: str\n    start_pos: int\n    end_pos: int\n    confidence: float  # 0-1\n    masked_value: str = \"\"  # Value with PHI masked\n    pattern_name: str = \"\"\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"phi_type\": self.phi_type.value,\n            \"value\": self.value,\n            \"start_pos\": self.start_pos,\n            \"end_pos\": self.end_pos,\n            \"confidence\": self.confidence,\n            \"masked_value\": self.masked_value,\n            \"pattern_name\": self.pattern_name,\n        }\n\n\n@dataclass\nclass PHIAlert:\n    \"\"\"An alert generated by PHI detection.\"\"\"\n\n    alert_level: PHIAlertLevel\n    phi_type: PHIType\n    message: str\n    recommended_action: PHIAction\n    match: Optional[PHIMatch] = None\n    context: Optional[Dict[str, Any]] = None\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"alert_level\": self.alert_level.value,\n            \"phi_type\": self.phi_type.value,\n            \"message\": self.message,\n            \"recommended_action\": self.recommended_action.value,\n            \"match\": self.match.to_dict() if self.match else None,\n            \"context\": self.context,\n            \"timestamp\": self.timestamp.isoformat(),\n        }\n\n\n@dataclass\nclass PHIScanResult:\n    \"\"\"Result of scanning text for PHI.\"\"\"\n\n    text: str\n    matches: List[PHIMatch]\n    alerts: List[PHIAlert]\n    sanitized_text: str  # Text with PHI masked\n    phi_count: int = 0\n    has_critical_phi: bool = False\n    scan_timestamp: datetime = field(default_factory=datetime.utcnow)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"matches\": [m.to_dict() for m in self.matches],\n            \"alerts\": [a.to_dict() for a in self.alerts],\n            \"sanitized_text\": self.sanitized_text,\n            \"phi_count\": self.phi_count,\n            \"has_critical_phi\": self.has_critical_phi,\n            \"scan_timestamp\": self.scan_timestamp.isoformat(),\n        }\n\n\n@dataclass\nclass PatientPHIContext:\n    \"\"\"Known PHI for the current patient context.\"\"\"\n\n    patient_id: str\n    known_names: Set[str] = field(default_factory=set)\n    known_dob: Optional[str] = None\n    known_mrn: Optional[str] = None\n    known_phone: Optional[str] = None\n    known_address_parts: Set[str] = field(default_factory=set)\n\n\n# ==============================================================================\n# PHI Patterns\n# ==============================================================================\n\n\n# Regex patterns for PHI detection\nPHI_PATTERNS = {\n    # SSN: 123-45-6789 or 123456789\n    PHIType.SSN: [\n        (r\"\\b\\d{3}-\\d{2}-\\d{4}\\b\", \"ssn_dashed\", 0.95),\n        (r\"\\b\\d{9}\\b\", \"ssn_nodash\", 0.3),  # Low confidence - could be other numbers\n    ],\n    # MRN: Various formats (common patterns)\n    PHIType.MRN: [\n        (r\"\\bMRN[:\\s#]*\\d{6,10}\\b\", \"mrn_labeled\", 0.95),\n        (r\"\\bmedical record[:\\s#]*\\d{6,10}\\b\", \"mrn_full\", 0.95),\n    ],\n    # Phone: (123) 456-7890 or 123-456-7890 or 1234567890\n    PHIType.PHONE: [\n        (r\"\\(\\d{3}\\)\\s*\\d{3}-\\d{4}\", \"phone_parens\", 0.9),\n        (r\"\\b\\d{3}-\\d{3}-\\d{4}\\b\", \"phone_dashed\", 0.85),\n        (r\"\\b\\d{10}\\b\", \"phone_nodash\", 0.2),  # Low confidence\n    ],\n    # Email\n    PHIType.EMAIL: [\n        (\n            r\"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\",\n            \"email_standard\",\n            0.95,\n        ),\n    ],\n    # Dates (more specific than year)\n    PHIType.DATE: [\n        (r\"\\b\\d{1,2}/\\d{1,2}/\\d{2,4}\\b\", \"date_slash\", 0.7),\n        (r\"\\b\\d{1,2}-\\d{1,2}-\\d{2,4}\\b\", \"date_dash\", 0.7),\n        (\n            r\"\\b(?:January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{1,2},?\\s+\\d{4}\\b\",\n            \"date_full\",\n            0.8,\n        ),\n    ],\n    # Address patterns\n    PHIType.ADDRESS: [\n        (\n            r\"\\b\\d{1,5}\\s+(?:[A-Za-z]+\\s+){1,3}(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Court|Ct)\\b\",\n            \"address_street\",\n            0.75,\n        ),\n        (r\"\\b(?:P\\.?O\\.?\\s*Box|PO\\s*Box)\\s+\\d+\\b\", \"address_pobox\", 0.85),\n    ],\n    # Age over 89 (HIPAA considers this PHI)\n    PHIType.AGE_OVER_89: [\n        (r\"\\b(?:9[0-9]|1[0-2][0-9])\\s*(?:year|yr)s?\\s*old\\b\", \"age_over_89\", 0.9),\n        (r\"\\bage\\s*(?:of\\s*)?\\s*(?:9[0-9]|1[0-2][0-9])\\b\", \"age_over_89_labeled\", 0.9),\n    ],\n}\n\n# Common name patterns (simplified - would use NER in production)\nNAME_PREFIXES = {\"mr\", \"mrs\", \"ms\", \"dr\", \"miss\", \"prof\", \"professor\"}\nNAME_SUFFIXES = {\"jr\", \"sr\", \"ii\", \"iii\", \"iv\", \"md\", \"phd\", \"rn\", \"np\"}\n\n\n# ==============================================================================\n# Dictation PHI Monitor Service\n# ==============================================================================\n\n\nclass DictationPHIMonitor:\n    \"\"\"\n    Real-time PHI detection and monitoring for dictation.\n\n    Monitors dictated text for Protected Health Information and\n    generates alerts when unexpected PHI is detected.\n\n    Usage:\n        monitor = DictationPHIMonitor()\n\n        # Set current patient context\n        monitor.set_patient_context(PatientPHIContext(\n            patient_id=\"123\",\n            known_names={\"John Smith\"},\n            known_mrn=\"MRN001234\"\n        ))\n\n        # Scan dictated text\n        result = monitor.scan_text(\"Patient John Smith, MRN 001234...\")\n\n        # Check alerts\n        for alert in result.alerts:\n            print(f\"[{alert.alert_level}] {alert.message}\")\n    \"\"\"\n\n    def __init__(self):\n        self._compiled_patterns: Dict[PHIType, List[Tuple[re.Pattern, str, float]]] = {}\n        self._patient_context: Optional[PatientPHIContext] = None\n        self._compile_patterns()\n\n    def _compile_patterns(self) -> None:\n        \"\"\"Compile regex patterns for efficiency.\"\"\"\n        for phi_type, patterns in PHI_PATTERNS.items():\n            self._compiled_patterns[phi_type] = [\n                (re.compile(pattern, re.IGNORECASE), name, confidence) for pattern, name, confidence in patterns\n            ]\n\n    def set_patient_context(self, context: PatientPHIContext) -> None:\n        \"\"\"\n        Set the current patient context.\n\n        PHI matching the patient context will be flagged as INFO\n        rather than WARNING/CRITICAL.\n        \"\"\"\n        self._patient_context = context\n        logger.debug(f\"Set PHI context for patient {context.patient_id}\")\n\n    def clear_patient_context(self) -> None:\n        \"\"\"Clear the current patient context.\"\"\"\n        self._patient_context = None\n        logger.debug(\"Cleared PHI patient context\")\n\n    def scan_text(self, text: str) -> PHIScanResult:\n        \"\"\"\n        Scan text for PHI.\n\n        Args:\n            text: Text to scan for PHI\n\n        Returns:\n            PHIScanResult with matches and alerts\n        \"\"\"\n        matches: List[PHIMatch] = []\n        alerts: List[PHIAlert] = []\n\n        # Scan with all patterns\n        for phi_type, patterns in self._compiled_patterns.items():\n            for pattern, pattern_name, base_confidence in patterns:\n                for match in pattern.finditer(text):\n                    value = match.group(0)\n                    phi_match = PHIMatch(\n                        phi_type=phi_type,\n                        value=value,\n                        start_pos=match.start(),\n                        end_pos=match.end(),\n                        confidence=base_confidence,\n                        masked_value=self._mask_value(value, phi_type),\n                        pattern_name=pattern_name,\n                    )\n                    matches.append(phi_match)\n\n                    # Generate alert\n                    alert = self._create_alert(phi_match)\n                    if alert:\n                        alerts.append(alert)\n\n        # Scan for potential names (simplified)\n        name_matches = self._scan_for_names(text)\n        matches.extend(name_matches)\n        for nm in name_matches:\n            alert = self._create_alert(nm)\n            if alert:\n                alerts.append(alert)\n\n        # Create sanitized text\n        sanitized_text = self._sanitize_text(text, matches)\n\n        # Determine if critical PHI found\n        has_critical = any(a.alert_level == PHIAlertLevel.CRITICAL for a in alerts)\n\n        return PHIScanResult(\n            text=text,\n            matches=matches,\n            alerts=alerts,\n            sanitized_text=sanitized_text,\n            phi_count=len(matches),\n            has_critical_phi=has_critical,\n        )\n\n    def _scan_for_names(self, text: str) -> List[PHIMatch]:\n        \"\"\"\n        Scan for potential names in text.\n\n        In production, this would use NER (Named Entity Recognition).\n        For now, uses simplified heuristics.\n        \"\"\"\n        matches = []\n\n        # Pattern: Title + Capitalized words\n        # e.g., \"Mr. John Smith\" or \"Dr. Jane Doe\"\n        title_pattern = r\"\\b(?:Mr|Mrs|Ms|Miss|Dr|Prof)\\.?\\s+([A-Z][a-z]+(?:\\s+[A-Z][a-z]+){1,2})\\b\"\n        for match in re.finditer(title_pattern, text):\n            name = match.group(0)\n            matches.append(\n                PHIMatch(\n                    phi_type=PHIType.NAME,\n                    value=name,\n                    start_pos=match.start(),\n                    end_pos=match.end(),\n                    confidence=0.8,\n                    masked_value=self._mask_value(name, PHIType.NAME),\n                    pattern_name=\"name_with_title\",\n                )\n            )\n\n        # Pattern: \"Patient [Name]\" or \"patient named [Name]\"\n        patient_pattern = r\"\\bpatient(?:\\s+named?)?\\s+([A-Z][a-z]+(?:\\s+[A-Z][a-z]+){0,2})\\b\"\n        for match in re.finditer(patient_pattern, text, re.IGNORECASE):\n            name = match.group(1)\n            full_match = match.group(0)\n            matches.append(\n                PHIMatch(\n                    phi_type=PHIType.NAME,\n                    value=name,\n                    start_pos=match.start() + len(full_match) - len(name),\n                    end_pos=match.end(),\n                    confidence=0.85,\n                    masked_value=self._mask_value(name, PHIType.NAME),\n                    pattern_name=\"patient_name\",\n                )\n            )\n\n        return matches\n\n    def _mask_value(self, value: str, phi_type: PHIType) -> str:\n        \"\"\"Create a masked version of PHI value.\"\"\"\n        if phi_type == PHIType.SSN:\n            return \"***-**-****\"\n        elif phi_type == PHIType.PHONE:\n            return \"(***) ***-****\"\n        elif phi_type == PHIType.EMAIL:\n            parts = value.split(\"@\")\n            if len(parts) == 2:\n                return f\"***@{parts[1]}\"\n            return \"***@***.***\"\n        elif phi_type == PHIType.MRN:\n            return \"MRN ******\"\n        elif phi_type == PHIType.NAME:\n            # Mask all but first letter of each word\n            words = value.split()\n            masked_words = [w[0] + \"*\" * (len(w) - 1) if len(w) > 1 else w for w in words]\n            return \" \".join(masked_words)\n        elif phi_type == PHIType.DATE:\n            return \"**/**/****\"\n        elif phi_type == PHIType.ADDRESS:\n            return \"[ADDRESS REDACTED]\"\n        else:\n            return \"*\" * min(len(value), 10)\n\n    def _create_alert(self, match: PHIMatch) -> Optional[PHIAlert]:\n        \"\"\"Create an alert for a PHI match.\"\"\"\n        # Check if PHI matches current patient context\n        if self._patient_context:\n            if self._is_expected_phi(match):\n                # PHI is expected for current patient\n                return PHIAlert(\n                    alert_level=PHIAlertLevel.INFO,\n                    phi_type=match.phi_type,\n                    message=f\"Detected {match.phi_type.value} matching current patient\",\n                    recommended_action=PHIAction.ALLOW,\n                    match=match,\n                )\n\n        # Unexpected PHI\n        alert_level = self._determine_alert_level(match)\n        action = self._determine_action(match, alert_level)\n\n        return PHIAlert(\n            alert_level=alert_level,\n            phi_type=match.phi_type,\n            message=self._create_alert_message(match, alert_level),\n            recommended_action=action,\n            match=match,\n        )\n\n    def _is_expected_phi(self, match: PHIMatch) -> bool:\n        \"\"\"Check if PHI matches current patient context.\"\"\"\n        if not self._patient_context:\n            return False\n\n        value_lower = match.value.lower()\n\n        if match.phi_type == PHIType.NAME:\n            for known_name in self._patient_context.known_names:\n                if known_name.lower() in value_lower or value_lower in known_name.lower():\n                    return True\n\n        elif match.phi_type == PHIType.MRN:\n            if self._patient_context.known_mrn:\n                mrn_digits = re.sub(r\"\\D\", \"\", match.value)\n                known_digits = re.sub(r\"\\D\", \"\", self._patient_context.known_mrn)\n                if mrn_digits == known_digits:\n                    return True\n\n        elif match.phi_type == PHIType.DOB:\n            if self._patient_context.known_dob:\n                if self._patient_context.known_dob in match.value:\n                    return True\n\n        return False\n\n    def _determine_alert_level(self, match: PHIMatch) -> PHIAlertLevel:\n        \"\"\"Determine alert level based on PHI type and confidence.\"\"\"\n        # Critical PHI types\n        if match.phi_type in (PHIType.SSN, PHIType.MRN) and match.confidence > 0.8:\n            return PHIAlertLevel.CRITICAL\n\n        # High confidence matches\n        if match.confidence > 0.85:\n            return PHIAlertLevel.WARNING\n\n        # Lower confidence\n        return PHIAlertLevel.INFO\n\n    def _determine_action(self, match: PHIMatch, alert_level: PHIAlertLevel) -> PHIAction:\n        \"\"\"Determine recommended action based on alert level.\"\"\"\n        if alert_level == PHIAlertLevel.CRITICAL:\n            return PHIAction.ALERT\n        elif alert_level == PHIAlertLevel.WARNING:\n            return PHIAction.MASK\n        else:\n            return PHIAction.ALLOW\n\n    def _create_alert_message(self, match: PHIMatch, alert_level: PHIAlertLevel) -> str:\n        \"\"\"Create a human-readable alert message.\"\"\"\n        phi_type_name = match.phi_type.value.replace(\"_\", \" \").title()\n\n        if alert_level == PHIAlertLevel.CRITICAL:\n            return f\"CRITICAL: Unexpected {phi_type_name} detected. Verify patient context.\"\n        elif alert_level == PHIAlertLevel.WARNING:\n            return f\"Warning: Potential {phi_type_name} detected. Please verify.\"\n        else:\n            return f\"Info: Possible {phi_type_name} detected (low confidence).\"\n\n    def _sanitize_text(self, text: str, matches: List[PHIMatch]) -> str:\n        \"\"\"Create a sanitized version of text with PHI masked.\"\"\"\n        if not matches:\n            return text\n\n        # Sort matches by position (reverse order to preserve positions)\n        sorted_matches = sorted(matches, key=lambda m: m.start_pos, reverse=True)\n\n        sanitized = text\n        for match in sorted_matches:\n            sanitized = sanitized[: match.start_pos] + match.masked_value + sanitized[match.end_pos :]\n\n        return sanitized\n\n    def get_phi_summary(self, result: PHIScanResult) -> Dict[str, Any]:\n        \"\"\"Get a summary of PHI detection results.\"\"\"\n        phi_by_type: Dict[str, int] = {}\n        for match in result.matches:\n            phi_type = match.phi_type.value\n            phi_by_type[phi_type] = phi_by_type.get(phi_type, 0) + 1\n\n        alert_by_level: Dict[str, int] = {}\n        for alert in result.alerts:\n            level = alert.alert_level.value\n            alert_by_level[level] = alert_by_level.get(level, 0) + 1\n\n        return {\n            \"total_phi_detected\": result.phi_count,\n            \"has_critical_phi\": result.has_critical_phi,\n            \"phi_by_type\": phi_by_type,\n            \"alert_by_level\": alert_by_level,\n            \"scan_timestamp\": result.scan_timestamp.isoformat(),\n        }\n\n\n# Global service instance\ndictation_phi_monitor = DictationPHIMonitor()\n"
}
