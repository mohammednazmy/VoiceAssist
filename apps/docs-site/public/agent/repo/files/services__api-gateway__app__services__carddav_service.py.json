{
  "path": "services/api-gateway/app/services/carddav_service.py",
  "language": "python",
  "size": 27918,
  "last_modified": "2025-12-05T03:07:13.133Z",
  "lines": 892,
  "content": "\"\"\"\nCardDAV Contacts Integration Service\n\nCardDAV contacts integration with Nextcloud and other servers.\n\nFeatures:\n- List address books\n- List/search contacts\n- Create/update/delete contacts\n- Contact groups/categories\n- vCard 3.0/4.0 support\n- Photo handling\n\"\"\"\n\nimport uuid\nimport xml.etree.ElementTree as ET  # nosec B405 - parsing trusted CardDAV responses\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass PhoneType(str, Enum):\n    \"\"\"Phone number types.\"\"\"\n\n    HOME = \"HOME\"\n    WORK = \"WORK\"\n    CELL = \"CELL\"\n    FAX = \"FAX\"\n    PAGER = \"PAGER\"\n    OTHER = \"OTHER\"\n\n\nclass EmailType(str, Enum):\n    \"\"\"Email address types.\"\"\"\n\n    HOME = \"HOME\"\n    WORK = \"WORK\"\n    OTHER = \"OTHER\"\n\n\nclass AddressType(str, Enum):\n    \"\"\"Address types.\"\"\"\n\n    HOME = \"HOME\"\n    WORK = \"WORK\"\n    OTHER = \"OTHER\"\n\n\n@dataclass\nclass PhoneNumber:\n    \"\"\"Phone number with type.\"\"\"\n\n    number: str\n    type: PhoneType = PhoneType.OTHER\n    is_primary: bool = False\n\n\n@dataclass\nclass EmailAddress:\n    \"\"\"Email address with type.\"\"\"\n\n    email: str\n    type: EmailType = EmailType.OTHER\n    is_primary: bool = False\n\n\n@dataclass\nclass PostalAddress:\n    \"\"\"Postal/mailing address.\"\"\"\n\n    street: Optional[str] = None\n    city: Optional[str] = None\n    state: Optional[str] = None\n    postal_code: Optional[str] = None\n    country: Optional[str] = None\n    type: AddressType = AddressType.OTHER\n\n    def to_vcard_value(self) -> str:\n        \"\"\"Convert to vCard ADR value.\"\"\"\n        # vCard ADR format: PO Box;Extended;Street;City;State;Postal;Country\n        street = self.street or \"\"\n        city = self.city or \"\"\n        state = self.state or \"\"\n        postal = self.postal_code or \"\"\n        country = self.country or \"\"\n        return f\";;{street};{city};{state};{postal};{country}\"\n\n\n@dataclass\nclass Contact:\n    \"\"\"Contact record.\"\"\"\n\n    uid: str\n    display_name: str\n\n    # Name components\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    middle_name: Optional[str] = None\n    prefix: Optional[str] = None\n    suffix: Optional[str] = None\n    nickname: Optional[str] = None\n\n    # Contact info\n    emails: List[EmailAddress] = field(default_factory=list)\n    phones: List[PhoneNumber] = field(default_factory=list)\n    addresses: List[PostalAddress] = field(default_factory=list)\n\n    # Organization\n    organization: Optional[str] = None\n    title: Optional[str] = None\n    department: Optional[str] = None\n\n    # Additional info\n    birthday: Optional[datetime] = None\n    anniversary: Optional[datetime] = None\n    notes: Optional[str] = None\n    website: Optional[str] = None\n\n    # Photo (base64 encoded)\n    photo: Optional[str] = None\n    photo_type: Optional[str] = None  # JPEG, PNG, etc.\n\n    # Categories/groups\n    categories: List[str] = field(default_factory=list)\n\n    # Metadata\n    etag: Optional[str] = None\n    created: Optional[datetime] = None\n    modified: Optional[datetime] = None\n\n    # Raw vCard\n    vcard_data: Optional[str] = None\n\n\n@dataclass\nclass AddressBook:\n    \"\"\"CardDAV address book.\"\"\"\n\n    name: str\n    display_name: str\n    url: str\n    description: Optional[str] = None\n    color: Optional[str] = None\n    contact_count: int = 0\n    ctag: Optional[str] = None  # Sync token\n\n\n@dataclass\nclass ContactSearchQuery:\n    \"\"\"Contact search parameters.\"\"\"\n\n    text: Optional[str] = None\n    email: Optional[str] = None\n    phone: Optional[str] = None\n    organization: Optional[str] = None\n    category: Optional[str] = None\n    limit: int = 100\n\n\n@dataclass\nclass ContactSyncResult:\n    \"\"\"Result of a CardDAV sync-token based sync.\"\"\"\n\n    contacts: List[Contact]\n    deleted: List[str]\n    sync_token: Optional[str]\n\n\n# XML namespaces\nNAMESPACES = {\n    \"D\": \"DAV:\",\n    \"C\": \"urn:ietf:params:xml:ns:carddav\",\n    \"CS\": \"http://calendarserver.org/ns/\",\n}\n\n# Register namespaces for ET\nfor prefix, uri in NAMESPACES.items():\n    ET.register_namespace(prefix, uri)\n\n\nclass CardDAVService:\n    \"\"\"\n    CardDAV contacts integration service.\n\n    Provides contact management via CardDAV protocol,\n    compatible with Nextcloud, Radicale, and other servers.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        username: str,\n        password: str,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.username = username\n        self.password = password\n        self.carddav_url = f\"{self.base_url}/remote.php/dav/addressbooks/users/{username}\"\n\n    def _get_auth(self) -> tuple:\n        \"\"\"Get HTTP basic auth tuple.\"\"\"\n        return (self.username, self.password)\n\n    async def list_address_books(self) -> List[AddressBook]:\n        \"\"\"List all address books for the user.\"\"\"\n        propfind_body = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <D:propfind xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:carddav\" xmlns:CS=\"http://calendarserver.org/ns/\">\n          <D:prop>\n            <D:displayname/>\n            <D:resourcetype/>\n            <C:addressbook-description/>\n            <CS:getctag/>\n          </D:prop>\n        </D:propfind>\"\"\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.request(\n                \"PROPFIND\",\n                self.carddav_url,\n                headers={\n                    \"Depth\": \"1\",\n                    \"Content-Type\": \"application/xml; charset=utf-8\",\n                },\n                content=propfind_body,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n\n        return self._parse_address_books(response.text)\n\n    def _parse_address_books(self, xml_text: str) -> List[AddressBook]:\n        \"\"\"Parse PROPFIND response for address books.\"\"\"\n        address_books = []\n\n        try:\n            root = ET.fromstring(xml_text)  # nosec B314 - trusted CardDAV response\n\n            for response in root.findall(\".//D:response\", NAMESPACES):\n                href = response.find(\"D:href\", NAMESPACES)\n                if href is None:\n                    continue\n\n                # Check if this is an address book\n                resource_type = response.find(\".//D:resourcetype/C:addressbook\", NAMESPACES)\n                if resource_type is None:\n                    continue\n\n                url = href.text\n                name = url.rstrip(\"/\").split(\"/\")[-1]\n\n                display_name_elem = response.find(\".//D:displayname\", NAMESPACES)\n                display_name = display_name_elem.text if display_name_elem is not None else name\n\n                description_elem = response.find(\".//C:addressbook-description\", NAMESPACES)\n                description = description_elem.text if description_elem is not None else None\n\n                ctag_elem = response.find(\".//CS:getctag\", NAMESPACES)\n                ctag = ctag_elem.text if ctag_elem is not None else None\n\n                address_books.append(\n                    AddressBook(\n                        name=name,\n                        display_name=display_name,\n                        url=f\"{self.base_url}{url}\",\n                        description=description,\n                        ctag=ctag,\n                    )\n                )\n\n        except ET.ParseError as e:\n            logger.error(f\"Failed to parse address books: {e}\")\n\n        return address_books\n\n    async def list_contacts(\n        self,\n        address_book: str = \"contacts\",\n        query: Optional[ContactSearchQuery] = None,\n    ) -> List[Contact]:\n        \"\"\"List all contacts in address book.\"\"\"\n        url = f\"{self.carddav_url}/{address_book}\"\n\n        if query and query.text:\n            # Use REPORT with addressbook-query\n            return await self._search_contacts(url, query)\n\n        # Use PROPFIND for full list\n        propfind_body = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <D:propfind xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n          <D:prop>\n            <D:getetag/>\n            <C:address-data/>\n          </D:prop>\n        </D:propfind>\"\"\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.request(\n                \"PROPFIND\",\n                url,\n                headers={\n                    \"Depth\": \"1\",\n                    \"Content-Type\": \"application/xml; charset=utf-8\",\n                },\n                content=propfind_body,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n\n        return self._parse_contacts(response.text)\n\n    async def sync_contacts(\n        self,\n        address_book: str = \"contacts\",\n        sync_token: Optional[str] = None,\n        limit: int = 500,\n    ) -> ContactSyncResult:\n        \"\"\"Incrementally sync contacts using CardDAV sync tokens.\"\"\"\n\n        # If we do not have a sync token yet, perform a full read\n        if not sync_token:\n            contacts = await self.list_contacts(address_book)\n            return ContactSyncResult(contacts=contacts, deleted=[], sync_token=None)\n\n        url = f\"{self.carddav_url}/{address_book}\"\n        report_body = f\"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <C:sync-collection xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n          <D:sync-token>{sync_token}</D:sync-token>\n          <D:prop>\n            <D:getetag/>\n            <C:address-data/>\n          </D:prop>\n          <C:limit><C:nresults>{limit}</C:nresults></C:limit>\n        </C:sync-collection>\"\"\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.request(\n                \"REPORT\",\n                url,\n                headers={\n                    \"Depth\": \"1\",\n                    \"Content-Type\": \"application/xml; charset=utf-8\",\n                },\n                content=report_body,\n                timeout=30.0,\n            )\n            # Some servers return 409 if token invalid/expired\n            if response.status_code == 409:\n                logger.warning(\"Sync token invalid; falling back to full contact sync\")\n                contacts = await self.list_contacts(address_book)\n                return ContactSyncResult(contacts=contacts, deleted=[], sync_token=None)\n\n            response.raise_for_status()\n\n        contacts = self._parse_contacts(response.text)\n        deleted: List[str] = []\n\n        try:\n            root = ET.fromstring(response.text)  # nosec B314 - trusted CardDAV response\n            for res in root.findall(\".//D:response\", NAMESPACES):\n                status = res.find(\".//D:status\", NAMESPACES)\n                href = res.find(\"D:href\", NAMESPACES)\n                if status is not None and \"404\" in status.text and href is not None:\n                    uid = href.text.rstrip(\"/\").split(\"/\")[-1].replace(\".vcf\", \"\")\n                    deleted.append(uid)\n\n            new_sync = self._extract_sync_token(root)\n        except ET.ParseError as e:\n            logger.error(f\"Failed to parse sync response: {e}\")\n            new_sync = None\n\n        return ContactSyncResult(contacts=contacts, deleted=deleted, sync_token=new_sync)\n\n    async def _search_contacts(\n        self,\n        url: str,\n        query: ContactSearchQuery,\n    ) -> List[Contact]:\n        \"\"\"Search contacts using CardDAV REPORT.\"\"\"\n        # Build filter\n        filters = []\n\n        if query.text:\n            # Search in multiple fields\n            for prop in [\"FN\", \"EMAIL\", \"TEL\", \"ORG\", \"NICKNAME\"]:\n                filters.append(\n                    f\"\"\"<C:prop-filter name=\"{prop}\">\n                      <C:text-match collation=\"i;unicode-casemap\" match-type=\"contains\">{query.text}</C:text-match>\n                    </C:prop-filter>\"\"\"\n                )\n\n        if query.email:\n            filters.append(\n                f\"\"\"<C:prop-filter name=\"EMAIL\">\n                  <C:text-match collation=\"i;unicode-casemap\" match-type=\"contains\">{query.email}</C:text-match>\n                </C:prop-filter>\"\"\"\n            )\n\n        if query.phone:\n            filters.append(\n                f\"\"\"<C:prop-filter name=\"TEL\">\n                  <C:text-match collation=\"i;unicode-casemap\" match-type=\"contains\">{query.phone}</C:text-match>\n                </C:prop-filter>\"\"\"\n            )\n\n        if query.organization:\n            filters.append(\n                f\"\"\"<C:prop-filter name=\"ORG\">\n                  <C:text-match collation=\"i;unicode-casemap\" match-type=\"contains\">{query.organization}</C:text-match>\n                </C:prop-filter>\"\"\"\n            )\n\n        filter_xml = \"\\n\".join(filters)\n\n        report_body = f\"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <C:addressbook-query xmlns:D=\"DAV:\" xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n          <D:prop>\n            <D:getetag/>\n            <C:address-data/>\n          </D:prop>\n          <C:filter test=\"anyof\">\n            {filter_xml}\n          </C:filter>\n          <C:limit><C:nresults>{query.limit}</C:nresults></C:limit>\n        </C:addressbook-query>\"\"\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.request(\n                \"REPORT\",\n                url,\n                headers={\n                    \"Depth\": \"1\",\n                    \"Content-Type\": \"application/xml; charset=utf-8\",\n                },\n                content=report_body,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n\n        return self._parse_contacts(response.text)\n\n    def _parse_contacts(self, xml_text: str) -> List[Contact]:\n        \"\"\"Parse PROPFIND/REPORT response for contacts.\"\"\"\n        contacts = []\n\n        try:\n            root = ET.fromstring(xml_text)  # nosec B314 - trusted CardDAV response\n\n            for response in root.findall(\".//D:response\", NAMESPACES):\n                href = response.find(\"D:href\", NAMESPACES)\n                if href is None or not href.text.endswith(\".vcf\"):\n                    continue\n\n                etag_elem = response.find(\".//D:getetag\", NAMESPACES)\n                etag = etag_elem.text.strip('\"') if etag_elem is not None else None\n\n                address_data = response.find(\".//C:address-data\", NAMESPACES)\n                if address_data is None or address_data.text is None:\n                    continue\n\n                contact = self._parse_vcard(address_data.text)\n                if contact:\n                    contact.etag = etag\n                    contacts.append(contact)\n\n        except ET.ParseError as e:\n            logger.error(f\"Failed to parse contacts: {e}\")\n\n        return contacts\n\n    def _extract_sync_token(self, root: ET.Element) -> Optional[str]:\n        \"\"\"Extract sync-token/ctag from a sync response.\"\"\"\n        sync_elem = root.find(\".//D:sync-token\", NAMESPACES)\n        if sync_elem is not None and sync_elem.text:\n            return sync_elem.text.strip()\n\n        ctag_elem = root.find(\".//CS:getctag\", NAMESPACES)\n        if ctag_elem is not None and ctag_elem.text:\n            return ctag_elem.text.strip()\n\n        return None\n\n    def _parse_vcard(self, vcard_text: str) -> Optional[Contact]:\n        \"\"\"Parse vCard text into Contact object.\"\"\"\n        if not vcard_text:\n            return None\n\n        lines = vcard_text.strip().split(\"\\n\")\n\n        contact_data: Dict[str, Any] = {\n            \"uid\": str(uuid.uuid4()),\n            \"display_name\": \"\",\n            \"emails\": [],\n            \"phones\": [],\n            \"addresses\": [],\n            \"categories\": [],\n        }\n\n        current_line = \"\"\n\n        for line in lines:\n            # Handle line folding (continued lines start with space/tab)\n            if line.startswith(\" \") or line.startswith(\"\\t\"):\n                current_line += line[1:]\n                continue\n\n            if current_line:\n                self._parse_vcard_line(current_line, contact_data)\n\n            current_line = line.strip()\n\n        # Don't forget the last line\n        if current_line:\n            self._parse_vcard_line(current_line, contact_data)\n\n        if not contact_data.get(\"display_name\"):\n            # Build display name from N if FN not present\n            if contact_data.get(\"first_name\") or contact_data.get(\"last_name\"):\n                parts = []\n                if contact_data.get(\"first_name\"):\n                    parts.append(contact_data[\"first_name\"])\n                if contact_data.get(\"last_name\"):\n                    parts.append(contact_data[\"last_name\"])\n                contact_data[\"display_name\"] = \" \".join(parts)\n            else:\n                return None  # No name, skip this contact\n\n        contact_data[\"vcard_data\"] = vcard_text\n\n        return Contact(**contact_data)\n\n    def _parse_vcard_line(self, line: str, data: Dict[str, Any]) -> None:\n        \"\"\"Parse a single vCard line and update data dict.\"\"\"\n        if \":\" not in line:\n            return\n\n        # Split property and value\n        prop_part, value = line.split(\":\", 1)\n\n        # Parse property name and parameters\n        parts = prop_part.split(\";\")\n        prop_name = parts[0].upper()\n        params = {}\n\n        for part in parts[1:]:\n            if \"=\" in part:\n                param_name, param_value = part.split(\"=\", 1)\n                params[param_name.upper()] = param_value.upper()\n            else:\n                # Type parameter without =\n                params[\"TYPE\"] = part.upper()\n\n        # Parse based on property\n        if prop_name == \"FN\":\n            data[\"display_name\"] = value\n\n        elif prop_name == \"N\":\n            # N format: Last;First;Middle;Prefix;Suffix\n            n_parts = value.split(\";\")\n            if len(n_parts) >= 1:\n                data[\"last_name\"] = n_parts[0] or None\n            if len(n_parts) >= 2:\n                data[\"first_name\"] = n_parts[1] or None\n            if len(n_parts) >= 3:\n                data[\"middle_name\"] = n_parts[2] or None\n            if len(n_parts) >= 4:\n                data[\"prefix\"] = n_parts[3] or None\n            if len(n_parts) >= 5:\n                data[\"suffix\"] = n_parts[4] or None\n\n        elif prop_name == \"NICKNAME\":\n            data[\"nickname\"] = value\n\n        elif prop_name == \"UID\":\n            data[\"uid\"] = value\n\n        elif prop_name == \"EMAIL\":\n            email_type = EmailType.OTHER\n            if \"WORK\" in params.get(\"TYPE\", \"\"):\n                email_type = EmailType.WORK\n            elif \"HOME\" in params.get(\"TYPE\", \"\"):\n                email_type = EmailType.HOME\n\n            data[\"emails\"].append(\n                EmailAddress(\n                    email=value,\n                    type=email_type,\n                    is_primary=\"PREF\" in params.get(\"TYPE\", \"\"),\n                )\n            )\n\n        elif prop_name == \"TEL\":\n            phone_type = PhoneType.OTHER\n            type_val = params.get(\"TYPE\", \"\")\n            if \"CELL\" in type_val or \"MOBILE\" in type_val:\n                phone_type = PhoneType.CELL\n            elif \"WORK\" in type_val:\n                phone_type = PhoneType.WORK\n            elif \"HOME\" in type_val:\n                phone_type = PhoneType.HOME\n            elif \"FAX\" in type_val:\n                phone_type = PhoneType.FAX\n\n            data[\"phones\"].append(\n                PhoneNumber(\n                    number=value,\n                    type=phone_type,\n                    is_primary=\"PREF\" in type_val,\n                )\n            )\n\n        elif prop_name == \"ADR\":\n            # ADR format: PO Box;Extended;Street;City;State;Postal;Country\n            addr_parts = value.split(\";\")\n\n            addr_type = AddressType.OTHER\n            if \"WORK\" in params.get(\"TYPE\", \"\"):\n                addr_type = AddressType.WORK\n            elif \"HOME\" in params.get(\"TYPE\", \"\"):\n                addr_type = AddressType.HOME\n\n            data[\"addresses\"].append(\n                PostalAddress(\n                    street=addr_parts[2] if len(addr_parts) > 2 else None,\n                    city=addr_parts[3] if len(addr_parts) > 3 else None,\n                    state=addr_parts[4] if len(addr_parts) > 4 else None,\n                    postal_code=addr_parts[5] if len(addr_parts) > 5 else None,\n                    country=addr_parts[6] if len(addr_parts) > 6 else None,\n                    type=addr_type,\n                )\n            )\n\n        elif prop_name == \"ORG\":\n            data[\"organization\"] = value.split(\";\")[0]  # First part is org name\n\n        elif prop_name == \"TITLE\":\n            data[\"title\"] = value\n\n        elif prop_name == \"NOTE\":\n            data[\"notes\"] = value\n\n        elif prop_name == \"URL\":\n            data[\"website\"] = value\n\n        elif prop_name == \"BDAY\":\n            try:\n                # Try ISO format first\n                if \"T\" in value:\n                    data[\"birthday\"] = datetime.fromisoformat(value.replace(\"Z\", \"+00:00\"))\n                else:\n                    data[\"birthday\"] = datetime.strptime(value, \"%Y%m%d\")\n            except ValueError:\n                pass\n\n        elif prop_name == \"CATEGORIES\":\n            data[\"categories\"] = [c.strip() for c in value.split(\",\")]\n\n        elif prop_name == \"PHOTO\":\n            if \"ENCODING\" in params:\n                # Base64 encoded photo\n                data[\"photo\"] = value\n                data[\"photo_type\"] = params.get(\"TYPE\", \"JPEG\")\n\n    async def get_contact(\n        self,\n        uid: str,\n        address_book: str = \"contacts\",\n    ) -> Optional[Contact]:\n        \"\"\"Get a single contact by UID.\"\"\"\n        url = f\"{self.carddav_url}/{address_book}/{uid}.vcf\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.get(url, timeout=30.0)\n\n            if response.status_code == 404:\n                return None\n\n            response.raise_for_status()\n\n        contact = self._parse_vcard(response.text)\n        if contact:\n            contact.etag = response.headers.get(\"ETag\", \"\").strip('\"')\n\n        return contact\n\n    async def create_contact(\n        self,\n        contact: Contact,\n        address_book: str = \"contacts\",\n    ) -> str:\n        \"\"\"Create a new contact.\"\"\"\n        uid = contact.uid or str(uuid.uuid4())\n        url = f\"{self.carddav_url}/{address_book}/{uid}.vcf\"\n\n        vcard = self._contact_to_vcard(contact, uid)\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.put(\n                url,\n                content=vcard,\n                headers={\"Content-Type\": \"text/vcard; charset=utf-8\"},\n                timeout=30.0,\n            )\n            response.raise_for_status()\n\n        logger.info(f\"Created contact {uid}\")\n        return uid\n\n    async def update_contact(\n        self,\n        contact: Contact,\n        address_book: str = \"contacts\",\n    ) -> bool:\n        \"\"\"Update an existing contact.\"\"\"\n        if not contact.uid:\n            raise ValueError(\"Contact UID is required for update\")\n\n        url = f\"{self.carddav_url}/{address_book}/{contact.uid}.vcf\"\n\n        vcard = self._contact_to_vcard(contact, contact.uid)\n\n        headers = {\"Content-Type\": \"text/vcard; charset=utf-8\"}\n\n        # Add If-Match header for optimistic locking if we have etag\n        if contact.etag:\n            headers[\"If-Match\"] = f'\"{contact.etag}\"'\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.put(\n                url,\n                content=vcard,\n                headers=headers,\n                timeout=30.0,\n            )\n            response.raise_for_status()\n\n        logger.info(f\"Updated contact {contact.uid}\")\n        return True\n\n    async def delete_contact(\n        self,\n        uid: str,\n        address_book: str = \"contacts\",\n    ) -> bool:\n        \"\"\"Delete a contact.\"\"\"\n        url = f\"{self.carddav_url}/{address_book}/{uid}.vcf\"\n\n        async with httpx.AsyncClient(auth=self._get_auth()) as client:\n            response = await client.delete(url, timeout=30.0)\n\n            if response.status_code == 404:\n                return False\n\n            response.raise_for_status()\n\n        logger.info(f\"Deleted contact {uid}\")\n        return True\n\n    def _contact_to_vcard(self, contact: Contact, uid: str) -> str:\n        \"\"\"Convert Contact to vCard 3.0 format.\"\"\"\n        lines = [\n            \"BEGIN:VCARD\",\n            \"VERSION:3.0\",\n            f\"UID:{uid}\",\n        ]\n\n        # Full name\n        if contact.display_name:\n            lines.append(f\"FN:{contact.display_name}\")\n\n        # Structured name\n        n_parts = [\n            contact.last_name or \"\",\n            contact.first_name or \"\",\n            contact.middle_name or \"\",\n            contact.prefix or \"\",\n            contact.suffix or \"\",\n        ]\n        lines.append(f\"N:{';'.join(n_parts)}\")\n\n        # Nickname\n        if contact.nickname:\n            lines.append(f\"NICKNAME:{contact.nickname}\")\n\n        # Emails\n        for i, email in enumerate(contact.emails):\n            type_str = f\"TYPE={email.type.value}\"\n            if email.is_primary:\n                type_str += \",PREF\"\n            lines.append(f\"EMAIL;{type_str}:{email.email}\")\n\n        # Phones\n        for phone in contact.phones:\n            type_str = f\"TYPE={phone.type.value}\"\n            if phone.is_primary:\n                type_str += \",PREF\"\n            lines.append(f\"TEL;{type_str}:{phone.number}\")\n\n        # Addresses\n        for addr in contact.addresses:\n            lines.append(f\"ADR;TYPE={addr.type.value}:{addr.to_vcard_value()}\")\n\n        # Organization\n        if contact.organization:\n            lines.append(f\"ORG:{contact.organization}\")\n\n        if contact.title:\n            lines.append(f\"TITLE:{contact.title}\")\n\n        # Birthday\n        if contact.birthday:\n            lines.append(f\"BDAY:{contact.birthday.strftime('%Y%m%d')}\")\n\n        # Notes\n        if contact.notes:\n            # Escape special characters\n            notes = contact.notes.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\")\n            lines.append(f\"NOTE:{notes}\")\n\n        # Website\n        if contact.website:\n            lines.append(f\"URL:{contact.website}\")\n\n        # Categories\n        if contact.categories:\n            lines.append(f\"CATEGORIES:{','.join(contact.categories)}\")\n\n        # Photo\n        if contact.photo:\n            photo_type = contact.photo_type or \"JPEG\"\n            lines.append(f\"PHOTO;ENCODING=b;TYPE={photo_type}:{contact.photo}\")\n\n        # Timestamp\n        lines.append(f\"REV:{datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}\")\n\n        lines.append(\"END:VCARD\")\n\n        return \"\\r\\n\".join(lines)\n\n    async def search_contacts(\n        self,\n        query: str,\n        address_book: str = \"contacts\",\n        limit: int = 100,\n    ) -> List[Contact]:\n        \"\"\"Search contacts by text.\"\"\"\n        search_query = ContactSearchQuery(text=query, limit=limit)\n        return await self.list_contacts(address_book, search_query)\n\n    async def get_contact_groups(\n        self,\n        address_book: str = \"contacts\",\n    ) -> List[str]:\n        \"\"\"Get all unique contact categories/groups.\"\"\"\n        contacts = await self.list_contacts(address_book)\n\n        groups = set()\n        for contact in contacts:\n            groups.update(contact.categories)\n\n        return sorted(groups)\n\n\n# Singleton instance\n_carddav_service: Optional[CardDAVService] = None\n\n\ndef get_carddav_service() -> Optional[CardDAVService]:\n    \"\"\"Get CardDAV service singleton.\"\"\"\n    return _carddav_service\n\n\ndef configure_carddav_service(\n    base_url: str,\n    username: str,\n    password: str,\n) -> CardDAVService:\n    \"\"\"Configure and return CardDAV service.\"\"\"\n    global _carddav_service\n    _carddav_service = CardDAVService(\n        base_url=base_url,\n        username=username,\n        password=password,\n    )\n    return _carddav_service\n"
}
