{
  "path": "services/api-gateway/app/services/dictation_service.py",
  "language": "python",
  "size": 22377,
  "last_modified": "2025-12-04T12:32:40.271Z",
  "lines": 713,
  "content": "\"\"\"\nDictation Service - Medical Documentation Dictation\n\nPhase 8: Hands-free clinical documentation system.\n\nThis service manages medical dictation sessions including:\n- SOAP, H&P, Progress, and Procedure note types\n- Section-based navigation (Subjective, Objective, Assessment, Plan)\n- Real-time transcription with medical vocabulary boosting\n- Voice command integration for hands-free editing\n- LLM-assisted formatting and grammar correction\n\nNote Types Supported:\n- SOAP: Subjective, Objective, Assessment, Plan\n- H&P: History and Physical\n- Progress: Progress Note\n- Procedure: Procedure Note\n- Custom: User-defined templates\n\"\"\"\n\nimport time\nimport uuid\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Awaitable, Callable, Dict, List, Optional\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Enums\n# ==============================================================================\n\n\nclass DictationState(str, Enum):\n    \"\"\"State of the dictation session.\"\"\"\n\n    IDLE = \"idle\"  # Not actively dictating\n    LISTENING = \"listening\"  # Actively capturing audio\n    PROCESSING = \"processing\"  # Processing/formatting transcription\n    PAUSED = \"paused\"  # Temporarily paused by user\n    REVIEWING = \"reviewing\"  # User is reviewing/editing the note\n    SAVING = \"saving\"  # Saving the note\n    COMPLETED = \"completed\"  # Dictation finished and saved\n\n\nclass NoteType(str, Enum):\n    \"\"\"Types of medical notes.\"\"\"\n\n    SOAP = \"soap\"  # Subjective, Objective, Assessment, Plan\n    HP = \"h_and_p\"  # History and Physical\n    PROGRESS = \"progress\"  # Progress Note\n    PROCEDURE = \"procedure\"  # Procedure Note\n    CONSULT = \"consult\"  # Consultation Note\n    DISCHARGE = \"discharge\"  # Discharge Summary\n    CUSTOM = \"custom\"  # User-defined template\n\n\nclass NoteSection(str, Enum):\n    \"\"\"Sections within notes (primarily for SOAP notes).\"\"\"\n\n    # SOAP sections\n    SUBJECTIVE = \"subjective\"\n    OBJECTIVE = \"objective\"\n    ASSESSMENT = \"assessment\"\n    PLAN = \"plan\"\n\n    # H&P sections\n    CHIEF_COMPLAINT = \"chief_complaint\"\n    HPI = \"history_present_illness\"\n    PMH = \"past_medical_history\"\n    MEDICATIONS = \"medications\"\n    ALLERGIES = \"allergies\"\n    SOCIAL_HISTORY = \"social_history\"\n    FAMILY_HISTORY = \"family_history\"\n    ROS = \"review_of_systems\"\n    PHYSICAL_EXAM = \"physical_exam\"\n    LABS = \"labs_imaging\"\n    IMPRESSION = \"impression\"\n\n    # General sections\n    NOTES = \"notes\"\n    CUSTOM = \"custom\"\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\n@dataclass\nclass NoteSectionContent:\n    \"\"\"Content for a single section of a note.\"\"\"\n\n    section: NoteSection\n    content: str = \"\"\n    raw_transcript: str = \"\"  # Original unformatted transcript\n    word_count: int = 0\n    last_updated: float = field(default_factory=time.time)\n    is_complete: bool = False\n\n\n@dataclass\nclass DictationNote:\n    \"\"\"A complete medical dictation note.\"\"\"\n\n    note_id: str\n    note_type: NoteType\n    user_id: str\n    patient_context: Optional[str] = None  # Anonymized patient identifier\n\n    # Content\n    sections: Dict[NoteSection, NoteSectionContent] = field(default_factory=dict)\n    current_section: NoteSection = NoteSection.SUBJECTIVE\n\n    # Metadata\n    created_at: float = field(default_factory=time.time)\n    updated_at: float = field(default_factory=time.time)\n    total_word_count: int = 0\n    duration_seconds: int = 0\n\n    # Status\n    is_draft: bool = True\n    is_saved: bool = False\n\n\n@dataclass\nclass DictationSessionConfig:\n    \"\"\"Configuration for a dictation session.\"\"\"\n\n    note_type: NoteType = NoteType.SOAP\n    language: str = \"en\"\n    specialty: Optional[str] = None  # e.g., \"cardiology\", \"oncology\"\n    auto_punctuate: bool = True\n    auto_format: bool = True\n    enable_commands: bool = True\n    patient_context: Optional[str] = None\n\n\n@dataclass\nclass DictationEvent:\n    \"\"\"Event emitted during dictation.\"\"\"\n\n    event_type: str  # \"state_change\", \"section_update\", \"command\", \"error\"\n    data: Dict[str, Any] = field(default_factory=dict)\n    timestamp: float = field(default_factory=time.time)\n\n\n# ==============================================================================\n# Dictation Session\n# ==============================================================================\n\n\nclass DictationSession:\n    \"\"\"\n    A single dictation session for creating a medical note.\n\n    Manages:\n    - State transitions (listening, paused, reviewing, etc.)\n    - Section-based content accumulation\n    - Voice command processing\n    - Event emission for real-time updates\n    \"\"\"\n\n    # Section order for different note types\n    SECTION_ORDER = {\n        NoteType.SOAP: [\n            NoteSection.SUBJECTIVE,\n            NoteSection.OBJECTIVE,\n            NoteSection.ASSESSMENT,\n            NoteSection.PLAN,\n        ],\n        NoteType.HP: [\n            NoteSection.CHIEF_COMPLAINT,\n            NoteSection.HPI,\n            NoteSection.PMH,\n            NoteSection.MEDICATIONS,\n            NoteSection.ALLERGIES,\n            NoteSection.SOCIAL_HISTORY,\n            NoteSection.FAMILY_HISTORY,\n            NoteSection.ROS,\n            NoteSection.PHYSICAL_EXAM,\n            NoteSection.LABS,\n            NoteSection.ASSESSMENT,\n            NoteSection.PLAN,\n        ],\n        NoteType.PROGRESS: [\n            NoteSection.SUBJECTIVE,\n            NoteSection.OBJECTIVE,\n            NoteSection.ASSESSMENT,\n            NoteSection.PLAN,\n        ],\n        NoteType.PROCEDURE: [\n            NoteSection.IMPRESSION,\n            NoteSection.NOTES,\n        ],\n    }\n\n    def __init__(\n        self,\n        session_id: str,\n        user_id: str,\n        config: DictationSessionConfig,\n        on_event: Optional[Callable[[DictationEvent], Awaitable[None]]] = None,\n    ):\n        self.session_id = session_id\n        self.user_id = user_id\n        self.config = config\n        self._on_event = on_event\n\n        # State\n        self._state = DictationState.IDLE\n        self._start_time: Optional[float] = None\n\n        # Note\n        self._note = DictationNote(\n            note_id=str(uuid.uuid4()),\n            note_type=config.note_type,\n            user_id=user_id,\n            patient_context=config.patient_context,\n        )\n\n        # Initialize sections based on note type\n        self._initialize_sections()\n\n        # Transcript buffer for current section\n        self._transcript_buffer: List[str] = []\n        self._last_transcript_time: float = 0.0\n\n    def _initialize_sections(self) -> None:\n        \"\"\"Initialize note sections based on note type.\"\"\"\n        sections = self.SECTION_ORDER.get(self.config.note_type, [NoteSection.NOTES])\n        for section in sections:\n            self._note.sections[section] = NoteSectionContent(section=section)\n\n        # Set initial section\n        if sections:\n            self._note.current_section = sections[0]\n\n    @property\n    def state(self) -> DictationState:\n        \"\"\"Get current dictation state.\"\"\"\n        return self._state\n\n    @property\n    def note(self) -> DictationNote:\n        \"\"\"Get the current note.\"\"\"\n        return self._note\n\n    @property\n    def current_section(self) -> NoteSection:\n        \"\"\"Get the current section being dictated.\"\"\"\n        return self._note.current_section\n\n    async def start(self) -> bool:\n        \"\"\"\n        Start the dictation session.\n\n        Returns:\n            True if started successfully\n        \"\"\"\n        if self._state != DictationState.IDLE:\n            logger.warning(f\"Cannot start dictation in state {self._state}\")\n            return False\n\n        self._state = DictationState.LISTENING\n        self._start_time = time.time()\n\n        await self._emit_event(\n            \"state_change\",\n            {\n                \"state\": self._state.value,\n                \"note_type\": self.config.note_type.value,\n                \"current_section\": self._note.current_section.value,\n            },\n        )\n\n        logger.info(f\"Dictation session started: {self.session_id}\")\n        return True\n\n    async def pause(self) -> bool:\n        \"\"\"Pause dictation.\"\"\"\n        if self._state != DictationState.LISTENING:\n            return False\n\n        self._state = DictationState.PAUSED\n        await self._emit_event(\"state_change\", {\"state\": self._state.value})\n        logger.info(f\"Dictation paused: {self.session_id}\")\n        return True\n\n    async def resume(self) -> bool:\n        \"\"\"Resume dictation from pause.\"\"\"\n        if self._state != DictationState.PAUSED:\n            return False\n\n        self._state = DictationState.LISTENING\n        await self._emit_event(\"state_change\", {\"state\": self._state.value})\n        logger.info(f\"Dictation resumed: {self.session_id}\")\n        return True\n\n    async def stop(self) -> DictationNote:\n        \"\"\"\n        Stop dictation and return the note.\n\n        Returns:\n            The completed DictationNote\n        \"\"\"\n        # Flush any buffered transcript\n        await self._flush_buffer()\n\n        # Calculate duration\n        if self._start_time:\n            self._note.duration_seconds = int(time.time() - self._start_time)\n\n        # Calculate total word count\n        self._note.total_word_count = sum(section.word_count for section in self._note.sections.values())\n\n        self._state = DictationState.COMPLETED\n        self._note.updated_at = time.time()\n\n        await self._emit_event(\n            \"state_change\",\n            {\n                \"state\": self._state.value,\n                \"duration_seconds\": self._note.duration_seconds,\n                \"total_word_count\": self._note.total_word_count,\n            },\n        )\n\n        logger.info(\n            f\"Dictation stopped: {self.session_id}, \"\n            f\"duration={self._note.duration_seconds}s, \"\n            f\"words={self._note.total_word_count}\"\n        )\n\n        return self._note\n\n    async def add_transcript(\n        self,\n        text: str,\n        is_final: bool = False,\n        confidence: float = 1.0,\n    ) -> None:\n        \"\"\"\n        Add transcribed text to the current section.\n\n        Args:\n            text: Transcribed text\n            is_final: Whether this is a final (not partial) transcript\n            confidence: STT confidence score\n        \"\"\"\n        if self._state != DictationState.LISTENING:\n            return\n\n        self._last_transcript_time = time.time()\n\n        if is_final:\n            # Add to buffer\n            self._transcript_buffer.append(text)\n\n            # Update section\n            current_section = self._note.sections[self._note.current_section]\n            current_section.raw_transcript += \" \" + text if current_section.raw_transcript else text\n            current_section.content = current_section.raw_transcript  # TODO: Apply formatting\n            current_section.word_count = len(current_section.content.split())\n            current_section.last_updated = time.time()\n\n            await self._emit_event(\n                \"section_update\",\n                {\n                    \"section\": self._note.current_section.value,\n                    \"content\": current_section.content,\n                    \"word_count\": current_section.word_count,\n                    \"is_final\": True,\n                },\n            )\n        else:\n            # Partial transcript - emit for real-time display\n            await self._emit_event(\n                \"section_update\",\n                {\n                    \"section\": self._note.current_section.value,\n                    \"partial_text\": text,\n                    \"is_final\": False,\n                },\n            )\n\n    async def go_to_section(self, section: NoteSection) -> bool:\n        \"\"\"\n        Navigate to a specific section.\n\n        Args:\n            section: The section to navigate to\n\n        Returns:\n            True if navigation was successful\n        \"\"\"\n        if section not in self._note.sections:\n            logger.warning(f\"Section {section.value} not available for {self.config.note_type.value}\")\n            return False\n\n        # Flush buffer before changing sections\n        await self._flush_buffer()\n\n        previous_section = self._note.current_section\n        self._note.current_section = section\n\n        await self._emit_event(\n            \"section_change\",\n            {\n                \"previous_section\": previous_section.value,\n                \"current_section\": section.value,\n            },\n        )\n\n        logger.info(f\"Navigated to section: {section.value}\")\n        return True\n\n    async def next_section(self) -> bool:\n        \"\"\"Navigate to the next section.\"\"\"\n        sections = self.SECTION_ORDER.get(self.config.note_type, [])\n        if not sections:\n            return False\n\n        try:\n            current_idx = sections.index(self._note.current_section)\n            if current_idx < len(sections) - 1:\n                return await self.go_to_section(sections[current_idx + 1])\n        except ValueError:\n            pass\n\n        return False\n\n    async def previous_section(self) -> bool:\n        \"\"\"Navigate to the previous section.\"\"\"\n        sections = self.SECTION_ORDER.get(self.config.note_type, [])\n        if not sections:\n            return False\n\n        try:\n            current_idx = sections.index(self._note.current_section)\n            if current_idx > 0:\n                return await self.go_to_section(sections[current_idx - 1])\n        except ValueError:\n            pass\n\n        return False\n\n    async def delete_last(self) -> bool:\n        \"\"\"Delete the last sentence/phrase.\"\"\"\n        current_section = self._note.sections[self._note.current_section]\n        if not current_section.content:\n            return False\n\n        # Find and remove the last sentence\n        content = current_section.content.rstrip()\n        # Find the last sentence boundary\n        for delimiter in [\". \", \"! \", \"? \", \"\\n\"]:\n            if delimiter in content:\n                idx = content.rfind(delimiter)\n                content = content[: idx + 1]\n                break\n        else:\n            # No sentence boundary, delete last word\n            words = content.split()\n            if words:\n                content = \" \".join(words[:-1])\n\n        current_section.content = content\n        current_section.word_count = len(content.split())\n        current_section.last_updated = time.time()\n\n        await self._emit_event(\n            \"section_update\",\n            {\n                \"section\": self._note.current_section.value,\n                \"content\": current_section.content,\n                \"word_count\": current_section.word_count,\n                \"is_final\": True,\n                \"deleted\": True,\n            },\n        )\n\n        return True\n\n    async def undo(self) -> bool:\n        \"\"\"Undo the last action (if buffer available).\"\"\"\n        if not self._transcript_buffer:\n            return False\n\n        # Remove last buffered item\n        removed = self._transcript_buffer.pop()\n\n        # Rebuild section content\n        current_section = self._note.sections[self._note.current_section]\n        if current_section.content.endswith(removed):\n            current_section.content = current_section.content[: -len(removed)].rstrip()\n            current_section.raw_transcript = current_section.content\n            current_section.word_count = len(current_section.content.split())\n            current_section.last_updated = time.time()\n\n        await self._emit_event(\n            \"section_update\",\n            {\n                \"section\": self._note.current_section.value,\n                \"content\": current_section.content,\n                \"word_count\": current_section.word_count,\n                \"is_final\": True,\n                \"undo\": True,\n            },\n        )\n\n        return True\n\n    async def insert_text(self, text: str) -> None:\n        \"\"\"Insert formatted text at the current position.\"\"\"\n        current_section = self._note.sections[self._note.current_section]\n\n        if current_section.content:\n            current_section.content += \" \" + text\n        else:\n            current_section.content = text\n\n        current_section.word_count = len(current_section.content.split())\n        current_section.last_updated = time.time()\n\n        await self._emit_event(\n            \"section_update\",\n            {\n                \"section\": self._note.current_section.value,\n                \"content\": current_section.content,\n                \"word_count\": current_section.word_count,\n                \"is_final\": True,\n            },\n        )\n\n    async def read_back(self) -> str:\n        \"\"\"Get the content of the current section for TTS playback.\"\"\"\n        current_section = self._note.sections[self._note.current_section]\n        return current_section.content\n\n    async def get_full_note(self) -> str:\n        \"\"\"Get the full formatted note content.\"\"\"\n        parts = []\n\n        for section in self.SECTION_ORDER.get(self.config.note_type, [NoteSection.NOTES]):\n            if section in self._note.sections:\n                section_content = self._note.sections[section]\n                if section_content.content:\n                    parts.append(f\"## {section.value.upper().replace('_', ' ')}\")\n                    parts.append(section_content.content)\n                    parts.append(\"\")\n\n        return \"\\n\".join(parts)\n\n    async def _flush_buffer(self) -> None:\n        \"\"\"Flush the transcript buffer.\"\"\"\n        # Buffer is already processed in add_transcript\n        self._transcript_buffer = []\n\n    async def _emit_event(self, event_type: str, data: Dict[str, Any]) -> None:\n        \"\"\"Emit a dictation event.\"\"\"\n        if self._on_event:\n            event = DictationEvent(event_type=event_type, data=data)\n            try:\n                await self._on_event(event)\n            except Exception as e:\n                logger.error(f\"Error emitting dictation event: {e}\")\n\n\n# ==============================================================================\n# Dictation Service\n# ==============================================================================\n\n\nclass DictationService:\n    \"\"\"\n    Main service for managing medical dictation sessions.\n\n    Usage:\n        service = DictationService()\n\n        # Create a session\n        session = await service.create_session(\n            user_id=\"user-123\",\n            config=DictationSessionConfig(\n                note_type=NoteType.SOAP,\n                specialty=\"cardiology\",\n            ),\n            on_event=handle_dictation_event,\n        )\n\n        # Start dictation\n        await session.start()\n\n        # Add transcribed text\n        await session.add_transcript(\"Patient presents with chest pain\", is_final=True)\n\n        # Navigate sections\n        await session.next_section()\n\n        # Stop and get note\n        note = await session.stop()\n    \"\"\"\n\n    def __init__(self):\n        self._sessions: Dict[str, DictationSession] = {}\n\n    async def create_session(\n        self,\n        user_id: str,\n        config: Optional[DictationSessionConfig] = None,\n        on_event: Optional[Callable[[DictationEvent], Awaitable[None]]] = None,\n    ) -> DictationSession:\n        \"\"\"\n        Create a new dictation session.\n\n        Args:\n            user_id: User ID\n            config: Session configuration\n            on_event: Callback for dictation events\n\n        Returns:\n            DictationSession instance\n        \"\"\"\n        session_id = str(uuid.uuid4())\n        config = config or DictationSessionConfig()\n\n        session = DictationSession(\n            session_id=session_id,\n            user_id=user_id,\n            config=config,\n            on_event=on_event,\n        )\n\n        self._sessions[session_id] = session\n\n        logger.info(\n            f\"Created dictation session: {session_id}, \"\n            f\"type={config.note_type.value}, \"\n            f\"specialty={config.specialty}\"\n        )\n\n        return session\n\n    def get_session(self, session_id: str) -> Optional[DictationSession]:\n        \"\"\"Get an active dictation session.\"\"\"\n        return self._sessions.get(session_id)\n\n    async def remove_session(self, session_id: str) -> Optional[DictationNote]:\n        \"\"\"\n        Remove a dictation session.\n\n        Returns:\n            The note from the session, if any\n        \"\"\"\n        session = self._sessions.pop(session_id, None)\n        if session:\n            if session.state != DictationState.COMPLETED:\n                note = await session.stop()\n            else:\n                note = session.note\n            logger.info(f\"Removed dictation session: {session_id}\")\n            return note\n        return None\n\n    def get_active_sessions(self, user_id: Optional[str] = None) -> List[str]:\n        \"\"\"Get list of active session IDs, optionally filtered by user.\"\"\"\n        if user_id:\n            return [sid for sid, session in self._sessions.items() if session.user_id == user_id]\n        return list(self._sessions.keys())\n\n    def get_note_types(self) -> List[Dict[str, str]]:\n        \"\"\"Get available note types with descriptions.\"\"\"\n        return [\n            {\n                \"type\": NoteType.SOAP.value,\n                \"name\": \"SOAP Note\",\n                \"description\": \"Subjective, Objective, Assessment, Plan\",\n            },\n            {\n                \"type\": NoteType.HP.value,\n                \"name\": \"History & Physical\",\n                \"description\": \"Comprehensive H&P\",\n            },\n            {\n                \"type\": NoteType.PROGRESS.value,\n                \"name\": \"Progress Note\",\n                \"description\": \"Follow-up progress note\",\n            },\n            {\n                \"type\": NoteType.PROCEDURE.value,\n                \"name\": \"Procedure Note\",\n                \"description\": \"Procedure documentation\",\n            },\n            {\n                \"type\": NoteType.CONSULT.value,\n                \"name\": \"Consultation\",\n                \"description\": \"Consultation note\",\n            },\n            {\n                \"type\": NoteType.DISCHARGE.value,\n                \"name\": \"Discharge Summary\",\n                \"description\": \"Discharge summary\",\n            },\n        ]\n\n\n# Global service instance\ndictation_service = DictationService()\n"
}
