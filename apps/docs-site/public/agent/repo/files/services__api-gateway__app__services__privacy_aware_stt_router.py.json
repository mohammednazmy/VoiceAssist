{
  "path": "services/api-gateway/app/services/privacy_aware_stt_router.py",
  "language": "python",
  "size": 22761,
  "last_modified": "2025-12-05T03:11:51.621Z",
  "lines": 653,
  "content": "\"\"\"\nPrivacy-Aware STT Router - PHI-Safe Speech-to-Text Routing\n\nVoice Mode v4 - Phase 1 Foundation (Privacy & Compliance)\n\nRoutes audio transcription requests to appropriate STT providers:\n- Cloud STT (Deepgram) for non-PHI conversations\n- Local Whisper for PHI-containing or sensitive sessions\n- Hybrid mode with real-time PHI detection and provider switching\n\nEnsures HIPAA compliance by keeping PHI data on-premise.\n\"\"\"\n\nimport asyncio\nimport logging\nimport re\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nimport numpy as np\n\nfrom app.services.local_whisper_service import (\n    LocalWhisperService,\n    TranscriptionLanguage,\n    TranscriptionResult,\n    WhisperConfig,\n    WhisperModelSize,\n    get_local_whisper_service,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass STTProvider(Enum):\n    \"\"\"Available STT providers.\"\"\"\n    DEEPGRAM = \"deepgram\"  # Cloud provider (fast, accurate)\n    WHISPER_LOCAL = \"whisper_local\"  # Local Whisper (PHI-safe)\n    WHISPER_API = \"whisper_api\"  # OpenAI Whisper API (cloud)\n    AZURE_SPEECH = \"azure_speech\"  # Azure Speech Services\n    GOOGLE_SPEECH = \"google_speech\"  # Google Cloud Speech-to-Text\n\n\nclass RoutingPolicy(Enum):\n    \"\"\"Routing policy options.\"\"\"\n    ALWAYS_LOCAL = \"always_local\"  # Always use local Whisper\n    ALWAYS_CLOUD = \"always_cloud\"  # Always use cloud (not HIPAA-safe)\n    PHI_AWARE = \"phi_aware\"  # Route based on PHI detection\n    SESSION_BASED = \"session_based\"  # Route based on session flags\n    HYBRID = \"hybrid\"  # Start cloud, switch to local on PHI detection\n\n\nclass PHICategory(Enum):\n    \"\"\"Categories of PHI detected.\"\"\"\n    NONE = \"none\"\n    NAME = \"name\"\n    DOB = \"date_of_birth\"\n    SSN = \"social_security\"\n    MRN = \"medical_record_number\"\n    PHONE = \"phone_number\"\n    EMAIL = \"email\"\n    ADDRESS = \"address\"\n    DIAGNOSIS = \"diagnosis\"\n    MEDICATION = \"medication\"\n    PROCEDURE = \"procedure\"\n    LAB_RESULT = \"lab_result\"\n    INSURANCE = \"insurance\"\n    UNKNOWN = \"unknown\"\n\n\n@dataclass\nclass RoutingDecision:\n    \"\"\"Result of a routing decision.\"\"\"\n    provider: STTProvider\n    reason: str\n    phi_detected: bool\n    phi_categories: List[PHICategory]\n    confidence: float\n    session_id: Optional[str] = None\n    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n\n@dataclass\nclass PrivacyRouterConfig:\n    \"\"\"Configuration for privacy-aware STT routing.\"\"\"\n    # Routing policy\n    policy: RoutingPolicy = RoutingPolicy.PHI_AWARE\n\n    # Default provider for non-PHI\n    default_provider: STTProvider = STTProvider.DEEPGRAM\n\n    # PHI-safe provider\n    phi_safe_provider: STTProvider = STTProvider.WHISPER_LOCAL\n\n    # PHI detection settings\n    enable_real_time_phi_detection: bool = True\n    phi_detection_threshold: float = 0.7\n\n    # Session-based overrides\n    allow_session_override: bool = True\n\n    # Fallback settings\n    enable_fallback: bool = True\n    fallback_provider: STTProvider = STTProvider.WHISPER_LOCAL\n\n    # Caching\n    cache_routing_decisions: bool = True\n    decision_cache_ttl_seconds: int = 300\n\n    # Logging\n    log_phi_detection: bool = True  # Log detection events (not PHI content)\n    audit_all_decisions: bool = True\n\n\n@dataclass\nclass RouterMetrics:\n    \"\"\"Metrics for STT routing.\"\"\"\n    total_requests: int = 0\n    cloud_requests: int = 0\n    local_requests: int = 0\n    phi_detected_count: int = 0\n    provider_switches: int = 0\n    fallback_activations: int = 0\n    avg_decision_time_ms: float = 0.0\n    phi_categories_detected: Dict[str, int] = field(default_factory=dict)\n\n\n# PHI detection patterns (simplified - production should use NER)\nPHI_PATTERNS = {\n    PHICategory.SSN: [\n        r'\\b\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}\\b',  # SSN format\n    ],\n    PHICategory.PHONE: [\n        r'\\b\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4}\\b',  # US phone\n        r'\\b\\(\\d{3}\\)\\s?\\d{3}[-.\\s]?\\d{4}\\b',  # (xxx) xxx-xxxx\n    ],\n    PHICategory.EMAIL: [\n        r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',\n    ],\n    PHICategory.MRN: [\n        r'\\bMRN\\s*[:#]?\\s*\\d{6,12}\\b',\n        r'\\bmedical\\s+record\\s+number\\s*[:#]?\\s*\\d+\\b',\n    ],\n    PHICategory.DOB: [\n        r'\\b(?:born|dob|date\\s+of\\s+birth)\\s*[:#]?\\s*\\d{1,2}[/-]\\d{1,2}[/-]\\d{2,4}\\b',\n    ],\n}\n\n# Keywords that suggest PHI context\nPHI_CONTEXT_KEYWORDS = [\n    \"patient\", \"diagnosis\", \"treatment\", \"prescription\", \"medication\",\n    \"insurance\", \"claim\", \"provider\", \"hospital\", \"clinic\", \"doctor\",\n    \"medical record\", \"health record\", \"test result\", \"lab result\",\n    \"blood pressure\", \"heart rate\", \"temperature\", \"weight\", \"height\",\n    \"allergies\", \"immunization\", \"vaccination\", \"surgery\", \"procedure\",\n]\n\n\nclass PrivacyAwareSTTRouter:\n    \"\"\"\n    Routes STT requests based on privacy requirements.\n\n    Ensures PHI-containing audio is processed locally while\n    allowing cloud processing for non-sensitive content.\n    \"\"\"\n\n    def __init__(self, config: Optional[PrivacyRouterConfig] = None):\n        self.config = config or PrivacyRouterConfig()\n        self._initialized = False\n        self._metrics = RouterMetrics()\n\n        # Provider instances\n        self._local_whisper: Optional[LocalWhisperService] = None\n        self._deepgram_client = None\n\n        # Session state\n        self._session_phi_state: Dict[str, bool] = {}  # session_id -> has_phi\n        self._decision_cache: Dict[str, RoutingDecision] = {}\n\n        # Callbacks\n        self._on_phi_detected: Optional[Callable[[str, List[PHICategory]], None]] = None\n        self._on_provider_switch: Optional[Callable[[str, STTProvider, STTProvider], None]] = None\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize the router and required providers.\"\"\"\n        if self._initialized:\n            return\n\n        logger.info(\n            \"Initializing PrivacyAwareSTTRouter\",\n            extra={\n                \"policy\": self.config.policy.value,\n                \"default_provider\": self.config.default_provider.value,\n                \"phi_safe_provider\": self.config.phi_safe_provider.value,\n            }\n        )\n\n        # Initialize local Whisper for PHI-safe processing\n        if self.config.phi_safe_provider == STTProvider.WHISPER_LOCAL:\n            self._local_whisper = get_local_whisper_service()\n            await self._local_whisper.initialize()\n\n        self._initialized = True\n\n    async def transcribe(\n        self,\n        audio: Union[bytes, np.ndarray],\n        session_id: Optional[str] = None,\n        language: Optional[TranscriptionLanguage] = None,\n        force_provider: Optional[STTProvider] = None,\n        context_text: Optional[str] = None,\n    ) -> Tuple[TranscriptionResult, RoutingDecision]:\n        \"\"\"\n        Transcribe audio with privacy-aware routing.\n\n        Args:\n            audio: Audio data (PCM16 bytes or numpy array)\n            session_id: Session identifier for state tracking\n            language: Language hint\n            force_provider: Override routing decision\n            context_text: Additional context for PHI detection\n\n        Returns:\n            Tuple of (TranscriptionResult, RoutingDecision)\n        \"\"\"\n        if not self._initialized:\n            await self.initialize()\n\n        start_time = datetime.now(timezone.utc)\n        self._metrics.total_requests += 1\n\n        # Determine routing\n        if force_provider:\n            decision = RoutingDecision(\n                provider=force_provider,\n                reason=\"forced_provider\",\n                phi_detected=False,\n                phi_categories=[],\n                confidence=1.0,\n                session_id=session_id,\n            )\n        else:\n            decision = await self._make_routing_decision(\n                audio, session_id, context_text\n            )\n\n        # Update metrics\n        decision_time = (datetime.now(timezone.utc) - start_time).total_seconds() * 1000\n        self._metrics.avg_decision_time_ms = (\n            self._metrics.avg_decision_time_ms * 0.9 + decision_time * 0.1\n        )\n\n        # Route to appropriate provider\n        try:\n            result = await self._transcribe_with_provider(\n                audio, decision.provider, language\n            )\n\n            # Post-transcription PHI check (for hybrid mode)\n            if self.config.policy == RoutingPolicy.HYBRID:\n                await self._post_transcription_phi_check(\n                    result, session_id, decision\n                )\n\n            return result, decision\n\n        except Exception as e:\n            logger.error(f\"Transcription error with {decision.provider}: {e}\")\n\n            # Try fallback\n            if self.config.enable_fallback:\n                return await self._fallback_transcription(\n                    audio, decision, language\n                )\n            raise\n\n    async def _make_routing_decision(\n        self,\n        audio: Union[bytes, np.ndarray],\n        session_id: Optional[str],\n        context_text: Optional[str],\n    ) -> RoutingDecision:\n        \"\"\"Make a routing decision based on policy and PHI detection.\"\"\"\n\n        # Check policy\n        if self.config.policy == RoutingPolicy.ALWAYS_LOCAL:\n            return RoutingDecision(\n                provider=STTProvider.WHISPER_LOCAL,\n                reason=\"always_local_policy\",\n                phi_detected=False,\n                phi_categories=[],\n                confidence=1.0,\n                session_id=session_id,\n            )\n\n        if self.config.policy == RoutingPolicy.ALWAYS_CLOUD:\n            return RoutingDecision(\n                provider=self.config.default_provider,\n                reason=\"always_cloud_policy\",\n                phi_detected=False,\n                phi_categories=[],\n                confidence=1.0,\n                session_id=session_id,\n            )\n\n        # Check session state\n        if session_id and self.config.policy == RoutingPolicy.SESSION_BASED:\n            if session_id in self._session_phi_state:\n                if self._session_phi_state[session_id]:\n                    return RoutingDecision(\n                        provider=self.config.phi_safe_provider,\n                        reason=\"session_marked_phi\",\n                        phi_detected=True,\n                        phi_categories=[PHICategory.UNKNOWN],\n                        confidence=1.0,\n                        session_id=session_id,\n                    )\n\n        # Check cached decision\n        if self.config.cache_routing_decisions and session_id:\n            cache_key = f\"{session_id}:latest\"\n            if cache_key in self._decision_cache:\n                cached = self._decision_cache[cache_key]\n                if cached.phi_detected:\n                    return RoutingDecision(\n                        provider=self.config.phi_safe_provider,\n                        reason=\"cached_phi_detection\",\n                        phi_detected=True,\n                        phi_categories=cached.phi_categories,\n                        confidence=cached.confidence,\n                        session_id=session_id,\n                    )\n\n        # PHI detection on context\n        phi_detected = False\n        phi_categories = []\n        confidence = 0.0\n\n        if context_text and self.config.enable_real_time_phi_detection:\n            phi_detected, phi_categories, confidence = self._detect_phi_in_text(\n                context_text\n            )\n\n        if phi_detected and confidence >= self.config.phi_detection_threshold:\n            self._metrics.phi_detected_count += 1\n\n            # Update session state\n            if session_id:\n                self._session_phi_state[session_id] = True\n\n            # Log detection (not content)\n            if self.config.log_phi_detection:\n                logger.info(\n                    \"PHI detected, routing to local provider\",\n                    extra={\n                        \"session_id\": session_id,\n                        \"categories\": [c.value for c in phi_categories],\n                        \"confidence\": confidence,\n                    }\n                )\n\n            # Callback\n            if self._on_phi_detected and session_id:\n                self._on_phi_detected(session_id, phi_categories)\n\n            decision = RoutingDecision(\n                provider=self.config.phi_safe_provider,\n                reason=\"phi_detected\",\n                phi_detected=True,\n                phi_categories=phi_categories,\n                confidence=confidence,\n                session_id=session_id,\n            )\n\n        else:\n            decision = RoutingDecision(\n                provider=self.config.default_provider,\n                reason=\"no_phi_detected\",\n                phi_detected=False,\n                phi_categories=[],\n                confidence=1.0 - confidence,\n                session_id=session_id,\n            )\n\n        # Cache decision\n        if self.config.cache_routing_decisions and session_id:\n            self._decision_cache[f\"{session_id}:latest\"] = decision\n\n        # Update metrics\n        if decision.provider in [STTProvider.DEEPGRAM, STTProvider.WHISPER_API,\n                                  STTProvider.AZURE_SPEECH, STTProvider.GOOGLE_SPEECH]:\n            self._metrics.cloud_requests += 1\n        else:\n            self._metrics.local_requests += 1\n\n        return decision\n\n    def _detect_phi_in_text(\n        self,\n        text: str\n    ) -> Tuple[bool, List[PHICategory], float]:\n        \"\"\"\n        Detect PHI in text using pattern matching.\n\n        Returns:\n            Tuple of (phi_detected, categories, confidence)\n        \"\"\"\n        detected_categories = []\n        max_confidence = 0.0\n\n        text_lower = text.lower()\n\n        # Check patterns\n        for category, patterns in PHI_PATTERNS.items():\n            for pattern in patterns:\n                if re.search(pattern, text, re.IGNORECASE):\n                    detected_categories.append(category)\n                    max_confidence = max(max_confidence, 0.9)\n\n                    # Update metrics\n                    cat_name = category.value\n                    self._metrics.phi_categories_detected[cat_name] = \\\n                        self._metrics.phi_categories_detected.get(cat_name, 0) + 1\n                    break\n\n        # Check context keywords\n        keyword_matches = sum(\n            1 for kw in PHI_CONTEXT_KEYWORDS\n            if kw in text_lower\n        )\n        if keyword_matches >= 2:\n            max_confidence = max(max_confidence, 0.5 + (keyword_matches * 0.1))\n            if PHICategory.UNKNOWN not in detected_categories:\n                detected_categories.append(PHICategory.UNKNOWN)\n\n        return len(detected_categories) > 0, detected_categories, max_confidence\n\n    async def _transcribe_with_provider(\n        self,\n        audio: Union[bytes, np.ndarray],\n        provider: STTProvider,\n        language: Optional[TranscriptionLanguage],\n    ) -> TranscriptionResult:\n        \"\"\"Transcribe audio using the specified provider.\"\"\"\n\n        if provider == STTProvider.WHISPER_LOCAL:\n            if not self._local_whisper:\n                self._local_whisper = get_local_whisper_service()\n                await self._local_whisper.initialize()\n            return await self._local_whisper.transcribe(audio, language=language)\n\n        elif provider == STTProvider.DEEPGRAM:\n            return await self._transcribe_deepgram(audio, language)\n\n        elif provider == STTProvider.WHISPER_API:\n            return await self._transcribe_whisper_api(audio, language)\n\n        else:\n            raise ValueError(f\"Unsupported provider: {provider}\")\n\n    async def _transcribe_deepgram(\n        self,\n        audio: Union[bytes, np.ndarray],\n        language: Optional[TranscriptionLanguage],\n    ) -> TranscriptionResult:\n        \"\"\"Transcribe using Deepgram cloud API.\"\"\"\n        # This would integrate with the existing Deepgram service\n        # For now, fall back to local Whisper\n        logger.warning(\"Deepgram integration pending, falling back to local Whisper\")\n        return await self._transcribe_with_provider(\n            audio, STTProvider.WHISPER_LOCAL, language\n        )\n\n    async def _transcribe_whisper_api(\n        self,\n        audio: Union[bytes, np.ndarray],\n        language: Optional[TranscriptionLanguage],\n    ) -> TranscriptionResult:\n        \"\"\"Transcribe using OpenAI Whisper API.\"\"\"\n        # This would integrate with OpenAI API\n        # For now, fall back to local Whisper\n        logger.warning(\"Whisper API integration pending, falling back to local\")\n        return await self._transcribe_with_provider(\n            audio, STTProvider.WHISPER_LOCAL, language\n        )\n\n    async def _post_transcription_phi_check(\n        self,\n        result: TranscriptionResult,\n        session_id: Optional[str],\n        original_decision: RoutingDecision,\n    ) -> None:\n        \"\"\"Check transcription result for PHI and update routing if needed.\"\"\"\n\n        if not result.text:\n            return\n\n        phi_detected, phi_categories, confidence = self._detect_phi_in_text(\n            result.text\n        )\n\n        if phi_detected and confidence >= self.config.phi_detection_threshold:\n            # Mark session for future routing\n            if session_id:\n                previous_state = self._session_phi_state.get(session_id, False)\n                self._session_phi_state[session_id] = True\n\n                # Track provider switch\n                if not previous_state:\n                    self._metrics.provider_switches += 1\n\n                    if self._on_provider_switch:\n                        self._on_provider_switch(\n                            session_id,\n                            original_decision.provider,\n                            self.config.phi_safe_provider\n                        )\n\n            logger.info(\n                \"PHI detected in transcription, future requests will use local provider\",\n                extra={\n                    \"session_id\": session_id,\n                    \"categories\": [c.value for c in phi_categories],\n                }\n            )\n\n    async def _fallback_transcription(\n        self,\n        audio: Union[bytes, np.ndarray],\n        original_decision: RoutingDecision,\n        language: Optional[TranscriptionLanguage],\n    ) -> Tuple[TranscriptionResult, RoutingDecision]:\n        \"\"\"Attempt fallback transcription.\"\"\"\n        self._metrics.fallback_activations += 1\n\n        fallback_decision = RoutingDecision(\n            provider=self.config.fallback_provider,\n            reason=f\"fallback_from_{original_decision.provider.value}\",\n            phi_detected=original_decision.phi_detected,\n            phi_categories=original_decision.phi_categories,\n            confidence=original_decision.confidence,\n            session_id=original_decision.session_id,\n        )\n\n        logger.warning(\n            f\"Falling back from {original_decision.provider.value} to \"\n            f\"{self.config.fallback_provider.value}\"\n        )\n\n        result = await self._transcribe_with_provider(\n            audio, self.config.fallback_provider, language\n        )\n\n        return result, fallback_decision\n\n    def mark_session_phi(self, session_id: str, has_phi: bool = True) -> None:\n        \"\"\"\n        Manually mark a session as containing PHI.\n\n        Args:\n            session_id: Session identifier\n            has_phi: Whether session contains PHI\n        \"\"\"\n        self._session_phi_state[session_id] = has_phi\n        logger.info(\n            f\"Session {session_id} manually marked as PHI={has_phi}\"\n        )\n\n    def clear_session_state(self, session_id: str) -> None:\n        \"\"\"Clear PHI state for a session.\"\"\"\n        if session_id in self._session_phi_state:\n            del self._session_phi_state[session_id]\n        if f\"{session_id}:latest\" in self._decision_cache:\n            del self._decision_cache[f\"{session_id}:latest\"]\n\n    def get_session_provider(self, session_id: str) -> STTProvider:\n        \"\"\"Get the current provider for a session.\"\"\"\n        if session_id in self._session_phi_state:\n            if self._session_phi_state[session_id]:\n                return self.config.phi_safe_provider\n        return self.config.default_provider\n\n    def on_phi_detected(\n        self,\n        callback: Callable[[str, List[PHICategory]], None]\n    ) -> None:\n        \"\"\"Register callback for PHI detection events.\"\"\"\n        self._on_phi_detected = callback\n\n    def on_provider_switch(\n        self,\n        callback: Callable[[str, STTProvider, STTProvider], None]\n    ) -> None:\n        \"\"\"Register callback for provider switch events.\"\"\"\n        self._on_provider_switch = callback\n\n    def get_metrics(self) -> RouterMetrics:\n        \"\"\"Get current router metrics.\"\"\"\n        return self._metrics\n\n    def reset_metrics(self) -> None:\n        \"\"\"Reset router metrics.\"\"\"\n        self._metrics = RouterMetrics()\n\n    def get_routing_stats(self) -> Dict[str, Any]:\n        \"\"\"Get routing statistics.\"\"\"\n        total = self._metrics.total_requests or 1\n        return {\n            \"total_requests\": self._metrics.total_requests,\n            \"cloud_percentage\": (self._metrics.cloud_requests / total) * 100,\n            \"local_percentage\": (self._metrics.local_requests / total) * 100,\n            \"phi_detection_rate\": (self._metrics.phi_detected_count / total) * 100,\n            \"provider_switches\": self._metrics.provider_switches,\n            \"fallback_rate\": (self._metrics.fallback_activations / total) * 100,\n            \"avg_decision_time_ms\": self._metrics.avg_decision_time_ms,\n            \"active_phi_sessions\": sum(1 for v in self._session_phi_state.values() if v),\n            \"phi_categories\": self._metrics.phi_categories_detected,\n        }\n\n\n# Singleton instance\n_privacy_router: Optional[PrivacyAwareSTTRouter] = None\n\n\ndef get_privacy_aware_stt_router() -> PrivacyAwareSTTRouter:\n    \"\"\"Get or create the singleton PrivacyAwareSTTRouter instance.\"\"\"\n    global _privacy_router\n    if _privacy_router is None:\n        _privacy_router = PrivacyAwareSTTRouter()\n    return _privacy_router\n\n\nasync def transcribe_with_privacy(\n    audio: Union[bytes, np.ndarray],\n    session_id: Optional[str] = None,\n    language: Optional[TranscriptionLanguage] = None,\n) -> Tuple[TranscriptionResult, RoutingDecision]:\n    \"\"\"\n    Convenience function for privacy-aware transcription.\n\n    Args:\n        audio: Audio data\n        session_id: Session identifier\n        language: Language hint\n\n    Returns:\n        Tuple of (TranscriptionResult, RoutingDecision)\n    \"\"\"\n    router = get_privacy_aware_stt_router()\n    await router.initialize()\n    return await router.transcribe(audio, session_id=session_id, language=language)\n"
}
