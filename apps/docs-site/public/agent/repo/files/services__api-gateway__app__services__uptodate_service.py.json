{
  "path": "services/api-gateway/app/services/uptodate_service.py",
  "language": "python",
  "size": 20644,
  "last_modified": "2025-12-04T11:27:01.995Z",
  "lines": 675,
  "content": "\"\"\"\nUpToDate API Service\n\nIntegration with UpToDate clinical decision support system:\n- Topic search and retrieval\n- Drug interaction checking\n- Medical graphics access\n- Evidence-based recommendations\n\nNote: Requires enterprise license from UpToDate (~$500-1500/month).\nAPI rate limits vary by license tier.\n\"\"\"\n\nimport hashlib\nimport hmac\nimport time\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom app.core.config import settings\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass Specialty(Enum):\n    \"\"\"Medical specialties supported by UpToDate\"\"\"\n\n    ALLERGY_IMMUNOLOGY = \"allergy-immunology\"\n    CARDIOLOGY = \"cardiology\"\n    DERMATOLOGY = \"dermatology\"\n    EMERGENCY_MEDICINE = \"emergency-medicine\"\n    ENDOCRINOLOGY = \"endocrinology\"\n    FAMILY_MEDICINE = \"family-medicine\"\n    GASTROENTEROLOGY = \"gastroenterology\"\n    GENERAL_SURGERY = \"general-surgery\"\n    GERIATRICS = \"geriatrics\"\n    HEMATOLOGY = \"hematology\"\n    INFECTIOUS_DISEASE = \"infectious-disease\"\n    INTERNAL_MEDICINE = \"internal-medicine\"\n    NEPHROLOGY = \"nephrology\"\n    NEUROLOGY = \"neurology\"\n    OBSTETRICS_GYNECOLOGY = \"obstetrics-gynecology\"\n    ONCOLOGY = \"oncology\"\n    OPHTHALMOLOGY = \"ophthalmology\"\n    ORTHOPEDICS = \"orthopedics\"\n    PEDIATRICS = \"pediatrics\"\n    PSYCHIATRY = \"psychiatry\"\n    PULMONOLOGY = \"pulmonology\"\n    RHEUMATOLOGY = \"rheumatology\"\n    UROLOGY = \"urology\"\n\n\nclass InteractionSeverity(Enum):\n    \"\"\"Drug interaction severity levels\"\"\"\n\n    CONTRAINDICATED = \"contraindicated\"\n    MAJOR = \"major\"\n    MODERATE = \"moderate\"\n    MINOR = \"minor\"\n    UNKNOWN = \"unknown\"\n\n\n@dataclass\nclass UpToDateTopic:\n    \"\"\"UpToDate topic search result\"\"\"\n\n    id: str\n    title: str\n    specialty: Optional[str] = None\n    last_updated: Optional[str] = None\n    relevance_score: float = 0.0\n    url: Optional[str] = None\n\n\n@dataclass\nclass TopicSection:\n    \"\"\"Section within an UpToDate topic\"\"\"\n\n    title: str\n    content: str\n    subsections: List[\"TopicSection\"] = field(default_factory=list)\n\n\n@dataclass\nclass Reference:\n    \"\"\"Literature reference\"\"\"\n\n    citation: str\n    pmid: Optional[str] = None\n    doi: Optional[str] = None\n    url: Optional[str] = None\n\n\n@dataclass\nclass UpToDateContent:\n    \"\"\"Full topic content from UpToDate\"\"\"\n\n    id: str\n    title: str\n    sections: List[TopicSection] = field(default_factory=list)\n    references: List[Reference] = field(default_factory=list)\n    last_updated: Optional[str] = None\n    authors: List[str] = field(default_factory=list)\n    summary: Optional[str] = None\n    grade_of_evidence: Optional[str] = None\n\n\n@dataclass\nclass DrugInteraction:\n    \"\"\"Drug-drug interaction result\"\"\"\n\n    drug1: str\n    drug2: str\n    severity: InteractionSeverity\n    description: str\n    mechanism: Optional[str] = None\n    management: Optional[str] = None\n    clinical_effects: Optional[str] = None\n    references: List[Reference] = field(default_factory=list)\n\n\n@dataclass\nclass DrugInteractionResult:\n    \"\"\"Complete drug interaction check result\"\"\"\n\n    drugs: List[str]\n    interactions: List[DrugInteraction]\n    has_contraindicated: bool = False\n    has_major: bool = False\n    checked_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass MedicalGraphic:\n    \"\"\"Medical graphic/image from UpToDate\"\"\"\n\n    id: str\n    title: str\n    image_url: str\n    description: Optional[str] = None\n    thumbnail_url: Optional[str] = None\n    topic_id: Optional[str] = None\n\n\n@dataclass\nclass CalculatorInput:\n    \"\"\"Input parameter for a medical calculator\"\"\"\n\n    name: str\n    label: str\n    type: str  # integer, float, boolean, string\n    required: bool = True\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    enum_values: Optional[List[str]] = None\n    unit: Optional[str] = None\n    default: Optional[Any] = None\n\n\n@dataclass\nclass CalculatorResult:\n    \"\"\"Result from running a medical calculator\"\"\"\n\n    calculator_id: str\n    calculator_name: str\n    inputs: Dict[str, Any]\n    result: float\n    result_unit: Optional[str] = None\n    interpretation: Optional[str] = None\n    recommendation: Optional[str] = None\n    risk_level: Optional[str] = None\n    references: List[Reference] = field(default_factory=list)\n\n\nclass UpToDateService:\n    \"\"\"\n    UpToDate API integration for clinical decision support.\n\n    This service provides access to UpToDate's clinical knowledge base:\n    - Topic search and retrieval\n    - Drug interaction checking\n    - Medical graphics\n    - Calculator integration\n\n    API Endpoints used:\n    - /search: Topic search\n    - /topics/{id}: Topic content\n    - /graphics/{id}: Medical graphics\n    - /drug-interactions: Drug interaction checker\n\n    Note: Requires enterprise API license from UpToDate.\n    Rate limits and access depend on license tier.\n    \"\"\"\n\n    BASE_URL = \"https://api.uptodate.com/v1\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        api_secret: Optional[str] = None,\n        cache_service: Optional[Any] = None,\n    ):\n        \"\"\"\n        Initialize UpToDate service.\n\n        Args:\n            api_key: UpToDate API key (defaults to settings)\n            api_secret: UpToDate API secret (defaults to settings)\n            cache_service: Optional cache service for response caching\n        \"\"\"\n        self.api_key = api_key or getattr(settings, \"UPTODATE_API_KEY\", \"\")\n        self.api_secret = api_secret or getattr(settings, \"UPTODATE_API_SECRET\", \"\")\n        self.cache = cache_service\n        self._client: Optional[httpx.AsyncClient] = None\n\n        logger.info(\n            \"UpToDateService initialized\",\n            extra={\"has_api_key\": bool(self.api_key)},\n        )\n\n    async def _get_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._client is None:\n            self._client = httpx.AsyncClient(\n                timeout=30.0,\n                headers={\"User-Agent\": \"VoiceAssist/1.0\"},\n            )\n        return self._client\n\n    async def close(self):\n        \"\"\"Close HTTP client.\"\"\"\n        if self._client:\n            await self._client.aclose()\n            self._client = None\n\n    def _generate_auth_signature(self, timestamp: str) -> str:\n        \"\"\"\n        Generate HMAC signature for API authentication.\n\n        Args:\n            timestamp: Unix timestamp string\n\n        Returns:\n            HMAC-SHA256 signature\n        \"\"\"\n        message = f\"{self.api_key}{timestamp}\"\n        signature = hmac.new(\n            self.api_secret.encode(\"utf-8\"),\n            message.encode(\"utf-8\"),\n            hashlib.sha256,\n        ).hexdigest()\n        return signature\n\n    def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Generate authentication headers for API requests.\"\"\"\n        timestamp = str(int(time.time()))\n        signature = self._generate_auth_signature(timestamp)\n\n        return {\n            \"X-API-Key\": self.api_key,\n            \"X-Timestamp\": timestamp,\n            \"X-Signature\": signature,\n            \"Content-Type\": \"application/json\",\n        }\n\n    def _get_cache_key(self, prefix: str, *args) -> str:\n        \"\"\"Generate cache key from arguments.\"\"\"\n        key_parts = [prefix] + [str(arg) for arg in args if arg]\n        key_str = \":\".join(key_parts)\n        return f\"uptodate:{hashlib.md5(key_str.encode(), usedforsecurity=False).hexdigest()}\"\n\n    async def _cached_get(self, cache_key: str, ttl: int = 3600) -> Optional[Dict[str, Any]]:\n        \"\"\"Get cached response if available.\"\"\"\n        if self.cache:\n            try:\n                return await self.cache.get(cache_key)\n            except Exception as e:\n                logger.warning(f\"Cache get failed: {e}\")\n        return None\n\n    async def _cached_set(self, cache_key: str, data: Dict[str, Any], ttl: int = 3600):\n        \"\"\"Set cached response.\"\"\"\n        if self.cache:\n            try:\n                await self.cache.set(cache_key, data, ttl=ttl)\n            except Exception as e:\n                logger.warning(f\"Cache set failed: {e}\")\n\n    async def _request(\n        self,\n        method: str,\n        endpoint: str,\n        params: Optional[Dict[str, Any]] = None,\n        json_data: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Make authenticated API request.\n\n        Args:\n            method: HTTP method (GET, POST, etc.)\n            endpoint: API endpoint path\n            params: Query parameters\n            json_data: JSON body data\n\n        Returns:\n            API response as dictionary\n\n        Raises:\n            httpx.HTTPStatusError: On API error\n        \"\"\"\n        if not self.api_key:\n            raise ValueError(\"UpToDate API key not configured\")\n\n        client = await self._get_client()\n        headers = self._get_auth_headers()\n\n        url = f\"{self.BASE_URL}{endpoint}\"\n\n        logger.debug(\n            \"UpToDate API request\",\n            extra={\"method\": method, \"endpoint\": endpoint},\n        )\n\n        response = await client.request(\n            method,\n            url,\n            headers=headers,\n            params=params,\n            json=json_data,\n        )\n\n        response.raise_for_status()\n        return response.json()\n\n    async def search_topics(\n        self,\n        query: str,\n        max_results: int = 10,\n        specialty: Optional[Specialty] = None,\n    ) -> List[UpToDateTopic]:\n        \"\"\"\n        Search UpToDate topics.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results (1-50)\n            specialty: Filter by medical specialty\n\n        Returns:\n            List of matching topics\n        \"\"\"\n        specialty_value = specialty.value if specialty else None\n        cache_key = self._get_cache_key(\"search\", query, max_results, specialty_value)\n\n        # Check cache\n        cached = await self._cached_get(cache_key)\n        if cached:\n            logger.debug(\"Cache hit for topic search\")\n            return [UpToDateTopic(**t) for t in cached]\n\n        # Make API request\n        params = {\n            \"q\": query,\n            \"limit\": min(max_results, 50),\n        }\n        if specialty_value:\n            params[\"specialty\"] = specialty_value\n\n        try:\n            response = await self._request(\"GET\", \"/search\", params=params)\n\n            topics = [\n                UpToDateTopic(\n                    id=item.get(\"id\", \"\"),\n                    title=item.get(\"title\", \"\"),\n                    specialty=item.get(\"specialty\"),\n                    last_updated=item.get(\"lastUpdated\"),\n                    relevance_score=item.get(\"score\", 0.0),\n                    url=item.get(\"url\"),\n                )\n                for item in response.get(\"results\", [])\n            ]\n\n            # Cache results\n            await self._cached_set(cache_key, [self._topic_to_dict(t) for t in topics], ttl=3600)\n\n            logger.info(\n                \"UpToDate search completed\",\n                extra={\"query\": query[:50], \"results\": len(topics)},\n            )\n\n            return topics\n\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"UpToDate search failed: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"UpToDate search error: {e}\")\n            return []\n\n    async def get_topic_content(\n        self,\n        topic_id: str,\n        section: Optional[str] = None,\n    ) -> Optional[UpToDateContent]:\n        \"\"\"\n        Get full topic content.\n\n        Args:\n            topic_id: UpToDate topic ID\n            section: Optional specific section to retrieve\n\n        Returns:\n            Full topic content or None if not found\n        \"\"\"\n        cache_key = self._get_cache_key(\"topic\", topic_id, section)\n\n        # Check cache (longer TTL for full content)\n        cached = await self._cached_get(cache_key)\n        if cached:\n            logger.debug(\"Cache hit for topic content\")\n            return self._dict_to_content(cached)\n\n        try:\n            params = {}\n            if section:\n                params[\"section\"] = section\n\n            response = await self._request(\"GET\", f\"/topics/{topic_id}\", params=params)\n\n            content = UpToDateContent(\n                id=topic_id,\n                title=response.get(\"title\", \"\"),\n                sections=self._parse_sections(response.get(\"sections\", [])),\n                references=self._parse_references(response.get(\"references\", [])),\n                last_updated=response.get(\"lastUpdated\"),\n                authors=response.get(\"authors\", []),\n                summary=response.get(\"summary\"),\n                grade_of_evidence=response.get(\"gradeOfEvidence\"),\n            )\n\n            # Cache for 24 hours\n            await self._cached_set(cache_key, self._content_to_dict(content), ttl=86400)\n\n            logger.info(\n                \"Retrieved topic content\",\n                extra={\"topic_id\": topic_id, \"title\": content.title[:50]},\n            )\n\n            return content\n\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                return None\n            logger.error(f\"Failed to get topic content: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Error getting topic content: {e}\")\n            return None\n\n    async def check_drug_interactions(\n        self,\n        drugs: List[str],\n    ) -> DrugInteractionResult:\n        \"\"\"\n        Check for drug-drug interactions.\n\n        Args:\n            drugs: List of drug names to check\n\n        Returns:\n            DrugInteractionResult with all interactions found\n        \"\"\"\n        if len(drugs) < 2:\n            return DrugInteractionResult(\n                drugs=drugs,\n                interactions=[],\n            )\n\n        try:\n            response = await self._request(\n                \"POST\",\n                \"/drug-interactions\",\n                json_data={\"drugs\": drugs},\n            )\n\n            interactions = []\n            for item in response.get(\"interactions\", []):\n                severity = InteractionSeverity.UNKNOWN\n                try:\n                    severity = InteractionSeverity(item.get(\"severity\", \"unknown\"))\n                except ValueError:\n                    pass\n\n                interactions.append(\n                    DrugInteraction(\n                        drug1=item.get(\"drug1\", \"\"),\n                        drug2=item.get(\"drug2\", \"\"),\n                        severity=severity,\n                        description=item.get(\"description\", \"\"),\n                        mechanism=item.get(\"mechanism\"),\n                        management=item.get(\"management\"),\n                        clinical_effects=item.get(\"clinicalEffects\"),\n                        references=self._parse_references(item.get(\"references\", [])),\n                    )\n                )\n\n            result = DrugInteractionResult(\n                drugs=drugs,\n                interactions=interactions,\n                has_contraindicated=any(i.severity == InteractionSeverity.CONTRAINDICATED for i in interactions),\n                has_major=any(i.severity == InteractionSeverity.MAJOR for i in interactions),\n            )\n\n            logger.info(\n                \"Drug interaction check completed\",\n                extra={\n                    \"drugs_count\": len(drugs),\n                    \"interactions_found\": len(interactions),\n                    \"has_major\": result.has_major,\n                },\n            )\n\n            return result\n\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"Drug interaction check failed: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Drug interaction error: {e}\")\n            return DrugInteractionResult(drugs=drugs, interactions=[])\n\n    async def get_graphics(\n        self,\n        topic_id: str,\n    ) -> List[MedicalGraphic]:\n        \"\"\"\n        Get medical graphics for a topic.\n\n        Args:\n            topic_id: UpToDate topic ID\n\n        Returns:\n            List of medical graphics\n        \"\"\"\n        cache_key = self._get_cache_key(\"graphics\", topic_id)\n\n        cached = await self._cached_get(cache_key)\n        if cached:\n            return [MedicalGraphic(**g) for g in cached]\n\n        try:\n            response = await self._request(\"GET\", f\"/topics/{topic_id}/graphics\")\n\n            graphics = [\n                MedicalGraphic(\n                    id=item.get(\"id\", \"\"),\n                    title=item.get(\"title\", \"\"),\n                    description=item.get(\"description\"),\n                    image_url=item.get(\"imageUrl\", \"\"),\n                    thumbnail_url=item.get(\"thumbnailUrl\"),\n                    topic_id=topic_id,\n                )\n                for item in response.get(\"graphics\", [])\n            ]\n\n            await self._cached_set(\n                cache_key,\n                [self._graphic_to_dict(g) for g in graphics],\n                ttl=86400,\n            )\n\n            return graphics\n\n        except Exception as e:\n            logger.error(f\"Failed to get graphics: {e}\")\n            return []\n\n    def _parse_sections(self, sections_data: List[Dict]) -> List[TopicSection]:\n        \"\"\"Parse section data into TopicSection objects.\"\"\"\n        sections = []\n        for item in sections_data:\n            section = TopicSection(\n                title=item.get(\"title\", \"\"),\n                content=item.get(\"content\", \"\"),\n                subsections=self._parse_sections(item.get(\"subsections\", [])),\n            )\n            sections.append(section)\n        return sections\n\n    def _parse_references(self, refs_data: List[Dict]) -> List[Reference]:\n        \"\"\"Parse reference data into Reference objects.\"\"\"\n        return [\n            Reference(\n                citation=ref.get(\"citation\", \"\"),\n                pmid=ref.get(\"pmid\"),\n                doi=ref.get(\"doi\"),\n                url=ref.get(\"url\"),\n            )\n            for ref in refs_data\n        ]\n\n    def _topic_to_dict(self, topic: UpToDateTopic) -> Dict[str, Any]:\n        \"\"\"Convert topic to dictionary for caching.\"\"\"\n        return {\n            \"id\": topic.id,\n            \"title\": topic.title,\n            \"specialty\": topic.specialty,\n            \"last_updated\": topic.last_updated,\n            \"relevance_score\": topic.relevance_score,\n            \"url\": topic.url,\n        }\n\n    def _content_to_dict(self, content: UpToDateContent) -> Dict[str, Any]:\n        \"\"\"Convert content to dictionary for caching.\"\"\"\n        return {\n            \"id\": content.id,\n            \"title\": content.title,\n            \"sections\": [self._section_to_dict(s) for s in content.sections],\n            \"references\": [self._ref_to_dict(r) for r in content.references],\n            \"last_updated\": content.last_updated,\n            \"authors\": content.authors,\n            \"summary\": content.summary,\n            \"grade_of_evidence\": content.grade_of_evidence,\n        }\n\n    def _dict_to_content(self, data: Dict[str, Any]) -> UpToDateContent:\n        \"\"\"Convert dictionary to UpToDateContent.\"\"\"\n        return UpToDateContent(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            sections=self._parse_sections(data.get(\"sections\", [])),\n            references=self._parse_references(data.get(\"references\", [])),\n            last_updated=data.get(\"last_updated\"),\n            authors=data.get(\"authors\", []),\n            summary=data.get(\"summary\"),\n            grade_of_evidence=data.get(\"grade_of_evidence\"),\n        )\n\n    def _section_to_dict(self, section: TopicSection) -> Dict[str, Any]:\n        \"\"\"Convert section to dictionary.\"\"\"\n        return {\n            \"title\": section.title,\n            \"content\": section.content,\n            \"subsections\": [self._section_to_dict(s) for s in section.subsections],\n        }\n\n    def _ref_to_dict(self, ref: Reference) -> Dict[str, Any]:\n        \"\"\"Convert reference to dictionary.\"\"\"\n        return {\n            \"citation\": ref.citation,\n            \"pmid\": ref.pmid,\n            \"doi\": ref.doi,\n            \"url\": ref.url,\n        }\n\n    def _graphic_to_dict(self, graphic: MedicalGraphic) -> Dict[str, Any]:\n        \"\"\"Convert graphic to dictionary.\"\"\"\n        return {\n            \"id\": graphic.id,\n            \"title\": graphic.title,\n            \"description\": graphic.description,\n            \"image_url\": graphic.image_url,\n            \"thumbnail_url\": graphic.thumbnail_url,\n            \"topic_id\": graphic.topic_id,\n        }\n\n\n# Global service instance\nuptodate_service = UpToDateService()\n"
}
