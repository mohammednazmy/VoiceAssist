{
  "path": "services/api-gateway/app/services/two_factor.py",
  "language": "python",
  "size": 6933,
  "last_modified": "2025-12-04T11:27:01.292Z",
  "lines": 241,
  "content": "\"\"\"\nTwo-Factor Authentication (2FA) Service using TOTP.\n\nProvides TOTP-based 2FA with:\n- Secret generation and QR code creation\n- Code verification with time window tolerance\n- Backup codes for account recovery\n\"\"\"\n\nimport base64\nimport io\nimport secrets\nfrom typing import Optional, Tuple\n\nimport pyotp\nimport qrcode\nfrom app.core.config import settings\nfrom cryptography.fernet import Fernet\n\n\nclass TwoFactorService:\n    \"\"\"\n    Service for managing TOTP-based two-factor authentication.\n    \"\"\"\n\n    # App name shown in authenticator apps\n    ISSUER_NAME = \"VoiceAssist Admin\"\n\n    # Number of backup codes to generate\n    BACKUP_CODE_COUNT = 10\n\n    # Backup code length (alphanumeric)\n    BACKUP_CODE_LENGTH = 8\n\n    def __init__(self):\n        \"\"\"Initialize the 2FA service with encryption key.\"\"\"\n        # Use SECRET_KEY for encrypting TOTP secrets at rest\n        # Ensure key is 32 bytes for Fernet\n        key_bytes = settings.SECRET_KEY.encode()[:32].ljust(32, b\"0\")\n        self.cipher = Fernet(base64.urlsafe_b64encode(key_bytes))\n\n    def generate_secret(self) -> str:\n        \"\"\"\n        Generate a new TOTP secret.\n\n        Returns:\n            Base32-encoded secret string\n        \"\"\"\n        return pyotp.random_base32()\n\n    def encrypt_secret(self, secret: str) -> str:\n        \"\"\"\n        Encrypt a TOTP secret for database storage.\n\n        Args:\n            secret: Plain TOTP secret\n\n        Returns:\n            Encrypted secret string\n        \"\"\"\n        return self.cipher.encrypt(secret.encode()).decode()\n\n    def decrypt_secret(self, encrypted_secret: str) -> str:\n        \"\"\"\n        Decrypt a TOTP secret from database storage.\n\n        Args:\n            encrypted_secret: Encrypted secret string\n\n        Returns:\n            Plain TOTP secret\n        \"\"\"\n        return self.cipher.decrypt(encrypted_secret.encode()).decode()\n\n    def get_provisioning_uri(self, secret: str, email: str) -> str:\n        \"\"\"\n        Generate a provisioning URI for authenticator apps.\n\n        Args:\n            secret: Plain TOTP secret\n            email: User's email (used as account name)\n\n        Returns:\n            otpauth:// URI for QR code generation\n        \"\"\"\n        totp = pyotp.TOTP(secret)\n        return totp.provisioning_uri(name=email, issuer_name=self.ISSUER_NAME)\n\n    def generate_qr_code(self, provisioning_uri: str) -> str:\n        \"\"\"\n        Generate a QR code image as base64-encoded PNG.\n\n        Args:\n            provisioning_uri: otpauth:// URI\n\n        Returns:\n            Base64-encoded PNG image data URL\n        \"\"\"\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_L,\n            box_size=10,\n            border=4,\n        )\n        qr.add_data(provisioning_uri)\n        qr.make(fit=True)\n\n        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n\n        # Convert to base64\n        buffer = io.BytesIO()\n        img.save(buffer, format=\"PNG\")\n        buffer.seek(0)\n        img_base64 = base64.b64encode(buffer.getvalue()).decode()\n\n        return f\"data:image/png;base64,{img_base64}\"\n\n    def verify_code(self, secret: str, code: str, valid_window: int = 1) -> bool:\n        \"\"\"\n        Verify a TOTP code.\n\n        Args:\n            secret: Plain TOTP secret\n            code: 6-digit TOTP code from user\n            valid_window: Number of time steps to check before/after current\n\n        Returns:\n            True if code is valid\n        \"\"\"\n        if not code or len(code) != 6 or not code.isdigit():\n            return False\n\n        totp = pyotp.TOTP(secret)\n        return totp.verify(code, valid_window=valid_window)\n\n    def generate_backup_codes(self) -> list[str]:\n        \"\"\"\n        Generate a set of backup codes for account recovery.\n\n        Returns:\n            List of backup codes\n        \"\"\"\n        codes = []\n        for _ in range(self.BACKUP_CODE_COUNT):\n            # Generate alphanumeric code\n            code = \"\".join(secrets.choice(\"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\") for _ in range(self.BACKUP_CODE_LENGTH))\n            # Format as XXXX-XXXX for readability\n            formatted = f\"{code[:4]}-{code[4:]}\"\n            codes.append(formatted)\n        return codes\n\n    def encrypt_backup_codes(self, codes: list[str]) -> str:\n        \"\"\"\n        Encrypt backup codes for database storage.\n\n        Args:\n            codes: List of backup codes\n\n        Returns:\n            Encrypted comma-separated codes\n        \"\"\"\n        joined = \",\".join(codes)\n        return self.cipher.encrypt(joined.encode()).decode()\n\n    def decrypt_backup_codes(self, encrypted_codes: str) -> list[str]:\n        \"\"\"\n        Decrypt backup codes from database storage.\n\n        Args:\n            encrypted_codes: Encrypted codes string\n\n        Returns:\n            List of backup codes\n        \"\"\"\n        if not encrypted_codes:\n            return []\n        decrypted = self.cipher.decrypt(encrypted_codes.encode()).decode()\n        return decrypted.split(\",\")\n\n    def verify_backup_code(self, encrypted_codes: str, code: str) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        Verify a backup code and remove it if valid.\n\n        Args:\n            encrypted_codes: Encrypted backup codes from database\n            code: Backup code to verify (with or without dash)\n\n        Returns:\n            Tuple of (is_valid, updated_encrypted_codes)\n            - If valid, returns (True, new_encrypted_codes)\n            - If invalid, returns (False, None)\n        \"\"\"\n        # Normalize code format\n        code = code.upper().replace(\"-\", \"\")\n        if len(code) != self.BACKUP_CODE_LENGTH:\n            return (False, None)\n\n        # Format for comparison\n        formatted_code = f\"{code[:4]}-{code[4:]}\"\n\n        codes = self.decrypt_backup_codes(encrypted_codes)\n\n        if formatted_code not in codes:\n            return (False, None)\n\n        # Remove used code\n        codes.remove(formatted_code)\n\n        if codes:\n            return (True, self.encrypt_backup_codes(codes))\n        else:\n            return (True, \"\")\n\n    def setup_2fa(self, email: str) -> dict:\n        \"\"\"\n        Generate all data needed to set up 2FA for a user.\n\n        Args:\n            email: User's email address\n\n        Returns:\n            Dict with secret, qr_code, and backup_codes\n        \"\"\"\n        secret = self.generate_secret()\n        provisioning_uri = self.get_provisioning_uri(secret, email)\n        qr_code = self.generate_qr_code(provisioning_uri)\n        backup_codes = self.generate_backup_codes()\n\n        return {\n            \"secret\": secret,\n            \"encrypted_secret\": self.encrypt_secret(secret),\n            \"qr_code\": qr_code,\n            \"provisioning_uri\": provisioning_uri,\n            \"backup_codes\": backup_codes,\n            \"encrypted_backup_codes\": self.encrypt_backup_codes(backup_codes),\n        }\n\n\n# Global instance\ntwo_factor_service = TwoFactorService()\n"
}
