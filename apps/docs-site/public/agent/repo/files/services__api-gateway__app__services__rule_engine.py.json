{
  "path": "services/api-gateway/app/services/rule_engine.py",
  "language": "python",
  "size": 23495,
  "last_modified": "2025-12-04T12:32:40.272Z",
  "lines": 717,
  "content": "\"\"\"Feature Flag Rule Engine (Phase 3.2).\n\nEvaluates targeting rules to determine which users should see which flag variants.\nSupports user attribute matching, percentage rollouts, and variant assignment.\n\nUsage:\n    from app.services.rule_engine import RuleEngine, UserContext\n\n    engine = RuleEngine()\n    user_ctx = UserContext(user_id=\"user-123\", user_role=\"admin\")\n\n    # Evaluate a flag for a user\n    result = engine.evaluate(flag, user_ctx)\n    if result.matched:\n        variant = result.variant\n        value = result.value\n\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nimport re\nimport warnings\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.logging import get_logger\nfrom packaging.version import InvalidVersion, Version\n\nlogger = get_logger(__name__)\n\n\n# ============================================================================\n# Type Definitions\n# ============================================================================\n\n\nclass Operator(str, Enum):\n    \"\"\"Supported operators for targeting conditions.\"\"\"\n\n    EQUALS = \"equals\"\n    NOT_EQUALS = \"not_equals\"\n    IN = \"in\"\n    NOT_IN = \"not_in\"\n    CONTAINS = \"contains\"\n    STARTS_WITH = \"starts_with\"\n    ENDS_WITH = \"ends_with\"\n    REGEX = \"regex\"\n    GT = \"gt\"\n    GTE = \"gte\"\n    LT = \"lt\"\n    LTE = \"lte\"\n    SEMVER_GT = \"semver_gt\"\n    SEMVER_GTE = \"semver_gte\"\n    SEMVER_LT = \"semver_lt\"\n    SEMVER_LTE = \"semver_lte\"\n\n\n@dataclass\nclass UserContext:\n    \"\"\"User context for evaluating targeting rules.\n\n    Attributes:\n        user_id: User's unique identifier\n        user_email: User's email address\n        user_role: User's role (admin, physician, staff, patient)\n        user_created_at: Account creation timestamp\n        user_plan: Subscription plan\n        user_country: ISO 3166-1 alpha-2 country code\n        user_language: Preferred language code\n        app_version: Application version string\n        platform: Platform (web, ios, android)\n        custom_attributes: Additional custom attributes\n    \"\"\"\n\n    user_id: Optional[str] = None\n    user_email: Optional[str] = None\n    user_role: Optional[str] = None\n    user_created_at: Optional[str] = None\n    user_plan: Optional[str] = None\n    user_country: Optional[str] = None\n    user_language: Optional[str] = None\n    app_version: Optional[str] = None\n    platform: Optional[str] = None\n    custom_attributes: Dict[str, Any] = field(default_factory=dict)\n\n    def get_attribute(self, attribute: str, custom_key: Optional[str] = None) -> Any:\n        \"\"\"Get an attribute value from the context.\n\n        Args:\n            attribute: Attribute name (user_id, user_role, etc.)\n            custom_key: Key for custom attributes\n\n        Returns:\n            Attribute value or None if not found\n        \"\"\"\n        if attribute == \"custom\" and custom_key:\n            return self.custom_attributes.get(custom_key)\n\n        # Map attribute names to context fields\n        attr_map = {\n            \"user_id\": self.user_id,\n            \"user_email\": self.user_email,\n            \"user_role\": self.user_role,\n            \"user_created_at\": self.user_created_at,\n            \"user_plan\": self.user_plan,\n            \"user_country\": self.user_country,\n            \"user_language\": self.user_language,\n            \"app_version\": self.app_version,\n            \"platform\": self.platform,\n        }\n\n        return attr_map.get(attribute)\n\n\n@dataclass\nclass TargetingCondition:\n    \"\"\"A single targeting rule condition.\"\"\"\n\n    attribute: str\n    operator: str\n    value: Any\n    custom_attribute_key: Optional[str] = None\n\n\n@dataclass\nclass TargetingRule:\n    \"\"\"A targeting rule with conditions and outcome.\"\"\"\n\n    id: str\n    name: str\n    priority: int\n    conditions: List[TargetingCondition]\n    variant: Optional[str] = None\n    enabled: Optional[bool] = None\n    value: Optional[Any] = None\n    description: Optional[str] = None\n\n\n@dataclass\nclass Variant:\n    \"\"\"A flag variant definition.\"\"\"\n\n    id: str\n    name: str\n    value: Any\n    weight: int\n    description: Optional[str] = None\n\n\n@dataclass\nclass EvaluationResult:\n    \"\"\"Result of evaluating a flag for a user.\"\"\"\n\n    matched: bool\n    variant: Optional[str] = None\n    value: Optional[Any] = None\n    enabled: Optional[bool] = None\n    matched_rule_id: Optional[str] = None\n    matched_rule_name: Optional[str] = None\n    reason: str = \"default\"\n\n\n# ============================================================================\n# Rule Engine Implementation\n# ============================================================================\n\n\nclass RuleEngine:\n    \"\"\"Evaluates targeting rules for feature flags.\n\n    The engine processes rules in priority order, evaluating conditions\n    against user context to determine which variant/value to serve.\n\n    Features:\n    - 16 comparison operators for targeting conditions\n    - Consistent variant selection using SHA-256 hashing\n    - Per-request bucket caching to reduce repeated hash computations\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the rule engine with empty bucket cache.\"\"\"\n        # Per-request cache for bucket computations\n        # Key: (user_id, flag_name, salt), Value: bucket (0-99)\n        self._bucket_cache: Dict[tuple, int] = {}\n\n    def clear_bucket_cache(self) -> None:\n        \"\"\"Clear the bucket cache.\n\n        Call this at the start of each request to prevent stale data\n        when processing multiple flags for the same user.\n        \"\"\"\n        self._bucket_cache.clear()\n\n    def evaluate_condition(\n        self,\n        condition: TargetingCondition,\n        user_ctx: UserContext,\n    ) -> bool:\n        \"\"\"Evaluate a single condition against user context.\n\n        Args:\n            condition: The condition to evaluate\n            user_ctx: User context with attributes\n\n        Returns:\n            True if condition matches, False otherwise\n        \"\"\"\n        user_value = user_ctx.get_attribute(\n            condition.attribute,\n            condition.custom_attribute_key,\n        )\n\n        if user_value is None:\n            # No value means condition doesn't match\n            # Exception: not_in and not_equals can match if value is None\n            if condition.operator in (Operator.NOT_IN.value, Operator.NOT_EQUALS.value):\n                return True\n            return False\n\n        target_value = condition.value\n        operator = condition.operator\n\n        try:\n            return self._apply_operator(operator, user_value, target_value)\n        except Exception as e:\n            logger.warning(\n                \"condition_evaluation_error\",\n                attribute=condition.attribute,\n                operator=operator,\n                error=str(e),\n            )\n            return False\n\n    def _apply_operator(\n        self,\n        operator: str,\n        user_value: Any,\n        target_value: Any,\n    ) -> bool:\n        \"\"\"Apply an operator to compare values.\n\n        Args:\n            operator: The operator to apply\n            user_value: User's attribute value\n            target_value: Target value from the condition\n\n        Returns:\n            True if comparison succeeds\n        \"\"\"\n        # String comparison operators\n        if operator == Operator.EQUALS.value:\n            return str(user_value).lower() == str(target_value).lower()\n\n        if operator == Operator.NOT_EQUALS.value:\n            return str(user_value).lower() != str(target_value).lower()\n\n        if operator == Operator.IN.value:\n            if isinstance(target_value, list):\n                return str(user_value).lower() in [str(v).lower() for v in target_value]\n            return str(user_value).lower() == str(target_value).lower()\n\n        if operator == Operator.NOT_IN.value:\n            if isinstance(target_value, list):\n                return str(user_value).lower() not in [str(v).lower() for v in target_value]\n            return str(user_value).lower() != str(target_value).lower()\n\n        if operator == Operator.CONTAINS.value:\n            return str(target_value).lower() in str(user_value).lower()\n\n        if operator == Operator.STARTS_WITH.value:\n            return str(user_value).lower().startswith(str(target_value).lower())\n\n        if operator == Operator.ENDS_WITH.value:\n            return str(user_value).lower().endswith(str(target_value).lower())\n\n        if operator == Operator.REGEX.value:\n            try:\n                pattern = re.compile(str(target_value), re.IGNORECASE)\n                return bool(pattern.search(str(user_value)))\n            except re.error:\n                return False\n\n        # Numeric comparison operators\n        if operator in (Operator.GT.value, Operator.GTE.value, Operator.LT.value, Operator.LTE.value):\n            try:\n                user_num = float(user_value)\n                target_num = float(target_value)\n\n                if operator == Operator.GT.value:\n                    return user_num > target_num\n                if operator == Operator.GTE.value:\n                    return user_num >= target_num\n                if operator == Operator.LT.value:\n                    return user_num < target_num\n                if operator == Operator.LTE.value:\n                    return user_num <= target_num\n            except (TypeError, ValueError):\n                return False\n\n        # Semantic version operators\n        if operator.startswith(\"semver_\"):\n            return self._compare_semver(operator, str(user_value), str(target_value))\n\n        # Unrecognized operator - emit warning and raise error\n        logger.warning(\n            \"unrecognized_operator\",\n            operator=operator,\n            user_value=user_value,\n            target_value=target_value,\n        )\n        warnings.warn(\n            f\"Unrecognized operator '{operator}' in targeting rule. \"\n            f\"Valid operators: {[op.value for op in Operator]}\",\n            category=UserWarning,\n            stacklevel=3,\n        )\n        raise ValueError(f\"Unrecognized operator: {operator}\")\n\n    def _compare_semver(self, operator: str, user_version: str, target_version: str) -> bool:\n        \"\"\"Compare semantic versions using the packaging library.\n\n        Handles prerelease versions (e.g., 1.0.0-alpha < 1.0.0) and\n        build metadata properly according to PEP 440 / SemVer.\n\n        Args:\n            operator: Semver comparison operator\n            user_version: User's version string\n            target_version: Target version string\n\n        Returns:\n            True if comparison succeeds\n        \"\"\"\n        try:\n            user_ver = self._parse_version(user_version)\n            target_ver = self._parse_version(target_version)\n\n            if user_ver is None or target_ver is None:\n                logger.debug(\n                    \"semver_parse_failed\",\n                    user_version=user_version,\n                    target_version=target_version,\n                )\n                return False\n\n            if operator == Operator.SEMVER_GT.value:\n                return user_ver > target_ver\n            if operator == Operator.SEMVER_GTE.value:\n                return user_ver >= target_ver\n            if operator == Operator.SEMVER_LT.value:\n                return user_ver < target_ver\n            if operator == Operator.SEMVER_LTE.value:\n                return user_ver <= target_ver\n\n        except Exception as e:\n            logger.warning(\n                \"semver_comparison_error\",\n                operator=operator,\n                user_version=user_version,\n                target_version=target_version,\n                error=str(e),\n            )\n            return False\n\n        return False\n\n    def _parse_version(self, version: str) -> Optional[Version]:\n        \"\"\"Parse a version string using the packaging library.\n\n        Handles both SemVer-style (1.2.3-beta+build) and PEP 440 versions.\n\n        Args:\n            version: Version string (e.g., \"1.2.3\", \"2.0.0-beta.1\", \"v1.0.0\")\n\n        Returns:\n            packaging.version.Version or None if invalid\n        \"\"\"\n        # Remove any prefix like 'v' or 'V'\n        version = version.lstrip(\"vV\").strip()\n\n        if not version:\n            return None\n\n        try:\n            return Version(version)\n        except InvalidVersion:\n            # Try converting SemVer prerelease format to PEP 440\n            # e.g., \"1.0.0-beta.1\" -> \"1.0.0b1\"\n            try:\n                # Replace common SemVer prerelease separators\n                pep440_version = self._semver_to_pep440(version)\n                return Version(pep440_version)\n            except InvalidVersion:\n                return None\n\n    def _semver_to_pep440(self, version: str) -> str:\n        \"\"\"Convert SemVer-style version to PEP 440 format.\n\n        Args:\n            version: SemVer string (e.g., \"1.0.0-beta.1\")\n\n        Returns:\n            PEP 440 compatible string (e.g., \"1.0.0b1\")\n        \"\"\"\n        # Split on prerelease separator\n        if \"-\" in version:\n            base, prerelease = version.split(\"-\", 1)\n            # Remove build metadata\n            prerelease = prerelease.split(\"+\")[0]\n\n            # Map common prerelease identifiers to PEP 440\n            prerelease_lower = prerelease.lower()\n            if prerelease_lower.startswith(\"alpha\"):\n                suffix = prerelease_lower.replace(\"alpha\", \"a\").replace(\".\", \"\")\n                return f\"{base}{suffix}\"\n            elif prerelease_lower.startswith(\"beta\"):\n                suffix = prerelease_lower.replace(\"beta\", \"b\").replace(\".\", \"\")\n                return f\"{base}{suffix}\"\n            elif prerelease_lower.startswith(\"rc\"):\n                suffix = prerelease_lower.replace(\".\", \"\")\n                return f\"{base}{suffix}\"\n            elif prerelease_lower.startswith(\"pre\"):\n                suffix = prerelease_lower.replace(\"pre\", \"rc\").replace(\".\", \"\")\n                return f\"{base}{suffix}\"\n            else:\n                # Generic prerelease: use .dev suffix\n                return f\"{base}.dev0\"\n\n        # Remove build metadata only\n        return version.split(\"+\")[0]\n\n    def evaluate_rule(\n        self,\n        rule: TargetingRule,\n        user_ctx: UserContext,\n    ) -> bool:\n        \"\"\"Evaluate a targeting rule against user context.\n\n        All conditions must match (AND logic).\n\n        Args:\n            rule: The targeting rule to evaluate\n            user_ctx: User context with attributes\n\n        Returns:\n            True if all conditions match\n        \"\"\"\n        if not rule.conditions:\n            # Empty conditions means rule always matches\n            return True\n\n        for condition in rule.conditions:\n            if not self.evaluate_condition(condition, user_ctx):\n                return False\n\n        return True\n\n    def evaluate_targeting_rules(\n        self,\n        rules_config: Dict[str, Any],\n        user_ctx: UserContext,\n        flag_type: str = \"boolean\",\n    ) -> EvaluationResult:\n        \"\"\"Evaluate all targeting rules for a flag.\n\n        Args:\n            rules_config: Targeting rules configuration from flag\n            user_ctx: User context with attributes\n            flag_type: Type of flag (boolean, multivariate, etc.)\n\n        Returns:\n            EvaluationResult with matched variant/value\n        \"\"\"\n        if not rules_config or \"rules\" not in rules_config:\n            return EvaluationResult(\n                matched=False,\n                reason=\"no_rules\",\n            )\n\n        rules = rules_config.get(\"rules\", [])\n\n        # Parse and sort rules by priority\n        parsed_rules = []\n        for rule_dict in rules:\n            conditions = [\n                TargetingCondition(\n                    attribute=c.get(\"attribute\", \"\"),\n                    operator=c.get(\"operator\", \"equals\"),\n                    value=c.get(\"value\"),\n                    custom_attribute_key=c.get(\"customAttributeKey\"),\n                )\n                for c in rule_dict.get(\"conditions\", [])\n            ]\n            parsed_rules.append(\n                TargetingRule(\n                    id=rule_dict.get(\"id\", \"\"),\n                    name=rule_dict.get(\"name\", \"\"),\n                    priority=rule_dict.get(\"priority\", 999),\n                    conditions=conditions,\n                    variant=rule_dict.get(\"variant\"),\n                    enabled=rule_dict.get(\"enabled\"),\n                    value=rule_dict.get(\"value\"),\n                    description=rule_dict.get(\"description\"),\n                )\n            )\n\n        # Sort by priority (lower = higher priority)\n        parsed_rules.sort(key=lambda r: r.priority)\n\n        # Evaluate rules in order\n        for rule in parsed_rules:\n            if self.evaluate_rule(rule, user_ctx):\n                return EvaluationResult(\n                    matched=True,\n                    variant=rule.variant,\n                    enabled=rule.enabled,\n                    value=rule.value,\n                    matched_rule_id=rule.id,\n                    matched_rule_name=rule.name,\n                    reason=\"rule_matched\",\n                )\n\n        # No rules matched, return default\n        return EvaluationResult(\n            matched=False,\n            variant=rules_config.get(\"defaultVariant\"),\n            enabled=rules_config.get(\"defaultEnabled\"),\n            reason=\"no_match\",\n        )\n\n    def select_variant(\n        self,\n        variants: List[Dict[str, Any]],\n        user_id: str,\n        flag_name: str,\n        salt: Optional[str] = None,\n    ) -> Optional[Variant]:\n        \"\"\"Select a variant for a user using consistent hashing.\n\n        The same user will always get the same variant for a given flag,\n        ensuring consistency across sessions. Weights are validated and\n        normalized to ensure they sum to 100.\n\n        Args:\n            variants: List of variant definitions\n            user_id: User's unique identifier\n            flag_name: Name of the flag (used in hash)\n            salt: Optional salt for hash (defaults to flag_name)\n\n        Returns:\n            Selected Variant or None if no variants\n        \"\"\"\n        if not variants:\n            return None\n\n        # Parse and validate variants\n        parsed_variants = self._parse_and_validate_variants(variants, flag_name)\n        if not parsed_variants:\n            return None\n\n        # Generate consistent hash bucket (0-99)\n        bucket = self._get_bucket(user_id, flag_name, salt)\n\n        # Find which variant this bucket falls into (weights normalized to 100)\n        cumulative_weight = 0\n        for variant in parsed_variants:\n            cumulative_weight += variant.weight\n            if bucket < cumulative_weight:\n                return variant\n\n        # Fallback to last variant\n        return parsed_variants[-1] if parsed_variants else None\n\n    def _parse_and_validate_variants(\n        self,\n        variants: List[Dict[str, Any]],\n        flag_name: str,\n    ) -> List[Variant]:\n        \"\"\"Parse variant dictionaries and validate/normalize weights.\n\n        Ensures:\n        - All weights are non-negative\n        - Weights sum to exactly 100 (normalized if needed)\n        - At least one variant has a positive weight\n\n        Args:\n            variants: List of variant definitions\n            flag_name: Flag name for logging\n\n        Returns:\n            List of validated Variant objects with normalized weights\n        \"\"\"\n        parsed_variants = []\n        has_negative_weight = False\n\n        for v in variants:\n            raw_weight = v.get(\"weight\", 0)\n\n            # Validate non-negative\n            if raw_weight < 0:\n                has_negative_weight = True\n                logger.warning(\n                    \"negative_variant_weight\",\n                    flag_name=flag_name,\n                    variant_name=v.get(\"name\", \"\"),\n                    weight=raw_weight,\n                )\n                raw_weight = 0  # Treat negative as zero\n\n            parsed_variants.append(\n                Variant(\n                    id=v.get(\"id\", \"\"),\n                    name=v.get(\"name\", \"\"),\n                    value=v.get(\"value\"),\n                    weight=raw_weight,\n                    description=v.get(\"description\"),\n                )\n            )\n\n        if has_negative_weight:\n            warnings.warn(\n                f\"Flag '{flag_name}' has variants with negative weights. \" \"Negative weights are treated as zero.\",\n                category=UserWarning,\n                stacklevel=3,\n            )\n\n        # Calculate total weight\n        total_weight = sum(v.weight for v in parsed_variants)\n\n        # Handle edge case: all weights are zero\n        if total_weight == 0:\n            logger.warning(\n                \"zero_total_variant_weight\",\n                flag_name=flag_name,\n                variant_count=len(parsed_variants),\n            )\n            # Equal distribution: each variant gets 100 / count\n            if parsed_variants:\n                equal_weight = 100 / len(parsed_variants)\n                for v in parsed_variants:\n                    v.weight = equal_weight\n            return parsed_variants\n\n        # Normalize weights to sum to 100\n        if total_weight != 100:\n            logger.debug(\n                \"normalizing_variant_weights\",\n                flag_name=flag_name,\n                original_total=total_weight,\n            )\n            scale_factor = 100 / total_weight\n            for v in parsed_variants:\n                v.weight = v.weight * scale_factor\n\n        return parsed_variants\n\n    def _get_bucket(self, user_id: str, flag_name: str, salt: Optional[str] = None) -> int:\n        \"\"\"Calculate a consistent bucket (0-99) for user/flag combination.\n\n        Uses caching to reduce repeated SHA-256 computations when evaluating\n        multiple flags for the same user within a single request.\n\n        Args:\n            user_id: User's unique identifier\n            flag_name: Name of the flag\n            salt: Optional salt value\n\n        Returns:\n            Bucket number 0-99\n        \"\"\"\n        # Check cache first\n        cache_key = (user_id, flag_name, salt or flag_name)\n        if cache_key in self._bucket_cache:\n            return self._bucket_cache[cache_key]\n\n        # Compute hash\n        hash_input = f\"{user_id}:{flag_name}:{salt or flag_name}\"\n        hash_bytes = hashlib.sha256(hash_input.encode()).digest()\n        # Use first 4 bytes as unsigned int, mod 100 for bucket\n        hash_int = int.from_bytes(hash_bytes[:4], byteorder=\"big\", signed=False)\n        bucket = hash_int % 100\n\n        # Cache result\n        self._bucket_cache[cache_key] = bucket\n        return bucket\n\n    def is_in_rollout(\n        self,\n        user_id: str,\n        flag_name: str,\n        rollout_percentage: int,\n        salt: Optional[str] = None,\n    ) -> bool:\n        \"\"\"Check if a user is within the rollout percentage.\n\n        Args:\n            user_id: User's unique identifier\n            flag_name: Name of the flag\n            rollout_percentage: Percentage of users to include (0-100)\n            salt: Optional salt for hash\n\n        Returns:\n            True if user is in rollout\n        \"\"\"\n        if rollout_percentage >= 100:\n            return True\n        if rollout_percentage <= 0:\n            return False\n\n        bucket = self._get_bucket(user_id, flag_name, salt)\n        return bucket < rollout_percentage\n\n\n# Singleton instance\nrule_engine = RuleEngine()\n"
}
