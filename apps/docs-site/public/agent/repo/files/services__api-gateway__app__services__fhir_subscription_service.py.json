{
  "path": "services/api-gateway/app/services/fhir_subscription_service.py",
  "language": "python",
  "size": 38960,
  "last_modified": "2025-12-04T21:46:28.148Z",
  "lines": 1101,
  "content": "\"\"\"\nFHIR Subscription Service - Voice Mode v4.1 Phase 3\n\nReal-time FHIR data streaming for clinical context enrichment.\n\nFeatures:\n- Subscribe to patient resource updates\n- Stream lab results, vitals, and observations\n- PHI-aware routing for streamed data\n- Integration with Thinker context\n- Reconnection and error handling\n\nReference: docs/voice/phase3-implementation-plan.md\n\nFeature Flag: backend.voice_v4_fhir_streaming\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional, Set\n\nfrom app.core.config import settings\nfrom app.core.feature_flags import feature_flag_service\n\nlogger = logging.getLogger(__name__)\n\n\n# ==============================================================================\n# Data Classes\n# ==============================================================================\n\n\nclass FHIRResourceType(str, Enum):\n    \"\"\"FHIR resource types supported for streaming.\"\"\"\n\n    PATIENT = \"Patient\"\n    OBSERVATION = \"Observation\"\n    CONDITION = \"Condition\"\n    MEDICATION_REQUEST = \"MedicationRequest\"\n    DIAGNOSTIC_REPORT = \"DiagnosticReport\"\n    VITAL_SIGNS = \"vital-signs\"\n    LAB_RESULT = \"laboratory\"\n    ALLERGY_INTOLERANCE = \"AllergyIntolerance\"\n\n\nclass SubscriptionStatus(str, Enum):\n    \"\"\"Status of a FHIR subscription.\"\"\"\n\n    PENDING = \"pending\"\n    ACTIVE = \"active\"\n    PAUSED = \"paused\"\n    ERROR = \"error\"\n    EXPIRED = \"expired\"\n\n\n@dataclass\nclass FHIRObservation:\n    \"\"\"A FHIR observation (lab result, vital sign, etc.).\"\"\"\n\n    resource_id: str\n    resource_type: FHIRResourceType\n    patient_id: str\n    code: str\n    code_display: str\n    value: Optional[str] = None\n    value_quantity: Optional[float] = None\n    value_unit: Optional[str] = None\n    effective_datetime: Optional[datetime] = None\n    status: str = \"final\"\n    interpretation: Optional[str] = None\n    reference_range: Optional[str] = None\n    raw_resource: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"resourceId\": self.resource_id,\n            \"resourceType\": self.resource_type.value,\n            \"patientId\": self.patient_id,\n            \"code\": self.code,\n            \"codeDisplay\": self.code_display,\n            \"value\": self.value,\n            \"valueQuantity\": self.value_quantity,\n            \"valueUnit\": self.value_unit,\n            \"effectiveDatetime\": (\n                self.effective_datetime.isoformat() if self.effective_datetime else None\n            ),\n            \"status\": self.status,\n            \"interpretation\": self.interpretation,\n            \"referenceRange\": self.reference_range,\n        }\n\n    def to_context_string(self) -> str:\n        \"\"\"Convert to string for Thinker context injection.\"\"\"\n        value_str = \"\"\n        if self.value_quantity is not None:\n            value_str = f\"{self.value_quantity} {self.value_unit or ''}\"\n        elif self.value:\n            value_str = self.value\n\n        result = f\"{self.code_display}: {value_str}\"\n\n        if self.interpretation:\n            result += f\" ({self.interpretation})\"\n\n        if self.reference_range:\n            result += f\" [ref: {self.reference_range}]\"\n\n        return result\n\n\n@dataclass\nclass FHIRSubscription:\n    \"\"\"A FHIR subscription for real-time updates.\"\"\"\n\n    subscription_id: str\n    patient_id: str\n    resource_types: List[FHIRResourceType]\n    status: SubscriptionStatus = SubscriptionStatus.PENDING\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_event_at: Optional[datetime] = None\n    event_count: int = 0\n    error_message: Optional[str] = None\n    webhook_url: Optional[str] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"subscriptionId\": self.subscription_id,\n            \"patientId\": self.patient_id,\n            \"resourceTypes\": [rt.value for rt in self.resource_types],\n            \"status\": self.status.value,\n            \"createdAt\": self.created_at.isoformat(),\n            \"lastEventAt\": self.last_event_at.isoformat() if self.last_event_at else None,\n            \"eventCount\": self.event_count,\n            \"errorMessage\": self.error_message,\n        }\n\n\n@dataclass\nclass StreamingEvent:\n    \"\"\"Event from a FHIR subscription stream.\"\"\"\n\n    event_id: str\n    subscription_id: str\n    resource_type: FHIRResourceType\n    resource_id: str\n    action: str  # \"create\", \"update\", \"delete\"\n    timestamp: datetime\n    observation: Optional[FHIRObservation] = None\n    raw_payload: Dict[str, Any] = field(default_factory=dict)\n\n\n# ==============================================================================\n# Configuration\n# ==============================================================================\n\n\n@dataclass\nclass FHIRConfig:\n    \"\"\"Configuration for FHIR service.\"\"\"\n\n    # Server settings\n    fhir_server_url: str = \"\"\n    auth_type: str = \"bearer\"  # \"bearer\", \"basic\", \"oauth2\"\n    auth_token: Optional[str] = None\n\n    # Subscription settings\n    subscription_channel: str = \"websocket\"  # \"websocket\", \"webhook\", \"polling\"\n    subscription_timeout_seconds: int = 3600  # 1 hour\n    max_subscriptions_per_patient: int = 5\n\n    # Polling settings (fallback)\n    polling_interval_seconds: int = 30\n    max_polling_results: int = 100\n\n    # Retry settings\n    max_retries: int = 3\n    retry_delay_seconds: int = 5\n    reconnect_delay_seconds: int = 10\n\n    # PHI settings\n    require_phi_routing: bool = True\n    log_phi_access: bool = True\n\n\n# ==============================================================================\n# FHIR Subscription Service\n# ==============================================================================\n\n\nclass FHIRSubscriptionService:\n    \"\"\"\n    Service for real-time FHIR data streaming.\n\n    Provides subscription-based access to patient data updates,\n    including lab results, vital signs, and clinical observations.\n\n    Usage:\n        service = FHIRSubscriptionService()\n        await service.initialize()\n\n        # Subscribe to patient updates\n        sub = await service.subscribe_to_patient(\n            patient_id=\"patient-123\",\n            resource_types=[FHIRResourceType.OBSERVATION, FHIRResourceType.VITAL_SIGNS]\n        )\n\n        # Stream observations\n        async for observation in service.stream_observations(patient_id=\"patient-123\"):\n            print(f\"New observation: {observation.code_display}\")\n\n        # Get latest vitals for context\n        vitals = await service.get_latest_vitals(patient_id=\"patient-123\")\n    \"\"\"\n\n    def __init__(self, config: Optional[FHIRConfig] = None):\n        self.config = config or FHIRConfig()\n        self._subscriptions: Dict[str, FHIRSubscription] = {}\n        self._patient_subscriptions: Dict[str, Set[str]] = {}  # patient_id -> sub_ids\n        self._event_callbacks: Dict[str, List[Callable]] = {}\n        self._initialized = False\n        self._ws_connections: Dict[str, Any] = {}\n        self._lock = asyncio.Lock()\n\n    async def initialize(self) -> bool:\n        \"\"\"Initialize the FHIR service.\"\"\"\n        if self._initialized:\n            return True\n\n        async with self._lock:\n            if self._initialized:\n                return True\n\n            try:\n                # Check feature flag\n                if not await feature_flag_service.is_enabled(\n                    \"backend.voice_v4_fhir_streaming\"\n                ):\n                    logger.info(\"FHIR streaming feature flag is disabled\")\n                    return False\n\n                # Load configuration from settings\n                if hasattr(settings, \"fhir_server_url\"):\n                    self.config.fhir_server_url = settings.fhir_server_url\n                if hasattr(settings, \"fhir_auth_token\"):\n                    self.config.auth_token = settings.fhir_auth_token\n\n                if not self.config.fhir_server_url:\n                    logger.warning(\"FHIR server URL not configured\")\n                    return False\n\n                # Test connection\n                if not await self._test_connection():\n                    logger.error(\"Failed to connect to FHIR server\")\n                    return False\n\n                self._initialized = True\n                logger.info(\n                    \"FHIR subscription service initialized\",\n                    extra={\"server_url\": self.config.fhir_server_url},\n                )\n                return True\n\n            except Exception as e:\n                logger.error(f\"Failed to initialize FHIR service: {e}\")\n                return False\n\n    async def _test_connection(self) -> bool:\n        \"\"\"Test connection to FHIR server.\"\"\"\n        try:\n            import httpx\n\n            async with httpx.AsyncClient() as client:\n                headers = self._get_auth_headers()\n                response = await client.get(\n                    f\"{self.config.fhir_server_url}/metadata\",\n                    headers=headers,\n                    timeout=10.0,\n                )\n                return response.status_code == 200\n        except Exception as e:\n            logger.error(f\"FHIR connection test failed: {e}\")\n            return False\n\n    def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Get authentication headers for FHIR requests.\"\"\"\n        headers = {\"Content-Type\": \"application/fhir+json\"}\n\n        if self.config.auth_token:\n            if self.config.auth_type == \"bearer\":\n                headers[\"Authorization\"] = f\"Bearer {self.config.auth_token}\"\n            elif self.config.auth_type == \"basic\":\n                headers[\"Authorization\"] = f\"Basic {self.config.auth_token}\"\n\n        return headers\n\n    def _json_dumps(self, data: Dict[str, Any]) -> str:\n        \"\"\"Serialize dict to JSON string.\"\"\"\n        import json\n        return json.dumps(data)\n\n    def _json_loads(self, data: str) -> Dict[str, Any]:\n        \"\"\"Deserialize JSON string to dict.\"\"\"\n        import json\n        return json.loads(data)\n\n    async def subscribe_to_patient(\n        self,\n        patient_id: str,\n        resource_types: Optional[List[FHIRResourceType]] = None,\n        session_id: Optional[str] = None,\n    ) -> Optional[FHIRSubscription]:\n        \"\"\"\n        Subscribe to real-time updates for a patient.\n\n        Args:\n            patient_id: FHIR patient ID\n            resource_types: Types of resources to subscribe to\n            session_id: Voice session ID for correlation\n\n        Returns:\n            FHIRSubscription if successful, None otherwise.\n        \"\"\"\n        if not self._initialized:\n            if not await self.initialize():\n                return None\n\n        # Default to common clinical resources\n        if resource_types is None:\n            resource_types = [\n                FHIRResourceType.OBSERVATION,\n                FHIRResourceType.VITAL_SIGNS,\n                FHIRResourceType.LAB_RESULT,\n            ]\n\n        # Check subscription limit\n        existing = self._patient_subscriptions.get(patient_id, set())\n        if len(existing) >= self.config.max_subscriptions_per_patient:\n            logger.warning(f\"Max subscriptions reached for patient {patient_id}\")\n            return None\n\n        try:\n            import uuid\n\n            subscription_id = f\"sub-{uuid.uuid4().hex[:12]}\"\n\n            subscription = FHIRSubscription(\n                subscription_id=subscription_id,\n                patient_id=patient_id,\n                resource_types=resource_types,\n                status=SubscriptionStatus.ACTIVE,\n            )\n\n            # Store subscription\n            self._subscriptions[subscription_id] = subscription\n            if patient_id not in self._patient_subscriptions:\n                self._patient_subscriptions[patient_id] = set()\n            self._patient_subscriptions[patient_id].add(subscription_id)\n\n            # Start streaming based on channel type\n            if self.config.subscription_channel == \"websocket\":\n                asyncio.create_task(\n                    self._start_websocket_subscription(subscription)\n                )\n            elif self.config.subscription_channel == \"polling\":\n                asyncio.create_task(self._start_polling_subscription(subscription))\n\n            logger.info(\n                \"FHIR subscription created\",\n                extra={\n                    \"subscription_id\": subscription_id,\n                    \"patient_id\": patient_id,\n                    \"resource_types\": [rt.value for rt in resource_types],\n                    \"session_id\": session_id,\n                },\n            )\n\n            return subscription\n\n        except Exception as e:\n            logger.error(f\"Failed to create FHIR subscription: {e}\")\n            return None\n\n    async def unsubscribe(self, subscription_id: str) -> bool:\n        \"\"\"Cancel a subscription.\"\"\"\n        subscription = self._subscriptions.pop(subscription_id, None)\n        if subscription:\n            # Remove from patient mapping\n            patient_subs = self._patient_subscriptions.get(subscription.patient_id, set())\n            patient_subs.discard(subscription_id)\n\n            # Close WebSocket if exists\n            ws = self._ws_connections.pop(subscription_id, None)\n            if ws:\n                await ws.close()\n\n            logger.info(f\"FHIR subscription cancelled: {subscription_id}\")\n            return True\n        return False\n\n    async def stream_observations(\n        self,\n        patient_id: str,\n        resource_types: Optional[List[FHIRResourceType]] = None,\n    ):\n        \"\"\"\n        Stream observations for a patient as they arrive.\n\n        Args:\n            patient_id: FHIR patient ID\n            resource_types: Filter by resource types (optional)\n\n        Yields:\n            FHIRObservation for each new observation.\n        \"\"\"\n        # Create subscription if needed\n        existing_subs = self._patient_subscriptions.get(patient_id, set())\n        if not existing_subs:\n            subscription = await self.subscribe_to_patient(patient_id, resource_types)\n            if not subscription:\n                return\n\n        # Create event queue for this stream\n        queue: asyncio.Queue = asyncio.Queue()\n\n        def callback(event: StreamingEvent):\n            if event.observation:\n                asyncio.create_task(queue.put(event.observation))\n\n        # Register callback\n        self._register_callback(patient_id, callback)\n\n        try:\n            while True:\n                observation = await queue.get()\n                yield observation\n        finally:\n            self._unregister_callback(patient_id, callback)\n\n    async def get_latest_vitals(\n        self,\n        patient_id: str,\n        max_results: int = 10,\n    ) -> List[FHIRObservation]:\n        \"\"\"\n        Get the latest vital signs for a patient.\n\n        Args:\n            patient_id: FHIR patient ID\n            max_results: Maximum observations to return\n\n        Returns:\n            List of recent vital sign observations.\n        \"\"\"\n        if not self._initialized:\n            if not await self.initialize():\n                return []\n\n        try:\n            import httpx\n\n            async with httpx.AsyncClient() as client:\n                # Query for vital signs observations\n                params = {\n                    \"patient\": patient_id,\n                    \"category\": \"vital-signs\",\n                    \"_sort\": \"-date\",\n                    \"_count\": max_results,\n                }\n\n                response = await client.get(\n                    f\"{self.config.fhir_server_url}/Observation\",\n                    params=params,\n                    headers=self._get_auth_headers(),\n                    timeout=30.0,\n                )\n\n                if response.status_code != 200:\n                    logger.error(f\"Failed to fetch vitals: {response.status_code}\")\n                    return []\n\n                bundle = response.json()\n                return self._parse_observation_bundle(bundle, patient_id)\n\n        except Exception as e:\n            logger.error(f\"Failed to get latest vitals: {e}\")\n            return []\n\n    async def get_latest_labs(\n        self,\n        patient_id: str,\n        max_results: int = 20,\n    ) -> List[FHIRObservation]:\n        \"\"\"\n        Get the latest lab results for a patient.\n\n        Args:\n            patient_id: FHIR patient ID\n            max_results: Maximum observations to return\n\n        Returns:\n            List of recent lab result observations.\n        \"\"\"\n        if not self._initialized:\n            if not await self.initialize():\n                return []\n\n        try:\n            import httpx\n\n            async with httpx.AsyncClient() as client:\n                params = {\n                    \"patient\": patient_id,\n                    \"category\": \"laboratory\",\n                    \"_sort\": \"-date\",\n                    \"_count\": max_results,\n                }\n\n                response = await client.get(\n                    f\"{self.config.fhir_server_url}/Observation\",\n                    params=params,\n                    headers=self._get_auth_headers(),\n                    timeout=30.0,\n                )\n\n                if response.status_code != 200:\n                    logger.error(f\"Failed to fetch labs: {response.status_code}\")\n                    return []\n\n                bundle = response.json()\n                return self._parse_observation_bundle(bundle, patient_id)\n\n        except Exception as e:\n            logger.error(f\"Failed to get latest labs: {e}\")\n            return []\n\n    def _parse_observation_bundle(\n        self,\n        bundle: Dict[str, Any],\n        patient_id: str,\n    ) -> List[FHIRObservation]:\n        \"\"\"Parse FHIR Bundle into list of observations.\"\"\"\n        observations = []\n\n        entries = bundle.get(\"entry\", [])\n        for entry in entries:\n            resource = entry.get(\"resource\", {})\n            if resource.get(\"resourceType\") != \"Observation\":\n                continue\n\n            try:\n                # Extract code\n                code_obj = resource.get(\"code\", {})\n                coding = code_obj.get(\"coding\", [{}])[0]\n\n                # Extract value\n                value = None\n                value_quantity = None\n                value_unit = None\n\n                if \"valueQuantity\" in resource:\n                    vq = resource[\"valueQuantity\"]\n                    value_quantity = vq.get(\"value\")\n                    value_unit = vq.get(\"unit\")\n                elif \"valueString\" in resource:\n                    value = resource[\"valueString\"]\n                elif \"valueCodeableConcept\" in resource:\n                    cc = resource[\"valueCodeableConcept\"]\n                    value = cc.get(\"text\") or cc.get(\"coding\", [{}])[0].get(\"display\")\n\n                # Extract interpretation\n                interpretation = None\n                if \"interpretation\" in resource:\n                    interp = resource[\"interpretation\"]\n                    if isinstance(interp, list) and interp:\n                        interpretation = (\n                            interp[0].get(\"text\")\n                            or interp[0].get(\"coding\", [{}])[0].get(\"display\")\n                        )\n\n                # Extract reference range\n                reference_range = None\n                if \"referenceRange\" in resource:\n                    rr = resource[\"referenceRange\"]\n                    if isinstance(rr, list) and rr:\n                        low = rr[0].get(\"low\", {}).get(\"value\")\n                        high = rr[0].get(\"high\", {}).get(\"value\")\n                        if low is not None and high is not None:\n                            reference_range = f\"{low}-{high}\"\n\n                # Parse effective datetime\n                effective_datetime = None\n                if \"effectiveDateTime\" in resource:\n                    from dateutil.parser import parse\n\n                    effective_datetime = parse(resource[\"effectiveDateTime\"])\n\n                observation = FHIRObservation(\n                    resource_id=resource.get(\"id\", \"\"),\n                    resource_type=FHIRResourceType.OBSERVATION,\n                    patient_id=patient_id,\n                    code=coding.get(\"code\", \"\"),\n                    code_display=coding.get(\"display\", code_obj.get(\"text\", \"\")),\n                    value=value,\n                    value_quantity=value_quantity,\n                    value_unit=value_unit,\n                    effective_datetime=effective_datetime,\n                    status=resource.get(\"status\", \"final\"),\n                    interpretation=interpretation,\n                    reference_range=reference_range,\n                    raw_resource=resource,\n                )\n                observations.append(observation)\n\n            except Exception as e:\n                logger.warning(f\"Failed to parse observation: {e}\")\n                continue\n\n        return observations\n\n    async def _start_websocket_subscription(self, subscription: FHIRSubscription):\n        \"\"\"\n        Start WebSocket-based subscription with reconnection support.\n\n        Implements FHIR R5 subscription framework with WebSocket channel.\n        \"\"\"\n        retry_count = 0\n        last_event_id: Optional[str] = None\n\n        while subscription.status == SubscriptionStatus.ACTIVE:\n            try:\n                import websockets\n\n                # Build WebSocket URL for subscription\n                ws_url = self._build_subscription_ws_url(subscription)\n\n                logger.info(\n                    f\"Connecting WebSocket subscription: {subscription.subscription_id}\",\n                    extra={\"url\": ws_url},\n                )\n\n                async with websockets.connect(\n                    ws_url,\n                    extra_headers=self._get_auth_headers(),\n                    ping_interval=30,\n                    ping_timeout=10,\n                ) as ws:\n                    # Store connection\n                    self._ws_connections[subscription.subscription_id] = ws\n                    retry_count = 0  # Reset retry count on successful connection\n\n                    # Send subscription bind message\n                    bind_message = {\n                        \"type\": \"bind\",\n                        \"subscriptionId\": subscription.subscription_id,\n                        \"patientId\": subscription.patient_id,\n                        \"resourceTypes\": [rt.value for rt in subscription.resource_types],\n                        \"lastEventId\": last_event_id,\n                    }\n                    await ws.send(self._json_dumps(bind_message))\n\n                    # Process incoming messages\n                    async for message in ws:\n                        try:\n                            data = self._json_loads(message)\n                            msg_type = data.get(\"type\")\n\n                            if msg_type == \"event\":\n                                # Process FHIR event\n                                event = self._parse_ws_event(subscription, data)\n                                if event:\n                                    last_event_id = event.event_id\n                                    self._emit_event_internal(event)\n\n                            elif msg_type == \"heartbeat\":\n                                # Heartbeat - connection is alive\n                                logger.debug(f\"WebSocket heartbeat: {subscription.subscription_id}\")\n\n                            elif msg_type == \"error\":\n                                error_msg = data.get(\"message\", \"Unknown error\")\n                                logger.error(f\"WebSocket error: {error_msg}\")\n                                subscription.error_message = error_msg\n                                if data.get(\"fatal\"):\n                                    subscription.status = SubscriptionStatus.ERROR\n                                    break\n\n                        except Exception as e:\n                            logger.error(f\"Error processing WebSocket message: {e}\")\n\n            except ImportError:\n                logger.warning(\"websockets package not installed, falling back to polling\")\n                await self._start_polling_subscription(subscription)\n                return\n\n            except Exception as e:\n                logger.error(f\"WebSocket connection error: {e}\")\n                retry_count += 1\n\n                if retry_count > self.config.max_retries:\n                    logger.error(f\"Max retries exceeded for subscription {subscription.subscription_id}\")\n                    subscription.status = SubscriptionStatus.ERROR\n                    subscription.error_message = f\"Connection failed after {retry_count} retries\"\n                    break\n\n                # Exponential backoff\n                delay = min(\n                    self.config.reconnect_delay_seconds * (2 ** (retry_count - 1)),\n                    300,  # Max 5 minutes\n                )\n                logger.info(f\"Reconnecting in {delay}s (attempt {retry_count})\")\n                await asyncio.sleep(delay)\n\n        # Cleanup\n        self._ws_connections.pop(subscription.subscription_id, None)\n        logger.info(f\"WebSocket subscription ended: {subscription.subscription_id}\")\n\n    def _build_subscription_ws_url(self, subscription: FHIRSubscription) -> str:\n        \"\"\"Build WebSocket URL for FHIR subscription.\"\"\"\n        # Convert HTTP(S) to WS(S)\n        base_url = self.config.fhir_server_url\n        if base_url.startswith(\"https://\"):\n            ws_url = \"wss://\" + base_url[8:]\n        elif base_url.startswith(\"http://\"):\n            ws_url = \"ws://\" + base_url[7:]\n        else:\n            ws_url = \"wss://\" + base_url\n\n        return f\"{ws_url}/Subscription/{subscription.subscription_id}/$stream\"\n\n    def _parse_ws_event(\n        self,\n        subscription: FHIRSubscription,\n        data: Dict[str, Any],\n    ) -> Optional[StreamingEvent]:\n        \"\"\"Parse WebSocket event message into StreamingEvent.\"\"\"\n        import uuid\n\n        try:\n            resource = data.get(\"resource\", {})\n            resource_type_str = resource.get(\"resourceType\", \"Observation\")\n\n            # Map to enum\n            resource_type = FHIRResourceType.OBSERVATION\n            for rt in FHIRResourceType:\n                if rt.value == resource_type_str:\n                    resource_type = rt\n                    break\n\n            # Parse observation if applicable\n            observation = None\n            if resource_type == FHIRResourceType.OBSERVATION:\n                observations = self._parse_observation_bundle(\n                    {\"entry\": [{\"resource\": resource}]},\n                    subscription.patient_id,\n                )\n                if observations:\n                    observation = observations[0]\n\n            return StreamingEvent(\n                event_id=data.get(\"eventId\", f\"evt-{uuid.uuid4().hex[:8]}\"),\n                subscription_id=subscription.subscription_id,\n                resource_type=resource_type,\n                resource_id=resource.get(\"id\", \"\"),\n                action=data.get(\"action\", \"update\"),\n                timestamp=datetime.now(timezone.utc),\n                observation=observation,\n                raw_payload=data,\n            )\n\n        except Exception as e:\n            logger.error(f\"Failed to parse WebSocket event: {e}\")\n            return None\n\n    def _emit_event_internal(self, event: StreamingEvent) -> None:\n        \"\"\"Internal event emission with subscription update.\"\"\"\n        subscription = self._subscriptions.get(event.subscription_id)\n        if subscription:\n            subscription.event_count += 1\n            subscription.last_event_at = event.timestamp\n\n            if event.observation:\n                self._emit_event(subscription, event.observation)\n\n    async def _start_polling_subscription(self, subscription: FHIRSubscription):\n        \"\"\"\n        Start polling-based subscription with change detection.\n\n        Implements efficient polling with:\n        - Last-Modified tracking to detect changes\n        - ETag support for conditional requests\n        - Rate limiting with adaptive intervals\n        \"\"\"\n        logger.info(f\"Polling subscription started: {subscription.subscription_id}\")\n\n        last_modified: Optional[str] = None\n        etag: Optional[str] = None\n        seen_ids: Set[str] = set()\n        last_poll_time: Optional[datetime] = None\n\n        while subscription.status == SubscriptionStatus.ACTIVE:\n            try:\n                import httpx\n\n                async with httpx.AsyncClient() as client:\n                    # Build query parameters\n                    params = {\n                        \"patient\": subscription.patient_id,\n                        \"_sort\": \"-_lastUpdated\",\n                        \"_count\": self.config.max_polling_results,\n                    }\n\n                    # Filter by resource types\n                    categories = []\n                    for rt in subscription.resource_types:\n                        if rt == FHIRResourceType.VITAL_SIGNS:\n                            categories.append(\"vital-signs\")\n                        elif rt == FHIRResourceType.LAB_RESULT:\n                            categories.append(\"laboratory\")\n\n                    if categories:\n                        params[\"category\"] = \",\".join(categories)\n\n                    # Add time filter if we have a last poll time\n                    if last_poll_time:\n                        params[\"_lastUpdated\"] = f\"gt{last_poll_time.isoformat()}\"\n\n                    # Build headers with conditional request support\n                    headers = self._get_auth_headers()\n                    if last_modified:\n                        headers[\"If-Modified-Since\"] = last_modified\n                    if etag:\n                        headers[\"If-None-Match\"] = etag\n\n                    response = await client.get(\n                        f\"{self.config.fhir_server_url}/Observation\",\n                        params=params,\n                        headers=headers,\n                        timeout=30.0,\n                    )\n\n                    # Handle conditional response\n                    if response.status_code == 304:\n                        # Not modified - no new data\n                        logger.debug(f\"No changes detected for {subscription.subscription_id}\")\n                    elif response.status_code == 200:\n                        # Update cache headers\n                        last_modified = response.headers.get(\"Last-Modified\")\n                        etag = response.headers.get(\"ETag\")\n\n                        # Parse and emit new observations\n                        bundle = response.json()\n                        observations = self._parse_observation_bundle(\n                            bundle, subscription.patient_id\n                        )\n\n                        for obs in observations:\n                            # Check if we've seen this observation\n                            if obs.resource_id not in seen_ids:\n                                seen_ids.add(obs.resource_id)\n                                self._emit_event(subscription, obs)\n\n                        # Limit seen_ids size\n                        if len(seen_ids) > 1000:\n                            seen_ids = set(list(seen_ids)[-500:])\n\n                    elif response.status_code >= 400:\n                        logger.error(\n                            f\"Polling request failed: {response.status_code}\",\n                            extra={\"response\": response.text[:500]},\n                        )\n\n                last_poll_time = datetime.now(timezone.utc)\n                await asyncio.sleep(self.config.polling_interval_seconds)\n\n            except Exception as e:\n                logger.error(f\"Polling error: {e}\")\n                subscription.error_message = str(e)\n                await asyncio.sleep(self.config.retry_delay_seconds)\n\n    def _register_callback(self, patient_id: str, callback: Callable):\n        \"\"\"Register callback for patient events.\"\"\"\n        if patient_id not in self._event_callbacks:\n            self._event_callbacks[patient_id] = []\n        self._event_callbacks[patient_id].append(callback)\n\n    def _unregister_callback(self, patient_id: str, callback: Callable):\n        \"\"\"Unregister callback for patient events.\"\"\"\n        callbacks = self._event_callbacks.get(patient_id, [])\n        if callback in callbacks:\n            callbacks.remove(callback)\n\n    def _emit_event(self, subscription: FHIRSubscription, observation: FHIRObservation):\n        \"\"\"Emit event to registered callbacks.\"\"\"\n        import uuid\n\n        event = StreamingEvent(\n            event_id=f\"evt-{uuid.uuid4().hex[:8]}\",\n            subscription_id=subscription.subscription_id,\n            resource_type=observation.resource_type,\n            resource_id=observation.resource_id,\n            action=\"update\",\n            timestamp=datetime.now(timezone.utc),\n            observation=observation,\n        )\n\n        subscription.event_count += 1\n        subscription.last_event_at = event.timestamp\n\n        callbacks = self._event_callbacks.get(subscription.patient_id, [])\n        for callback in callbacks:\n            try:\n                callback(event)\n            except Exception as e:\n                logger.error(f\"Event callback error: {e}\")\n\n\n# ==============================================================================\n# Context Injection Helpers\n# ==============================================================================\n\n\nclass FHIRContextBuilder:\n    \"\"\"\n    Builder for creating clinical context strings for Thinker injection.\n\n    Formats FHIR observations into natural language context that\n    can be injected into the AI assistant's context window.\n    \"\"\"\n\n    @staticmethod\n    def build_vitals_context(observations: List[FHIRObservation]) -> str:\n        \"\"\"\n        Build vitals summary for context injection.\n\n        Args:\n            observations: List of vital sign observations\n\n        Returns:\n            Natural language summary of vitals.\n        \"\"\"\n        if not observations:\n            return \"\"\n\n        lines = [\"Recent vital signs:\"]\n        for obs in observations:\n            lines.append(f\"  - {obs.to_context_string()}\")\n\n        return \"\\n\".join(lines)\n\n    @staticmethod\n    def build_labs_context(\n        observations: List[FHIRObservation],\n        highlight_abnormal: bool = True,\n    ) -> str:\n        \"\"\"\n        Build lab results summary for context injection.\n\n        Args:\n            observations: List of lab result observations\n            highlight_abnormal: Whether to highlight abnormal values\n\n        Returns:\n            Natural language summary of lab results.\n        \"\"\"\n        if not observations:\n            return \"\"\n\n        lines = [\"Recent lab results:\"]\n\n        # Group by category/panel if possible\n        abnormal = []\n        normal = []\n\n        for obs in observations:\n            context_str = obs.to_context_string()\n            if highlight_abnormal and obs.interpretation:\n                interp_lower = obs.interpretation.lower()\n                if any(x in interp_lower for x in [\"high\", \"low\", \"abnormal\", \"critical\"]):\n                    abnormal.append(f\"  - {context_str}\")\n                else:\n                    normal.append(f\"  - {context_str}\")\n            else:\n                normal.append(f\"  - {context_str}\")\n\n        if abnormal:\n            lines.append(\"  ABNORMAL VALUES:\")\n            lines.extend(abnormal)\n            if normal:\n                lines.append(\"  Other results:\")\n                lines.extend(normal[:5])  # Limit normal results\n        else:\n            lines.extend(normal[:10])  # Limit total results\n\n        return \"\\n\".join(lines)\n\n    @staticmethod\n    def build_clinical_summary(\n        vitals: List[FHIRObservation],\n        labs: List[FHIRObservation],\n        max_length: int = 1000,\n    ) -> str:\n        \"\"\"\n        Build comprehensive clinical summary for context injection.\n\n        Args:\n            vitals: List of vital sign observations\n            labs: List of lab result observations\n            max_length: Maximum character length\n\n        Returns:\n            Combined clinical context summary.\n        \"\"\"\n        sections = []\n\n        vitals_context = FHIRContextBuilder.build_vitals_context(vitals)\n        if vitals_context:\n            sections.append(vitals_context)\n\n        labs_context = FHIRContextBuilder.build_labs_context(labs)\n        if labs_context:\n            sections.append(labs_context)\n\n        if not sections:\n            return \"\"\n\n        result = \"\\n\\n\".join(sections)\n\n        # Truncate if needed\n        if len(result) > max_length:\n            result = result[: max_length - 3] + \"...\"\n\n        return result\n\n\nasync def get_patient_context_for_thinker(\n    patient_id: str,\n    include_vitals: bool = True,\n    include_labs: bool = True,\n    max_vitals: int = 5,\n    max_labs: int = 10,\n) -> str:\n    \"\"\"\n    Get formatted patient clinical context for Thinker injection.\n\n    This is a convenience function that fetches FHIR data and formats it\n    for injection into the AI assistant's context window.\n\n    Args:\n        patient_id: FHIR patient ID\n        include_vitals: Whether to include vital signs\n        include_labs: Whether to include lab results\n        max_vitals: Maximum vital sign observations\n        max_labs: Maximum lab result observations\n\n    Returns:\n        Formatted clinical context string.\n\n    Example:\n        context = await get_patient_context_for_thinker(\"patient-123\")\n        # Returns:\n        # Recent vital signs:\n        #   - Blood Pressure: 120/80 mmHg\n        #   - Heart Rate: 72 bpm\n        #\n        # Recent lab results:\n        #   ABNORMAL VALUES:\n        #   - Glucose: 180 mg/dL (High) [ref: 70-100]\n        #   Other results:\n        #   - Hemoglobin A1c: 6.5 %\n    \"\"\"\n    service = get_fhir_subscription_service()\n\n    vitals = []\n    labs = []\n\n    if include_vitals:\n        vitals = await service.get_latest_vitals(patient_id, max_results=max_vitals)\n\n    if include_labs:\n        labs = await service.get_latest_labs(patient_id, max_results=max_labs)\n\n    return FHIRContextBuilder.build_clinical_summary(vitals, labs)\n\n\n# ==============================================================================\n# Singleton Instance\n# ==============================================================================\n\n_fhir_subscription_service: Optional[FHIRSubscriptionService] = None\n\n\ndef get_fhir_subscription_service() -> FHIRSubscriptionService:\n    \"\"\"Get or create FHIR subscription service instance.\"\"\"\n    global _fhir_subscription_service\n    if _fhir_subscription_service is None:\n        _fhir_subscription_service = FHIRSubscriptionService()\n    return _fhir_subscription_service\n"
}
