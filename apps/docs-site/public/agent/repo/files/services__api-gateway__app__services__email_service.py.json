{
  "path": "services/api-gateway/app/services/email_service.py",
  "language": "python",
  "size": 42057,
  "last_modified": "2025-12-05T03:07:13.133Z",
  "lines": 1243,
  "content": "\"\"\"\nComplete Email Integration Service\n\nIMAP/SMTP email integration with support for:\n- Folder management\n- Email threading\n- Full-text search\n- Attachment handling\n- Email sending (reply/forward)\n- Draft management\n\nWorks with any IMAP/SMTP server including Nextcloud Mail.\n\"\"\"\n\nimport email\nimport email.utils\nimport functools\nimport re\nimport uuid\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom email.header import decode_header, make_header\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport aioimaplib\nimport aiosmtplib\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass EmailPriority(str, Enum):\n    \"\"\"Email priority levels.\"\"\"\n\n    LOW = \"low\"\n    NORMAL = \"normal\"\n    HIGH = \"high\"\n\n\nclass EmailFlag(str, Enum):\n    \"\"\"IMAP email flags.\"\"\"\n\n    SEEN = \"\\\\Seen\"\n    ANSWERED = \"\\\\Answered\"\n    FLAGGED = \"\\\\Flagged\"\n    DELETED = \"\\\\Deleted\"\n    DRAFT = \"\\\\Draft\"\n    RECENT = \"\\\\Recent\"\n\n\n@dataclass\nclass EmailAddress:\n    \"\"\"Parsed email address.\"\"\"\n\n    email: str\n    name: Optional[str] = None\n\n    def __str__(self) -> str:\n        if self.name:\n            return f'\"{self.name}\" <{self.email}>'\n        return self.email\n\n\n@dataclass\nclass EmailAttachment:\n    \"\"\"Email attachment.\"\"\"\n\n    filename: str\n    content_type: str\n    size: int\n    content: Optional[bytes] = None\n    content_id: Optional[str] = None  # For inline attachments\n\n\n@dataclass\nclass EmailFolder:\n    \"\"\"Email folder/mailbox.\"\"\"\n\n    name: str\n    delimiter: str = \"/\"\n    flags: List[str] = field(default_factory=list)\n    total_messages: int = 0\n    unread_messages: int = 0\n    recent_messages: int = 0\n\n    @property\n    def is_inbox(self) -> bool:\n        return self.name.upper() == \"INBOX\"\n\n    @property\n    def is_sent(self) -> bool:\n        return \"\\\\Sent\" in self.flags or self.name.lower() in [\"sent\", \"sent items\"]\n\n    @property\n    def is_drafts(self) -> bool:\n        return \"\\\\Drafts\" in self.flags or self.name.lower() in [\"drafts\"]\n\n    @property\n    def is_trash(self) -> bool:\n        return \"\\\\Trash\" in self.flags or self.name.lower() in [\"trash\", \"deleted\"]\n\n    @property\n    def is_spam(self) -> bool:\n        return \"\\\\Junk\" in self.flags or self.name.lower() in [\"spam\", \"junk\"]\n\n\n@dataclass\nclass Email:\n    \"\"\"Complete email message.\"\"\"\n\n    id: str\n    uid: int\n    subject: str\n    from_addr: EmailAddress\n    to_addrs: List[EmailAddress]\n    date: datetime\n    folder: str = \"INBOX\"\n\n    # Optional headers\n    cc_addrs: List[EmailAddress] = field(default_factory=list)\n    bcc_addrs: List[EmailAddress] = field(default_factory=list)\n    reply_to: Optional[EmailAddress] = None\n\n    # Content\n    body_text: Optional[str] = None\n    body_html: Optional[str] = None\n    preview: Optional[str] = None\n\n    # Attachments\n    attachments: List[EmailAttachment] = field(default_factory=list)\n    has_attachments: bool = False\n\n    # Threading\n    message_id: Optional[str] = None\n    in_reply_to: Optional[str] = None\n    references: List[str] = field(default_factory=list)\n    thread_id: Optional[str] = None\n\n    # Flags\n    is_read: bool = False\n    is_flagged: bool = False\n    is_answered: bool = False\n    is_draft: bool = False\n\n    # Priority\n    priority: EmailPriority = EmailPriority.NORMAL\n\n    # Raw headers for debugging\n    raw_headers: Dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass EmailThread:\n    \"\"\"Email conversation thread.\"\"\"\n\n    thread_id: str\n    subject: str\n    participants: List[EmailAddress]\n    messages: List[Email]\n    last_message_date: datetime\n    unread_count: int = 0\n    total_count: int = 0\n\n\n@dataclass\nclass PaginatedEmails:\n    \"\"\"Paginated email list response.\"\"\"\n\n    messages: List[Email]\n    total: int\n    page: int\n    page_size: int\n    has_more: bool = False\n\n    @property\n    def total_pages(self) -> int:\n        return (self.total + self.page_size - 1) // self.page_size\n\n\n@dataclass\nclass EmailSearchQuery:\n    \"\"\"Email search query parameters.\"\"\"\n\n    text: Optional[str] = None\n    from_addr: Optional[str] = None\n    to_addr: Optional[str] = None\n    subject: Optional[str] = None\n    has_attachment: Optional[bool] = None\n    is_unread: Optional[bool] = None\n    is_flagged: Optional[bool] = None\n    date_from: Optional[datetime] = None\n    date_to: Optional[datetime] = None\n    folder: str = \"INBOX\"\n\n\nclass EmailService:\n    \"\"\"\n    Complete IMAP/SMTP email integration service.\n\n    Provides async email operations with support for\n    threading, search, and attachment handling.\n    \"\"\"\n\n    def __init__(\n        self,\n        imap_host: str,\n        imap_port: int = 993,\n        smtp_host: str = \"\",\n        smtp_port: int = 587,\n        username: str = \"\",\n        password: str = \"\",\n        use_ssl: bool = True,\n        use_starttls: bool = True,\n    ):\n        self.imap_host = imap_host\n        self.imap_port = imap_port\n        self.smtp_host = smtp_host or imap_host\n        self.smtp_port = smtp_port\n        self.username = username\n        self.password = password\n        self.use_ssl = use_ssl\n        self.use_starttls = use_starttls\n\n        self._imap_client: Optional[aioimaplib.IMAP4_SSL] = None\n\n    async def _reset_imap_connection(self) -> None:\n        \"\"\"Force close current IMAP connection.\"\"\"\n        if self._imap_client:\n            try:\n                await self._imap_client.logout()\n            except Exception:\n                pass\n        self._imap_client = None\n\n    async def _get_imap_connection(self) -> aioimaplib.IMAP4_SSL:\n        \"\"\"Get or create IMAP connection.\"\"\"\n        if self._imap_client is None:\n            try:\n                if self.use_ssl:\n                    self._imap_client = aioimaplib.IMAP4_SSL(\n                        host=self.imap_host,\n                        port=self.imap_port,\n                    )\n                else:\n                    self._imap_client = aioimaplib.IMAP4(\n                        host=self.imap_host,\n                        port=self.imap_port,\n                    )\n\n                await self._imap_client.wait_hello_from_server()\n                await self._imap_client.login(self.username, self.password)\n            except Exception as exc:\n                logger.error(f\"IMAP connection failed: {exc}\")\n                await self._reset_imap_connection()\n                raise\n\n        return self._imap_client\n\n    async def _execute_imap_command(self, command, *args, **kwargs):\n        \"\"\"Execute an IMAP command with automatic reconnect.\"\"\"\n        try:\n            return await command(*args, **kwargs)\n        except Exception:\n            logger.warning(\"IMAP command failed; resetting connection and retrying\")\n            await self._reset_imap_connection()\n            imap = await self._get_imap_connection()\n\n            rebound_command = self._rebind_imap_callable(command, imap)\n            return await rebound_command(*args, **kwargs)\n\n    def _rebind_imap_callable(self, command, imap):\n        \"\"\"Rebind an IMAP callable to a fresh client instance when possible.\"\"\"\n\n        def _rebind(cmd):\n            # Handle functools.partial wrapping bound methods\n            if isinstance(cmd, functools.partial):\n                rebound_inner = _rebind(cmd.func)\n                return functools.partial(rebound_inner, *cmd.args, **(cmd.keywords or {}))\n\n            # Rebind bound methods using their underlying function\n            if getattr(cmd, \"__self__\", None) is not None:\n                func = getattr(cmd, \"__func__\", None)\n                if func is not None:\n                    return func.__get__(imap, type(imap))\n\n                name = getattr(cmd, \"__name__\", None)\n                if name and hasattr(imap, name):\n                    return getattr(imap, name)\n\n            return cmd\n\n        rebound = _rebind(command)\n        if rebound is not command:\n            logger.debug(\"Rebound IMAP command to refreshed connection\")\n        return rebound\n\n    async def close(self) -> None:\n        \"\"\"Close IMAP connection.\"\"\"\n        if self._imap_client:\n            try:\n                await self._imap_client.logout()\n            except Exception:\n                pass\n            self._imap_client = None\n\n    async def list_folders(self) -> List[EmailFolder]:\n        \"\"\"List all email folders.\"\"\"\n        imap = await self._get_imap_connection()\n        response = await self._execute_imap_command(imap.list)\n\n        if response.result != \"OK\":\n            logger.error(f\"Failed to list folders: {response}\")\n            return []\n\n        folders = []\n        for line in response.lines:\n            if isinstance(line, bytes):\n                line = line.decode(\"utf-8\", errors=\"replace\")\n\n            # Parse LIST response: (flags) \"delimiter\" \"name\"\n            match = re.match(r'\\(([^)]*)\\)\\s+\"([^\"]+)\"\\s+\"?([^\"]+)\"?', line)\n            if match:\n                flags_str, delimiter, name = match.groups()\n                flags = [f.strip() for f in flags_str.split() if f.strip()]\n                folders.append(\n                    EmailFolder(\n                        name=name,\n                        delimiter=delimiter,\n                        flags=flags,\n                    )\n                )\n\n        # Get message counts for each folder\n        for folder in folders:\n            try:\n                status = await self._execute_imap_command(\n                    imap.status,\n                    f'\"{folder.name}\"',\n                    \"(MESSAGES UNSEEN RECENT)\",\n                )\n                if status.result == \"OK\":\n                    status_line = status.lines[0]\n                    if isinstance(status_line, bytes):\n                        status_line = status_line.decode()\n\n                    messages_match = re.search(r\"MESSAGES\\s+(\\d+)\", status_line)\n                    unseen_match = re.search(r\"UNSEEN\\s+(\\d+)\", status_line)\n                    recent_match = re.search(r\"RECENT\\s+(\\d+)\", status_line)\n\n                    if messages_match:\n                        folder.total_messages = int(messages_match.group(1))\n                    if unseen_match:\n                        folder.unread_messages = int(unseen_match.group(1))\n                    if recent_match:\n                        folder.recent_messages = int(recent_match.group(1))\n            except Exception as e:\n                logger.warning(f\"Failed to get status for {folder.name}: {e}\")\n\n        return folders\n\n    async def list_messages(\n        self,\n        folder: str = \"INBOX\",\n        page: int = 1,\n        page_size: int = 50,\n        search_query: Optional[EmailSearchQuery] = None,\n    ) -> PaginatedEmails:\n        \"\"\"List messages in folder with pagination.\"\"\"\n        imap = await self._get_imap_connection()\n\n        response = await self._execute_imap_command(imap.select, folder)\n        if response.result != \"OK\":\n            logger.error(f\"Failed to select folder {folder}: {response}\")\n            return PaginatedEmails(messages=[], total=0, page=page, page_size=page_size)\n\n        search_criteria = self._build_search_criteria(search_query)\n        response = await self._execute_imap_command(imap.search, search_criteria)\n        if response.result != \"OK\":\n            logger.error(f\"Search failed: {response}\")\n            return PaginatedEmails(messages=[], total=0, page=page, page_size=page_size)\n\n        message_ids = []\n        for line in response.lines:\n            if isinstance(line, bytes):\n                line = line.decode()\n            if line.strip():\n                message_ids.extend(line.strip().split())\n\n        message_ids = list(reversed(message_ids))\n        total = len(message_ids)\n\n        start = (page - 1) * page_size\n        end = start + page_size\n        page_ids = message_ids[start:end]\n\n        if not page_ids:\n            return PaginatedEmails(\n                messages=[],\n                total=total,\n                page=page,\n                page_size=page_size,\n                has_more=end < total,\n            )\n\n        messages = await self._fetch_messages(imap, page_ids, folder, headers_only=True)\n\n        return PaginatedEmails(\n            messages=messages,\n            total=total,\n            page=page,\n            page_size=page_size,\n            has_more=end < total,\n        )\n\n    def _build_search_criteria(self, query: Optional[EmailSearchQuery]) -> str:\n        \"\"\"Build IMAP search criteria from query.\"\"\"\n        if not query:\n            return \"ALL\"\n\n        criteria = []\n\n        if query.text:\n            criteria.append(f'(OR SUBJECT \"{query.text}\" FROM \"{query.text}\")')\n\n        if query.from_addr:\n            criteria.append(f'FROM \"{query.from_addr}\"')\n\n        if query.to_addr:\n            criteria.append(f'TO \"{query.to_addr}\"')\n\n        if query.subject:\n            criteria.append(f'SUBJECT \"{query.subject}\"')\n\n        if query.is_unread is True:\n            criteria.append(\"UNSEEN\")\n        elif query.is_unread is False:\n            criteria.append(\"SEEN\")\n\n        if query.is_flagged is True:\n            criteria.append(\"FLAGGED\")\n        elif query.is_flagged is False:\n            criteria.append(\"UNFLAGGED\")\n\n        if query.date_from:\n            date_str = query.date_from.strftime(\"%d-%b-%Y\")\n            criteria.append(f\"SINCE {date_str}\")\n\n        if query.date_to:\n            date_str = query.date_to.strftime(\"%d-%b-%Y\")\n            criteria.append(f\"BEFORE {date_str}\")\n\n        return \" \".join(criteria) if criteria else \"ALL\"\n\n    async def _fetch_messages(\n        self,\n        imap: aioimaplib.IMAP4_SSL,\n        message_ids: List[str],\n        folder: str,\n        headers_only: bool = False,\n    ) -> List[Email]:\n        \"\"\"Fetch messages by ID.\"\"\"\n        if not message_ids:\n            return []\n\n        if headers_only:\n            fetch_parts = \"(FLAGS BODY.PEEK[HEADER])\"\n        else:\n            fetch_parts = \"(FLAGS RFC822)\"\n\n        messages = []\n        id_list = \",\".join(message_ids)\n\n        response = await self._execute_imap_command(imap.fetch, id_list, fetch_parts)\n        if response.result != \"OK\":\n            logger.error(f\"Fetch failed: {response}\")\n            return []\n\n        current_id = None\n        current_data: Dict[str, Any] = {}\n\n        for line in response.lines:\n            if isinstance(line, bytes):\n                match = re.match(rb\"(\\d+)\\s+FETCH\\s+\\(\", line)\n                if match:\n                    if current_id and current_data:\n                        email_obj = self._parse_email_data(current_id, current_data, folder, headers_only)\n                        if email_obj:\n                            messages.append(email_obj)\n                    current_id = match.group(1).decode()\n                    current_data = {\"raw\": line}\n                elif current_data:\n                    current_data[\"raw\"] = current_data.get(\"raw\", b\"\") + line\n\n        if current_id and current_data:\n            email_obj = self._parse_email_data(current_id, current_data, folder, headers_only)\n            if email_obj:\n                messages.append(email_obj)\n\n        return messages\n\n    def _parse_email_data(\n        self,\n        msg_id: str,\n        data: Dict[str, Any],\n        folder: str,\n        headers_only: bool,\n    ) -> Optional[Email]:\n        \"\"\"Parse email from fetch response data.\"\"\"\n        try:\n            raw = data.get(\"raw\", b\"\")\n            if isinstance(raw, str):\n                raw = raw.encode()\n\n            if headers_only:\n                match = re.search(rb\"HEADER\\]\\s*\\{(\\d+)\\}\\r?\\n(.+)\", raw, re.DOTALL)\n            else:\n                match = re.search(rb\"RFC822\\]\\s*\\{(\\d+)\\}\\r?\\n(.+)\", raw, re.DOTALL)\n\n            if not match:\n                match = re.search(rb\"HEADER\\]\\s+(.+)\", raw, re.DOTALL)\n                if not match:\n                    match = re.search(rb\"RFC822\\s+(.+)\", raw, re.DOTALL)\n\n            if not match:\n                return None\n\n            email_content = match.group(2) if len(match.groups()) > 1 else match.group(1)\n            msg = email.message_from_bytes(email_content)\n\n            flags_match = re.search(rb\"FLAGS\\s*\\(([^)]*)\\)\", raw)\n            flags = []\n            if flags_match:\n                flags = flags_match.group(1).decode().split()\n\n            subject = self._decode_header(msg.get(\"Subject\", \"\"))\n            from_addr = self._parse_address(msg.get(\"From\", \"\"))\n            to_addrs = self._parse_addresses(msg.get(\"To\", \"\"))\n            cc_addrs = self._parse_addresses(msg.get(\"Cc\", \"\"))\n            date = self._parse_date(msg.get(\"Date\", \"\"))\n\n            email_obj = Email(\n                id=msg_id,\n                uid=int(msg_id),\n                subject=subject,\n                from_addr=from_addr,\n                to_addrs=to_addrs,\n                cc_addrs=cc_addrs,\n                date=date,\n                folder=folder,\n                message_id=msg.get(\"Message-ID\"),\n                in_reply_to=msg.get(\"In-Reply-To\"),\n                references=msg.get(\"References\", \"\").split(),\n                is_read=EmailFlag.SEEN.value in flags,\n                is_flagged=EmailFlag.FLAGGED.value in flags,\n                is_answered=EmailFlag.ANSWERED.value in flags,\n                is_draft=EmailFlag.DRAFT.value in flags,\n            )\n\n            if not headers_only:\n                email_obj.body_text = self._get_body_text(msg)\n                email_obj.body_html = self._get_body_html(msg)\n                email_obj.attachments = self._get_attachments(msg)\n                email_obj.has_attachments = len(email_obj.attachments) > 0\n            else:\n                email_obj.preview = subject[:100] if subject else \"\"\n\n            return email_obj\n\n        except Exception as e:\n            logger.error(f\"Failed to parse email {msg_id}: {e}\")\n            return None\n\n    def _decode_header(self, header: Optional[str]) -> str:\n        \"\"\"Decode email header.\"\"\"\n        if not header:\n            return \"\"\n        try:\n            decoded = str(make_header(decode_header(header)))\n            return decoded\n        except Exception:\n            return header\n\n    def _parse_address(self, addr_str: str) -> EmailAddress:\n        \"\"\"Parse a single email address.\"\"\"\n        if not addr_str:\n            return EmailAddress(email=\"\", name=None)\n        try:\n            name, addr = email.utils.parseaddr(addr_str)\n            name = self._decode_header(name) if name else None\n            return EmailAddress(email=addr, name=name)\n        except Exception:\n            return EmailAddress(email=addr_str, name=None)\n\n    def _parse_addresses(self, addr_str: str) -> List[EmailAddress]:\n        \"\"\"Parse multiple email addresses.\"\"\"\n        if not addr_str:\n            return []\n        addresses = []\n        for addr in email.utils.getaddresses([addr_str]):\n            name, email_addr = addr\n            if email_addr:\n                name = self._decode_header(name) if name else None\n                addresses.append(EmailAddress(email=email_addr, name=name))\n        return addresses\n\n    def _parse_date(self, date_str: str) -> datetime:\n        \"\"\"Parse email date header.\"\"\"\n        if not date_str:\n            return datetime.utcnow()\n        try:\n            parsed = email.utils.parsedate_to_datetime(date_str)\n            return parsed.replace(tzinfo=None)\n        except Exception:\n            return datetime.utcnow()\n\n    def _get_body_text(self, msg: email.message.Message) -> Optional[str]:\n        \"\"\"Extract plain text body from email.\"\"\"\n        if msg.is_multipart():\n            for part in msg.walk():\n                content_type = part.get_content_type()\n                content_disposition = str(part.get(\"Content-Disposition\", \"\"))\n                if content_type == \"text/plain\" and \"attachment\" not in content_disposition:\n                    payload = part.get_payload(decode=True)\n                    if payload:\n                        charset = part.get_content_charset() or \"utf-8\"\n                        return payload.decode(charset, errors=\"replace\")\n        else:\n            if msg.get_content_type() == \"text/plain\":\n                payload = msg.get_payload(decode=True)\n                if payload:\n                    charset = msg.get_content_charset() or \"utf-8\"\n                    return payload.decode(charset, errors=\"replace\")\n        return None\n\n    def _get_body_html(self, msg: email.message.Message) -> Optional[str]:\n        \"\"\"Extract HTML body from email.\"\"\"\n        if msg.is_multipart():\n            for part in msg.walk():\n                content_type = part.get_content_type()\n                content_disposition = str(part.get(\"Content-Disposition\", \"\"))\n                if content_type == \"text/html\" and \"attachment\" not in content_disposition:\n                    payload = part.get_payload(decode=True)\n                    if payload:\n                        charset = part.get_content_charset() or \"utf-8\"\n                        return payload.decode(charset, errors=\"replace\")\n        else:\n            if msg.get_content_type() == \"text/html\":\n                payload = msg.get_payload(decode=True)\n                if payload:\n                    charset = msg.get_content_charset() or \"utf-8\"\n                    return payload.decode(charset, errors=\"replace\")\n        return None\n\n    def _get_attachments(\n        self,\n        msg: email.message.Message,\n        include_content: bool = False,\n    ) -> List[EmailAttachment]:\n        \"\"\"Extract attachments from email.\"\"\"\n        attachments = []\n        if not msg.is_multipart():\n            return attachments\n\n        for part in msg.walk():\n            content_disposition = str(part.get(\"Content-Disposition\", \"\"))\n            if \"attachment\" in content_disposition or \"inline\" in content_disposition:\n                filename = part.get_filename()\n                if filename:\n                    filename = self._decode_header(filename)\n                else:\n                    filename = f\"attachment_{len(attachments) + 1}\"\n\n                content_type = part.get_content_type()\n                payload = part.get_payload(decode=True)\n                size = len(payload) if payload else 0\n\n                attachment = EmailAttachment(\n                    filename=filename,\n                    content_type=content_type,\n                    size=size,\n                    content=payload if include_content else None,\n                    content_id=part.get(\"Content-ID\"),\n                )\n                attachments.append(attachment)\n\n        return attachments\n\n    async def get_message(\n        self,\n        message_id: str,\n        folder: str = \"INBOX\",\n    ) -> Optional[Email]:\n        \"\"\"Get full message content.\"\"\"\n        imap = await self._get_imap_connection()\n        response = await self._execute_imap_command(imap.select, folder)\n        if response.result != \"OK\":\n            return None\n        messages = await self._fetch_messages(imap, [message_id], folder, headers_only=False)\n        return messages[0] if messages else None\n\n    async def send_email(\n        self,\n        to: List[str],\n        subject: str,\n        body: str,\n        cc: Optional[List[str]] = None,\n        bcc: Optional[List[str]] = None,\n        attachments: Optional[List[EmailAttachment]] = None,\n        reply_to_message_id: Optional[str] = None,\n        is_html: bool = False,\n        priority: EmailPriority = EmailPriority.NORMAL,\n    ) -> bool:\n        \"\"\"Send an email.\"\"\"\n        msg = MIMEMultipart(\"mixed\")\n        msg[\"From\"] = self.username\n        msg[\"To\"] = \", \".join(to)\n        msg[\"Subject\"] = subject\n        msg[\"Date\"] = email.utils.formatdate(localtime=True)\n        msg[\"Message-ID\"] = f\"<{uuid.uuid4()}@{self.smtp_host}>\"\n\n        if cc:\n            msg[\"Cc\"] = \", \".join(cc)\n\n        if reply_to_message_id:\n            msg[\"In-Reply-To\"] = reply_to_message_id\n            msg[\"References\"] = reply_to_message_id\n\n        if priority == EmailPriority.HIGH:\n            msg[\"X-Priority\"] = \"1\"\n            msg[\"Importance\"] = \"high\"\n        elif priority == EmailPriority.LOW:\n            msg[\"X-Priority\"] = \"5\"\n            msg[\"Importance\"] = \"low\"\n\n        content_type = \"html\" if is_html or \"<html>\" in body.lower() else \"plain\"\n        msg.attach(MIMEText(body, content_type, \"utf-8\"))\n\n        if attachments:\n            for attachment in attachments:\n                if attachment.content:\n                    part = MIMEApplication(attachment.content)\n                    part.add_header(\n                        \"Content-Disposition\",\n                        \"attachment\",\n                        filename=attachment.filename,\n                    )\n                    part.add_header(\"Content-Type\", attachment.content_type)\n                    msg.attach(part)\n\n        try:\n            all_recipients = to + (cc or []) + (bcc or [])\n\n            async with aiosmtplib.SMTP(\n                hostname=self.smtp_host,\n                port=self.smtp_port,\n                use_tls=self.use_ssl,\n                start_tls=self.use_starttls and not self.use_ssl,\n            ) as smtp:\n                await smtp.login(self.username, self.password)\n                await smtp.sendmail(self.username, all_recipients, msg.as_string())\n\n            logger.info(f\"Email sent to {len(all_recipients)} recipients\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to send email: {e}\")\n            return False\n\n    async def reply_to(\n        self,\n        original_message: Email,\n        body: str,\n        reply_all: bool = False,\n        attachments: Optional[List[EmailAttachment]] = None,\n        is_html: bool = False,\n    ) -> bool:\n        \"\"\"Reply to an email.\"\"\"\n        to = [original_message.from_addr.email]\n\n        cc = None\n        if reply_all:\n            cc = [\n                addr.email\n                for addr in original_message.to_addrs + original_message.cc_addrs\n                if addr.email.lower() != self.username.lower()\n            ]\n\n        subject = original_message.subject\n        if not subject.lower().startswith(\"re:\"):\n            subject = f\"Re: {subject}\"\n\n        return await self.send_email(\n            to=to,\n            subject=subject,\n            body=body,\n            cc=cc,\n            attachments=attachments,\n            reply_to_message_id=original_message.message_id,\n            is_html=is_html,\n        )\n\n    async def forward(\n        self,\n        original_message: Email,\n        to: List[str],\n        body: Optional[str] = None,\n        include_attachments: bool = True,\n    ) -> bool:\n        \"\"\"Forward an email.\"\"\"\n        subject = original_message.subject\n        if not subject.lower().startswith(\"fwd:\"):\n            subject = f\"Fwd: {subject}\"\n\n        forward_header = f\"\"\"\n---------- Forwarded message ---------\nFrom: {original_message.from_addr}\nDate: {original_message.date.strftime('%Y-%m-%d %H:%M')}\nSubject: {original_message.subject}\nTo: {', '.join(str(a) for a in original_message.to_addrs)}\n\n\"\"\"\n        original_body = original_message.body_text or original_message.body_html or \"\"\n        full_body = (body or \"\") + forward_header + original_body\n        attachments = original_message.attachments if include_attachments else None\n\n        return await self.send_email(to=to, subject=subject, body=full_body, attachments=attachments)\n\n    async def mark_as_read(self, message_id: str, folder: str = \"INBOX\") -> bool:\n        \"\"\"Mark message as read.\"\"\"\n        return await self._set_flag(message_id, folder, EmailFlag.SEEN, True)\n\n    async def mark_as_unread(self, message_id: str, folder: str = \"INBOX\") -> bool:\n        \"\"\"Mark message as unread.\"\"\"\n        return await self._set_flag(message_id, folder, EmailFlag.SEEN, False)\n\n    async def flag_message(self, message_id: str, folder: str = \"INBOX\") -> bool:\n        \"\"\"Flag/star a message.\"\"\"\n        return await self._set_flag(message_id, folder, EmailFlag.FLAGGED, True)\n\n    async def unflag_message(self, message_id: str, folder: str = \"INBOX\") -> bool:\n        \"\"\"Unflag/unstar a message.\"\"\"\n        return await self._set_flag(message_id, folder, EmailFlag.FLAGGED, False)\n\n    async def _set_flag(\n        self,\n        message_id: str,\n        folder: str,\n        flag: EmailFlag,\n        value: bool,\n    ) -> bool:\n        \"\"\"Set or remove a flag on a message.\"\"\"\n        imap = await self._get_imap_connection()\n        response = await self._execute_imap_command(imap.select, folder)\n        if response.result != \"OK\":\n            return False\n\n        action = \"+FLAGS\" if value else \"-FLAGS\"\n        response = await self._execute_imap_command(imap.store, message_id, action, flag.value)\n        return response.result == \"OK\"\n\n    async def move_message(\n        self,\n        message_id: str,\n        from_folder: str,\n        to_folder: str,\n    ) -> bool:\n        \"\"\"Move message to another folder.\"\"\"\n        imap = await self._get_imap_connection()\n\n        response = await self._execute_imap_command(imap.select, from_folder)\n        if response.result != \"OK\":\n            return False\n\n        response = await self._execute_imap_command(imap.copy, message_id, to_folder)\n        if response.result != \"OK\":\n            return False\n\n        response = await self._execute_imap_command(imap.store, message_id, \"+FLAGS\", EmailFlag.DELETED.value)\n        if response.result != \"OK\":\n            return False\n\n        await self._execute_imap_command(imap.expunge)\n        return True\n\n    async def delete_message(\n        self,\n        message_id: str,\n        folder: str = \"INBOX\",\n        permanent: bool = False,\n    ) -> bool:\n        \"\"\"Delete a message.\"\"\"\n        imap = await self._get_imap_connection()\n\n        response = await self._execute_imap_command(imap.select, folder)\n        if response.result != \"OK\":\n            return False\n\n        if permanent:\n            response = await self._execute_imap_command(imap.store, message_id, \"+FLAGS\", EmailFlag.DELETED.value)\n            if response.result == \"OK\":\n                await self._execute_imap_command(imap.expunge)\n                return True\n        else:\n            folders = await self.list_folders()\n            trash_folder = next((f.name for f in folders if f.is_trash), \"Trash\")\n            return await self.move_message(message_id, folder, trash_folder)\n\n        return False\n\n    async def get_thread(\n        self,\n        message_id: str,\n        folder: str = \"INBOX\",\n    ) -> Optional[EmailThread]:\n        \"\"\"Get all messages in a thread.\"\"\"\n        message = await self.get_message(message_id, folder)\n        if not message:\n            return None\n\n        thread_id = message.in_reply_to or message.message_id\n\n        imap = await self._get_imap_connection()\n        await self._execute_imap_command(imap.select, folder)\n\n        message_ids = set()\n\n        if thread_id:\n            response = await self._execute_imap_command(imap.search, f'HEADER \"References\" \"{thread_id}\"')\n            if response.result == \"OK\":\n                for line in response.lines:\n                    if isinstance(line, bytes):\n                        line = line.decode()\n                    message_ids.update(line.split())\n\n            response = await self._execute_imap_command(imap.search, f'HEADER \"Message-ID\" \"{thread_id}\"')\n            if response.result == \"OK\":\n                for line in response.lines:\n                    if isinstance(line, bytes):\n                        line = line.decode()\n                    message_ids.update(line.split())\n\n        message_ids.add(message_id)\n\n        messages = await self._fetch_messages(imap, list(message_ids), folder, headers_only=False)\n\n        if not messages:\n            return None\n\n        messages.sort(key=lambda m: m.date)\n\n        participants = set()\n        for msg in messages:\n            participants.add(msg.from_addr)\n            participants.update(msg.to_addrs)\n\n        return EmailThread(\n            thread_id=thread_id or message_id,\n            subject=messages[0].subject,\n            participants=list(participants),\n            messages=messages,\n            last_message_date=messages[-1].date,\n            unread_count=sum(1 for m in messages if not m.is_read),\n            total_count=len(messages),\n        )\n\n    async def search(self, query: EmailSearchQuery) -> PaginatedEmails:\n        \"\"\"Search emails with query.\"\"\"\n        return await self.list_messages(folder=query.folder, search_query=query)\n\n\n# Singleton instance\n_email_service: Optional[EmailService] = None\n\n\ndef get_email_service() -> Optional[EmailService]:\n    \"\"\"Get email service singleton.\"\"\"\n    return _email_service\n\n\ndef configure_email_service(\n    imap_host: str,\n    imap_port: int = 993,\n    smtp_host: str = \"\",\n    smtp_port: int = 587,\n    username: str = \"\",\n    password: str = \"\",\n) -> EmailService:\n    \"\"\"Configure and return email service.\"\"\"\n    global _email_service\n    _email_service = EmailService(\n        imap_host=imap_host,\n        imap_port=imap_port,\n        smtp_host=smtp_host,\n        smtp_port=smtp_port,\n        username=username,\n        password=password,\n    )\n    return _email_service\n\n\n# =============================================================================\n# Admin Panel Email Functions (Invitations, Password Resets)\n# =============================================================================\n\n\nasync def send_admin_email(\n    to: str,\n    subject: str,\n    body_html: str,\n    body_text: Optional[str] = None,\n) -> bool:\n    \"\"\"\n    Send an admin email using SMTP configuration from settings.\n\n    Used for system emails like invitations and password resets.\n    \"\"\"\n    from app.core.config import settings\n\n    if not settings.SMTP_USER or not settings.SMTP_PASSWORD:\n        logger.error(\"SMTP not configured - cannot send email\")\n        return False\n\n    msg = MIMEMultipart(\"alternative\")\n    msg[\"From\"] = settings.SMTP_FROM or settings.SMTP_USER\n    msg[\"To\"] = to\n    msg[\"Subject\"] = subject\n    msg[\"Date\"] = email.utils.formatdate(localtime=True)\n    msg[\"Message-ID\"] = f\"<{uuid.uuid4()}@asimo.io>\"\n\n    # Add plain text version (fallback)\n    if body_text:\n        msg.attach(MIMEText(body_text, \"plain\", \"utf-8\"))\n\n    # Add HTML version\n    msg.attach(MIMEText(body_html, \"html\", \"utf-8\"))\n\n    try:\n        async with aiosmtplib.SMTP(\n            hostname=settings.SMTP_HOST,\n            port=settings.SMTP_PORT,\n            use_tls=settings.SMTP_USE_SSL,\n            start_tls=not settings.SMTP_USE_SSL,  # Use STARTTLS only if not using SSL\n        ) as smtp:\n            await smtp.login(settings.SMTP_USER, settings.SMTP_PASSWORD)\n            await smtp.sendmail(settings.SMTP_FROM or settings.SMTP_USER, [to], msg.as_string())\n\n        logger.info(f\"Admin email sent to {to}: {subject}\")\n        return True\n\n    except Exception as e:\n        logger.error(f\"Failed to send admin email to {to}: {e}\")\n        return False\n\n\nasync def send_invitation_email(\n    to: str,\n    inviter_name: str,\n    invitation_link: str,\n    expires_in_days: int = 7,\n) -> bool:\n    \"\"\"Send an invitation email to a new user.\"\"\"\n    subject = \"You've been invited to join Asimo Admin Panel\"\n\n    body_html = f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <style>\n        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; line-height: 1.6; color: #333; }}\n        .container {{ max-width: 600px; margin: 0 auto; padding: 40px 20px; }}\n        .header {{ text-align: center; margin-bottom: 30px; }}\n        .header h1 {{ color: #6366f1; margin: 0; }}\n        .content {{ background: #f9fafb; border-radius: 8px; padding: 30px; margin-bottom: 30px; }}\n        .button {{ display: inline-block; background: #6366f1; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }}\n        .button:hover {{ background: #4f46e5; }}\n        .footer {{ text-align: center; color: #6b7280; font-size: 14px; }}\n        .expires {{ color: #dc2626; font-size: 14px; margin-top: 20px; }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Asimo Admin Panel</h1>\n        </div>\n        <div class=\"content\">\n            <p>Hi there,</p>\n            <p><strong>{inviter_name}</strong> has invited you to join the Asimo Admin Panel.</p>\n            <p>Click the button below to set up your account:</p>\n            <p style=\"text-align: center; margin: 30px 0;\">\n                <a href=\"{invitation_link}\" class=\"button\">Accept Invitation</a>\n            </p>\n            <p class=\"expires\">This invitation expires in {expires_in_days} days.</p>\n        </div>\n        <div class=\"footer\">\n            <p>If you didn't expect this invitation, you can safely ignore this email.</p>\n            <p>&copy; Asimo.io</p>\n        </div>\n    </div>\n</body>\n</html>\n\"\"\"\n\n    body_text = f\"\"\"\nYou've been invited to join Asimo Admin Panel\n\n{inviter_name} has invited you to join the Asimo Admin Panel.\n\nClick the link below to set up your account:\n{invitation_link}\n\nThis invitation expires in {expires_in_days} days.\n\nIf you didn't expect this invitation, you can safely ignore this email.\n\"\"\"\n\n    return await send_admin_email(to, subject, body_html, body_text)\n\n\nasync def send_password_reset_email(\n    to: str,\n    reset_link: str,\n    expires_in_hours: int = 24,\n) -> bool:\n    \"\"\"Send a password reset email.\"\"\"\n    subject = \"Reset your Asimo Admin Panel password\"\n\n    body_html = f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <style>\n        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; line-height: 1.6; color: #333; }}\n        .container {{ max-width: 600px; margin: 0 auto; padding: 40px 20px; }}\n        .header {{ text-align: center; margin-bottom: 30px; }}\n        .header h1 {{ color: #6366f1; margin: 0; }}\n        .content {{ background: #f9fafb; border-radius: 8px; padding: 30px; margin-bottom: 30px; }}\n        .button {{ display: inline-block; background: #6366f1; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 600; }}\n        .button:hover {{ background: #4f46e5; }}\n        .footer {{ text-align: center; color: #6b7280; font-size: 14px; }}\n        .warning {{ background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; padding: 15px; margin-top: 20px; color: #991b1b; font-size: 14px; }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Asimo Admin Panel</h1>\n        </div>\n        <div class=\"content\">\n            <p>Hi,</p>\n            <p>We received a request to reset your password. Click the button below to choose a new password:</p>\n            <p style=\"text-align: center; margin: 30px 0;\">\n                <a href=\"{reset_link}\" class=\"button\">Reset Password</a>\n            </p>\n            <p style=\"color: #6b7280; font-size: 14px;\">This link expires in {expires_in_hours} hours.</p>\n            <div class=\"warning\">\n                If you didn't request a password reset, please ignore this email or contact support if you have concerns.\n            </div>\n        </div>\n        <div class=\"footer\">\n            <p>&copy; Asimo.io</p>\n        </div>\n    </div>\n</body>\n</html>\n\"\"\"\n\n    body_text = f\"\"\"\nReset your Asimo Admin Panel password\n\nWe received a request to reset your password. Click the link below to choose a new password:\n\n{reset_link}\n\nThis link expires in {expires_in_hours} hours.\n\nIf you didn't request a password reset, please ignore this email or contact support if you have concerns.\n\"\"\"\n\n    return await send_admin_email(to, subject, body_html, body_text)\n\n\nasync def send_temporary_password_email(\n    to: str,\n    temporary_password: str,\n) -> bool:\n    \"\"\"Send an email with a temporary password.\"\"\"\n    subject = \"Your temporary password for Asimo Admin Panel\"\n\n    body_html = f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <style>\n        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; line-height: 1.6; color: #333; }}\n        .container {{ max-width: 600px; margin: 0 auto; padding: 40px 20px; }}\n        .header {{ text-align: center; margin-bottom: 30px; }}\n        .header h1 {{ color: #6366f1; margin: 0; }}\n        .content {{ background: #f9fafb; border-radius: 8px; padding: 30px; margin-bottom: 30px; }}\n        .password-box {{ background: #1f2937; color: #f9fafb; padding: 15px 20px; border-radius: 6px; font-family: monospace; font-size: 18px; text-align: center; margin: 20px 0; letter-spacing: 1px; }}\n        .footer {{ text-align: center; color: #6b7280; font-size: 14px; }}\n        .warning {{ background: #fef3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 15px; margin-top: 20px; color: #856404; font-size: 14px; }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Asimo Admin Panel</h1>\n        </div>\n        <div class=\"content\">\n            <p>Hi,</p>\n            <p>Your password has been reset. Use the temporary password below to log in:</p>\n            <div class=\"password-box\">{temporary_password}</div>\n            <div class=\"warning\">\n                <strong>Important:</strong> You will be required to change this password on your next login.\n            </div>\n        </div>\n        <div class=\"footer\">\n            <p>&copy; Asimo.io</p>\n        </div>\n    </div>\n</body>\n</html>\n\"\"\"\n\n    body_text = f\"\"\"\nYour temporary password for Asimo Admin Panel\n\nYour password has been reset. Use the temporary password below to log in:\n\n{temporary_password}\n\nImportant: You will be required to change this password on your next login.\n\"\"\"\n\n    return await send_admin_email(to, subject, body_html, body_text)\n"
}
