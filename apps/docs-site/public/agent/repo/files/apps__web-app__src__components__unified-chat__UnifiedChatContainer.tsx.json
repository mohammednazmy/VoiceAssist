{
  "path": "apps/web-app/src/components/unified-chat/UnifiedChatContainer.tsx",
  "language": "typescript",
  "size": 31731,
  "last_modified": "2025-12-04T01:16:34.774Z",
  "lines": 916,
  "content": "/**\n * Unified Chat Container\n *\n * Main container for the unified chat/voice interface.\n * Provides three-panel layout with collapsible sidebar and context pane.\n *\n * This component is rendered when the unified_chat_voice_ui feature flag is enabled.\n */\n\nimport {\n  useState,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  lazy,\n  Suspense,\n} from \"react\";\nimport { useParams, useNavigate, useLocation } from \"react-router-dom\";\nimport { useShallow } from \"zustand/react/shallow\";\nimport { useAuth } from \"../../hooks/useAuth\";\nimport { useToastContext } from \"../../contexts/ToastContext\";\nimport {\n  useUnifiedConversationStore,\n  type MessageSource,\n} from \"../../stores/unifiedConversationStore\";\nimport { useVoiceSettingsStore } from \"../../stores/voiceSettingsStore\";\nimport { useAnnouncer } from \"../accessibility/LiveRegion\";\nimport { useChatSession } from \"../../hooks/useChatSession\";\nimport { useConversations } from \"../../hooks/useConversations\";\nimport { MessageList } from \"../chat/MessageList\";\nimport { ConnectionStatus } from \"../chat/ConnectionStatus\";\nimport { ChatErrorBoundary } from \"../chat/ChatErrorBoundary\";\nimport { UnifiedInputArea } from \"./UnifiedInputArea\";\nimport { CollapsibleSidebar } from \"./CollapsibleSidebar\";\nimport { CollapsibleContextPane } from \"./CollapsibleContextPane\";\nimport { UnifiedHeader } from \"./UnifiedHeader\";\nimport { ThinkerTalkerVoicePanel } from \"../voice/ThinkerTalkerVoicePanel\";\nimport { VoiceModeSettings } from \"../voice/VoiceModeSettings\";\nimport { useKeyboardShortcuts } from \"../../hooks/useKeyboardShortcuts\";\nimport type { TTVoiceMetrics } from \"../../hooks/useThinkerTalkerSession\";\n\n// Lazy-loaded dialogs for better initial load performance\nconst KeyboardShortcutsDialog = lazy(() =>\n  import(\"../KeyboardShortcutsDialog\").then((m) => ({\n    default: m.KeyboardShortcutsDialog,\n  })),\n);\nconst ExportDialog = lazy(() =>\n  import(\"../export/ExportDialog\").then((m) => ({ default: m.ExportDialog })),\n);\nconst ShareDialog = lazy(() =>\n  import(\"../sharing/ShareDialog\").then((m) => ({ default: m.ShareDialog })),\n);\nimport type {\n  Message,\n  Conversation,\n  WebSocketErrorCode,\n} from \"@voiceassist/types\";\nimport { extractErrorMessage } from \"@voiceassist/types\";\n// Loader2 removed - using ChatSkeleton instead\nimport { ChatSkeleton } from \"./UnifiedChatSkeleton\";\nimport { ErrorDisplay, type ChatErrorType } from \"./UnifiedChatError\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype LoadingState = \"idle\" | \"creating\" | \"validating\" | \"loading-history\";\n\ninterface UnifiedChatContainerProps {\n  /** Pre-loaded conversation ID from ChatPage */\n  conversationId?: string;\n  /** Start in voice mode (from ?mode=voice or startVoiceMode location state) */\n  startInVoiceMode?: boolean;\n  /** Callback when conversation is created/loaded */\n  onConversationReady?: (conversationId: string) => void;\n}\n\n// ============================================================================\n// Main Component\n// ============================================================================\n\nexport function UnifiedChatContainer({\n  conversationId: propsConversationId,\n  startInVoiceMode = false,\n  onConversationReady,\n}: UnifiedChatContainerProps) {\n  const { conversationId: paramsConversationId } = useParams<{\n    conversationId: string;\n  }>();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { apiClient } = useAuth();\n  const toast = useToastContext();\n  const { announce } = useAnnouncer();\n\n  // Use props conversationId if provided, otherwise fall back to URL params\n  const conversationId = propsConversationId || paramsConversationId;\n\n  // Check if we should start in voice mode (props take precedence)\n  const searchParams = new URLSearchParams(location.search);\n  const startVoiceMode =\n    startInVoiceMode ||\n    searchParams.get(\"mode\") === \"voice\" ||\n    (location.state as { startVoiceMode?: boolean } | null)?.startVoiceMode ===\n      true;\n\n  // Unified store state - use shallow comparison to prevent unnecessary re-renders\n  // Only subscribe to the specific fields we need\n  const {\n    conversationId: activeConversationId,\n    messages,\n    isTyping,\n    inputMode,\n    voiceModeActive,\n  } = useUnifiedConversationStore(\n    useShallow((state) => ({\n      conversationId: state.conversationId,\n      messages: state.messages,\n      isTyping: state.isTyping,\n      inputMode: state.inputMode,\n      voiceModeActive: state.voiceModeActive,\n    })),\n  );\n\n  // Get action methods separately (these don't cause re-renders)\n  const setConversation = useUnifiedConversationStore(\n    (state) => state.setConversation,\n  );\n  const addMessage = useUnifiedConversationStore((state) => state.addMessage);\n  const setMessages = useUnifiedConversationStore((state) => state.setMessages);\n  const setTyping = useUnifiedConversationStore((state) => state.setTyping);\n  const activateVoiceMode = useUnifiedConversationStore(\n    (state) => state.activateVoiceMode,\n  );\n\n  // Voice settings\n  const _voiceModeType = useVoiceSettingsStore((state) => state.voiceModeType);\n\n  // Memoize error handler to prevent unnecessary hook re-initialization\n  const handleConversationsError = useCallback(\n    (message: string, description?: string) =>\n      toast.error(message, description),\n    [toast],\n  );\n\n  // Conversations hook for title editing\n  const { updateConversation } = useConversations({\n    onError: handleConversationsError,\n  });\n\n  // Local state\n  const [loadingState, setLoadingState] = useState<LoadingState>(\"idle\");\n  const [errorType, setErrorType] = useState<ChatErrorType>(null);\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n  const [conversation, setLocalConversation] = useState<Conversation | null>(\n    null,\n  );\n  const [initialMessages, setInitialMessages] = useState<Message[]>([]);\n\n  // Panel visibility state\n  const [isSidebarOpen, setIsSidebarOpen] = useState(true);\n  const [isContextPaneOpen, setIsContextPaneOpen] = useState(false);\n  const [isShortcutsDialogOpen, setIsShortcutsDialogOpen] = useState(false);\n  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);\n  const [isShareDialogOpen, setIsShareDialogOpen] = useState(false);\n  const [isVoicePanelOpen, setIsVoicePanelOpen] = useState(startVoiceMode);\n  const [isVoiceSettingsOpen, setIsVoiceSettingsOpen] = useState(false);\n\n  // Pagination state\n  const [hasMoreMessages, setHasMoreMessages] = useState(false);\n  const [isLoadingMoreMessages, setIsLoadingMoreMessages] = useState(false);\n  const [totalMessageCount, setTotalMessageCount] = useState(0);\n\n  // Auto-titling state\n  const [hasAutoTitled, setHasAutoTitled] = useState(false);\n\n  // Chat session hook for WebSocket communication\n  const {\n    messages: chatMessages,\n    connectionStatus,\n    isTyping: chatIsTyping,\n    sendMessage: sendChatMessage,\n    editMessage: _editMessage,\n    regenerateMessage: _regenerateMessage,\n    deleteMessage: _deleteMessage,\n    reconnect: reconnectChat,\n    addMessage: _addChatMessage,\n  } = useChatSession({\n    conversationId: activeConversationId || undefined,\n    initialMessages,\n    onError: (code: WebSocketErrorCode, message: string) => {\n      console.error(`[UnifiedChat] WebSocket error ${code}: ${message}`);\n      // Don't set errorType for connection errors - just show toast\n      // This allows the UI to remain usable while disconnected\n      // The ConnectionStatus component will indicate the disconnected state\n      toast.error(\"Connection Error\", message);\n    },\n  });\n\n  // Sync chat messages to unified store\n  // We use refs to track synced messages and handle client→server ID transitions\n  const syncedMessageIds = useRef(new Set<string>());\n  // Track client message IDs that have been synced, mapped to their content hash\n  // This helps detect when a message's ID changes from client to server ID\n  const syncedContentHashes = useRef(new Map<string, string>()); // contentHash → messageId\n\n  // Helper to create a content hash for deduplication\n  const getContentHash = useCallback(\n    (msg: { role: string; content: string }) =>\n      `${msg.role}:${msg.content.slice(0, 100)}`,\n    [],\n  );\n\n  // Track the last synced content for each message to detect streaming updates\n  const syncedMessageContent = useRef(new Map<string, string>());\n\n  // NOTE: We intentionally exclude 'messages' from dependencies to prevent render loops.\n  // The effect only needs to run when chatMessages changes (new messages from WebSocket).\n  // We access the store's current messages inside the effect using the closure.\n  useEffect(() => {\n    if (chatMessages.length > 0) {\n      // Get current store messages at effect execution time\n      const storeMessages = useUnifiedConversationStore.getState().messages;\n      const updateMessage =\n        useUnifiedConversationStore.getState().updateMessage;\n\n      chatMessages.forEach((msg) => {\n        // Check both the store and our local tracking to avoid duplicates\n        const alreadySynced = syncedMessageIds.current.has(msg.id);\n        const existsInStore = storeMessages.some((m) => m.id === msg.id);\n\n        if (!alreadySynced && !existsInStore) {\n          // Check if this is actually an ID update (same content, different ID)\n          // This happens when the server confirms the message and assigns a server ID\n          const contentHash = getContentHash(msg);\n          const existingIdForContent =\n            syncedContentHashes.current.get(contentHash);\n\n          if (existingIdForContent && existingIdForContent !== msg.id) {\n            // This is an ID update - update the existing message's ID in the store\n            // instead of adding a duplicate\n            updateMessage(existingIdForContent, { id: msg.id } as any);\n            // Update our tracking\n            syncedMessageIds.current.delete(existingIdForContent);\n            syncedMessageIds.current.add(msg.id);\n            syncedContentHashes.current.set(contentHash, msg.id);\n            syncedMessageContent.current.set(msg.id, msg.content);\n          } else {\n            // New message - add to store\n            syncedMessageIds.current.add(msg.id);\n            syncedContentHashes.current.set(contentHash, msg.id);\n            syncedMessageContent.current.set(msg.id, msg.content);\n            addMessage({\n              ...msg,\n              source: \"text\" as MessageSource,\n            });\n          }\n        } else if (alreadySynced || existsInStore) {\n          // Message already synced - check if content has been updated (streaming)\n          const lastSyncedContent = syncedMessageContent.current.get(msg.id);\n          if (lastSyncedContent !== msg.content) {\n            // Content changed (streaming update) - update the message in the store\n            syncedMessageContent.current.set(msg.id, msg.content);\n            // Update content hash tracking as well\n            syncedContentHashes.current.set(getContentHash(msg), msg.id);\n            updateMessage(msg.id, {\n              content: msg.content,\n              citations: msg.citations,\n              metadata: msg.metadata,\n            });\n          }\n        }\n      });\n    }\n  }, [chatMessages, addMessage, getContentHash]);\n\n  // Sync typing state\n  useEffect(() => {\n    setTyping(chatIsTyping);\n  }, [chatIsTyping, setTyping]);\n\n  // Keyboard shortcuts\n  useKeyboardShortcuts({\n    onToggleCitations: () => setIsContextPaneOpen((prev) => !prev),\n    onToggleClinicalContext: () => setIsContextPaneOpen((prev) => !prev),\n    onShowShortcuts: () => setIsShortcutsDialogOpen(true),\n    onToggleVoicePanel: () => setIsVoicePanelOpen((prev) => !prev),\n    onCloseVoicePanel: () => setIsVoicePanelOpen(false),\n    isVoicePanelOpen,\n  });\n\n  // -------------------------------------------------------------------------\n  // Conversation Management\n  // -------------------------------------------------------------------------\n\n  // Ref to prevent duplicate conversation creation (React Strict Mode runs effects twice)\n  const isCreatingConversationRef = useRef(false);\n\n  const createNewConversation = useCallback(async () => {\n    console.log(\"[UnifiedChat] createNewConversation called\", {\n      hasApiClient: !!apiClient,\n      isCreating: isCreatingConversationRef.current,\n    });\n\n    // Prevent duplicate calls (React Strict Mode protection)\n    if (!apiClient) {\n      console.log(\n        \"[UnifiedChat] createNewConversation - no apiClient, returning\",\n      );\n      return;\n    }\n    if (isCreatingConversationRef.current) {\n      console.log(\n        \"[UnifiedChat] createNewConversation - already creating, returning\",\n      );\n      return;\n    }\n    isCreatingConversationRef.current = true;\n\n    setLoadingState(\"creating\");\n    setErrorType(null);\n\n    try {\n      console.log(\"[UnifiedChat] Creating new conversation...\");\n      const newConversation =\n        await apiClient.createConversation(\"New Conversation\");\n\n      if (newConversation?.id) {\n        console.log(\"[UnifiedChat] Conversation created:\", newConversation.id);\n        setConversation(newConversation.id);\n        setLocalConversation(newConversation);\n        navigate(`/chat/${newConversation.id}`, { replace: true });\n        onConversationReady?.(newConversation.id);\n        announce(\"New conversation created\");\n      } else {\n        throw new Error(\"Failed to create conversation\");\n      }\n    } catch (error) {\n      console.error(\"[UnifiedChat] Failed to create conversation:\", error);\n      setErrorType(\"failed-create\");\n      setErrorMessage(error instanceof Error ? error.message : \"Unknown error\");\n    } finally {\n      setLoadingState(\"idle\");\n      isCreatingConversationRef.current = false;\n    }\n  }, [apiClient, navigate, setConversation, onConversationReady, announce]);\n\n  const loadConversation = useCallback(\n    async (id: string) => {\n      if (!apiClient) return;\n\n      setLoadingState(\"loading-history\");\n      setErrorType(null);\n\n      try {\n        // Load conversation metadata\n        const conv = await apiClient.getConversation(id);\n        if (!conv) {\n          setErrorType(\"not-found\");\n          return;\n        }\n\n        setLocalConversation(conv);\n        setConversation(id);\n\n        // Load messages\n        const messagesResponse = await apiClient.getMessages(id, 1, 50);\n\n        if (messagesResponse?.items) {\n          const loadedMessages = messagesResponse.items;\n          const total = messagesResponse.totalCount || loadedMessages.length;\n          const totalPages = Math.ceil(total / 50);\n\n          // Set initial messages for chat session\n          setInitialMessages(loadedMessages);\n\n          // Add messages to store using batch set (prevents N re-renders)\n          const unifiedMessages = loadedMessages.map((msg: Message) => {\n            // Handle potentially invalid timestamps with fallback\n            let createdAt: string;\n            try {\n              const date = msg.timestamp ? new Date(msg.timestamp) : new Date();\n              createdAt = isNaN(date.getTime())\n                ? new Date().toISOString()\n                : date.toISOString();\n            } catch {\n              createdAt = new Date().toISOString();\n            }\n            return {\n              ...msg,\n              source: \"text\" as MessageSource,\n              sessionId: id,\n              createdAt,\n            };\n          });\n          setMessages(unifiedMessages);\n\n          setTotalMessageCount(total);\n          setHasMoreMessages(totalPages > 1);\n        }\n\n        onConversationReady?.(id);\n        announce(\"Conversation loaded\");\n      } catch (error: unknown) {\n        console.error(\"[UnifiedChat] Failed to load conversation:\", error);\n        if ((error as any)?.response?.status === 404) {\n          setErrorType(\"not-found\");\n        } else {\n          setErrorType(\"failed-load\");\n        }\n        setErrorMessage(extractErrorMessage(error));\n      } finally {\n        setLoadingState(\"idle\");\n      }\n    },\n    [apiClient, setConversation, setMessages, onConversationReady, announce],\n  );\n\n  // Initialize conversation\n  // Track the last conversation ID we tried to load to prevent duplicate loads\n  const lastLoadedConversationIdRef = useRef<string | null>(null);\n  // Track if we've started creating a new conversation\n  const hasStartedCreateRef = useRef(false);\n\n  useEffect(() => {\n    console.log(\"[UnifiedChat] Init effect running\", {\n      conversationId,\n      hasApiClient: !!apiClient,\n      lastLoadedId: lastLoadedConversationIdRef.current,\n      hasStartedCreate: hasStartedCreateRef.current,\n    });\n\n    // Don't try to initialize if apiClient isn't available yet\n    if (!apiClient) {\n      console.log(\"[UnifiedChat] Init effect - no apiClient, waiting...\");\n      return;\n    }\n\n    // Clear synced message tracking when switching conversations\n    syncedMessageIds.current.clear();\n    syncedContentHashes.current.clear();\n    syncedMessageContent.current.clear();\n\n    if (conversationId) {\n      // Load existing conversation (only if we haven't loaded this one yet)\n      if (lastLoadedConversationIdRef.current !== conversationId) {\n        console.log(\n          \"[UnifiedChat] Init effect - loading conversation:\",\n          conversationId,\n        );\n        lastLoadedConversationIdRef.current = conversationId;\n        hasStartedCreateRef.current = false; // Reset create flag\n        loadConversation(conversationId);\n      }\n    } else {\n      // Create new conversation (only once)\n      if (!hasStartedCreateRef.current) {\n        console.log(\"[UnifiedChat] Init effect - creating new conversation\");\n        hasStartedCreateRef.current = true;\n        createNewConversation();\n      }\n    }\n    // Note: We intentionally omit loadConversation and createNewConversation from deps\n    // to prevent infinite loops. We use refs to track what we've already done.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [conversationId, apiClient]);\n\n  // Start voice mode if requested\n  useEffect(() => {\n    if (startVoiceMode && loadingState === \"idle\" && !errorType) {\n      activateVoiceMode();\n    }\n  }, [startVoiceMode, loadingState, errorType, activateVoiceMode]);\n\n  // Announce voice mode changes for screen readers\n  useEffect(() => {\n    if (voiceModeActive) {\n      announce(\"Voice mode activated. You can speak to interact.\");\n    } else if (inputMode === \"text\") {\n      // Only announce when switching from voice to text, not initial load\n      // Check if we're in a state where voice was previously active\n    }\n  }, [voiceModeActive, inputMode, announce]);\n\n  // Announce typing indicator for screen readers\n  useEffect(() => {\n    if (isTyping) {\n      announce(\"Assistant is typing\");\n    }\n  }, [isTyping, announce]);\n\n  // -------------------------------------------------------------------------\n  // Event Handlers\n  // -------------------------------------------------------------------------\n\n  const handleRetry = useCallback(() => {\n    if (conversationId) {\n      loadConversation(conversationId);\n    } else {\n      createNewConversation();\n    }\n  }, [conversationId, loadConversation, createNewConversation]);\n\n  const handleGoHome = useCallback(() => {\n    navigate(\"/\");\n  }, [navigate]);\n\n  // Handle title change\n  const handleTitleChange = useCallback(\n    async (newTitle: string) => {\n      if (!activeConversationId) return;\n\n      try {\n        await updateConversation(activeConversationId, {\n          title: newTitle,\n        });\n        setLocalConversation((prev) =>\n          prev ? { ...prev, title: newTitle } : prev,\n        );\n        toast.success(\"Title updated\");\n      } catch (error) {\n        throw error; // Let the header handle the error display\n      }\n    },\n    [activeConversationId, updateConversation, toast],\n  );\n\n  // Handle export - open dialog\n  const handleExport = useCallback(() => {\n    if (!activeConversationId) return;\n    setIsExportDialogOpen(true);\n  }, [activeConversationId]);\n\n  // Handle share - open dialog\n  const handleShare = useCallback(() => {\n    if (!activeConversationId) return;\n    setIsShareDialogOpen(true);\n  }, [activeConversationId]);\n\n  // Generate auto-title from message content\n  const generateAutoTitle = useCallback((content: string): string => {\n    // Clean and truncate the message for use as a title\n    const cleaned = content\n      .replace(/\\n+/g, \" \") // Replace newlines with spaces\n      .replace(/\\s+/g, \" \") // Collapse multiple spaces\n      .trim();\n\n    // Max 50 characters, try to break at word boundary\n    if (cleaned.length <= 50) {\n      return cleaned;\n    }\n\n    // Find last space before 50 chars\n    const truncated = cleaned.substring(0, 50);\n    const lastSpace = truncated.lastIndexOf(\" \");\n\n    if (lastSpace > 30) {\n      return truncated.substring(0, lastSpace) + \"...\";\n    }\n\n    return truncated + \"...\";\n  }, []);\n\n  // Auto-title conversation based on first message\n  const autoTitleConversation = useCallback(\n    async (messageContent: string) => {\n      if (\n        hasAutoTitled ||\n        !activeConversationId ||\n        !conversation ||\n        conversation.title !== \"New Conversation\"\n      ) {\n        return;\n      }\n\n      const newTitle = generateAutoTitle(messageContent);\n\n      try {\n        await updateConversation(activeConversationId, { title: newTitle });\n        setLocalConversation((prev) =>\n          prev ? { ...prev, title: newTitle } : prev,\n        );\n        setHasAutoTitled(true);\n      } catch (error) {\n        // Silently fail - title remains as \"New Conversation\"\n        console.warn(\"[UnifiedChat] Auto-title failed:\", error);\n      }\n    },\n    [\n      hasAutoTitled,\n      activeConversationId,\n      conversation,\n      generateAutoTitle,\n      updateConversation,\n    ],\n  );\n\n  // Handle send message\n  const handleSendMessage = useCallback(\n    (content: string, _source: MessageSource) => {\n      if (!content.trim()) return;\n\n      // Auto-title conversation if this is the first message\n      autoTitleConversation(content);\n\n      // Send via WebSocket - the message will be added to chatMessages by useChatSession,\n      // then synced to the unified store by the sync useEffect.\n      // NOTE: We don't call addMessage here to avoid duplicate messages.\n      // The sync effect at line ~190 handles syncing chatMessages → unified store.\n      sendChatMessage(content);\n    },\n    [sendChatMessage, autoTitleConversation],\n  );\n\n  const handleLoadMoreMessages = useCallback(async () => {\n    if (\n      !apiClient ||\n      !activeConversationId ||\n      isLoadingMoreMessages ||\n      !hasMoreMessages\n    ) {\n      return;\n    }\n\n    setIsLoadingMoreMessages(true);\n    try {\n      // Calculate next page based on current messages\n      const currentPage = Math.ceil(messages.length / 50);\n      const messagesResponse = await apiClient.getMessages(\n        activeConversationId,\n        currentPage + 1,\n        50,\n      );\n\n      if (messagesResponse?.items) {\n        const olderMessages = messagesResponse.items;\n        const total = messagesResponse.totalCount || 0;\n        const totalPages = Math.ceil(total / 50);\n\n        // Prepend older messages\n        olderMessages.forEach((msg: Message) => {\n          addMessage({\n            ...msg,\n            source: \"text\" as MessageSource,\n          });\n        });\n\n        setHasMoreMessages(currentPage + 1 < totalPages);\n      }\n    } catch (error) {\n      console.error(\"[UnifiedChat] Failed to load more messages:\", error);\n      toast.error(\"Failed to load older messages\");\n    } finally {\n      setIsLoadingMoreMessages(false);\n    }\n  }, [\n    apiClient,\n    activeConversationId,\n    messages.length,\n    isLoadingMoreMessages,\n    hasMoreMessages,\n    addMessage,\n    toast,\n  ]);\n\n  // -------------------------------------------------------------------------\n  // Voice Mode Handlers\n  // -------------------------------------------------------------------------\n\n  // Handle voice user message - add transcribed speech to chat timeline\n  const handleVoiceUserMessage = useCallback(\n    (content: string) => {\n      if (!content.trim()) return;\n\n      // Auto-title conversation if this is the first message\n      autoTitleConversation(content);\n\n      // Add to unified store with voice source\n      addMessage({\n        role: \"user\",\n        content,\n        source: \"voice\" as MessageSource,\n      });\n\n      // Send via WebSocket for conversation history\n      sendChatMessage(content);\n    },\n    [addMessage, sendChatMessage, autoTitleConversation],\n  );\n\n  // Handle voice assistant message - add AI response to chat timeline\n  const handleVoiceAssistantMessage = useCallback(\n    (content: string) => {\n      if (!content.trim()) return;\n\n      addMessage({\n        role: \"assistant\",\n        content,\n        source: \"voice\" as MessageSource,\n      });\n    },\n    [addMessage],\n  );\n\n  // Handle voice metrics update - export to backend for observability\n  const handleVoiceMetricsUpdate = useCallback(\n    (metrics: TTVoiceMetrics) => {\n      // Send metrics to backend (non-blocking)\n      if (\n        activeConversationId &&\n        typeof navigator !== \"undefined\" &&\n        \"sendBeacon\" in navigator\n      ) {\n        const payload = JSON.stringify({\n          conversation_id: activeConversationId,\n          ...metrics,\n          timestamp: new Date().toISOString(),\n        });\n        const blob = new Blob([payload], { type: \"application/json\" });\n        navigator.sendBeacon(\"/api/voice/metrics\", blob);\n      }\n    },\n    [activeConversationId],\n  );\n\n  // Handle voice panel close\n  const handleVoicePanelClose = useCallback(() => {\n    setIsVoicePanelOpen(false);\n  }, []);\n\n  // -------------------------------------------------------------------------\n  // Render Helpers\n  // -------------------------------------------------------------------------\n\n  // Map UnifiedMessage to Message format for MessageList\n  const mappedMessages: Message[] = useMemo(() => {\n    return messages.map((msg) => {\n      // Handle potentially invalid timestamps with fallback\n      let timestamp: number;\n      try {\n        const date = msg.createdAt ? new Date(msg.createdAt) : new Date();\n        timestamp = isNaN(date.getTime()) ? Date.now() : date.getTime();\n      } catch {\n        timestamp = Date.now();\n      }\n      return {\n        id: msg.id,\n        conversationId: activeConversationId || undefined,\n        role: msg.role,\n        content: msg.content,\n        citations: msg.citations || msg.metadata?.citations,\n        timestamp,\n        metadata: msg.metadata,\n      };\n    });\n  }, [messages, activeConversationId]);\n\n  // -------------------------------------------------------------------------\n  // Render\n  // -------------------------------------------------------------------------\n\n  // Show loading skeleton\n  if (loadingState !== \"idle\") {\n    return <ChatSkeleton />;\n  }\n\n  // Show error state\n  if (errorType) {\n    return (\n      <ErrorDisplay\n        type={errorType}\n        message={errorMessage}\n        onRetry={handleRetry}\n        onGoHome={handleGoHome}\n      />\n    );\n  }\n\n  return (\n    <ChatErrorBoundary\n      onError={(err, info) => {\n        console.error(\"[UnifiedChatContainer] Error:\", err, info);\n        setErrorType(\"websocket\");\n        setErrorMessage(\"An unexpected error occurred\");\n      }}\n    >\n      <div\n        className=\"flex h-full bg-neutral-50\"\n        role=\"application\"\n        aria-label=\"Chat interface\"\n        data-testid=\"unified-chat-container\"\n      >\n        {/* Collapsible Sidebar */}\n        <CollapsibleSidebar\n          isOpen={isSidebarOpen}\n          onToggle={() => setIsSidebarOpen(!isSidebarOpen)}\n          conversationId={activeConversationId}\n        />\n\n        {/* Main Content Area */}\n        <main\n          className=\"flex-1 flex flex-col min-w-0\"\n          aria-label=\"Conversation\"\n        >\n          {/* Header */}\n          <UnifiedHeader\n            conversation={conversation}\n            isSidebarOpen={isSidebarOpen}\n            isContextPaneOpen={isContextPaneOpen}\n            onToggleSidebar={() => setIsSidebarOpen(!isSidebarOpen)}\n            onToggleContextPane={() => setIsContextPaneOpen(!isContextPaneOpen)}\n            onTitleChange={handleTitleChange}\n            onExport={handleExport}\n            onShare={handleShare}\n            onSettings={() => setIsVoiceSettingsOpen(true)}\n          />\n\n          {/* Connection Status */}\n          <ConnectionStatus\n            status={connectionStatus}\n            onReconnect={reconnectChat}\n            compact\n          />\n\n          {/* Message List */}\n          <div\n            className=\"flex-1 overflow-hidden\"\n            role=\"log\"\n            aria-live=\"polite\"\n            aria-label=\"Conversation messages\"\n          >\n            <MessageList\n              messages={mappedMessages}\n              isTyping={isTyping}\n              onLoadMore={handleLoadMoreMessages}\n              hasMore={hasMoreMessages}\n              isLoadingMore={isLoadingMoreMessages}\n              totalCount={totalMessageCount}\n            />\n          </div>\n\n          {/* Voice Mode Panel - appears above input when active */}\n          {isVoicePanelOpen && (\n            <ThinkerTalkerVoicePanel\n              conversationId={activeConversationId || undefined}\n              onClose={handleVoicePanelClose}\n              onUserMessage={handleVoiceUserMessage}\n              onAssistantMessage={handleVoiceAssistantMessage}\n              onMetricsUpdate={handleVoiceMetricsUpdate}\n            />\n          )}\n\n          {/* Unified Input Area */}\n          <UnifiedInputArea\n            conversationId={activeConversationId}\n            onSendMessage={handleSendMessage}\n            disabled={false}\n            sendDisabled={connectionStatus !== \"connected\"}\n            onToggleVoicePanel={() => setIsVoicePanelOpen((prev) => !prev)}\n            isVoicePanelOpen={isVoicePanelOpen}\n          />\n        </main>\n\n        {/* Collapsible Context Pane */}\n        <CollapsibleContextPane\n          isOpen={isContextPaneOpen}\n          onToggle={() => setIsContextPaneOpen(!isContextPaneOpen)}\n          conversationId={activeConversationId}\n        />\n\n        {/* Lazy-loaded Dialogs - wrapped in Suspense for code splitting */}\n        <Suspense fallback={null}>\n          {/* Keyboard Shortcuts Dialog */}\n          {isShortcutsDialogOpen && (\n            <KeyboardShortcutsDialog\n              isOpen={isShortcutsDialogOpen}\n              onClose={() => setIsShortcutsDialogOpen(false)}\n            />\n          )}\n\n          {/* Export Dialog */}\n          {activeConversationId && isExportDialogOpen && (\n            <ExportDialog\n              isOpen={isExportDialogOpen}\n              onClose={() => setIsExportDialogOpen(false)}\n              conversationId={activeConversationId}\n              conversationTitle={conversation?.title || \"New Conversation\"}\n              messages={mappedMessages}\n            />\n          )}\n\n          {/* Share Dialog */}\n          {activeConversationId && isShareDialogOpen && (\n            <ShareDialog\n              isOpen={isShareDialogOpen}\n              onClose={() => setIsShareDialogOpen(false)}\n              conversationId={activeConversationId}\n              conversationTitle={conversation?.title || \"New Conversation\"}\n            />\n          )}\n        </Suspense>\n\n        {/* Voice Settings Modal */}\n        <VoiceModeSettings\n          isOpen={isVoiceSettingsOpen}\n          onClose={() => setIsVoiceSettingsOpen(false)}\n        />\n      </div>\n    </ChatErrorBoundary>\n  );\n}\n\nexport default UnifiedChatContainer;\n"
}
