{
  "path": "services/api-gateway/app/services/repair_strategy_service.py",
  "language": "python",
  "size": 17121,
  "last_modified": "2025-12-04T11:26:59.936Z",
  "lines": 469,
  "content": "\"\"\"\nRepair Strategy Service - Conversational Repair Handling\n\nPhase 7: Graceful handling of misunderstandings in voice conversations.\n\nThis service manages conversational repair strategies when:\n- AI is uncertain about user intent\n- User corrects the AI\n- Transcription quality is low\n- User shows signs of frustration\n\nRepair Strategies:\n- ECHO_CHECK: \"So you're asking about X?\" - Confirms understanding\n- CLARIFY_SPECIFIC: \"Did you mean X or Y?\" - Offers specific options\n- REQUEST_REPHRASE: \"Could you say that differently?\" - Asks for rewording\n- PARTIAL_ANSWER: \"I'm not sure, but...\" - Provides best-effort response\n\"\"\"\n\nimport re\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Tuple\n\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\n# ==============================================================================\n# Enums and Data Classes\n# ==============================================================================\n\n\nclass RepairStrategy(str, Enum):\n    \"\"\"Types of conversational repair strategies.\"\"\"\n\n    ECHO_CHECK = \"echo_check\"  # \"So you're asking about X?\"\n    CLARIFY_SPECIFIC = \"clarify_specific\"  # \"Did you mean X or Y?\"\n    REQUEST_REPHRASE = \"request_rephrase\"  # \"Could you say that differently?\"\n    PARTIAL_ANSWER = \"partial_answer\"  # \"I'm not sure, but...\"\n    NO_REPAIR = \"no_repair\"  # No repair needed, proceed normally\n\n\nclass CorrectionType(str, Enum):\n    \"\"\"Types of user corrections detected.\"\"\"\n\n    EXPLICIT = \"explicit\"  # \"No, I said...\" or \"I meant...\"\n    IMPLICIT = \"implicit\"  # Rephrasing without explicit correction marker\n    FRUSTRATION = \"frustration\"  # Repeated corrections with frustration signals\n    NONE = \"none\"\n\n\n@dataclass\nclass RepairContext:\n    \"\"\"Context for determining appropriate repair strategy.\"\"\"\n\n    # Transcript information\n    transcript: str\n    transcript_confidence: float  # 0-1, from STT\n\n    # Response confidence\n    response_confidence: float  # 0-1, how confident AI is in understanding\n\n    # Correction history\n    correction_count: int = 0\n    last_correction_time: Optional[float] = None\n    correction_types: List[CorrectionType] = field(default_factory=list)\n\n    # User state\n    frustration_score: float = 0.0  # 0-1\n    repeat_count: int = 0  # How many times user repeated similar content\n\n    # Ambiguity\n    ambiguous_terms: List[str] = field(default_factory=list)\n    possible_interpretations: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass RepairRecommendation:\n    \"\"\"Recommendation from repair strategy analysis.\"\"\"\n\n    strategy: RepairStrategy\n    confidence: float  # 0-1\n    suggested_prefix: Optional[str] = None  # Prefix to add to response\n    suggested_suffix: Optional[str] = None  # Suffix to add to response\n    clarification_options: List[str] = field(default_factory=list)\n    escalate_to_human: bool = False  # If true, offer to connect to human support\n\n\n# ==============================================================================\n# Correction Detection\n# ==============================================================================\n\n\nclass CorrectionDetector:\n    \"\"\"Detects user corrections and frustration patterns.\"\"\"\n\n    # Explicit correction markers\n    EXPLICIT_CORRECTION_PATTERNS = [\n        r\"\\bno\\s*,?\\s*i\\s+(said|meant|was\\s+asking|asked)\\b\",\n        r\"\\bthat'?s?\\s+not\\s+what\\s+i\\b\",\n        r\"\\bi\\s+didn'?t\\s+(say|mean|ask)\\b\",\n        r\"\\bactually\\s*,?\\s*i\\b\",\n        r\"\\blet\\s+me\\s+clarify\\b\",\n        r\"\\bto\\s+clarify\\b\",\n        r\"\\bwhat\\s+i\\s+meant\\s+(was|is)\\b\",\n        r\"\\bsorry\\s*,?\\s*i\\s+meant\\b\",\n        r\"\\bnot\\s+that\\s*,?\\s*i\\b\",\n    ]\n\n    # Frustration indicators\n    FRUSTRATION_PATTERNS = [\n        r\"\\bi\\s+already\\s+(said|told|asked)\\b\",\n        r\"\\bfor\\s+the\\s+(second|third|fourth|fifth)\\s+time\\b\",\n        r\"\\bagain\\s*,?\\s*i\\b\",\n        r\"\\bhow\\s+many\\s+times\\b\",\n        r\"\\bare\\s+you\\s+(listening|hearing)\\b\",\n        r\"\\bcome\\s+on\\b\",\n        r\"\\bugh\\b\",\n        r\"\\bseriously\\b\",\n        r\"\\bwhy\\s+(can'?t|don'?t|won'?t)\\s+you\\b\",\n    ]\n\n    # Rephrase indicators (user trying different words)\n    REPHRASE_INDICATORS = [\n        r\"\\bin\\s+other\\s+words\\b\",\n        r\"\\bbasically\\b\",\n        r\"\\bwhat\\s+i'?m\\s+(trying\\s+to\\s+)?(say|ask)\\b\",\n        r\"\\bput\\s+(it\\s+)?differently\\b\",\n        r\"\\blet\\s+me\\s+(re)?phrase\\b\",\n    ]\n\n    def __init__(self):\n        self._explicit_patterns = [re.compile(p, re.IGNORECASE) for p in self.EXPLICIT_CORRECTION_PATTERNS]\n        self._frustration_patterns = [re.compile(p, re.IGNORECASE) for p in self.FRUSTRATION_PATTERNS]\n        self._rephrase_patterns = [re.compile(p, re.IGNORECASE) for p in self.REPHRASE_INDICATORS]\n\n    def detect_correction(self, transcript: str) -> Tuple[CorrectionType, float]:\n        \"\"\"\n        Detect if user is making a correction.\n\n        Returns:\n            Tuple of (CorrectionType, confidence)\n        \"\"\"\n        text = transcript.lower().strip()\n\n        # Check for frustration (highest priority)\n        frustration_matches = sum(1 for p in self._frustration_patterns if p.search(text))\n        if frustration_matches > 0:\n            confidence = min(1.0, 0.5 + frustration_matches * 0.2)\n            return CorrectionType.FRUSTRATION, confidence\n\n        # Check for explicit correction\n        explicit_matches = sum(1 for p in self._explicit_patterns if p.search(text))\n        if explicit_matches > 0:\n            confidence = min(1.0, 0.6 + explicit_matches * 0.15)\n            return CorrectionType.EXPLICIT, confidence\n\n        # Check for implicit rephrase\n        rephrase_matches = sum(1 for p in self._rephrase_patterns if p.search(text))\n        if rephrase_matches > 0:\n            confidence = min(1.0, 0.4 + rephrase_matches * 0.2)\n            return CorrectionType.IMPLICIT, confidence\n\n        return CorrectionType.NONE, 0.0\n\n    def calculate_frustration_score(\n        self,\n        transcript: str,\n        correction_count: int,\n        time_since_last_correction: Optional[float],\n    ) -> float:\n        \"\"\"\n        Calculate overall frustration score.\n\n        Args:\n            transcript: Current user transcript\n            correction_count: Number of corrections in session\n            time_since_last_correction: Seconds since last correction\n\n        Returns:\n            Frustration score 0-1\n        \"\"\"\n        score = 0.0\n\n        # Base score from correction count\n        if correction_count >= 3:\n            score += 0.4\n        elif correction_count >= 2:\n            score += 0.2\n        elif correction_count >= 1:\n            score += 0.1\n\n        # Bonus for rapid corrections (within 30 seconds)\n        if time_since_last_correction is not None and time_since_last_correction < 30:\n            score += 0.2\n\n        # Bonus for frustration patterns in transcript\n        text = transcript.lower()\n        frustration_matches = sum(1 for p in self._frustration_patterns if p.search(text))\n        score += frustration_matches * 0.15\n\n        # Cap at 1.0\n        return min(1.0, score)\n\n\n# ==============================================================================\n# Repair Strategy Selection\n# ==============================================================================\n\n\nclass RepairStrategySelector:\n    \"\"\"Selects appropriate repair strategy based on context.\"\"\"\n\n    # Thresholds\n    LOW_CONFIDENCE_THRESHOLD = 0.7\n    VERY_LOW_CONFIDENCE_THRESHOLD = 0.5\n    HIGH_FRUSTRATION_THRESHOLD = 0.6\n    ESCALATION_THRESHOLD = 0.8\n\n    def __init__(self):\n        self._correction_detector = CorrectionDetector()\n\n    def select_strategy(self, context: RepairContext) -> RepairRecommendation:\n        \"\"\"\n        Select the best repair strategy based on context.\n\n        Args:\n            context: RepairContext with all relevant information\n\n        Returns:\n            RepairRecommendation with strategy and suggested responses\n        \"\"\"\n        # Detect if this is a correction\n        correction_type, correction_confidence = self._correction_detector.detect_correction(context.transcript)\n\n        # Calculate frustration\n        time_since_correction = None\n        if context.last_correction_time:\n            time_since_correction = time.time() - context.last_correction_time\n\n        frustration = self._correction_detector.calculate_frustration_score(\n            context.transcript,\n            context.correction_count,\n            time_since_correction,\n        )\n\n        # High frustration: consider escalation\n        if frustration > self.ESCALATION_THRESHOLD:\n            return RepairRecommendation(\n                strategy=RepairStrategy.REQUEST_REPHRASE,\n                confidence=0.9,\n                suggested_prefix=\"I apologize for the confusion. \",\n                suggested_suffix=\" Would you like me to connect you with someone who can help?\",\n                escalate_to_human=True,\n            )\n\n        # Frustration correction: apologize and ask for rephrase\n        if correction_type == CorrectionType.FRUSTRATION:\n            return RepairRecommendation(\n                strategy=RepairStrategy.REQUEST_REPHRASE,\n                confidence=0.85,\n                suggested_prefix=\"I'm sorry for the misunderstanding. \",\n                suggested_suffix=\" Could you tell me again what you need?\",\n            )\n\n        # Explicit correction: echo check to confirm understanding\n        if correction_type == CorrectionType.EXPLICIT:\n            return RepairRecommendation(\n                strategy=RepairStrategy.ECHO_CHECK,\n                confidence=0.8,\n                suggested_prefix=\"I understand. So you're asking about \",\n                suggested_suffix=\"?\",\n            )\n\n        # Very low confidence: request rephrase\n        if context.response_confidence < self.VERY_LOW_CONFIDENCE_THRESHOLD:\n            return RepairRecommendation(\n                strategy=RepairStrategy.REQUEST_REPHRASE,\n                confidence=0.75,\n                suggested_prefix=\"I want to make sure I understand correctly. \",\n                suggested_suffix=\" Could you rephrase that for me?\",\n            )\n\n        # Low confidence with ambiguous terms: offer specific options\n        if context.response_confidence < self.LOW_CONFIDENCE_THRESHOLD and len(context.possible_interpretations) >= 2:\n            return RepairRecommendation(\n                strategy=RepairStrategy.CLARIFY_SPECIFIC,\n                confidence=0.7,\n                suggested_prefix=\"Just to clarify, \",\n                clarification_options=context.possible_interpretations[:3],\n            )\n\n        # Low confidence: partial answer with hedging\n        if context.response_confidence < self.LOW_CONFIDENCE_THRESHOLD:\n            return RepairRecommendation(\n                strategy=RepairStrategy.PARTIAL_ANSWER,\n                confidence=0.65,\n                suggested_prefix=\"I'm not entirely certain, but \",\n                suggested_suffix=\" Does that help, or would you like me to clarify?\",\n            )\n\n        # Low transcript confidence: echo check\n        if context.transcript_confidence < self.LOW_CONFIDENCE_THRESHOLD:\n            return RepairRecommendation(\n                strategy=RepairStrategy.ECHO_CHECK,\n                confidence=0.6,\n                suggested_prefix=\"I heard you say \",\n                suggested_suffix=\". Is that correct?\",\n            )\n\n        # No repair needed\n        return RepairRecommendation(\n            strategy=RepairStrategy.NO_REPAIR,\n            confidence=1.0,\n        )\n\n\n# ==============================================================================\n# Repair Service\n# ==============================================================================\n\n\nclass RepairStrategyService:\n    \"\"\"\n    Main service for conversational repair management.\n\n    Usage:\n        service = RepairStrategyService()\n\n        # Analyze context and get repair recommendation\n        recommendation = service.get_repair_recommendation(\n            transcript=\"No, I said I need help with billing\",\n            transcript_confidence=0.85,\n            response_confidence=0.6,\n            correction_count=1,\n        )\n\n        if recommendation.strategy != RepairStrategy.NO_REPAIR:\n            # Apply repair strategy to response\n            response = service.apply_repair(recommendation, original_response)\n    \"\"\"\n\n    def __init__(self):\n        self._selector = RepairStrategySelector()\n        self._session_contexts: Dict[str, RepairContext] = {}\n\n    def get_repair_recommendation(\n        self,\n        transcript: str,\n        transcript_confidence: float,\n        response_confidence: float,\n        session_id: Optional[str] = None,\n        possible_interpretations: Optional[List[str]] = None,\n    ) -> RepairRecommendation:\n        \"\"\"\n        Get repair recommendation for the current interaction.\n\n        Args:\n            transcript: User's spoken text\n            transcript_confidence: STT confidence (0-1)\n            response_confidence: AI's confidence in understanding (0-1)\n            session_id: Optional session ID for tracking history\n            possible_interpretations: List of possible meanings if ambiguous\n\n        Returns:\n            RepairRecommendation with strategy and suggestions\n        \"\"\"\n        # Get or create session context\n        if session_id and session_id in self._session_contexts:\n            context = self._session_contexts[session_id]\n            # Update with new information\n            context.transcript = transcript\n            context.transcript_confidence = transcript_confidence\n            context.response_confidence = response_confidence\n            if possible_interpretations:\n                context.possible_interpretations = possible_interpretations\n        else:\n            context = RepairContext(\n                transcript=transcript,\n                transcript_confidence=transcript_confidence,\n                response_confidence=response_confidence,\n                possible_interpretations=possible_interpretations or [],\n            )\n\n        # Detect corrections and update context\n        correction_type, _ = self._selector._correction_detector.detect_correction(transcript)\n        if correction_type != CorrectionType.NONE:\n            context.correction_count += 1\n            context.correction_types.append(correction_type)\n            context.last_correction_time = time.time()\n\n        # Get recommendation\n        recommendation = self._selector.select_strategy(context)\n\n        # Store updated context\n        if session_id:\n            self._session_contexts[session_id] = context\n\n        logger.debug(\n            f\"Repair recommendation: strategy={recommendation.strategy.value}, \"\n            f\"confidence={recommendation.confidence:.2f}, \"\n            f\"correction_count={context.correction_count}\"\n        )\n\n        return recommendation\n\n    def apply_repair(\n        self,\n        recommendation: RepairRecommendation,\n        original_response: str,\n    ) -> str:\n        \"\"\"\n        Apply repair strategy to response.\n\n        Args:\n            recommendation: RepairRecommendation from get_repair_recommendation\n            original_response: The AI's original response\n\n        Returns:\n            Modified response with repair applied\n        \"\"\"\n        if recommendation.strategy == RepairStrategy.NO_REPAIR:\n            return original_response\n\n        modified = original_response\n\n        # Apply prefix\n        if recommendation.suggested_prefix:\n            modified = recommendation.suggested_prefix + modified\n\n        # Apply suffix\n        if recommendation.suggested_suffix:\n            modified = modified.rstrip(\".!?\") + recommendation.suggested_suffix\n\n        # Handle clarification options\n        if recommendation.strategy == RepairStrategy.CLARIFY_SPECIFIC and recommendation.clarification_options:\n            options = recommendation.clarification_options\n            if len(options) == 2:\n                options_text = f\"did you mean {options[0]} or {options[1]}?\"\n            else:\n                options_text = \"did you mean \" + \", \".join(options[:-1]) + f\", or {options[-1]}?\"\n            modified = recommendation.suggested_prefix + options_text\n\n        return modified\n\n    def clear_session(self, session_id: str) -> None:\n        \"\"\"Clear repair context for a session.\"\"\"\n        if session_id in self._session_contexts:\n            del self._session_contexts[session_id]\n            logger.debug(f\"Cleared repair context for session: {session_id}\")\n\n    def get_session_stats(self, session_id: str) -> Optional[Dict]:\n        \"\"\"Get repair statistics for a session.\"\"\"\n        if session_id not in self._session_contexts:\n            return None\n\n        context = self._session_contexts[session_id]\n        return {\n            \"correction_count\": context.correction_count,\n            \"frustration_score\": context.frustration_score,\n            \"correction_types\": [ct.value for ct in context.correction_types],\n        }\n\n\n# Global service instance\nrepair_strategy_service = RepairStrategyService()\n"
}
