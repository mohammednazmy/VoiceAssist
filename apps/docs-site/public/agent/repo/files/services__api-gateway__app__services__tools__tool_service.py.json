{
  "path": "services/api-gateway/app/services/tools/tool_service.py",
  "language": "python",
  "size": 20283,
  "last_modified": "2025-12-04T11:27:01.557Z",
  "lines": 556,
  "content": "\"\"\"\nUnified Tool Service for VoiceAssist\n\nProvides a central registry and executor for all function calling tools.\nUsed by both Voice Mode (OpenAI Realtime API) and Chat Mode (Chat Completions API).\n\"\"\"\n\nimport json\nimport logging\nimport time\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nlogger = logging.getLogger(__name__)\n\n\nclass ToolCategory(str, Enum):\n    \"\"\"Categories for organizing tools.\"\"\"\n\n    CALENDAR = \"calendar\"\n    SEARCH = \"search\"\n    MEDICAL = \"medical\"\n    KNOWLEDGE = \"knowledge\"\n    UTILITY = \"utility\"\n\n\n@dataclass\nclass ToolDefinition:\n    \"\"\"Definition of a tool that can be executed.\"\"\"\n\n    name: str\n    description: str\n    parameters: Dict[str, Any]  # JSON Schema\n    category: ToolCategory\n    requires_auth: bool = False  # Requires user authentication/connection\n    requires_confirmation: bool = False  # Should prompt user before executing\n    enabled: bool = True\n\n\n@dataclass\nclass ToolResult:\n    \"\"\"Result of a tool execution.\"\"\"\n\n    success: bool\n    data: Any\n    error: Optional[str] = None\n    error_type: Optional[str] = None\n    needs_clarification: bool = False\n    needs_connection: bool = False\n    available_calendars: Optional[List[str]] = None\n    message: Optional[str] = None\n    duration_ms: int = 0\n\n\n@dataclass\nclass ToolExecutionContext:\n    \"\"\"Context for tool execution.\"\"\"\n\n    user_id: str\n    session_id: Optional[str] = None\n    mode: str = \"chat\"  # \"voice\" or \"chat\"\n    trace_id: Optional[str] = None\n    db_session: Optional[AsyncSession] = None\n\n\n# Tool handler type\nToolHandler = Callable[[Dict[str, Any], ToolExecutionContext], Any]\n\n\nclass ToolService:\n    \"\"\"\n    Unified tool execution service for Voice and Chat modes.\n\n    Provides:\n    - Tool registration and discovery\n    - OpenAI-compatible tool schema generation\n    - Tool execution with error handling\n    - Analytics logging\n    \"\"\"\n\n    def __init__(self):\n        self._tools: Dict[str, ToolDefinition] = {}\n        self._handlers: Dict[str, ToolHandler] = {}\n        self._register_default_tools()\n\n    def _register_default_tools(self):\n        \"\"\"Register all default tools.\"\"\"\n        # Calendar tools\n        self.register(\n            ToolDefinition(\n                name=\"calendar_create_event\",\n                description=(\n                    \"Create a new calendar event or appointment. \"\n                    \"Use this when the user wants to add something to their calendar.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"title\": {\n                            \"type\": \"string\",\n                            \"description\": \"Event title or name\",\n                        },\n                        \"start_time\": {\n                            \"type\": \"string\",\n                            \"description\": (\n                                \"Start time in natural language \" \"(e.g., 'Thursday at 6pm', 'tomorrow at noon')\"\n                            ),\n                        },\n                        \"end_time\": {\n                            \"type\": \"string\",\n                            \"description\": \"End time (optional, defaults to 1 hour after start)\",\n                        },\n                        \"description\": {\n                            \"type\": \"string\",\n                            \"description\": \"Event description or notes\",\n                        },\n                        \"location\": {\n                            \"type\": \"string\",\n                            \"description\": \"Event location\",\n                        },\n                        \"calendar_provider\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"google\", \"microsoft\", \"apple\", \"nextcloud\"],\n                            \"description\": \"Which calendar to use (if user has multiple connected)\",\n                        },\n                    },\n                    \"required\": [\"title\", \"start_time\"],\n                },\n                category=ToolCategory.CALENDAR,\n                requires_auth=True,\n            ),\n        )\n\n        self.register(\n            ToolDefinition(\n                name=\"calendar_list_events\",\n                description=\"List upcoming calendar events. Use when the user asks about their schedule.\",\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"start_date\": {\n                            \"type\": \"string\",\n                            \"description\": \"Start date to search from (e.g., 'today', 'tomorrow', '2024-01-15')\",\n                        },\n                        \"end_date\": {\n                            \"type\": \"string\",\n                            \"description\": \"End date to search to (optional, defaults to 7 days from start)\",\n                        },\n                        \"calendar_provider\": {\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"google\",\n                                \"microsoft\",\n                                \"apple\",\n                                \"nextcloud\",\n                                \"all\",\n                            ],\n                            \"description\": \"Which calendar to query (or 'all' for all connected calendars)\",\n                        },\n                        \"max_results\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of events to return (default 10)\",\n                        },\n                    },\n                    \"required\": [],\n                },\n                category=ToolCategory.CALENDAR,\n                requires_auth=True,\n            ),\n        )\n\n        self.register(\n            ToolDefinition(\n                name=\"calendar_update_event\",\n                description=(\n                    \"Update an existing calendar event. Use when the user wants to modify, \"\n                    \"reschedule, or change details of an event. First list events to get the event ID.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"event_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"The ID of the event to update (get from calendar_list_events)\",\n                        },\n                        \"title\": {\n                            \"type\": \"string\",\n                            \"description\": \"New title for the event (optional)\",\n                        },\n                        \"start_time\": {\n                            \"type\": \"string\",\n                            \"description\": \"New start time in natural language (optional)\",\n                        },\n                        \"end_time\": {\n                            \"type\": \"string\",\n                            \"description\": \"New end time (optional)\",\n                        },\n                        \"description\": {\n                            \"type\": \"string\",\n                            \"description\": \"New description (optional)\",\n                        },\n                        \"location\": {\n                            \"type\": \"string\",\n                            \"description\": \"New location (optional)\",\n                        },\n                        \"calendar_provider\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"google\", \"microsoft\", \"apple\", \"nextcloud\"],\n                            \"description\": \"Which calendar the event is on\",\n                        },\n                    },\n                    \"required\": [\"event_id\"],\n                },\n                category=ToolCategory.CALENDAR,\n                requires_auth=True,\n            ),\n        )\n\n        self.register(\n            ToolDefinition(\n                name=\"calendar_delete_event\",\n                description=(\n                    \"Delete a calendar event. Use when the user wants to remove or cancel an event. \"\n                    \"First list events to get the event ID, then confirm with the user before deleting.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"event_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"The ID of the event to delete (get from calendar_list_events)\",\n                        },\n                        \"calendar_provider\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"google\", \"microsoft\", \"apple\", \"nextcloud\"],\n                            \"description\": \"Which calendar the event is on\",\n                        },\n                    },\n                    \"required\": [\"event_id\"],\n                },\n                category=ToolCategory.CALENDAR,\n                requires_auth=True,\n                requires_confirmation=True,\n            ),\n        )\n\n        # Web search tool\n        self.register(\n            ToolDefinition(\n                name=\"web_search\",\n                description=(\n                    \"Search the web for information. Use when the user asks to \"\n                    \"'google' something, look up current events, or find info not in KB.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\n                            \"type\": \"string\",\n                            \"description\": \"The search query\",\n                        },\n                        \"max_results\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum results to return (default 5)\",\n                        },\n                    },\n                    \"required\": [\"query\"],\n                },\n                category=ToolCategory.SEARCH,\n            ),\n        )\n\n        # PubMed search tool\n        self.register(\n            ToolDefinition(\n                name=\"pubmed_search\",\n                description=(\n                    \"Search PubMed for medical literature, research papers, \"\n                    \"and clinical studies. Use for medical research queries.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query for PubMed\",\n                        },\n                        \"max_results\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum results (default 5)\",\n                        },\n                        \"date_range\": {\n                            \"type\": \"string\",\n                            \"description\": \"Date filter like '2024', 'last 5 years', 'last year'\",\n                        },\n                        \"article_types\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"enum\": [\n                                    \"review\",\n                                    \"clinical trial\",\n                                    \"meta-analysis\",\n                                    \"case report\",\n                                    \"guideline\",\n                                ],\n                            },\n                            \"description\": \"Filter by article type\",\n                        },\n                    },\n                    \"required\": [\"query\"],\n                },\n                category=ToolCategory.MEDICAL,\n            ),\n        )\n\n        # Medical calculator tool\n        self.register(\n            ToolDefinition(\n                name=\"medical_calculator\",\n                description=(\n                    \"Calculate medical scores and risk assessments. \"\n                    \"Includes Wells DVT, CHA2DS2-VASc, MELD, Child-Pugh, BMI, eGFR.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"calculator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Calculator name (e.g., 'wells_dvt', 'cha2ds2_vasc', 'meld', 'bmi', 'egfr')\",\n                        },\n                        \"inputs\": {\n                            \"type\": \"object\",\n                            \"description\": \"Calculator-specific input parameters\",\n                        },\n                    },\n                    \"required\": [\"calculator\", \"inputs\"],\n                },\n                category=ToolCategory.MEDICAL,\n            ),\n        )\n\n        # KB search tool (for searching the knowledge base)\n        self.register(\n            ToolDefinition(\n                name=\"kb_search\",\n                description=(\n                    \"Search the medical knowledge base for relevant information \"\n                    \"from textbooks, guidelines, and curated content.\"\n                ),\n                parameters={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query\",\n                        },\n                        \"sources\": {\n                            \"type\": \"array\",\n                            \"items\": {\"type\": \"string\"},\n                            \"description\": \"Filter by source types (e.g., 'textbook', 'guideline')\",\n                        },\n                        \"max_results\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum results (default 5)\",\n                        },\n                    },\n                    \"required\": [\"query\"],\n                },\n                category=ToolCategory.KNOWLEDGE,\n            ),\n        )\n\n    def register(self, tool: ToolDefinition, handler: Optional[ToolHandler] = None):\n        \"\"\"Register a tool definition and optional handler.\"\"\"\n        self._tools[tool.name] = tool\n        if handler:\n            self._handlers[tool.name] = handler\n        logger.debug(f\"Registered tool: {tool.name}\")\n\n    def register_handler(self, tool_name: str, handler: ToolHandler):\n        \"\"\"Register a handler for an existing tool.\"\"\"\n        if tool_name not in self._tools:\n            raise ValueError(f\"Tool {tool_name} not registered\")\n        self._handlers[tool_name] = handler\n\n    def get_tool(self, name: str) -> Optional[ToolDefinition]:\n        \"\"\"Get a tool definition by name.\"\"\"\n        return self._tools.get(name)\n\n    def list_tools(self, category: Optional[ToolCategory] = None) -> List[ToolDefinition]:\n        \"\"\"List all registered tools, optionally filtered by category.\"\"\"\n        tools = list(self._tools.values())\n        if category:\n            tools = [t for t in tools if t.category == category]\n        return [t for t in tools if t.enabled]\n\n    def get_openai_tools(self, categories: Optional[List[ToolCategory]] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        Return tools in OpenAI function calling format.\n\n        Args:\n            categories: Optional list of categories to include. If None, includes all.\n\n        Returns:\n            List of tool definitions in OpenAI format\n        \"\"\"\n        tools = []\n        for tool in self._tools.values():\n            if not tool.enabled:\n                continue\n            if categories and tool.category not in categories:\n                continue\n\n            tools.append(\n                {\n                    \"type\": \"function\",\n                    \"function\": {\n                        \"name\": tool.name,\n                        \"description\": tool.description,\n                        \"parameters\": tool.parameters,\n                    },\n                }\n            )\n        return tools\n\n    def get_openai_tools_for_realtime(self, categories: Optional[List[ToolCategory]] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        Return tools in OpenAI Realtime API format.\n\n        The Realtime API uses a slightly different format than Chat Completions.\n        \"\"\"\n        tools = []\n        for tool in self._tools.values():\n            if not tool.enabled:\n                continue\n            if categories and tool.category not in categories:\n                continue\n\n            tools.append(\n                {\n                    \"type\": \"function\",\n                    \"name\": tool.name,\n                    \"description\": tool.description,\n                    \"parameters\": tool.parameters,\n                }\n            )\n        return tools\n\n    async def execute(\n        self,\n        name: str,\n        arguments: Dict[str, Any],\n        context: ToolExecutionContext,\n    ) -> ToolResult:\n        \"\"\"\n        Execute a tool by name with the given arguments.\n\n        Args:\n            name: Tool name\n            arguments: Tool arguments\n            context: Execution context with user info\n\n        Returns:\n            ToolResult with success/failure and data\n        \"\"\"\n        start_time = time.time()\n\n        tool = self._tools.get(name)\n        if not tool:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"Unknown tool: {name}\",\n                error_type=\"ToolNotFound\",\n            )\n\n        if not tool.enabled:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"Tool {name} is disabled\",\n                error_type=\"ToolDisabled\",\n            )\n\n        handler = self._handlers.get(name)\n        if not handler:\n            # Fall back to dynamic handler lookup\n            handler = self._get_dynamic_handler(name)\n\n        if not handler:\n            return ToolResult(\n                success=False,\n                data=None,\n                error=f\"No handler registered for tool: {name}\",\n                error_type=\"NoHandler\",\n            )\n\n        try:\n            logger.info(f\"Executing tool: {name} with args: {json.dumps(arguments)[:500]}\")\n            result = await handler(arguments, context)\n            duration_ms = int((time.time() - start_time) * 1000)\n\n            if isinstance(result, ToolResult):\n                result.duration_ms = duration_ms\n                return result\n\n            # Wrap plain result\n            return ToolResult(\n                success=True,\n                data=result,\n                duration_ms=duration_ms,\n            )\n\n        except Exception as e:\n            duration_ms = int((time.time() - start_time) * 1000)\n            logger.exception(f\"Error executing tool {name}: {e}\")\n            return ToolResult(\n                success=False,\n                data=None,\n                error=str(e),\n                error_type=type(e).__name__,\n                duration_ms=duration_ms,\n            )\n\n    def _get_dynamic_handler(self, tool_name: str) -> Optional[ToolHandler]:\n        \"\"\"\n        Get a handler dynamically based on tool name.\n\n        This allows lazy loading of handlers without circular imports.\n        \"\"\"\n        from app.services.tools import calendar_tool, medical_tools, search_tools\n\n        handler_map = {\n            # Calendar tools\n            \"calendar_create_event\": calendar_tool.handle_create_event,\n            \"calendar_list_events\": calendar_tool.handle_list_events,\n            \"calendar_update_event\": calendar_tool.handle_update_event,\n            \"calendar_delete_event\": calendar_tool.handle_delete_event,\n            # Search tools\n            \"web_search\": search_tools.handle_web_search,\n            \"pubmed_search\": search_tools.handle_pubmed_search,\n            \"kb_search\": search_tools.handle_kb_search,\n            # Medical tools\n            \"medical_calculator\": medical_tools.handle_medical_calculator,\n        }\n\n        return handler_map.get(tool_name)\n\n\n# Global singleton instance\ntool_service = ToolService()\n"
}
