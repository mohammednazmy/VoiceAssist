{
  "path": "services/api-gateway/app/services/thinking_feedback_service.py",
  "language": "python",
  "size": 15647,
  "last_modified": "2025-12-05T03:05:36.641Z",
  "lines": 457,
  "content": "\"\"\"\nThinking Feedback Service - Audio cues during LLM processing\n\nVoice Mode v4 - Phase 2 Integration\n\nProvides configurable audio feedback during AI processing:\n- Thinking tones (beeps, chimes) while LLM generates\n- Progress indicators for long operations\n- Completion sounds\n- User-configurable tone styles and volumes\n\"\"\"\n\nimport asyncio\nimport base64\nimport logging\nimport math\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional\n\nimport numpy as np\n\nlogger = logging.getLogger(__name__)\n\n\nclass ToneStyle(Enum):\n    \"\"\"Available thinking tone styles.\"\"\"\n    SUBTLE = \"subtle\"  # Soft, unobtrusive beeps\n    MODERN = \"modern\"  # Contemporary digital tones\n    CLASSIC = \"classic\"  # Traditional notification sounds\n    MINIMAL = \"minimal\"  # Single subtle tone\n    AMBIENT = \"ambient\"  # Gentle ambient sound\n    SILENT = \"silent\"  # No audio feedback\n\n\nclass ToneType(Enum):\n    \"\"\"Types of feedback tones.\"\"\"\n    THINKING_START = \"thinking_start\"  # Processing started\n    THINKING_LOOP = \"thinking_loop\"  # Ongoing processing\n    THINKING_END = \"thinking_end\"  # Processing complete\n    PROGRESS = \"progress\"  # Progress milestone\n    ERROR = \"error\"  # Error occurred\n    READY = \"ready\"  # Ready for input\n\n\n@dataclass\nclass ToneConfig:\n    \"\"\"Configuration for a specific tone type.\"\"\"\n    frequency_hz: float = 440.0  # Base frequency\n    duration_ms: int = 100  # Tone duration\n    volume: float = 0.3  # 0.0 to 1.0\n    fade_in_ms: int = 10  # Fade in duration\n    fade_out_ms: int = 20  # Fade out duration\n    harmonics: List[float] = field(default_factory=lambda: [1.0, 0.5, 0.25])\n    waveform: str = \"sine\"  # sine, triangle, square\n\n\n@dataclass\nclass ThinkingFeedbackConfig:\n    \"\"\"Configuration for thinking feedback service.\"\"\"\n    enabled: bool = True\n    style: ToneStyle = ToneStyle.SUBTLE\n    volume: float = 0.3  # Master volume 0.0 to 1.0\n\n    # Timing\n    loop_interval_ms: int = 1500  # Interval between thinking tones\n    min_thinking_duration_ms: int = 500  # Min duration before playing tones\n\n    # Sample rate\n    sample_rate: int = 24000  # Match TTS output rate\n\n    # Per-tone overrides (optional)\n    tone_configs: Dict[ToneType, ToneConfig] = field(default_factory=dict)\n\n\n# Predefined tone presets\nTONE_PRESETS = {\n    ToneStyle.SUBTLE: {\n        ToneType.THINKING_START: ToneConfig(\n            frequency_hz=880, duration_ms=80, volume=0.2,\n            harmonics=[1.0, 0.3], fade_out_ms=30\n        ),\n        ToneType.THINKING_LOOP: ToneConfig(\n            frequency_hz=660, duration_ms=60, volume=0.15,\n            harmonics=[1.0, 0.2], fade_out_ms=25\n        ),\n        ToneType.THINKING_END: ToneConfig(\n            frequency_hz=1046, duration_ms=120, volume=0.25,\n            harmonics=[1.0, 0.4, 0.2], fade_out_ms=40\n        ),\n        ToneType.ERROR: ToneConfig(\n            frequency_hz=220, duration_ms=200, volume=0.3,\n            harmonics=[1.0, 0.5], waveform=\"triangle\"\n        ),\n        ToneType.READY: ToneConfig(\n            frequency_hz=523, duration_ms=100, volume=0.2,\n            harmonics=[1.0, 0.3, 0.1]\n        ),\n    },\n    ToneStyle.MODERN: {\n        ToneType.THINKING_START: ToneConfig(\n            frequency_hz=1200, duration_ms=50, volume=0.25,\n            harmonics=[1.0, 0.2]\n        ),\n        ToneType.THINKING_LOOP: ToneConfig(\n            frequency_hz=800, duration_ms=40, volume=0.18,\n            harmonics=[1.0]\n        ),\n        ToneType.THINKING_END: ToneConfig(\n            frequency_hz=1400, duration_ms=80, volume=0.28,\n            harmonics=[1.0, 0.3]\n        ),\n        ToneType.ERROR: ToneConfig(\n            frequency_hz=300, duration_ms=150, volume=0.35,\n            waveform=\"square\"\n        ),\n        ToneType.READY: ToneConfig(\n            frequency_hz=1000, duration_ms=60, volume=0.22\n        ),\n    },\n    ToneStyle.CLASSIC: {\n        ToneType.THINKING_START: ToneConfig(\n            frequency_hz=440, duration_ms=150, volume=0.3,\n            harmonics=[1.0, 0.5, 0.25]\n        ),\n        ToneType.THINKING_LOOP: ToneConfig(\n            frequency_hz=392, duration_ms=100, volume=0.2,\n            harmonics=[1.0, 0.4]\n        ),\n        ToneType.THINKING_END: ToneConfig(\n            frequency_hz=523, duration_ms=200, volume=0.35,\n            harmonics=[1.0, 0.5, 0.3]\n        ),\n        ToneType.ERROR: ToneConfig(\n            frequency_hz=196, duration_ms=300, volume=0.4,\n            harmonics=[1.0, 0.6]\n        ),\n        ToneType.READY: ToneConfig(\n            frequency_hz=440, duration_ms=120, volume=0.28\n        ),\n    },\n    ToneStyle.MINIMAL: {\n        ToneType.THINKING_START: ToneConfig(\n            frequency_hz=600, duration_ms=50, volume=0.15,\n            harmonics=[1.0]\n        ),\n        ToneType.THINKING_LOOP: ToneConfig(\n            frequency_hz=600, duration_ms=30, volume=0.1,\n            harmonics=[1.0]\n        ),\n        ToneType.THINKING_END: ToneConfig(\n            frequency_hz=700, duration_ms=60, volume=0.18,\n            harmonics=[1.0]\n        ),\n        ToneType.ERROR: ToneConfig(\n            frequency_hz=250, duration_ms=100, volume=0.25,\n            harmonics=[1.0]\n        ),\n        ToneType.READY: ToneConfig(\n            frequency_hz=550, duration_ms=40, volume=0.12\n        ),\n    },\n    ToneStyle.AMBIENT: {\n        ToneType.THINKING_START: ToneConfig(\n            frequency_hz=350, duration_ms=300, volume=0.12,\n            harmonics=[1.0, 0.8, 0.6, 0.4], fade_in_ms=50, fade_out_ms=100\n        ),\n        ToneType.THINKING_LOOP: ToneConfig(\n            frequency_hz=280, duration_ms=400, volume=0.08,\n            harmonics=[1.0, 0.7, 0.5], fade_in_ms=80, fade_out_ms=150\n        ),\n        ToneType.THINKING_END: ToneConfig(\n            frequency_hz=420, duration_ms=350, volume=0.15,\n            harmonics=[1.0, 0.6, 0.4, 0.2], fade_in_ms=50, fade_out_ms=120\n        ),\n        ToneType.ERROR: ToneConfig(\n            frequency_hz=180, duration_ms=400, volume=0.2,\n            harmonics=[1.0, 0.8], fade_out_ms=150\n        ),\n        ToneType.READY: ToneConfig(\n            frequency_hz=380, duration_ms=250, volume=0.1,\n            fade_in_ms=40, fade_out_ms=80\n        ),\n    },\n}\n\n\nclass ThinkingFeedbackService:\n    \"\"\"\n    Service for providing audio feedback during AI processing.\n\n    Generates and manages thinking tones, progress indicators,\n    and completion sounds.\n    \"\"\"\n\n    def __init__(self, config: Optional[ThinkingFeedbackConfig] = None):\n        self.config = config or ThinkingFeedbackConfig()\n        self._tone_cache: Dict[str, bytes] = {}\n        self._active_sessions: Dict[str, asyncio.Task] = {}\n        self._initialized = False\n\n        # Callbacks\n        self._on_tone_generated: Optional[Callable[[ToneType, bytes], None]] = None\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize the service and pre-generate common tones.\"\"\"\n        if self._initialized:\n            return\n\n        logger.info(\n            \"Initializing ThinkingFeedbackService\",\n            extra={\n                \"style\": self.config.style.value,\n                \"enabled\": self.config.enabled,\n                \"volume\": self.config.volume,\n            }\n        )\n\n        # Pre-generate tones for current style\n        if self.config.enabled and self.config.style != ToneStyle.SILENT:\n            await self._pregenerate_tones()\n\n        self._initialized = True\n\n    async def _pregenerate_tones(self) -> None:\n        \"\"\"Pre-generate all tones for the current style.\"\"\"\n        for tone_type in ToneType:\n            cache_key = f\"{self.config.style.value}:{tone_type.value}\"\n            if cache_key not in self._tone_cache:\n                audio = await self.generate_tone(tone_type)\n                self._tone_cache[cache_key] = audio\n\n    def _get_tone_config(self, tone_type: ToneType) -> ToneConfig:\n        \"\"\"Get configuration for a specific tone type.\"\"\"\n        # Check for user override\n        if tone_type in self.config.tone_configs:\n            return self.config.tone_configs[tone_type]\n\n        # Get from preset\n        if self.config.style in TONE_PRESETS:\n            preset = TONE_PRESETS[self.config.style]\n            if tone_type in preset:\n                return preset[tone_type]\n\n        # Default fallback\n        return ToneConfig()\n\n    async def generate_tone(self, tone_type: ToneType) -> bytes:\n        \"\"\"\n        Generate audio bytes for a specific tone type.\n\n        Args:\n            tone_type: Type of tone to generate\n\n        Returns:\n            PCM16 audio bytes\n        \"\"\"\n        if self.config.style == ToneStyle.SILENT:\n            return b''\n\n        tone_config = self._get_tone_config(tone_type)\n\n        # Apply master volume\n        volume = tone_config.volume * self.config.volume\n\n        # Generate samples\n        num_samples = int(self.config.sample_rate * tone_config.duration_ms / 1000)\n        t = np.linspace(0, tone_config.duration_ms / 1000, num_samples)\n\n        # Generate waveform with harmonics\n        signal = np.zeros(num_samples)\n        for i, harmonic_vol in enumerate(tone_config.harmonics):\n            freq = tone_config.frequency_hz * (i + 1)\n\n            if tone_config.waveform == \"sine\":\n                signal += harmonic_vol * np.sin(2 * np.pi * freq * t)\n            elif tone_config.waveform == \"triangle\":\n                signal += harmonic_vol * 2 * np.abs(2 * (freq * t % 1) - 1) - 1\n            elif tone_config.waveform == \"square\":\n                signal += harmonic_vol * np.sign(np.sin(2 * np.pi * freq * t))\n\n        # Apply envelope (fade in/out)\n        envelope = np.ones(num_samples)\n\n        # Fade in\n        fade_in_samples = int(self.config.sample_rate * tone_config.fade_in_ms / 1000)\n        if fade_in_samples > 0:\n            envelope[:fade_in_samples] = np.linspace(0, 1, fade_in_samples)\n\n        # Fade out\n        fade_out_samples = int(self.config.sample_rate * tone_config.fade_out_ms / 1000)\n        if fade_out_samples > 0:\n            envelope[-fade_out_samples:] = np.linspace(1, 0, fade_out_samples)\n\n        signal *= envelope\n\n        # Apply volume and convert to PCM16\n        signal = signal * volume * 32767\n        signal = np.clip(signal, -32768, 32767).astype(np.int16)\n\n        return signal.tobytes()\n\n    async def get_tone(self, tone_type: ToneType) -> bytes:\n        \"\"\"\n        Get tone audio, using cache if available.\n\n        Args:\n            tone_type: Type of tone\n\n        Returns:\n            PCM16 audio bytes\n        \"\"\"\n        if not self.config.enabled or self.config.style == ToneStyle.SILENT:\n            return b''\n\n        cache_key = f\"{self.config.style.value}:{tone_type.value}\"\n\n        if cache_key not in self._tone_cache:\n            audio = await self.generate_tone(tone_type)\n            self._tone_cache[cache_key] = audio\n\n        return self._tone_cache[cache_key]\n\n    async def start_thinking_loop(\n        self,\n        session_id: str,\n        on_tone: Callable[[bytes], None]\n    ) -> None:\n        \"\"\"\n        Start a thinking tone loop for a session.\n\n        Args:\n            session_id: Unique session identifier\n            on_tone: Callback to receive tone audio\n        \"\"\"\n        if not self.config.enabled or self.config.style == ToneStyle.SILENT:\n            return\n\n        # Cancel existing loop for this session\n        await self.stop_thinking_loop(session_id)\n\n        async def loop():\n            # Play start tone\n            start_tone = await self.get_tone(ToneType.THINKING_START)\n            if start_tone:\n                on_tone(start_tone)\n\n            # Wait minimum duration\n            await asyncio.sleep(self.config.min_thinking_duration_ms / 1000)\n\n            # Loop with interval\n            while True:\n                loop_tone = await self.get_tone(ToneType.THINKING_LOOP)\n                if loop_tone:\n                    on_tone(loop_tone)\n                await asyncio.sleep(self.config.loop_interval_ms / 1000)\n\n        task = asyncio.create_task(loop())\n        self._active_sessions[session_id] = task\n        logger.debug(f\"Started thinking loop for session {session_id}\")\n\n    async def stop_thinking_loop(\n        self,\n        session_id: str,\n        play_end_tone: bool = True,\n        on_tone: Optional[Callable[[bytes], None]] = None\n    ) -> None:\n        \"\"\"\n        Stop thinking tone loop for a session.\n\n        Args:\n            session_id: Session identifier\n            play_end_tone: Whether to play completion tone\n            on_tone: Callback for end tone\n        \"\"\"\n        if session_id in self._active_sessions:\n            task = self._active_sessions[session_id]\n            task.cancel()\n            try:\n                await task\n            except asyncio.CancelledError:\n                pass\n            del self._active_sessions[session_id]\n            logger.debug(f\"Stopped thinking loop for session {session_id}\")\n\n        # Play end tone\n        if play_end_tone and on_tone and self.config.enabled:\n            end_tone = await self.get_tone(ToneType.THINKING_END)\n            if end_tone:\n                on_tone(end_tone)\n\n    async def play_error_tone(\n        self,\n        on_tone: Callable[[bytes], None]\n    ) -> None:\n        \"\"\"Play error feedback tone.\"\"\"\n        if not self.config.enabled:\n            return\n\n        error_tone = await self.get_tone(ToneType.ERROR)\n        if error_tone:\n            on_tone(error_tone)\n\n    async def play_ready_tone(\n        self,\n        on_tone: Callable[[bytes], None]\n    ) -> None:\n        \"\"\"Play ready/listening feedback tone.\"\"\"\n        if not self.config.enabled:\n            return\n\n        ready_tone = await self.get_tone(ToneType.READY)\n        if ready_tone:\n            on_tone(ready_tone)\n\n    def update_style(self, style: ToneStyle) -> None:\n        \"\"\"Update tone style (clears cache).\"\"\"\n        self.config.style = style\n        self._tone_cache.clear()\n\n    def update_volume(self, volume: float) -> None:\n        \"\"\"Update master volume (clears cache).\"\"\"\n        self.config.volume = max(0.0, min(1.0, volume))\n        self._tone_cache.clear()\n\n    def set_enabled(self, enabled: bool) -> None:\n        \"\"\"Enable or disable feedback tones.\"\"\"\n        self.config.enabled = enabled\n\n    def get_available_styles(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of available tone styles with descriptions.\"\"\"\n        return [\n            {\"id\": ToneStyle.SUBTLE.value, \"name\": \"Subtle\", \"description\": \"Soft, unobtrusive beeps\"},\n            {\"id\": ToneStyle.MODERN.value, \"name\": \"Modern\", \"description\": \"Contemporary digital tones\"},\n            {\"id\": ToneStyle.CLASSIC.value, \"name\": \"Classic\", \"description\": \"Traditional notification sounds\"},\n            {\"id\": ToneStyle.MINIMAL.value, \"name\": \"Minimal\", \"description\": \"Single subtle tone\"},\n            {\"id\": ToneStyle.AMBIENT.value, \"name\": \"Ambient\", \"description\": \"Gentle ambient sounds\"},\n            {\"id\": ToneStyle.SILENT.value, \"name\": \"Silent\", \"description\": \"No audio feedback\"},\n        ]\n\n    async def cleanup(self) -> None:\n        \"\"\"Clean up all active sessions.\"\"\"\n        for session_id in list(self._active_sessions.keys()):\n            await self.stop_thinking_loop(session_id, play_end_tone=False)\n\n\n# Singleton instance\n_thinking_feedback_service: Optional[ThinkingFeedbackService] = None\n\n\ndef get_thinking_feedback_service() -> ThinkingFeedbackService:\n    \"\"\"Get or create the singleton ThinkingFeedbackService instance.\"\"\"\n    global _thinking_feedback_service\n    if _thinking_feedback_service is None:\n        _thinking_feedback_service = ThinkingFeedbackService()\n    return _thinking_feedback_service\n"
}
