{
  "path": "services/api-gateway/app/services/admin_event_publisher.py",
  "language": "python",
  "size": 13576,
  "last_modified": "2025-12-05T03:07:13.132Z",
  "lines": 445,
  "content": "\"\"\"\nAdmin Event Publisher Service for real-time admin panel updates.\n\nThis service provides:\n- Redis pub/sub based event publishing for admin WebSocket clients\n- Event types for conversations, users, voice sessions, and system alerts\n- Async event publishing to avoid blocking main request flow\n\"\"\"\n\nimport asyncio\nimport json\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Literal, Optional\n\nfrom app.core.logging import get_logger\nfrom app.core.redis_config import redis_pool\n\nlogger = get_logger(__name__)\n\n# Redis channel for admin events\nADMIN_EVENTS_CHANNEL = \"admin:events\"\n\n\nclass AdminEventType(str, Enum):\n    \"\"\"Types of events published to admin panel.\"\"\"\n\n    # Session events\n    SESSION_CONNECTED = \"session.connected\"\n    SESSION_DISCONNECTED = \"session.disconnected\"\n\n    # Conversation events\n    CONVERSATION_CREATED = \"conversation.created\"\n    CONVERSATION_UPDATED = \"conversation.updated\"\n    CONVERSATION_DELETED = \"conversation.deleted\"\n\n    # Message events\n    MESSAGE_CREATED = \"message.created\"\n\n    # Clinical context events\n    CLINICAL_CONTEXT_CREATED = \"clinical_context.created\"\n    CLINICAL_CONTEXT_UPDATED = \"clinical_context.updated\"\n\n    # Attachment events\n    ATTACHMENT_UPLOADED = \"attachment.uploaded\"\n    ATTACHMENT_DELETED = \"attachment.deleted\"\n\n    # PHI events\n    PHI_ACCESSED = \"phi.accessed\"\n    PHI_DETECTED = \"phi.detected\"\n\n    # Voice events\n    VOICE_SESSION_STARTED = \"voice.session_started\"\n    VOICE_SESSION_ENDED = \"voice.session_ended\"\n    VOICE_SESSION_ERROR = \"voice.session_error\"\n\n    # TT Pipeline events\n    TT_STATE_CHANGED = \"tt.state_changed\"\n    TT_TOOL_CALLED = \"tt.tool_called\"\n    TT_CONTEXT_CREATED = \"tt.context_created\"\n    TT_CONTEXT_EXPIRED = \"tt.context_expired\"\n\n    # System events\n    SYSTEM_ALERT = \"system.alert\"\n    SYSTEM_HEALTH_CHANGED = \"system.health_changed\"\n\n    # User events\n    USER_LOGGED_IN = \"user.logged_in\"\n    USER_LOGGED_OUT = \"user.logged_out\"\n    USER_CREATED = \"user.created\"\n\n\nclass AdminEvent:\n    \"\"\"Represents an admin event to be published.\"\"\"\n\n    def __init__(\n        self,\n        event_type: AdminEventType | str,\n        data: Dict[str, Any] = None,\n        user_id: Optional[str] = None,\n        user_email: Optional[str] = None,\n        session_id: Optional[str] = None,\n        resource_id: Optional[str] = None,\n        resource_type: Optional[str] = None,\n    ):\n        self.type = event_type.value if isinstance(event_type, AdminEventType) else event_type\n        self.timestamp = datetime.utcnow().isoformat() + \"Z\"\n        self.data = data or {}\n        self.user_id = user_id\n        self.user_email = user_email\n        self.session_id = session_id\n        self.resource_id = resource_id\n        self.resource_type = resource_type\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert event to dictionary for JSON serialization.\"\"\"\n        return {\n            \"type\": self.type,\n            \"timestamp\": self.timestamp,\n            \"user_id\": self.user_id,\n            \"user_email\": self.user_email,\n            \"session_id\": self.session_id,\n            \"resource_id\": self.resource_id,\n            \"resource_type\": self.resource_type,\n            \"data\": self.data,\n        }\n\n    def to_json(self) -> str:\n        \"\"\"Convert event to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n\n\nclass AdminEventPublisher:\n    \"\"\"\n    Service for publishing admin events via Redis pub/sub.\n\n    Features:\n    - Non-blocking async event publishing\n    - Event batching for high-frequency events\n    - Automatic Redis connection management\n    \"\"\"\n\n    _instance: Optional[\"AdminEventPublisher\"] = None\n\n    def __init__(self):\n        self._enabled = True\n        self._buffer: List[AdminEvent] = []\n        self._buffer_size = 50\n        self._flush_interval = 1.0  # seconds\n        self._flush_task: Optional[asyncio.Task] = None\n        self._running = False\n        self._lock = asyncio.Lock()\n\n    @classmethod\n    def get_instance(cls) -> \"AdminEventPublisher\":\n        \"\"\"Get singleton instance of the publisher.\"\"\"\n        if cls._instance is None:\n            cls._instance = cls()\n        return cls._instance\n\n    async def start(self):\n        \"\"\"Start the background flush task.\"\"\"\n        if self._running:\n            return\n        self._running = True\n        self._flush_task = asyncio.create_task(self._periodic_flush())\n        logger.info(\"AdminEventPublisher started\")\n\n    async def stop(self):\n        \"\"\"Stop the publisher and flush remaining events.\"\"\"\n        self._running = False\n        if self._flush_task:\n            self._flush_task.cancel()\n            try:\n                await self._flush_task\n            except asyncio.CancelledError:\n                pass\n        # Final flush\n        await self._flush_buffer()\n        logger.info(\"AdminEventPublisher stopped\")\n\n    def enable(self):\n        \"\"\"Enable event publishing.\"\"\"\n        self._enabled = True\n\n    def disable(self):\n        \"\"\"Disable event publishing (useful for testing).\"\"\"\n        self._enabled = False\n\n    async def publish(self, event: AdminEvent) -> bool:\n        \"\"\"\n        Publish an admin event to Redis pub/sub.\n\n        Args:\n            event: The AdminEvent to publish\n\n        Returns:\n            True if event was queued successfully\n        \"\"\"\n        if not self._enabled:\n            return False\n\n        async with self._lock:\n            self._buffer.append(event)\n\n            # Flush if buffer is full\n            if len(self._buffer) >= self._buffer_size:\n                await self._flush_buffer_internal()\n\n        return True\n\n    async def publish_immediate(self, event: AdminEvent) -> bool:\n        \"\"\"\n        Publish an event immediately without buffering.\n\n        Use for high-priority events that need real-time delivery.\n\n        Args:\n            event: The AdminEvent to publish\n\n        Returns:\n            True if published successfully\n        \"\"\"\n        if not self._enabled:\n            return False\n\n        try:\n            redis = await redis_pool.get_client()\n            if redis:\n                await redis.publish(ADMIN_EVENTS_CHANNEL, event.to_json())\n                logger.debug(f\"Published admin event: {event.type}\")\n                return True\n            else:\n                logger.warning(\"Redis not available for admin event publishing\")\n                return False\n        except Exception as e:\n            logger.error(f\"Failed to publish admin event: {e}\")\n            return False\n\n    async def _periodic_flush(self):\n        \"\"\"Background task to periodically flush the event buffer.\"\"\"\n        while self._running:\n            try:\n                await asyncio.sleep(self._flush_interval)\n                await self._flush_buffer()\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in periodic flush: {e}\")\n\n    async def _flush_buffer(self):\n        \"\"\"Flush the event buffer under lock.\"\"\"\n        async with self._lock:\n            await self._flush_buffer_internal()\n\n    async def _flush_buffer_internal(self):\n        \"\"\"Flush the event buffer (call under lock).\"\"\"\n        if not self._buffer:\n            return\n\n        events_to_flush = self._buffer.copy()\n        self._buffer.clear()\n\n        try:\n            redis = await redis_pool.get_client()\n            if redis:\n                # Publish all events in a pipeline for efficiency\n                async with redis.pipeline() as pipe:\n                    for event in events_to_flush:\n                        pipe.publish(ADMIN_EVENTS_CHANNEL, event.to_json())\n                    await pipe.execute()\n                logger.debug(f\"Flushed {len(events_to_flush)} admin events\")\n            else:\n                logger.warning(f\"Redis not available, dropping {len(events_to_flush)} admin events\")\n        except Exception as e:\n            logger.error(f\"Failed to flush admin events: {e}\")\n\n\n# Convenience functions for common events\n\n\nasync def publish_session_connected(\n    user_id: str,\n    user_email: str,\n    session_id: str,\n    session_type: str = \"web\",\n) -> bool:\n    \"\"\"Publish a session connected event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.SESSION_CONNECTED,\n        user_id=user_id,\n        user_email=user_email,\n        session_id=session_id,\n        data={\"session_type\": session_type},\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_session_disconnected(\n    user_id: str,\n    session_id: str,\n    duration_seconds: Optional[float] = None,\n) -> bool:\n    \"\"\"Publish a session disconnected event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.SESSION_DISCONNECTED,\n        user_id=user_id,\n        session_id=session_id,\n        data={\"duration_seconds\": duration_seconds} if duration_seconds else {},\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_conversation_created(\n    user_id: str,\n    conversation_id: str,\n    title: Optional[str] = None,\n) -> bool:\n    \"\"\"Publish a conversation created event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.CONVERSATION_CREATED,\n        user_id=user_id,\n        resource_id=conversation_id,\n        resource_type=\"conversation\",\n        data={\"title\": title} if title else {},\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_message_created(\n    user_id: str,\n    conversation_id: str,\n    message_id: str,\n    role: str,\n) -> bool:\n    \"\"\"Publish a message created event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.MESSAGE_CREATED,\n        user_id=user_id,\n        resource_id=message_id,\n        resource_type=\"message\",\n        data={\"conversation_id\": conversation_id, \"role\": role},\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_clinical_context_updated(\n    user_id: str,\n    context_id: str,\n    fields_updated: List[str] = None,\n) -> bool:\n    \"\"\"Publish a clinical context updated event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.CLINICAL_CONTEXT_UPDATED,\n        user_id=user_id,\n        resource_id=context_id,\n        resource_type=\"clinical_context\",\n        data={\"fields_updated\": fields_updated or []},\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_phi_accessed(\n    admin_user_id: str,\n    admin_email: str,\n    context_id: str,\n    target_user_id: str,\n) -> bool:\n    \"\"\"Publish a PHI accessed event (immediate for audit).\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.PHI_ACCESSED,\n        user_id=admin_user_id,\n        user_email=admin_email,\n        resource_id=context_id,\n        resource_type=\"clinical_context\",\n        data={\"target_user_id\": target_user_id},\n    )\n    # PHI access events are published immediately for audit\n    return await AdminEventPublisher.get_instance().publish_immediate(event)\n\n\nasync def publish_voice_session_started(\n    user_id: str,\n    session_id: str,\n    session_type: str = \"realtime\",\n    voice: Optional[str] = None,\n) -> bool:\n    \"\"\"Publish a voice session started event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.VOICE_SESSION_STARTED,\n        user_id=user_id,\n        session_id=session_id,\n        resource_type=\"voice_session\",\n        data={\"session_type\": session_type, \"voice\": voice},\n    )\n    return await AdminEventPublisher.get_instance().publish_immediate(event)\n\n\nasync def publish_voice_session_ended(\n    user_id: str,\n    session_id: str,\n    duration_seconds: Optional[float] = None,\n    messages_count: int = 0,\n) -> bool:\n    \"\"\"Publish a voice session ended event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.VOICE_SESSION_ENDED,\n        user_id=user_id,\n        session_id=session_id,\n        resource_type=\"voice_session\",\n        data={\n            \"duration_seconds\": duration_seconds,\n            \"messages_count\": messages_count,\n        },\n    )\n    return await AdminEventPublisher.get_instance().publish(event)\n\n\nasync def publish_tt_state_changed(\n    user_id: str,\n    session_id: str,\n    new_state: str,\n    previous_state: Optional[str] = None,\n) -> bool:\n    \"\"\"Publish a TT pipeline state change event.\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.TT_STATE_CHANGED,\n        user_id=user_id,\n        session_id=session_id,\n        resource_type=\"tt_session\",\n        data={\"new_state\": new_state, \"previous_state\": previous_state},\n    )\n    return await AdminEventPublisher.get_instance().publish_immediate(event)\n\n\nasync def publish_system_alert(\n    alert_type: str,\n    message: str,\n    severity: Literal[\"info\", \"warning\", \"error\", \"critical\"] = \"info\",\n    details: Optional[Dict[str, Any]] = None,\n) -> bool:\n    \"\"\"Publish a system alert event (always immediate).\"\"\"\n    event = AdminEvent(\n        event_type=AdminEventType.SYSTEM_ALERT,\n        data={\n            \"alert_type\": alert_type,\n            \"message\": message,\n            \"severity\": severity,\n            \"details\": details or {},\n        },\n    )\n    return await AdminEventPublisher.get_instance().publish_immediate(event)\n\n\n# Singleton instance\n_publisher: Optional[AdminEventPublisher] = None\n\n\ndef get_admin_event_publisher() -> AdminEventPublisher:\n    \"\"\"Get the global admin event publisher instance.\"\"\"\n    global _publisher\n    if _publisher is None:\n        _publisher = AdminEventPublisher.get_instance()\n    return _publisher\n"
}
