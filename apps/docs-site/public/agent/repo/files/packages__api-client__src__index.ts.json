{
  "path": "packages/api-client/src/index.ts",
  "language": "typescript",
  "size": 64404,
  "last_modified": "2025-12-02T03:06:59.777Z",
  "lines": 2280,
  "content": "/**\n * VoiceAssist API Client\n * HTTP client for communicating with VoiceAssist backend services\n */\n\nimport axios, { type AxiosInstance, type AxiosRequestConfig } from \"axios\";\nimport type {\n  ApiResponse,\n  LoginRequest,\n  TokenResponse,\n  User,\n  Conversation,\n  UpdateConversationRequest,\n  Message,\n  Document,\n  SearchResult,\n  SystemMetrics,\n  AuditLogEntry,\n  PaginatedResponse,\n  AuthTokens,\n  Branch,\n  CreateBranchRequest,\n  Folder,\n  CreateFolderRequest,\n  UpdateFolderRequest,\n  ShareRequest,\n  ShareResponse,\n  ShareLink,\n  Attachment,\n  AttachmentUploadResponse,\n  ClinicalContext,\n  ClinicalContextCreate,\n  ClinicalContextUpdate,\n  ClinicalContextPreset,\n  ClinicalPresetCreate,\n  ClinicalPresetUpdate,\n  IntegrationSummary,\n  IntegrationDetail,\n  IntegrationConfigUpdate,\n  IntegrationTestResult,\n  IntegrationMetrics,\n  IntegrationsHealthSummary,\n  PHIRule,\n  PHIRuleUpdate,\n  PHIRulesResponse,\n  PHITestRequest,\n  PHITestResult,\n  PHIRedactResult,\n  PHIRoutingConfig,\n  PHIRoutingUpdate,\n  PHIStats,\n  PHIEventsResponse,\n  PHIHealthStatus,\n  // Sprint 4: Medical AI & System types\n  ModelInfo,\n  ModelUsageMetrics,\n  SearchStats,\n  EmbeddingStats,\n  ModelRoutingConfig,\n  ModelRoutingUpdate,\n  ResourceMetrics,\n  BackupStatus,\n  BackupHistoryEntry,\n  BackupTriggerResult,\n  BackupType,\n  MaintenanceStatus,\n  MaintenanceRequest,\n  SystemHealth,\n  // Note: CacheStats uses local definition (line 181) with different structure\n  CacheNamespacesResponse,\n  CacheInvalidateResult,\n} from \"@voiceassist/types\";\nimport { withRetry, type RetryConfig } from \"./retry\";\n\ntype CryptoLike = {\n  randomUUID?: () => string;\n  getRandomValues?: (array: Uint8Array) => Uint8Array;\n};\n\n/**\n * Response when 2FA is required during login\n */\nexport interface TwoFactorRequiredResponse {\n  requires_2fa: true;\n  user_id: string;\n  message: string;\n}\n\n/**\n * Type guard to check if login response requires 2FA\n */\nexport function isTwoFactorRequired(\n  response: AuthTokens | TwoFactorRequiredResponse,\n): response is TwoFactorRequiredResponse {\n  return \"requires_2fa\" in response && response.requires_2fa === true;\n}\n\nconst cryptoApi: CryptoLike | undefined =\n  typeof crypto !== \"undefined\" ? (crypto as CryptoLike) : undefined;\n\nconst randomHex = (length: number): string => {\n  if (cryptoApi?.getRandomValues) {\n    const bytes = new Uint8Array(Math.ceil(length / 2));\n    cryptoApi.getRandomValues(bytes);\n    return Array.from(bytes)\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\")\n      .slice(0, length);\n  }\n  return Math.random()\n    .toString(16)\n    .slice(2, 2 + length)\n    .padEnd(length, \"0\");\n};\n\nconst buildTraceparent = (): string => {\n  const traceId = (\n    cryptoApi?.randomUUID?.().replace(/-/g, \"\") || randomHex(32)\n  ).slice(0, 32);\n  const spanId = randomHex(16).slice(0, 16);\n  return `00-${traceId}-${spanId}-01`;\n};\n\nexport interface ApiClientConfig {\n  baseURL: string;\n  timeout?: number;\n  onUnauthorized?: () => void;\n  getAccessToken?: () => string | null;\n  enableRetry?: boolean;\n  retryConfig?: Partial<RetryConfig>;\n  onRetry?: (attempt: number, error: any) => void;\n  correlationId?: string;\n  environment?: \"staging\" | \"production\" | string;\n}\n\n/** Admin KB document in list response */\nexport interface AdminKBDocument {\n  document_id: string;\n  title: string;\n  source_type: string;\n  upload_date: string;\n  chunks_indexed: number;\n}\n\n/** Admin KB document detail response */\nexport interface AdminKBDocumentDetail {\n  document_id: string;\n  title: string;\n  source_type: string;\n  filename: string;\n  file_type: string;\n  chunks_indexed: number;\n  total_tokens: number | null;\n  indexing_status: string;\n  indexing_error: string | null;\n  metadata: Record<string, unknown>;\n  created_at: string;\n  updated_at: string;\n}\n\n/** Admin KB upload response */\nexport interface AdminKBUploadResponse {\n  document_id: string;\n  title: string;\n  status: string;\n  chunks_indexed: number;\n  message: string;\n}\n\n/** Feature Flag configuration */\nexport interface FeatureFlag {\n  name: string;\n  enabled: boolean;\n  description: string;\n  created_at: string;\n  updated_at: string;\n  rollout_percentage?: number;\n  user_groups?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/** Request to create a new feature flag */\nexport interface CreateFeatureFlagRequest {\n  name: string;\n  enabled?: boolean;\n  description: string;\n  rollout_percentage?: number;\n  user_groups?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/** Request to update an existing feature flag */\nexport interface UpdateFeatureFlagRequest {\n  enabled?: boolean;\n  description?: string;\n  rollout_percentage?: number;\n  user_groups?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/** Cache statistics */\nexport interface CacheStats {\n  total_keys: number;\n  memory_used_bytes: number;\n  memory_used_human: string;\n  hit_rate: number;\n  miss_rate: number;\n  uptime_seconds: number;\n  connected_clients: number;\n  keys_by_prefix: Record<string, number>;\n}\n\nexport class VoiceAssistApiClient {\n  private client: AxiosInstance;\n  private config: ApiClientConfig;\n  private correlationId: string;\n\n  constructor(config: ApiClientConfig) {\n    this.config = {\n      enableRetry: true, // Enable retry by default\n      ...config,\n    };\n\n    this.correlationId =\n      this.config.correlationId ||\n      cryptoApi?.randomUUID?.() ||\n      `corr-${randomHex(16)}`;\n    this.client = axios.create({\n      baseURL: config.baseURL,\n      timeout: config.timeout || 30000,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Client-Env\": this.config.environment || \"staging\",\n      },\n    });\n\n    // Request interceptor - add auth token\n    this.client.interceptors.request.use((requestConfig) => {\n      const token = this.config.getAccessToken?.();\n      if (token && requestConfig.headers) {\n        requestConfig.headers.Authorization = `Bearer ${token}`;\n      }\n\n      const traceparent = buildTraceparent();\n\n      if (requestConfig.headers) {\n        requestConfig.headers[\"X-Correlation-ID\"] =\n          requestConfig.headers[\"X-Correlation-ID\"] || this.correlationId;\n        requestConfig.headers[\"traceparent\"] =\n          requestConfig.headers[\"traceparent\"] || traceparent;\n      }\n      return requestConfig;\n    });\n\n    // Response interceptor - handle errors\n    this.client.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        if (error.response?.status === 401) {\n          this.config.onUnauthorized?.();\n        }\n        return Promise.reject(error);\n      },\n    );\n  }\n\n  /**\n   * Wrap a request with retry logic if enabled\n   */\n  private async withRetryIfEnabled<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.config.enableRetry) {\n      return withRetry(fn, this.config.retryConfig, this.config.onRetry);\n    }\n    return fn();\n  }\n\n  /**\n   * Execute an arbitrary HTTP request using the configured Axios client.\n   * This is useful for endpoints that don't yet have a dedicated helper.\n   */\n  async request<T = any>(config: AxiosRequestConfig): Promise<T> {\n    const exec = async () => {\n      const response = await this.client.request<T>(config);\n      return response.data;\n    };\n\n    return this.withRetryIfEnabled(exec);\n  }\n\n  /**\n   * Expose the configured base URL for diagnostic and display purposes\n   */\n  getBaseUrl(): string {\n    return this.config.baseURL;\n  }\n\n  // =========================================================================\n  // Authentication\n  // =========================================================================\n\n  async login(\n    credentials: LoginRequest,\n  ): Promise<AuthTokens | TwoFactorRequiredResponse> {\n    const response = await this.client.post<\n      TokenResponse | TwoFactorRequiredResponse\n    >(\"/api/auth/login\", credentials);\n\n    // Check if 2FA is required\n    if (\"requires_2fa\" in response.data && response.data.requires_2fa) {\n      return response.data as TwoFactorRequiredResponse;\n    }\n\n    // Convert backend response to frontend format\n    const tokenResponse = response.data as TokenResponse;\n    return {\n      accessToken: tokenResponse.access_token,\n      refreshToken: tokenResponse.refresh_token,\n      expiresIn: tokenResponse.expires_in,\n    };\n  }\n\n  /**\n   * Verify 2FA code during login and get tokens\n   */\n  async verify2FALogin(\n    userId: string,\n    code: string,\n    isBackupCode: boolean = false,\n  ): Promise<AuthTokens> {\n    const response = await this.client.post<TokenResponse>(\n      \"/api/auth/2fa/verify-login\",\n      {\n        user_id: userId,\n        code,\n        is_backup_code: isBackupCode,\n      },\n    );\n    return {\n      accessToken: response.data.access_token,\n      refreshToken: response.data.refresh_token,\n      expiresIn: response.data.expires_in,\n    };\n  }\n\n  async register(data: {\n    email: string;\n    password: string;\n    full_name: string;\n  }): Promise<User> {\n    const response = await this.client.post<User>(\"/api/auth/register\", data);\n    return response.data;\n  }\n\n  async logout(): Promise<void> {\n    await this.client.post(\"/api/auth/logout\");\n  }\n\n  async refreshToken(refreshToken: string): Promise<AuthTokens> {\n    const response = await this.client.post<TokenResponse>(\n      \"/api/auth/refresh\",\n      {\n        refresh_token: refreshToken,\n      },\n    );\n    // Convert backend response to frontend format\n    return {\n      accessToken: response.data.access_token,\n      refreshToken: response.data.refresh_token,\n      expiresIn: response.data.expires_in,\n    };\n  }\n\n  async getCurrentUser(): Promise<User> {\n    const response = await this.client.get<User>(\"/api/users/me\");\n    return response.data;\n  }\n\n  /**\n   * Get session timeout information for the current session.\n   * Used by frontend to display session expiration warnings.\n   */\n  async getSessionInfo(): Promise<{\n    absolute_timeout_hours: number;\n    inactivity_timeout_minutes: number;\n    absolute_remaining_seconds: number;\n    inactivity_remaining_seconds: number;\n    session_started_at: string;\n    last_activity_at: string | null;\n  }> {\n    const response = await this.client.get(\"/api/auth/session\");\n    return response.data;\n  }\n\n  async updateProfile(updates: {\n    name?: string;\n    email?: string;\n  }): Promise<User> {\n    const response = await this.client.put<ApiResponse<User>>(\n      \"/api/users/me\",\n      updates,\n    );\n    return response.data.data!;\n  }\n\n  async changePassword(\n    currentPassword: string,\n    newPassword: string,\n  ): Promise<void> {\n    await this.client.put(\"/api/users/me/password\", {\n      currentPassword,\n      newPassword,\n    });\n  }\n\n  // =========================================================================\n  // Voice (Transcription & TTS)\n  // =========================================================================\n\n  async transcribeAudio(audio: Blob, filename = \"audio.webm\"): Promise<string> {\n    const formData = new FormData();\n    formData.append(\"audio\", audio as any, filename);\n\n    const response = await this.client.post<{ text: string }>(\n      \"/api/voice/transcribe\",\n      formData,\n      {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      },\n    );\n\n    return response.data.text;\n  }\n\n  async synthesizeSpeech(text: string, voiceId?: string): Promise<Blob> {\n    const response = await this.client.post<Blob>(\n      \"/api/voice/synthesize\",\n      { text, voiceId },\n      {\n        responseType: \"blob\",\n      },\n    );\n\n    return response.data;\n  }\n\n  /**\n   * Synthesize speech with streaming audio response (low latency).\n   * Uses ElevenLabs streaming when available, falls back to standard TTS.\n   *\n   * @param text - Text to synthesize\n   * @param options - TTS options including voice settings\n   * @returns Response object with streaming body\n   */\n  async synthesizeSpeechStream(\n    text: string,\n    options?: {\n      voiceId?: string;\n      provider?: \"openai\" | \"elevenlabs\";\n      stability?: number;\n      similarityBoost?: number;\n      style?: number;\n      language?: string;\n    },\n  ): Promise<Response> {\n    // Use native fetch for streaming support (axios buffers responses)\n    const token = this.config.getAccessToken?.();\n    const url = `${this.config.baseURL}/api/voice/synthesize/stream`;\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...(token ? { Authorization: `Bearer ${token}` } : {}),\n        \"X-Correlation-ID\": this.correlationId,\n        traceparent: buildTraceparent(),\n      },\n      body: JSON.stringify({\n        text,\n        voice_id: options?.voiceId,\n        provider: options?.provider,\n        stability: options?.stability,\n        similarity_boost: options?.similarityBoost,\n        style: options?.style,\n        language: options?.language,\n      }),\n    });\n\n    if (!response.ok) {\n      // Handle 401 - trigger unauthorized handler\n      if (response.status === 401) {\n        this.config.onUnauthorized?.();\n      }\n      throw new Error(\n        `TTS streaming failed: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return response;\n  }\n\n  async createRealtimeSession(request: {\n    conversation_id?: string | null;\n    // Optional Voice Mode settings from frontend\n    voice?: string | null; // \"alloy\" | \"echo\" | \"fable\" | \"onyx\" | \"nova\" | \"shimmer\"\n    language?: string | null; // \"en\" | \"es\" | \"fr\" | \"de\" | \"it\" | \"pt\"\n    vad_sensitivity?: number | null; // 0-100 (maps to VAD threshold)\n  }): Promise<{\n    url: string;\n    model: string;\n    session_id: string;\n    expires_at: number;\n    conversation_id?: string | null;\n    auth: {\n      type: string; // \"ephemeral_token\"\n      token: string; // OpenAI ephemeral token (NOT the raw API key)\n      expires_at: number; // Unix timestamp\n    };\n    voice_config: {\n      voice: string;\n      language?: string | null;\n      modalities: string[];\n      input_audio_format: string;\n      output_audio_format: string;\n      input_audio_transcription: {\n        model: string;\n      };\n      turn_detection: {\n        type: string;\n        threshold: number;\n        prefix_padding_ms: number;\n        silence_duration_ms: number;\n      };\n    };\n  }> {\n    const response = await this.client.post(\n      \"/api/voice/realtime-session\",\n      request,\n    );\n    return response.data;\n  }\n\n  async relayVoiceTranscript(request: {\n    conversation_id: string;\n    transcript: string;\n    clinical_context_id?: string | null;\n  }): Promise<{\n    user_message_id: string;\n    assistant_message_id: string;\n    answer: string;\n    citations: Record<string, any>[];\n  }> {\n    const response = await this.client.post(\"/api/voice/relay\", request);\n    return response.data;\n  }\n\n  /**\n   * Phase 11: Get available TTS voices from all configured providers\n   * @param provider Optional filter by provider (\"openai\" | \"elevenlabs\")\n   */\n  async getAvailableVoices(provider?: string): Promise<{\n    voices: Array<{\n      voice_id: string;\n      name: string;\n      provider: string; // \"openai\" | \"elevenlabs\"\n      category?: string | null;\n      preview_url?: string | null;\n      description?: string | null;\n      labels?: Record<string, string> | null;\n    }>;\n    default_voice_id?: string | null;\n    default_provider: string;\n  }> {\n    const params = provider ? { provider } : {};\n    const response = await this.client.get(\"/api/voice/voices\", { params });\n    return response.data;\n  }\n\n  /**\n   * Submit voice session metrics for observability\n   * Note: For page unload scenarios, use sendBeacon directly instead\n   */\n  async submitVoiceMetrics(metrics: {\n    conversation_id?: string | null;\n    connection_time_ms?: number | null;\n    time_to_first_transcript_ms?: number | null;\n    last_stt_latency_ms?: number | null;\n    last_response_latency_ms?: number | null;\n    session_duration_ms?: number | null;\n    user_transcript_count?: number;\n    ai_response_count?: number;\n    reconnect_count?: number;\n    session_started_at?: number | null;\n  }): Promise<{ status: string }> {\n    const response = await this.client.post(\"/api/voice/metrics\", metrics);\n    return response.data;\n  }\n\n  /**\n   * Log a voice event (e.g., barge-in) for analytics and observability\n   */\n  async logVoiceEvent(event: {\n    conversation_id?: string | null;\n    event_type:\n      | \"barge_in\"\n      | \"connection_error\"\n      | \"transcription_error\"\n      | \"synthesis_error\";\n    timestamp: number;\n    metadata?: {\n      interrupted_content?: string;\n      completion_percentage?: number;\n      error_message?: string;\n      [key: string]: unknown;\n    };\n  }): Promise<{ status: string; event_id: string }> {\n    const response = await this.client.post(\"/api/voice/events\", event);\n    return response.data;\n  }\n\n  // =========================================================================\n  // Thinker/Talker Voice Pipeline (Phase: T/T Migration)\n  // =========================================================================\n\n  /**\n   * Get Thinker/Talker pipeline status and availability\n   * Returns information about STT, TTS, and LLM services\n   */\n  async getTTPipelineStatus(): Promise<{\n    available: boolean;\n    mode: string; // \"thinker_talker\" or \"realtime_fallback\"\n    services: {\n      stt: {\n        primary: string;\n        fallback: string;\n        status: \"healthy\" | \"degraded\" | \"unavailable\";\n      };\n      tts: {\n        provider: string;\n        status: \"healthy\" | \"degraded\" | \"unavailable\";\n      };\n      llm: {\n        model: string;\n        status: \"healthy\" | \"degraded\" | \"unavailable\";\n      };\n    };\n    latency_targets: {\n      stt_ms: number;\n      llm_first_token_ms: number;\n      tts_ttfb_ms: number;\n      total_ms: number;\n    };\n  }> {\n    const response = await this.client.get(\"/api/voice/pipeline/status\");\n    return response.data;\n  }\n\n  /**\n   * Get WebSocket URL for Thinker/Talker voice pipeline\n   * This is the endpoint for the T/T voice WebSocket connection\n   */\n  getTTPipelineWebSocketUrl(): string {\n    const wsProtocol = this.config.baseURL.startsWith(\"https\") ? \"wss\" : \"ws\";\n    const wsHost = this.config.baseURL.replace(/^https?:\\/\\//, \"\");\n    return `${wsProtocol}://${wsHost}/api/voice/pipeline-ws`;\n  }\n\n  /**\n   * Submit T/T pipeline metrics for observability\n   */\n  async submitTTPipelineMetrics(metrics: {\n    conversation_id?: string | null;\n    session_id?: string | null;\n    connection_time_ms?: number | null;\n    stt_latency_ms?: number | null;\n    llm_first_token_ms?: number | null;\n    tts_first_audio_ms?: number | null;\n    total_latency_ms?: number | null;\n    session_duration_ms?: number | null;\n    user_utterance_count?: number;\n    ai_response_count?: number;\n    tool_call_count?: number;\n    barge_in_count?: number;\n    reconnect_count?: number;\n    pipeline_mode?: string;\n  }): Promise<{ status: string }> {\n    const response = await this.client.post(\n      \"/api/voice/pipeline/metrics\",\n      metrics,\n    );\n    return response.data;\n  }\n\n  async getOAuthUrl(provider: \"google\" | \"microsoft\"): Promise<string> {\n    const response = await this.client.get<ApiResponse<{ url: string }>>(\n      `/api/auth/oauth/${provider}/authorize`,\n    );\n    return response.data.data!.url;\n  }\n\n  async handleOAuthCallback(\n    provider: \"google\" | \"microsoft\",\n    code: string,\n  ): Promise<AuthTokens> {\n    const response = await this.client.post<TokenResponse>(\n      `/api/auth/oauth/${provider}/callback`,\n      { code },\n    );\n    // Convert backend response to frontend format\n    return {\n      accessToken: response.data.access_token,\n      refreshToken: response.data.refresh_token,\n      expiresIn: response.data.expires_in,\n    };\n  }\n\n  // =========================================================================\n  // Conversations\n  // =========================================================================\n\n  async getConversations(\n    page = 1,\n    pageSize = 20,\n  ): Promise<PaginatedResponse<Conversation>> {\n    const response = await this.client.get<\n      ApiResponse<{\n        items: Conversation[];\n        total: number;\n        page: number;\n        pageSize: number;\n      }>\n    >(\"/api/conversations\", { params: { page, pageSize } });\n    const data = response.data.data!;\n    // Transform backend response (total) to frontend format (totalCount, totalPages)\n    return {\n      items: data.items,\n      page: data.page,\n      pageSize: data.pageSize,\n      totalCount: data.total,\n      totalPages: Math.ceil(data.total / data.pageSize),\n    };\n  }\n\n  async getConversation(id: string): Promise<Conversation> {\n    const response = await this.client.get<ApiResponse<Conversation>>(\n      `/api/conversations/${id}`,\n    );\n    return response.data.data!;\n  }\n\n  async createConversation(title: string): Promise<Conversation> {\n    const response = await this.client.post<ApiResponse<Conversation>>(\n      \"/api/conversations\",\n      { title },\n    );\n    return response.data.data!;\n  }\n\n  async updateConversation(\n    id: string,\n    updates: UpdateConversationRequest,\n  ): Promise<Conversation> {\n    const response = await this.client.patch<ApiResponse<Conversation>>(\n      `/api/conversations/${id}`,\n      updates,\n    );\n    return response.data.data!;\n  }\n\n  async archiveConversation(id: string): Promise<Conversation> {\n    return this.updateConversation(id, { archived: true });\n  }\n\n  async unarchiveConversation(id: string): Promise<Conversation> {\n    return this.updateConversation(id, { archived: false });\n  }\n\n  async deleteConversation(id: string): Promise<void> {\n    await this.client.delete(`/api/conversations/${id}`);\n  }\n\n  /**\n   * Delete ALL conversations for the current user.\n   * This is a destructive operation - use with caution.\n   * @returns Object with deleted_count and confirmation message\n   */\n  async deleteAllConversations(): Promise<{\n    deleted_count: number;\n    message: string;\n  }> {\n    const response = await this.client.delete<\n      ApiResponse<{ deleted_count: number; message: string }>\n    >(\"/api/conversations/all\");\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Messages\n  // =========================================================================\n\n  async getMessages(\n    conversationId: string,\n    page = 1,\n    pageSize = 50,\n  ): Promise<PaginatedResponse<Message>> {\n    const response = await this.client.get<\n      ApiResponse<{\n        items: Message[];\n        total: number;\n        page: number;\n        pageSize: number;\n      }>\n    >(`/api/conversations/${conversationId}/messages`, {\n      params: { page, pageSize },\n    });\n    const data = response.data.data!;\n    // Transform backend response (total) to frontend format (totalCount, totalPages)\n    return {\n      items: data.items,\n      page: data.page,\n      pageSize: data.pageSize,\n      totalCount: data.total,\n      totalPages: Math.ceil(data.total / data.pageSize),\n    };\n  }\n\n  /**\n   * Send a message to a conversation\n   * @param conversationId - The conversation ID\n   * @param content - The message content\n   * @param options - Optional parameters including idempotency key\n   */\n  async sendMessage(\n    conversationId: string,\n    content: string,\n    options?: {\n      role?: \"user\" | \"assistant\" | \"system\";\n      branchId?: string;\n      parentMessageId?: string;\n      clientMessageId?: string;\n      metadata?: Record<string, any>;\n    },\n  ): Promise<Message & { isDuplicate?: boolean }> {\n    const response = await this.client.post<\n      ApiResponse<Message & { is_duplicate?: boolean }>\n    >(`/api/conversations/${conversationId}/messages`, {\n      content,\n      role: options?.role ?? \"user\",\n      branch_id: options?.branchId,\n      parent_message_id: options?.parentMessageId,\n      client_message_id: options?.clientMessageId,\n      metadata: options?.metadata,\n    });\n    const data = response.data.data!;\n    return {\n      ...data,\n      isDuplicate: data.is_duplicate,\n    };\n  }\n\n  /**\n   * Send an idempotent message to a conversation\n   * Safe to retry - will return existing message if client_message_id already exists\n   * @param conversationId - The conversation ID\n   * @param clientMessageId - Unique client-generated ID for deduplication\n   * @param content - The message content\n   * @param options - Optional parameters\n   */\n  async sendIdempotentMessage(\n    conversationId: string,\n    clientMessageId: string,\n    content: string,\n    options?: {\n      role?: \"user\" | \"assistant\" | \"system\";\n      branchId?: string;\n      parentMessageId?: string;\n      metadata?: Record<string, any>;\n    },\n  ): Promise<Message & { isDuplicate: boolean }> {\n    return this.sendMessage(conversationId, content, {\n      ...options,\n      clientMessageId,\n    }) as Promise<Message & { isDuplicate: boolean }>;\n  }\n\n  async editMessage(\n    conversationId: string,\n    messageId: string,\n    content: string,\n  ): Promise<Message> {\n    const response = await this.client.patch<ApiResponse<Message>>(\n      `/api/conversations/${conversationId}/messages/${messageId}`,\n      { content },\n    );\n    return response.data.data!;\n  }\n\n  async deleteMessage(\n    conversationId: string,\n    messageId: string,\n  ): Promise<void> {\n    await this.client.delete(\n      `/api/conversations/${conversationId}/messages/${messageId}`,\n    );\n  }\n\n  /**\n   * Regenerate a message with custom options\n   * Creates a branch to preserve the original message\n   */\n  async regenerateWithOptions(\n    conversationId: string,\n    messageId: string,\n    options: {\n      temperature?: number;\n      lengthPreference?: \"short\" | \"medium\" | \"detailed\";\n      useClinicalContext?: boolean;\n      createBranch?: boolean;\n      clinicalContextId?: string;\n    },\n  ): Promise<{\n    message: Message;\n    branchId?: string;\n    originalMessageId: string;\n  }> {\n    const response = await this.client.post<\n      ApiResponse<{\n        message: Message;\n        branch_id?: string;\n        original_message_id: string;\n      }>\n    >(`/api/conversations/${conversationId}/messages/${messageId}/regenerate`, {\n      temperature: options.temperature ?? 0.7,\n      length_preference: options.lengthPreference ?? \"medium\",\n      use_clinical_context: options.useClinicalContext ?? false,\n      create_branch: options.createBranch ?? true,\n      clinical_context_id: options.clinicalContextId,\n    });\n    const data = response.data.data!;\n    return {\n      message: data.message,\n      branchId: data.branch_id,\n      originalMessageId: data.original_message_id,\n    };\n  }\n\n  // =========================================================================\n  // Conversation Branching (Phase 2, Week 10)\n  // =========================================================================\n\n  async createBranch(\n    sessionId: string,\n    request: CreateBranchRequest,\n  ): Promise<Branch> {\n    const response = await this.client.post<ApiResponse<Branch>>(\n      `/api/conversations/${sessionId}/branches`,\n      request,\n    );\n    return response.data.data!;\n  }\n\n  async listBranches(sessionId: string): Promise<Branch[]> {\n    const response = await this.client.get<ApiResponse<Branch[]>>(\n      `/api/conversations/${sessionId}/branches`,\n    );\n    return response.data.data!;\n  }\n\n  async getBranchMessages(\n    sessionId: string,\n    branchId: string,\n  ): Promise<Message[]> {\n    const response = await this.client.get<ApiResponse<Message[]>>(\n      `/api/conversations/${sessionId}/branches/${branchId}/messages`,\n    );\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Knowledge Base\n  // =========================================================================\n\n  async searchKnowledgeBase(\n    query: string,\n    limit = 10,\n  ): Promise<SearchResult[]> {\n    const response = await this.client.post<ApiResponse<SearchResult[]>>(\n      \"/kb/search\",\n      { query, limit },\n    );\n    return response.data.data!;\n  }\n\n  async getDocuments(\n    page = 1,\n    pageSize = 20,\n  ): Promise<PaginatedResponse<Document>> {\n    const response = await this.client.get<\n      ApiResponse<PaginatedResponse<Document>>\n    >(\"/kb/documents\", { params: { page, pageSize } });\n    return response.data.data!;\n  }\n\n  async getDocument(id: string): Promise<Document> {\n    const response = await this.client.get<ApiResponse<Document>>(\n      `/kb/documents/${id}`,\n    );\n    return response.data.data!;\n  }\n\n  async uploadDocument(file: File, category: string): Promise<Document> {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    formData.append(\"category\", category);\n\n    const response = await this.client.post<ApiResponse<Document>>(\n      \"/kb/documents\",\n      formData,\n      {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      },\n    );\n    return response.data.data!;\n  }\n\n  async deleteDocument(id: string): Promise<void> {\n    await this.client.delete(`/kb/documents/${id}`);\n  }\n\n  // =========================================================================\n  // Admin\n  // =========================================================================\n\n  async getSystemMetrics(): Promise<SystemMetrics> {\n    const response =\n      await this.client.get<ApiResponse<SystemMetrics>>(\"/admin/metrics\");\n    return response.data.data!;\n  }\n\n  async getAuditLogs(\n    page = 1,\n    pageSize = 50,\n  ): Promise<PaginatedResponse<AuditLogEntry>> {\n    const response = await this.client.get<\n      ApiResponse<PaginatedResponse<AuditLogEntry>>\n    >(\"/admin/audit-logs\", { params: { page, pageSize } });\n    return response.data.data!;\n  }\n\n  async getUsers(page = 1, pageSize = 20): Promise<PaginatedResponse<User>> {\n    const response = await this.client.get<\n      ApiResponse<PaginatedResponse<User>>\n    >(\"/admin/users\", { params: { page, pageSize } });\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Admin Knowledge Base\n  // =========================================================================\n\n  /**\n   * List all documents in the knowledge base (admin only)\n   * @param skip - Number of documents to skip for pagination\n   * @param limit - Maximum number of documents to return\n   * @param sourceType - Optional filter by source type\n   */\n  async getAdminKBDocuments(\n    skip = 0,\n    limit = 50,\n    sourceType?: string,\n  ): Promise<{\n    documents: AdminKBDocument[];\n    total: number;\n  }> {\n    const params: Record<string, unknown> = { skip, limit };\n    if (sourceType) params.source_type = sourceType;\n\n    const response = await this.client.get<\n      ApiResponse<{ documents: AdminKBDocument[]; total: number }>\n    >(\"/admin/kb/documents\", { params });\n    return response.data.data!;\n  }\n\n  /**\n   * Get details for a specific document (admin only)\n   * @param documentId - Document ID\n   */\n  async getAdminKBDocument(documentId: string): Promise<AdminKBDocumentDetail> {\n    const response = await this.client.get<ApiResponse<AdminKBDocumentDetail>>(\n      `/admin/kb/documents/${documentId}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Upload and index a document to the knowledge base (admin only)\n   * @param file - File to upload\n   * @param title - Optional document title (defaults to filename)\n   * @param sourceType - Type of source (e.g., \"uploaded\", \"guideline\", \"journal\")\n   * @param onProgress - Optional progress callback\n   */\n  async uploadAdminKBDocument(\n    file: File,\n    title?: string,\n    sourceType = \"uploaded\",\n    onProgress?: (progress: number) => void,\n  ): Promise<AdminKBUploadResponse> {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (title) formData.append(\"title\", title);\n    formData.append(\"source_type\", sourceType);\n\n    const response = await this.client.post<ApiResponse<AdminKBUploadResponse>>(\n      \"/admin/kb/documents\",\n      formData,\n      {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n        onUploadProgress: (progressEvent) => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(\n              (progressEvent.loaded * 100) / progressEvent.total,\n            );\n            onProgress(percentCompleted);\n          }\n        },\n      },\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Delete a document from the knowledge base (admin only)\n   * @param documentId - Document ID to delete\n   */\n  async deleteAdminKBDocument(\n    documentId: string,\n  ): Promise<{ document_id: string; status: string; message: string }> {\n    const response = await this.client.delete<\n      ApiResponse<{ document_id: string; status: string; message: string }>\n    >(`/admin/kb/documents/${documentId}`);\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Folders\n  // =========================================================================\n\n  async getFolders(parentId?: string | null): Promise<Folder[]> {\n    const params = parentId ? { parent_id: parentId } : undefined;\n    const response = await this.client.get<Folder[]>(\"/api/folders\", {\n      params,\n    });\n    return response.data;\n  }\n\n  async getFolderTree(): Promise<Folder[]> {\n    const response = await this.client.get<Folder[]>(\"/api/folders/tree\");\n    return response.data;\n  }\n\n  async getFolder(id: string): Promise<Folder> {\n    const response = await this.client.get<Folder>(`/api/folders/${id}`);\n    return response.data;\n  }\n\n  async createFolder(request: CreateFolderRequest): Promise<Folder> {\n    const response = await this.client.post<Folder>(\"/api/folders\", request);\n    return response.data;\n  }\n\n  async updateFolder(\n    id: string,\n    request: UpdateFolderRequest,\n  ): Promise<Folder> {\n    const response = await this.client.put<Folder>(\n      `/api/folders/${id}`,\n      request,\n    );\n    return response.data;\n  }\n\n  async deleteFolder(id: string): Promise<void> {\n    await this.client.delete(`/api/folders/${id}`);\n  }\n\n  async moveFolder(folderId: string, targetFolderId: string): Promise<Folder> {\n    const response = await this.client.post<Folder>(\n      `/api/folders/${folderId}/move/${targetFolderId}`,\n    );\n    return response.data;\n  }\n\n  async moveConversationToFolder(\n    conversationId: string,\n    folderId: string | null,\n  ): Promise<Conversation> {\n    return this.updateConversation(conversationId, { folderId });\n  }\n\n  // =========================================================================\n  // Sharing\n  // =========================================================================\n\n  async createShareLink(\n    sessionId: string,\n    request: ShareRequest,\n  ): Promise<ShareResponse> {\n    const response = await this.client.post<ShareResponse>(\n      `/api/sessions/${sessionId}/share`,\n      request,\n    );\n    return response.data;\n  }\n\n  async getSharedConversation(\n    shareToken: string,\n    password?: string,\n  ): Promise<any> {\n    const params = password ? { password } : undefined;\n    const response = await this.client.get(`/api/shared/${shareToken}`, {\n      params,\n    });\n    return response.data;\n  }\n\n  async listShareLinks(sessionId: string): Promise<ShareLink[]> {\n    const response = await this.client.get<ShareLink[]>(\n      `/api/sessions/${sessionId}/shares`,\n    );\n    return response.data;\n  }\n\n  async revokeShareLink(sessionId: string, shareToken: string): Promise<void> {\n    await this.client.delete(`/api/sessions/${sessionId}/share/${shareToken}`);\n  }\n\n  // =========================================================================\n  // Attachments\n  // =========================================================================\n\n  async uploadAttachment(\n    messageId: string,\n    file: File,\n    onProgress?: (progress: number) => void,\n  ): Promise<AttachmentUploadResponse> {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n\n    const response = await this.client.post<AttachmentUploadResponse>(\n      `/api/messages/${messageId}/attachments`,\n      formData,\n      {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n        onUploadProgress: (progressEvent) => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(\n              (progressEvent.loaded * 100) / progressEvent.total,\n            );\n            onProgress(percentCompleted);\n          }\n        },\n      },\n    );\n\n    return response.data;\n  }\n\n  async listAttachments(messageId: string): Promise<Attachment[]> {\n    const response = await this.client.get<Attachment[]>(\n      `/api/messages/${messageId}/attachments`,\n    );\n    return response.data;\n  }\n\n  async deleteAttachment(attachmentId: string): Promise<void> {\n    await this.client.delete(`/api/attachments/${attachmentId}`);\n  }\n\n  async downloadAttachment(attachmentId: string): Promise<Blob> {\n    const response = await this.client.get(\n      `/api/attachments/${attachmentId}/download`,\n      {\n        responseType: \"blob\",\n      },\n    );\n    return response.data;\n  }\n\n  getAttachmentUrl(attachmentId: string): string {\n    return `${this.config.baseURL}/api/attachments/${attachmentId}/download`;\n  }\n\n  // =========================================================================\n  // Clinical Context\n  // =========================================================================\n\n  async createClinicalContext(\n    context: ClinicalContextCreate,\n  ): Promise<ClinicalContext> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.post<ClinicalContext>(\n        \"/api/clinical-contexts\",\n        context,\n      );\n      return response.data;\n    });\n  }\n\n  async getCurrentClinicalContext(\n    sessionId?: string,\n  ): Promise<ClinicalContext> {\n    return this.withRetryIfEnabled(async () => {\n      const params = sessionId ? { session_id: sessionId } : undefined;\n      const response = await this.client.get<ClinicalContext>(\n        \"/api/clinical-contexts/current\",\n        { params },\n      );\n      return response.data;\n    });\n  }\n\n  async getClinicalContext(contextId: string): Promise<ClinicalContext> {\n    const response = await this.client.get<ClinicalContext>(\n      `/api/clinical-contexts/${contextId}`,\n    );\n    return response.data;\n  }\n\n  async updateClinicalContext(\n    contextId: string,\n    update: ClinicalContextUpdate,\n  ): Promise<ClinicalContext> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.put<ClinicalContext>(\n        `/api/clinical-contexts/${contextId}`,\n        update,\n      );\n      return response.data;\n    });\n  }\n\n  async deleteClinicalContext(contextId: string): Promise<void> {\n    await this.client.delete(`/api/clinical-contexts/${contextId}`);\n  }\n\n  // =========================================================================\n  // Clinical Context Presets\n  // =========================================================================\n\n  /**\n   * Get all clinical context presets for the current user\n   * Includes both built-in presets and user-created custom presets\n   */\n  async listClinicalPresets(): Promise<ClinicalContextPreset[]> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.get<ClinicalContextPreset[]>(\n        \"/api/clinical-presets\",\n      );\n      return response.data;\n    });\n  }\n\n  /**\n   * Get a specific clinical context preset by ID\n   */\n  async getClinicalPreset(presetId: string): Promise<ClinicalContextPreset> {\n    const response = await this.client.get<ClinicalContextPreset>(\n      `/api/clinical-presets/${presetId}`,\n    );\n    return response.data;\n  }\n\n  /**\n   * Create a new custom clinical context preset\n   */\n  async createClinicalPreset(\n    preset: ClinicalPresetCreate,\n  ): Promise<ClinicalContextPreset> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.post<ClinicalContextPreset>(\n        \"/api/clinical-presets\",\n        preset,\n      );\n      return response.data;\n    });\n  }\n\n  /**\n   * Update an existing custom clinical context preset\n   * Note: Built-in presets cannot be modified\n   */\n  async updateClinicalPreset(\n    presetId: string,\n    update: ClinicalPresetUpdate,\n  ): Promise<ClinicalContextPreset> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.put<ClinicalContextPreset>(\n        `/api/clinical-presets/${presetId}`,\n        update,\n      );\n      return response.data;\n    });\n  }\n\n  /**\n   * Delete a custom clinical context preset\n   * Note: Built-in presets cannot be deleted\n   */\n  async deleteClinicalPreset(presetId: string): Promise<void> {\n    await this.client.delete(`/api/clinical-presets/${presetId}`);\n  }\n\n  /**\n   * Apply a preset to create or update the current clinical context\n   * Returns the new clinical context\n   */\n  async applyClinicalPreset(\n    presetId: string,\n    sessionId?: string,\n  ): Promise<ClinicalContext> {\n    return this.withRetryIfEnabled(async () => {\n      const response = await this.client.post<ClinicalContext>(\n        `/api/clinical-presets/${presetId}/apply`,\n        { session_id: sessionId },\n      );\n      return response.data;\n    });\n  }\n\n  // =========================================================================\n  // Export\n  // =========================================================================\n\n  /**\n   * Export conversation as Markdown\n   * Returns a Blob that can be downloaded\n   */\n  async exportConversationAsMarkdown(conversationId: string): Promise<Blob> {\n    const response = await this.client.get(\n      `/api/export/sessions/${conversationId}/export/markdown`,\n      {\n        responseType: \"blob\",\n      },\n    );\n    return response.data;\n  }\n\n  /**\n   * Export conversation as PDF\n   * Returns a Blob that can be downloaded\n   */\n  async exportConversationAsPdf(conversationId: string): Promise<Blob> {\n    const response = await this.client.get(\n      `/api/export/sessions/${conversationId}/export/pdf`,\n      {\n        responseType: \"blob\",\n      },\n    );\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Feature Flags\n  // =========================================================================\n\n  async getFeatureFlags(): Promise<FeatureFlag[]> {\n    const response = await this.client.get<FeatureFlag[]>(\n      \"/admin/feature-flags\",\n    );\n    return response.data;\n  }\n\n  async getFeatureFlag(flagName: string): Promise<FeatureFlag> {\n    const response = await this.client.get<FeatureFlag>(\n      `/admin/feature-flags/${flagName}`,\n    );\n    return response.data;\n  }\n\n  async createFeatureFlag(\n    flag: CreateFeatureFlagRequest,\n  ): Promise<FeatureFlag> {\n    const response = await this.client.post<FeatureFlag>(\n      \"/admin/feature-flags\",\n      flag,\n    );\n    return response.data;\n  }\n\n  async updateFeatureFlag(\n    flagName: string,\n    updates: UpdateFeatureFlagRequest,\n  ): Promise<FeatureFlag> {\n    const response = await this.client.patch<FeatureFlag>(\n      `/admin/feature-flags/${flagName}`,\n      updates,\n    );\n    return response.data;\n  }\n\n  async deleteFeatureFlag(flagName: string): Promise<void> {\n    await this.client.delete(`/admin/feature-flags/${flagName}`);\n  }\n\n  async toggleFeatureFlag(flagName: string): Promise<FeatureFlag> {\n    const response = await this.client.post<FeatureFlag>(\n      `/admin/feature-flags/${flagName}/toggle`,\n    );\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Cache Management\n  // =========================================================================\n\n  async getCacheStats(): Promise<CacheStats> {\n    const response = await this.client.get<CacheStats>(\"/admin/cache/stats\");\n    return response.data;\n  }\n\n  async clearCache(): Promise<{ status: string; message: string }> {\n    const response = await this.client.post<{\n      status: string;\n      message: string;\n    }>(\"/admin/cache/clear\");\n    return response.data;\n  }\n\n  async invalidateCachePattern(\n    pattern: string,\n  ): Promise<{ status: string; keys_invalidated: number }> {\n    const response = await this.client.post<{\n      status: string;\n      keys_invalidated: number;\n    }>(\"/admin/cache/invalidate\", null, {\n      params: { pattern },\n    });\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Integrations (Sprint 2)\n  // =========================================================================\n\n  /**\n   * List all integrations with their current status\n   */\n  async getIntegrations(): Promise<IntegrationSummary[]> {\n    const response = await this.client.get<IntegrationSummary[]>(\n      \"/api/admin/integrations/\",\n    );\n    return response.data;\n  }\n\n  /**\n   * Get detailed information about a specific integration\n   * @param integrationId - Integration identifier (e.g., \"postgres\", \"redis\", \"openai\")\n   */\n  async getIntegration(integrationId: string): Promise<IntegrationDetail> {\n    const response = await this.client.get<IntegrationDetail>(\n      `/api/admin/integrations/${integrationId}`,\n    );\n    return response.data;\n  }\n\n  /**\n   * Update configuration for an integration (admin only)\n   * @param integrationId - Integration identifier\n   * @param config - Configuration updates\n   */\n  async updateIntegrationConfig(\n    integrationId: string,\n    config: IntegrationConfigUpdate,\n  ): Promise<IntegrationDetail> {\n    const response = await this.client.patch<IntegrationDetail>(\n      `/api/admin/integrations/${integrationId}/config`,\n      config,\n    );\n    return response.data;\n  }\n\n  /**\n   * Test connectivity for an integration (admin only)\n   * @param integrationId - Integration identifier\n   */\n  async testIntegration(integrationId: string): Promise<IntegrationTestResult> {\n    const response = await this.client.post<IntegrationTestResult>(\n      `/api/admin/integrations/${integrationId}/test`,\n    );\n    return response.data;\n  }\n\n  /**\n   * Get metrics for all integrations\n   */\n  async getIntegrationMetrics(): Promise<IntegrationMetrics[]> {\n    const response = await this.client.get<IntegrationMetrics[]>(\n      \"/api/admin/integrations/metrics/summary\",\n    );\n    return response.data;\n  }\n\n  /**\n   * Get overall health summary of all integrations\n   */\n  async getIntegrationsHealth(): Promise<IntegrationsHealthSummary> {\n    const response = await this.client.get<IntegrationsHealthSummary>(\n      \"/api/admin/integrations/health\",\n    );\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin PHI & Security (Sprint 3)\n  // =========================================================================\n\n  /**\n   * List all PHI detection rules with their current status\n   */\n  async getPHIRules(): Promise<PHIRulesResponse> {\n    const response =\n      await this.client.get<ApiResponse<PHIRulesResponse>>(\"/admin/phi/rules\");\n    return response.data.data!;\n  }\n\n  /**\n   * Get details of a specific PHI detection rule\n   */\n  async getPHIRule(ruleId: string): Promise<PHIRule> {\n    const response = await this.client.get<ApiResponse<PHIRule>>(\n      `/admin/phi/rules/${ruleId}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Update a PHI detection rule (enable/disable)\n   */\n  async updatePHIRule(ruleId: string, update: PHIRuleUpdate): Promise<PHIRule> {\n    const response = await this.client.put<ApiResponse<PHIRule>>(\n      `/admin/phi/rules/${ruleId}`,\n      update,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Test PHI detection on provided text\n   */\n  async testPHIDetection(request: PHITestRequest): Promise<PHITestResult> {\n    const response = await this.client.post<ApiResponse<PHITestResult>>(\n      \"/admin/phi/test\",\n      request,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Redact PHI from provided text\n   */\n  async redactPHI(request: PHITestRequest): Promise<PHIRedactResult> {\n    const response = await this.client.post<ApiResponse<PHIRedactResult>>(\n      \"/admin/phi/redact\",\n      request,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get current PHI routing configuration\n   */\n  async getPHIRouting(): Promise<PHIRoutingConfig> {\n    const response =\n      await this.client.get<ApiResponse<PHIRoutingConfig>>(\n        \"/admin/phi/routing\",\n      );\n    return response.data.data!;\n  }\n\n  /**\n   * Update PHI routing configuration\n   */\n  async updatePHIRouting(update: PHIRoutingUpdate): Promise<PHIRoutingConfig> {\n    const response = await this.client.patch<ApiResponse<PHIRoutingConfig>>(\n      \"/admin/phi/routing\",\n      update,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get PHI detection statistics\n   */\n  async getPHIStats(days: number = 7): Promise<PHIStats> {\n    const response = await this.client.get<ApiResponse<PHIStats>>(\n      `/admin/phi/stats?days=${days}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get recent PHI detection events\n   */\n  async getPHIEvents(\n    limit: number = 50,\n    offset: number = 0,\n  ): Promise<PHIEventsResponse> {\n    const response = await this.client.get<ApiResponse<PHIEventsResponse>>(\n      `/admin/phi/events?limit=${limit}&offset=${offset}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get PHI detection system health status\n   */\n  async getPHIHealth(): Promise<PHIHealthStatus> {\n    const response =\n      await this.client.get<ApiResponse<PHIHealthStatus>>(\"/admin/phi/health\");\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Admin Medical AI (Sprint 4)\n  // =========================================================================\n\n  /**\n   * List all available AI models with their configuration\n   */\n  async getModels(): Promise<ModelInfo[]> {\n    const response = await this.client.get<\n      ApiResponse<{ models: ModelInfo[] }>\n    >(\"/admin/medical/models\");\n    return response.data.data!.models;\n  }\n\n  /**\n   * Get detailed information about a specific model\n   */\n  async getModel(modelId: string): Promise<ModelInfo & { usage_24h?: any }> {\n    const response = await this.client.get<\n      ApiResponse<ModelInfo & { usage_24h?: any }>\n    >(`/admin/medical/models/${modelId}`);\n    return response.data.data!;\n  }\n\n  /**\n   * Get AI model usage metrics and cost tracking\n   */\n  async getModelMetrics(days: number = 1): Promise<ModelUsageMetrics> {\n    const response = await this.client.get<ApiResponse<ModelUsageMetrics>>(\n      `/admin/medical/metrics?days=${days}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get search analytics and statistics\n   */\n  async getSearchStats(days: number = 1): Promise<SearchStats> {\n    const response = await this.client.get<ApiResponse<SearchStats>>(\n      `/admin/medical/search/stats?days=${days}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get embedding database statistics\n   */\n  async getEmbeddingStats(): Promise<EmbeddingStats> {\n    const response = await this.client.get<ApiResponse<EmbeddingStats>>(\n      \"/admin/medical/embeddings/stats\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get current model routing configuration\n   */\n  async getModelRouting(): Promise<ModelRoutingConfig> {\n    const response = await this.client.get<ApiResponse<ModelRoutingConfig>>(\n      \"/admin/medical/routing\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Update model routing configuration\n   */\n  async updateModelRouting(\n    update: ModelRoutingUpdate,\n  ): Promise<{ message: string; updates: ModelRoutingUpdate }> {\n    const response = await this.client.patch<\n      ApiResponse<{ message: string; updates: ModelRoutingUpdate }>\n    >(\"/admin/medical/routing\", update);\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Admin System (Sprint 4)\n  // =========================================================================\n\n  /**\n   * Get system resource metrics (disk, memory, CPU)\n   */\n  async getSystemResources(): Promise<ResourceMetrics> {\n    const response = await this.client.get<ApiResponse<ResourceMetrics>>(\n      \"/admin/system/resources\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get overall system health status\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    const response = await this.client.get<ApiResponse<SystemHealth>>(\n      \"/admin/system/health\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get current backup status and configuration\n   */\n  async getBackupStatus(): Promise<BackupStatus> {\n    const response = await this.client.get<ApiResponse<BackupStatus>>(\n      \"/admin/system/backup/status\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get backup history\n   */\n  async getBackupHistory(\n    limit: number = 10,\n  ): Promise<{ history: BackupHistoryEntry[]; total: number }> {\n    const response = await this.client.get<\n      ApiResponse<{ history: BackupHistoryEntry[]; total: number }>\n    >(`/admin/system/backup/history?limit=${limit}`);\n    return response.data.data!;\n  }\n\n  /**\n   * Trigger a manual backup (admin only)\n   */\n  async triggerBackup(\n    backupType: BackupType = \"full\",\n  ): Promise<BackupTriggerResult> {\n    const response = await this.client.post<ApiResponse<BackupTriggerResult>>(\n      `/admin/system/backup/trigger?backup_type=${backupType}`,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Get current maintenance mode status\n   */\n  async getMaintenanceStatus(): Promise<MaintenanceStatus> {\n    const response = await this.client.get<ApiResponse<MaintenanceStatus>>(\n      \"/admin/system/maintenance\",\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Enable maintenance mode (admin only)\n   */\n  async enableMaintenance(\n    request: MaintenanceRequest,\n  ): Promise<MaintenanceStatus> {\n    const response = await this.client.post<ApiResponse<MaintenanceStatus>>(\n      \"/admin/system/maintenance/enable\",\n      request,\n    );\n    return response.data.data!;\n  }\n\n  /**\n   * Disable maintenance mode (admin only)\n   */\n  async disableMaintenance(): Promise<{\n    enabled: boolean;\n    action: string;\n    disabled_by: string;\n  }> {\n    const response = await this.client.post<\n      ApiResponse<{ enabled: boolean; action: string; disabled_by: string }>\n    >(\"/admin/system/maintenance/disable\");\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Admin Cache Management Enhanced (Sprint 4)\n  // =========================================================================\n\n  /**\n   * Get cache statistics by namespace\n   */\n  async getCacheNamespaces(): Promise<CacheNamespacesResponse> {\n    const response = await this.client.get<\n      ApiResponse<CacheNamespacesResponse>\n    >(\"/admin/cache/stats/namespaces\");\n    return response.data.data!;\n  }\n\n  /**\n   * Invalidate all cache entries in a specific namespace\n   */\n  async invalidateCacheNamespace(\n    namespace: string,\n  ): Promise<CacheInvalidateResult> {\n    const response = await this.client.post<ApiResponse<CacheInvalidateResult>>(\n      \"/admin/cache/invalidate/namespace\",\n      null,\n      { params: { namespace } },\n    );\n    return response.data.data!;\n  }\n\n  // =========================================================================\n  // Admin Conversations\n  // =========================================================================\n\n  /**\n   * List all conversations across all users (admin only)\n   */\n  async getAdminConversations(\n    params: {\n      limit?: number;\n      offset?: number;\n      user_id?: string;\n      search?: string;\n    } = {},\n  ): Promise<{\n    conversations: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/conversations\", {\n      params,\n    });\n    return response.data;\n  }\n\n  /**\n   * Get a specific conversation with details (admin only)\n   */\n  async getAdminConversation(conversationId: string): Promise<{\n    conversation: any;\n  }> {\n    const response = await this.client.get(\n      `/api/admin/conversations/${conversationId}`,\n    );\n    return response.data;\n  }\n\n  /**\n   * Get messages for a conversation (admin only)\n   */\n  async getAdminConversationMessages(\n    conversationId: string,\n    params: { limit?: number; offset?: number } = {},\n  ): Promise<{\n    messages: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\n      `/api/admin/conversations/${conversationId}/messages`,\n      { params },\n    );\n    return response.data;\n  }\n\n  /**\n   * Export a conversation (admin only)\n   */\n  async exportAdminConversation(\n    conversationId: string,\n    format: \"json\" | \"markdown\",\n  ): Promise<{ export: { content: string; format: string } }> {\n    const response = await this.client.post(\n      `/api/admin/conversations/${conversationId}/export`,\n      { format },\n    );\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Clinical Contexts (HIPAA)\n  // =========================================================================\n\n  /**\n   * List all clinical contexts across all users (admin only)\n   * PHI is masked by default - set includePhi=true to access full data (logged for audit)\n   */\n  async getAdminClinicalContexts(\n    params: {\n      limit?: number;\n      offset?: number;\n      user_id?: string;\n      include_phi?: boolean;\n    } = {},\n  ): Promise<{\n    contexts: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/clinical/contexts\", {\n      params,\n    });\n    return response.data;\n  }\n\n  /**\n   * Get a specific clinical context (admin only)\n   * PHI is masked by default - set includePhi=true to access full data (logged for audit)\n   */\n  async getAdminClinicalContext(\n    contextId: string,\n    includePhi: boolean = false,\n  ): Promise<{ context: any }> {\n    const response = await this.client.get(\n      `/api/admin/clinical/contexts/${contextId}`,\n      { params: { include_phi: includePhi } },\n    );\n    return response.data;\n  }\n\n  /**\n   * Get clinical context statistics (admin only)\n   */\n  async getAdminClinicalStats(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/clinical/stats\");\n    return response.data;\n  }\n\n  /**\n   * Get PHI access audit log (admin only)\n   */\n  async getAdminPHIAuditLog(\n    params: {\n      limit?: number;\n      offset?: number;\n      admin_user_id?: string;\n      context_id?: string;\n    } = {},\n  ): Promise<{\n    logs: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/clinical/audit\", {\n      params,\n    });\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Voice & TT Pipeline\n  // =========================================================================\n\n  /**\n   * List all active voice sessions (admin only)\n   */\n  async getAdminVoiceSessions(): Promise<{\n    sessions: any[];\n    total: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/voice/sessions\");\n    return response.data;\n  }\n\n  /**\n   * Get voice metrics (admin only)\n   */\n  async getAdminVoiceMetrics(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/voice/metrics\");\n    return response.data;\n  }\n\n  /**\n   * Get voice health status (admin only)\n   */\n  async getAdminVoiceHealth(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/voice/health\");\n    return response.data;\n  }\n\n  /**\n   * Get voice configuration (admin only)\n   */\n  async getAdminVoiceConfig(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/voice/config\");\n    return response.data;\n  }\n\n  /**\n   * Disconnect a voice session (admin only)\n   */\n  async disconnectAdminVoiceSession(sessionId: string): Promise<void> {\n    await this.client.post(`/api/admin/voice/sessions/${sessionId}/disconnect`);\n  }\n\n  /**\n   * List TT pipeline sessions (admin only)\n   */\n  async getAdminTTSessions(): Promise<{\n    sessions: any[];\n    total: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/voice/tt-sessions\");\n    return response.data;\n  }\n\n  /**\n   * List TT conversation contexts (admin only)\n   */\n  async getAdminTTContexts(): Promise<{\n    contexts: any[];\n    total: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/voice/contexts\");\n    return response.data;\n  }\n\n  /**\n   * Cleanup expired TT contexts (admin only)\n   */\n  async cleanupAdminTTContexts(): Promise<{ cleaned_count: number }> {\n    const response = await this.client.post(\n      \"/api/admin/voice/contexts/cleanup\",\n    );\n    return response.data;\n  }\n\n  /**\n   * Get TT quality presets (admin only)\n   */\n  async getAdminQualityPresets(): Promise<{ presets: any[] }> {\n    const response = await this.client.get(\"/api/admin/voice/quality-presets\");\n    return response.data;\n  }\n\n  /**\n   * Get TT tool analytics (admin only)\n   */\n  async getAdminTTAnalytics(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/voice/analytics/tools\");\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Attachments\n  // =========================================================================\n\n  /**\n   * List all attachments across all users (admin only)\n   */\n  async getAdminAttachments(\n    params: {\n      limit?: number;\n      offset?: number;\n      user_id?: string;\n      file_type?: string;\n    } = {},\n  ): Promise<{\n    attachments: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/attachments\", {\n      params,\n    });\n    return response.data;\n  }\n\n  /**\n   * Get attachment storage statistics (admin only)\n   */\n  async getAdminAttachmentStats(days: number = 30): Promise<any> {\n    const response = await this.client.get(\"/api/admin/attachments/stats\", {\n      params: { days },\n    });\n    return response.data;\n  }\n\n  /**\n   * Delete an attachment (admin only)\n   */\n  async deleteAdminAttachment(attachmentId: string): Promise<void> {\n    await this.client.delete(`/api/admin/attachments/${attachmentId}`);\n  }\n\n  /**\n   * Bulk delete attachments (admin only)\n   */\n  async bulkDeleteAdminAttachments(\n    attachmentIds: string[],\n  ): Promise<{ deleted_count: number }> {\n    const response = await this.client.post(\n      \"/api/admin/attachments/bulk-delete\",\n      { attachment_ids: attachmentIds },\n    );\n    return response.data;\n  }\n\n  /**\n   * Cleanup orphaned attachments (admin only)\n   */\n  async cleanupOrphanedAttachments(): Promise<{ cleaned_count: number }> {\n    const response = await this.client.post(\n      \"/api/admin/attachments/cleanup-orphaned\",\n    );\n    return response.data;\n  }\n\n  // =========================================================================\n  // Admin Folders\n  // =========================================================================\n\n  /**\n   * List all folders across all users (admin only)\n   */\n  async getAdminFolders(\n    params: {\n      limit?: number;\n      offset?: number;\n      user_id?: string;\n    } = {},\n  ): Promise<{\n    folders: any[];\n    total: number;\n    limit: number;\n    offset: number;\n  }> {\n    const response = await this.client.get(\"/api/admin/folders\", { params });\n    return response.data;\n  }\n\n  /**\n   * Get folder statistics (admin only)\n   */\n  async getAdminFolderStats(): Promise<any> {\n    const response = await this.client.get(\"/api/admin/folders/stats\");\n    return response.data;\n  }\n\n  /**\n   * Delete a folder (admin only)\n   */\n  async deleteAdminFolder(\n    folderId: string,\n    recursive: boolean = false,\n  ): Promise<{ deleted_folders: number; orphaned_conversations: number }> {\n    const response = await this.client.delete(\n      `/api/admin/folders/${folderId}`,\n      { params: { recursive } },\n    );\n    return response.data;\n  }\n}\n\n// Default export\nexport default VoiceAssistApiClient;\n"
}
