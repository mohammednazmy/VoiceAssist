{
  "path": "services/api-gateway/app/api/admin_conversations.py",
  "language": "python",
  "size": 24898,
  "last_modified": "2025-12-04T11:26:45.342Z",
  "lines": 739,
  "content": "\"\"\"Admin Conversation Management API endpoints.\n\nProvides admin-level access to view and manage all user conversations\nfor compliance, support, and operational purposes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport json\nimport logging\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional\n\nfrom app.api.admin.utils import log_audit_event\nfrom app.core.api_envelope import ErrorCodes, error_response, success_response\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_admin_or_viewer, get_current_admin_user\nfrom app.models.attachment import MessageAttachment\nfrom app.models.message import Message\nfrom app.models.session import Session as ChatSession\nfrom app.models.user import User\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, status\nfrom fastapi.responses import StreamingResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import desc, func, or_\nfrom sqlalchemy.orm import Session, joinedload\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/conversations\", tags=[\"admin\", \"conversations\"])\n\n\n# ============================================================================\n# Response Schemas\n# ============================================================================\n\n\nclass ConversationAdminResponse(BaseModel):\n    \"\"\"Admin view of a conversation.\"\"\"\n\n    id: str\n    user_id: str\n    user_email: str\n    user_name: Optional[str] = None\n    title: str\n    archived: bool\n    folder_id: Optional[str] = None\n    message_count: int\n    branch_count: int\n    has_attachments: bool\n    created_at: str\n    updated_at: str\n    last_message_at: Optional[str] = None\n\n\nclass MessageAdminResponse(BaseModel):\n    \"\"\"Admin view of a message.\"\"\"\n\n    id: str\n    session_id: str\n    role: str\n    content: str\n    branch_id: Optional[str] = None\n    parent_message_id: Optional[str] = None\n    tool_calls: Optional[Dict] = None\n    tool_results: Optional[Dict] = None\n    contains_phi: bool = False\n    tokens: Optional[int] = None\n    model: Optional[str] = None\n    created_at: str\n    attachments: List[Dict] = Field(default_factory=list)\n\n\nclass ConversationDetailResponse(BaseModel):\n    \"\"\"Detailed conversation with messages.\"\"\"\n\n    conversation: ConversationAdminResponse\n    messages: List[MessageAdminResponse]\n    total_messages: int\n\n\nclass ExportRequest(BaseModel):\n    \"\"\"Request for exporting conversation.\"\"\"\n\n    format: str = Field(default=\"json\", pattern=\"^(json|markdown|csv)$\")\n    include_metadata: bool = True\n\n\n# ============================================================================\n# List All Conversations (Across Users)\n# ============================================================================\n\n\n@router.get(\"\")\nasync def list_admin_conversations(\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin: User = Depends(get_current_admin_or_viewer),\n    offset: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    user_id: Optional[str] = Query(None, description=\"Filter by user ID\"),\n    search: Optional[str] = Query(None, description=\"Search in title or content\"),\n    archived: Optional[bool] = Query(None, description=\"Filter by archived status\"),\n    has_phi: Optional[bool] = Query(None, description=\"Filter conversations containing PHI\"),\n    start_date: Optional[str] = Query(None, description=\"Filter by start date (ISO 8601)\"),\n    end_date: Optional[str] = Query(None, description=\"Filter by end date (ISO 8601)\"),\n) -> Dict:\n    \"\"\"\n    List all conversations across all users with filtering and pagination.\n\n    Admin users can view all conversations for compliance and support purposes.\n    \"\"\"\n    try:\n        # Base query with user join for email\n        query = (\n            db.query(\n                ChatSession,\n                func.count(Message.id).label(\"message_count\"),\n                func.count(func.distinct(Message.branch_id)).label(\"branch_count\"),\n                func.max(Message.created_at).label(\"last_message_at\"),\n                func.bool_or(Message.contains_phi).label(\"has_phi\"),\n                User.email.label(\"user_email\"),\n                User.full_name.label(\"user_name\"),\n            )\n            .join(User, User.id == ChatSession.user_id)\n            .outerjoin(Message, Message.session_id == ChatSession.id)\n            .group_by(ChatSession.id, User.email, User.full_name)\n        )\n\n        # Apply filters\n        if user_id:\n            try:\n                user_uuid = uuid.UUID(user_id)\n                query = query.filter(ChatSession.user_id == user_uuid)\n            except ValueError:\n                return error_response(\n                    error_code=ErrorCodes.VALIDATION_ERROR,\n                    message=\"Invalid user_id format\",\n                    trace_id=getattr(request.state, \"trace_id\", None),\n                )\n\n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                or_(\n                    ChatSession.title.ilike(search_term),\n                    User.email.ilike(search_term),\n                )\n            )\n\n        if archived is not None:\n            query = query.filter(ChatSession.archived == (1 if archived else 0))\n\n        if start_date:\n            try:\n                start_dt = datetime.fromisoformat(start_date.replace(\"Z\", \"+00:00\"))\n                query = query.filter(ChatSession.created_at >= start_dt)\n            except ValueError:\n                pass\n\n        if end_date:\n            try:\n                end_dt = datetime.fromisoformat(end_date.replace(\"Z\", \"+00:00\"))\n                query = query.filter(ChatSession.created_at <= end_dt)\n            except ValueError:\n                pass\n\n        # Get total count (before pagination)\n        total_query = query.with_entities(func.count(func.distinct(ChatSession.id)))\n        total = total_query.scalar() or 0\n\n        # Apply ordering and pagination\n        results = query.order_by(desc(ChatSession.updated_at)).offset(offset).limit(limit).all()\n\n        # Check for attachments in a separate query\n        session_ids = [r[0].id for r in results]\n        attachments_query = (\n            db.query(Message.session_id)\n            .join(MessageAttachment, MessageAttachment.message_id == Message.id)\n            .filter(Message.session_id.in_(session_ids))\n            .distinct()\n        )\n        sessions_with_attachments = {r[0] for r in attachments_query.all()}\n\n        # Build response\n        conversations = []\n        for row in results:\n            session = row[0]\n            message_count = row[1] or 0\n            branch_count = row[2] or 1\n            last_message_at = row[3]\n            session_has_phi = row[4] or False\n            user_email = row[5]\n            user_name = row[6]\n\n            # Apply PHI filter if specified\n            if has_phi is not None and session_has_phi != has_phi:\n                continue\n\n            conversations.append(\n                ConversationAdminResponse(\n                    id=str(session.id),\n                    user_id=str(session.user_id),\n                    user_email=user_email,\n                    user_name=user_name,\n                    title=session.title or \"Untitled Conversation\",\n                    archived=bool(session.archived),\n                    folder_id=str(session.folder_id) if session.folder_id else None,\n                    message_count=message_count,\n                    branch_count=branch_count,\n                    has_attachments=session.id in sessions_with_attachments,\n                    created_at=(session.created_at.isoformat() + \"Z\" if session.created_at else \"\"),\n                    updated_at=(session.updated_at.isoformat() + \"Z\" if session.updated_at else \"\"),\n                    last_message_at=(last_message_at.isoformat() + \"Z\" if last_message_at else None),\n                ).model_dump()\n            )\n\n        trace_id = getattr(request.state, \"trace_id\", None)\n        return success_response(\n            {\n                \"conversations\": conversations,\n                \"total\": total,\n                \"offset\": offset,\n                \"limit\": limit,\n            },\n            trace_id=trace_id,\n        )\n\n    except Exception as e:\n        logger.exception(\"Error listing admin conversations\")\n        return error_response(\n            error_code=ErrorCodes.INTERNAL_ERROR,\n            message=str(e),\n            trace_id=getattr(request.state, \"trace_id\", None),\n        )\n\n\n# ============================================================================\n# Get Conversation Detail\n# ============================================================================\n\n\n@router.get(\"/{conversation_id}\")\nasync def get_admin_conversation(\n    conversation_id: str,\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin: User = Depends(get_current_admin_or_viewer),\n) -> Dict:\n    \"\"\"\n    Get detailed view of a specific conversation including all messages.\n\n    Admin users can view any conversation for compliance and support purposes.\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        return error_response(\n            error_code=ErrorCodes.VALIDATION_ERROR,\n            message=\"Invalid conversation ID format\",\n            trace_id=getattr(request.state, \"trace_id\", None),\n        )\n\n    # Get conversation with user info\n    result = (\n        db.query(ChatSession, User.email, User.full_name)\n        .join(User, User.id == ChatSession.user_id)\n        .filter(ChatSession.id == conv_uuid)\n        .first()\n    )\n\n    if not result:\n        return error_response(\n            error_code=ErrorCodes.NOT_FOUND,\n            message=\"Conversation not found\",\n            trace_id=getattr(request.state, \"trace_id\", None),\n        )\n\n    session, user_email, user_name = result\n\n    # Get all messages with attachments\n    messages = (\n        db.query(Message)\n        .options(joinedload(Message.attachments))\n        .filter(Message.session_id == conv_uuid)\n        .order_by(Message.created_at)\n        .all()\n    )\n\n    # Count branches and check for attachments\n    branch_ids = set()\n    has_attachments = False\n    has_phi = False\n\n    message_responses = []\n    for msg in messages:\n        if msg.branch_id:\n            branch_ids.add(msg.branch_id)\n        if msg.attachments:\n            has_attachments = True\n        if msg.contains_phi:\n            has_phi = True\n\n        attachments = []\n        for att in msg.attachments:\n            attachments.append(\n                {\n                    \"id\": str(att.id),\n                    \"file_name\": att.file_name,\n                    \"file_type\": att.file_type,\n                    \"file_size\": att.file_size,\n                }\n            )\n\n        message_responses.append(\n            MessageAdminResponse(\n                id=str(msg.id),\n                session_id=str(msg.session_id),\n                role=msg.role,\n                content=msg.content,\n                branch_id=msg.branch_id,\n                parent_message_id=(str(msg.parent_message_id) if msg.parent_message_id else None),\n                tool_calls=msg.tool_calls,\n                tool_results=msg.tool_results,\n                contains_phi=msg.contains_phi,\n                tokens=msg.tokens,\n                model=msg.model,\n                created_at=msg.created_at.isoformat() + \"Z\" if msg.created_at else \"\",\n                attachments=attachments,\n            ).model_dump()\n        )\n\n    conversation = ConversationAdminResponse(\n        id=str(session.id),\n        user_id=str(session.user_id),\n        user_email=user_email,\n        user_name=user_name,\n        title=session.title or \"Untitled Conversation\",\n        archived=bool(session.archived),\n        folder_id=str(session.folder_id) if session.folder_id else None,\n        message_count=len(messages),\n        branch_count=max(1, len(branch_ids)),\n        has_attachments=has_attachments,\n        created_at=session.created_at.isoformat() + \"Z\" if session.created_at else \"\",\n        updated_at=session.updated_at.isoformat() + \"Z\" if session.updated_at else \"\",\n        last_message_at=messages[-1].created_at.isoformat() + \"Z\" if messages else None,\n    )\n\n    # Log audit event for viewing conversation\n    await log_audit_event(\n        db=db,\n        admin_user=current_admin,\n        action=\"view_conversation\",\n        resource_type=\"conversation\",\n        resource_id=conversation_id,\n        details={\"user_email\": user_email, \"contains_phi\": has_phi},\n    )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        {\n            \"conversation\": conversation.model_dump(),\n            \"messages\": message_responses,\n            \"total_messages\": len(messages),\n        },\n        trace_id=trace_id,\n    )\n\n\n# ============================================================================\n# Get Conversation Messages (Paginated)\n# ============================================================================\n\n\n@router.get(\"/{conversation_id}/messages\")\nasync def get_admin_conversation_messages(\n    conversation_id: str,\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin: User = Depends(get_current_admin_or_viewer),\n    offset: int = Query(0, ge=0),\n    limit: int = Query(50, ge=1, le=200),\n    branch_id: Optional[str] = Query(None, description=\"Filter by branch ID\"),\n) -> Dict:\n    \"\"\"\n    Get paginated messages for a specific conversation.\n\n    Supports filtering by branch for branched conversations.\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        return error_response(\n            error_code=ErrorCodes.VALIDATION_ERROR,\n            message=\"Invalid conversation ID format\",\n            trace_id=getattr(request.state, \"trace_id\", None),\n        )\n\n    # Verify conversation exists\n    session = db.query(ChatSession).filter(ChatSession.id == conv_uuid).first()\n    if not session:\n        return error_response(\n            error_code=ErrorCodes.NOT_FOUND,\n            message=\"Conversation not found\",\n            trace_id=getattr(request.state, \"trace_id\", None),\n        )\n\n    # Build query\n    query = db.query(Message).filter(Message.session_id == conv_uuid)\n\n    if branch_id:\n        query = query.filter(Message.branch_id == branch_id)\n\n    total = query.count()\n    messages = (\n        query.options(joinedload(Message.attachments)).order_by(Message.created_at).offset(offset).limit(limit).all()\n    )\n\n    message_responses = []\n    for msg in messages:\n        attachments = [\n            {\n                \"id\": str(att.id),\n                \"file_name\": att.file_name,\n                \"file_type\": att.file_type,\n                \"file_size\": att.file_size,\n            }\n            for att in msg.attachments\n        ]\n\n        message_responses.append(\n            MessageAdminResponse(\n                id=str(msg.id),\n                session_id=str(msg.session_id),\n                role=msg.role,\n                content=msg.content,\n                branch_id=msg.branch_id,\n                parent_message_id=(str(msg.parent_message_id) if msg.parent_message_id else None),\n                tool_calls=msg.tool_calls,\n                tool_results=msg.tool_results,\n                contains_phi=msg.contains_phi,\n                tokens=msg.tokens,\n                model=msg.model,\n                created_at=msg.created_at.isoformat() + \"Z\" if msg.created_at else \"\",\n                attachments=attachments,\n            ).model_dump()\n        )\n\n    trace_id = getattr(request.state, \"trace_id\", None)\n    return success_response(\n        {\n            \"messages\": message_responses,\n            \"total\": total,\n            \"offset\": offset,\n            \"limit\": limit,\n        },\n        trace_id=trace_id,\n    )\n\n\n# ============================================================================\n# Export Conversation\n# ============================================================================\n\n\n@router.post(\"/{conversation_id}/export\")\nasync def export_admin_conversation(\n    conversation_id: str,\n    export_request: ExportRequest,\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin: User = Depends(get_current_admin_user),\n) -> StreamingResponse:\n    \"\"\"\n    Export a conversation for compliance or legal purposes.\n\n    Supports JSON, Markdown, and CSV formats.\n    \"\"\"\n    try:\n        conv_uuid = uuid.UUID(conversation_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid conversation ID format\",\n        )\n\n    # Get conversation with user info\n    result = (\n        db.query(ChatSession, User.email, User.full_name)\n        .join(User, User.id == ChatSession.user_id)\n        .filter(ChatSession.id == conv_uuid)\n        .first()\n    )\n\n    if not result:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Conversation not found\",\n        )\n\n    session, user_email, user_name = result\n\n    # Get all messages\n    messages = (\n        db.query(Message)\n        .options(joinedload(Message.attachments))\n        .filter(Message.session_id == conv_uuid)\n        .order_by(Message.created_at)\n        .all()\n    )\n\n    # Log audit event\n    await log_audit_event(\n        db=db,\n        admin_user=current_admin,\n        action=\"export_conversation\",\n        resource_type=\"conversation\",\n        resource_id=conversation_id,\n        details={\"format\": export_request.format, \"user_email\": user_email},\n    )\n\n    # Generate export based on format\n    if export_request.format == \"json\":\n        content = _export_json(session, messages, user_email, user_name, export_request.include_metadata)\n        media_type = \"application/json\"\n        filename = f\"conversation_{conversation_id}.json\"\n    elif export_request.format == \"markdown\":\n        content = _export_markdown(session, messages, user_email, user_name, export_request.include_metadata)\n        media_type = \"text/markdown\"\n        filename = f\"conversation_{conversation_id}.md\"\n    else:  # csv\n        content = _export_csv(session, messages, user_email, export_request.include_metadata)\n        media_type = \"text/csv\"\n        filename = f\"conversation_{conversation_id}.csv\"\n\n    return StreamingResponse(\n        io.BytesIO(content.encode(\"utf-8\")),\n        media_type=media_type,\n        headers={\"Content-Disposition\": f'attachment; filename=\"{filename}\"'},\n    )\n\n\ndef _export_json(session, messages, user_email, user_name, include_metadata):\n    \"\"\"Export conversation as JSON.\"\"\"\n    data = {\n        \"conversation\": {\n            \"id\": str(session.id),\n            \"title\": session.title or \"Untitled Conversation\",\n            \"user_email\": user_email,\n            \"user_name\": user_name,\n            \"created_at\": (session.created_at.isoformat() + \"Z\" if session.created_at else None),\n            \"updated_at\": (session.updated_at.isoformat() + \"Z\" if session.updated_at else None),\n        },\n        \"messages\": [],\n        \"exported_at\": datetime.now(timezone.utc).isoformat() + \"Z\",\n    }\n\n    for msg in messages:\n        msg_data = {\n            \"role\": msg.role,\n            \"content\": msg.content,\n            \"created_at\": msg.created_at.isoformat() + \"Z\" if msg.created_at else None,\n        }\n        if include_metadata:\n            msg_data.update(\n                {\n                    \"id\": str(msg.id),\n                    \"branch_id\": msg.branch_id,\n                    \"tokens\": msg.tokens,\n                    \"model\": msg.model,\n                    \"contains_phi\": msg.contains_phi,\n                    \"tool_calls\": msg.tool_calls,\n                }\n            )\n        data[\"messages\"].append(msg_data)\n\n    return json.dumps(data, indent=2)\n\n\ndef _export_markdown(session, messages, user_email, user_name, include_metadata):\n    \"\"\"Export conversation as Markdown.\"\"\"\n    lines = [\n        f\"# {session.title or 'Untitled Conversation'}\",\n        \"\",\n        f\"**User:** {user_name or user_email}\",\n        f\"**Date:** {session.created_at.strftime('%Y-%m-%d %H:%M UTC') if session.created_at else 'N/A'}\",\n        \"\",\n        \"---\",\n        \"\",\n    ]\n\n    for msg in messages:\n        role_label = {\n            \"user\": \"User\",\n            \"assistant\": \"Assistant\",\n            \"system\": \"System\",\n            \"tool\": \"Tool\",\n        }.get(msg.role, msg.role.title())\n        lines.append(f\"### {role_label}\")\n        if include_metadata:\n            lines.append(f\"*{msg.created_at.strftime('%Y-%m-%d %H:%M:%S UTC') if msg.created_at else 'N/A'}*\")\n        lines.append(\"\")\n        lines.append(msg.content)\n        lines.append(\"\")\n\n    lines.append(\"---\")\n    lines.append(f\"*Exported at {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}*\")\n\n    return \"\\n\".join(lines)\n\n\ndef _export_csv(session, messages, user_email, include_metadata):\n    \"\"\"Export conversation as CSV.\"\"\"\n    import csv\n\n    output = io.StringIO()\n    fieldnames = [\"timestamp\", \"role\", \"content\"]\n    if include_metadata:\n        fieldnames.extend([\"message_id\", \"branch_id\", \"tokens\", \"model\", \"contains_phi\"])\n\n    writer = csv.DictWriter(output, fieldnames=fieldnames)\n    writer.writeheader()\n\n    for msg in messages:\n        row = {\n            \"timestamp\": msg.created_at.isoformat() if msg.created_at else \"\",\n            \"role\": msg.role,\n            \"content\": msg.content.replace(\"\\n\", \"\\\\n\"),\n        }\n        if include_metadata:\n            row.update(\n                {\n                    \"message_id\": str(msg.id),\n                    \"branch_id\": msg.branch_id or \"\",\n                    \"tokens\": msg.tokens or \"\",\n                    \"model\": msg.model or \"\",\n                    \"contains_phi\": str(msg.contains_phi),\n                }\n            )\n        writer.writerow(row)\n\n    return output.getvalue()\n\n\n# ============================================================================\n# Bulk Export User Conversations\n# ============================================================================\n\n\n@router.post(\"/users/{user_id}/export\")\nasync def export_user_conversations(\n    user_id: str,\n    export_request: ExportRequest,\n    request: Request,\n    db: Session = Depends(get_db),\n    current_admin: User = Depends(get_current_admin_user),\n) -> StreamingResponse:\n    \"\"\"\n    Export all conversations for a specific user.\n\n    Used for compliance, legal requests, or data portability.\n    \"\"\"\n    try:\n        user_uuid = uuid.UUID(user_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid user ID format\",\n        )\n\n    # Get user\n    user = db.query(User).filter(User.id == user_uuid).first()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\",\n        )\n\n    # Get all conversations\n    sessions = db.query(ChatSession).filter(ChatSession.user_id == user_uuid).order_by(ChatSession.created_at).all()\n\n    # Log audit event\n    await log_audit_event(\n        db=db,\n        admin_user=current_admin,\n        action=\"bulk_export_user_conversations\",\n        resource_type=\"user\",\n        resource_id=user_id,\n        details={\n            \"format\": export_request.format,\n            \"conversation_count\": len(sessions),\n            \"user_email\": user.email,\n        },\n    )\n\n    # Export all conversations\n    all_data = {\n        \"user\": {\n            \"id\": str(user.id),\n            \"email\": user.email,\n            \"name\": user.full_name,\n        },\n        \"conversations\": [],\n        \"exported_at\": datetime.now(timezone.utc).isoformat() + \"Z\",\n        \"total_conversations\": len(sessions),\n    }\n\n    for session in sessions:\n        messages = db.query(Message).filter(Message.session_id == session.id).order_by(Message.created_at).all()\n\n        conv_data = {\n            \"id\": str(session.id),\n            \"title\": session.title or \"Untitled Conversation\",\n            \"created_at\": (session.created_at.isoformat() + \"Z\" if session.created_at else None),\n            \"messages\": [],\n        }\n\n        for msg in messages:\n            conv_data[\"messages\"].append(\n                {\n                    \"role\": msg.role,\n                    \"content\": msg.content,\n                    \"created_at\": (msg.created_at.isoformat() + \"Z\" if msg.created_at else None),\n                }\n            )\n\n        all_data[\"conversations\"].append(conv_data)\n\n    content = json.dumps(all_data, indent=2)\n    filename = f\"user_{user_id}_conversations.json\"\n\n    return StreamingResponse(\n        io.BytesIO(content.encode(\"utf-8\")),\n        media_type=\"application/json\",\n        headers={\"Content-Disposition\": f'attachment; filename=\"{filename}\"'},\n    )\n"
}
