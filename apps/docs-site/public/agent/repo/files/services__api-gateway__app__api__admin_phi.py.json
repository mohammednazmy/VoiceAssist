{
  "path": "services/api-gateway/app/api/admin_phi.py",
  "language": "python",
  "size": 21105,
  "last_modified": "2025-12-04T11:26:46.035Z",
  "lines": 677,
  "content": "\"\"\"Admin PHI & Security API endpoints (Sprint 3).\n\nProvides comprehensive PHI (Protected Health Information) management for the Admin Panel:\n- PHI detection rule configuration\n- PHI detection testing and preview\n- Detection statistics and audit logs\n- Routing configuration (local vs cloud for PHI-containing queries)\n\nHIPAA Compliance: This module allows admins to configure and monitor PHI handling\nto ensure compliance with HIPAA regulations. All actions are audit logged.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nfrom app.core.api_envelope import error_response, success_response\nfrom app.core.database import get_db, redis_client\nfrom app.core.dependencies import get_current_admin_user\nfrom app.middleware.phi_redaction import PHI_PATTERNS, redact_phi\nfrom app.models.audit_log import AuditLog\nfrom app.services.phi_detector import PHIDetector\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import desc, func\nfrom sqlalchemy.orm import Session\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(prefix=\"/api/admin/phi\", tags=[\"admin\", \"phi\", \"security\"])\n\n# Redis keys for PHI configuration\nREDIS_PHI_RULES_KEY = \"voiceassist:phi:rules\"\nREDIS_PHI_ROUTING_KEY = \"voiceassist:phi:routing\"\nREDIS_PHI_STATS_KEY = \"voiceassist:phi:stats\"\n\n# Global PHI detector instance\n_phi_detector = PHIDetector()\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass PHIRuleStatus(str, Enum):\n    \"\"\"Status of a PHI detection rule.\"\"\"\n\n    ENABLED = \"enabled\"\n    DISABLED = \"disabled\"\n\n\nclass PHIRuleType(str, Enum):\n    \"\"\"Type of PHI that a rule detects.\"\"\"\n\n    SSN = \"ssn\"\n    PHONE = \"phone\"\n    EMAIL = \"email\"\n    MRN = \"mrn\"\n    ACCOUNT = \"account\"\n    IP_ADDRESS = \"ip_address\"\n    URL = \"url\"\n    DOB = \"dob\"\n    NAME = \"name\"\n    ADDRESS = \"address\"\n    CREDIT_CARD = \"credit_card\"\n\n\nclass PHIRoutingMode(str, Enum):\n    \"\"\"Routing mode when PHI is detected.\"\"\"\n\n    LOCAL_ONLY = \"local_only\"  # Always use local LLM for PHI queries\n    CLOUD_ALLOWED = \"cloud_allowed\"  # Allow cloud with redaction\n    HYBRID = \"hybrid\"  # Local for high-confidence, cloud for low\n\n\nclass PHIRule(BaseModel):\n    \"\"\"PHI detection rule configuration.\"\"\"\n\n    id: str\n    name: str\n    description: str\n    phi_type: PHIRuleType\n    status: PHIRuleStatus = PHIRuleStatus.ENABLED\n    pattern: Optional[str] = None  # Regex pattern (read-only for built-in rules)\n    is_builtin: bool = True\n    detection_count: int = 0\n    last_detection: Optional[str] = None\n\n\nclass PHIRuleUpdate(BaseModel):\n    \"\"\"Update a PHI detection rule.\"\"\"\n\n    status: PHIRuleStatus\n\n\nclass PHITestRequest(BaseModel):\n    \"\"\"Request to test PHI detection.\"\"\"\n\n    text: str = Field(..., min_length=1, max_length=10000)\n    include_redacted: bool = True\n\n\nclass PHITestResult(BaseModel):\n    \"\"\"Result of PHI detection test.\"\"\"\n\n    contains_phi: bool\n    phi_types: List[str]\n    confidence: float\n    details: Dict[str, Any]\n    redacted_text: Optional[str] = None\n\n\nclass PHIRoutingConfig(BaseModel):\n    \"\"\"PHI routing configuration.\"\"\"\n\n    mode: PHIRoutingMode = PHIRoutingMode.LOCAL_ONLY\n    confidence_threshold: float = Field(0.7, ge=0.0, le=1.0)\n    local_llm_enabled: bool = False\n    local_llm_url: Optional[str] = None\n    redact_before_cloud: bool = True\n    audit_all_phi: bool = True\n\n\nclass PHIRoutingUpdate(BaseModel):\n    \"\"\"Update PHI routing configuration.\"\"\"\n\n    mode: Optional[PHIRoutingMode] = None\n    confidence_threshold: Optional[float] = Field(None, ge=0.0, le=1.0)\n    redact_before_cloud: Optional[bool] = None\n    audit_all_phi: Optional[bool] = None\n\n\nclass PHIStats(BaseModel):\n    \"\"\"PHI detection statistics.\"\"\"\n\n    total_detections: int\n    detections_today: int\n    detections_this_week: int\n    by_type: Dict[str, int]\n    by_day: List[Dict[str, Any]]\n    routing_stats: Dict[str, int]\n\n\nclass PHIEvent(BaseModel):\n    \"\"\"A PHI detection event.\"\"\"\n\n    id: str\n    timestamp: str\n    phi_types: List[str]\n    confidence: float\n    action_taken: str  # e.g., \"routed_local\", \"redacted_cloud\", \"blocked\"\n    user_id: Optional[str] = None\n    session_id: Optional[str] = None\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\n\ndef get_builtin_rules() -> List[PHIRule]:\n    \"\"\"Get all built-in PHI detection rules.\"\"\"\n    rules = []\n\n    # Pattern-based rules from PHI_PATTERNS\n    pattern_descriptions = {\n        \"ssn\": (\n            \"Social Security Number\",\n            \"Detects SSN in xxx-xx-xxxx or xxxxxxxxx format\",\n        ),\n        \"phone\": (\"Phone Number\", \"Detects US phone numbers in various formats\"),\n        \"email\": (\"Email Address\", \"Detects email addresses\"),\n        \"mrn\": (\"Medical Record Number\", \"Detects MRN patterns with labels\"),\n        \"account\": (\"Account Number\", \"Detects account numbers with labels\"),\n        \"ip_address\": (\"IP Address\", \"Detects IPv4 addresses\"),\n        \"url\": (\"URL\", \"Detects HTTP/HTTPS URLs\"),\n        \"dob\": (\"Date of Birth\", \"Detects DOB with context keywords\"),\n        \"credit_card\": (\"Credit Card Number\", \"Detects credit card numbers\"),\n        \"address\": (\"Street Address\", \"Detects street addresses\"),\n    }\n\n    for phi_type, (name, description) in pattern_descriptions.items():\n        # Get pattern if it exists\n        pattern = None\n        if phi_type in PHI_PATTERNS:\n            pattern = PHI_PATTERNS[phi_type].pattern\n\n        rules.append(\n            PHIRule(\n                id=f\"builtin_{phi_type}\",\n                name=name,\n                description=description,\n                phi_type=(PHIRuleType(phi_type) if phi_type in [t.value for t in PHIRuleType] else PHIRuleType.SSN),\n                pattern=pattern,\n                is_builtin=True,\n            )\n        )\n\n    # Add name detection rule (uses different pattern)\n    rules.append(\n        PHIRule(\n            id=\"builtin_name\",\n            name=\"Personal Name\",\n            description=\"Detects potential personal names (capitalized word pairs)\",\n            phi_type=PHIRuleType.NAME,\n            pattern=r\"\\b[A-Z][a-z]+ [A-Z][a-z]+\\b\",\n            is_builtin=True,\n        )\n    )\n\n    return rules\n\n\ndef get_rule_status(rule_id: str) -> PHIRuleStatus:\n    \"\"\"Get the status of a rule from Redis.\"\"\"\n    try:\n        status = redis_client.hget(REDIS_PHI_RULES_KEY, rule_id)\n        if status:\n            return PHIRuleStatus(status)\n    except Exception as e:\n        logger.warning(f\"Failed to get rule status from Redis: {e}\")\n    return PHIRuleStatus.ENABLED\n\n\ndef set_rule_status(rule_id: str, status: PHIRuleStatus) -> None:\n    \"\"\"Set the status of a rule in Redis.\"\"\"\n    try:\n        redis_client.hset(REDIS_PHI_RULES_KEY, rule_id, status.value)\n    except Exception as e:\n        logger.error(f\"Failed to set rule status in Redis: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to update rule status\")\n\n\ndef get_routing_config() -> PHIRoutingConfig:\n    \"\"\"Get PHI routing configuration from Redis.\"\"\"\n    try:\n        config_str = redis_client.get(REDIS_PHI_ROUTING_KEY)\n        if config_str:\n            import json\n\n            config_dict = json.loads(config_str)\n            return PHIRoutingConfig(**config_dict)\n    except Exception as e:\n        logger.warning(f\"Failed to get routing config from Redis: {e}\")\n    return PHIRoutingConfig()\n\n\ndef set_routing_config(config: PHIRoutingConfig) -> None:\n    \"\"\"Set PHI routing configuration in Redis.\"\"\"\n    try:\n        import json\n\n        redis_client.set(REDIS_PHI_ROUTING_KEY, json.dumps(config.model_dump()))\n    except Exception as e:\n        logger.error(f\"Failed to set routing config in Redis: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to update routing config\")\n\n\ndef increment_detection_stat(phi_type: str) -> None:\n    \"\"\"Increment detection statistics in Redis.\"\"\"\n    try:\n        today = datetime.now(timezone.utc).strftime(\"%Y-%m-%d\")\n        redis_client.hincrby(f\"{REDIS_PHI_STATS_KEY}:total\", phi_type, 1)\n        redis_client.hincrby(f\"{REDIS_PHI_STATS_KEY}:daily:{today}\", phi_type, 1)\n        redis_client.hincrby(f\"{REDIS_PHI_STATS_KEY}:total\", \"all\", 1)\n    except Exception as e:\n        logger.warning(f\"Failed to increment detection stat: {e}\")\n\n\ndef log_phi_detection_audit(\n    db: Session,\n    phi_types: List[str],\n    action: str,\n    user_id: Optional[str] = None,\n    details: Optional[Dict] = None,\n) -> None:\n    \"\"\"Log PHI detection to audit log.\"\"\"\n    try:\n        # Note: AuditLog model uses 'additional_data' not 'details'\n        audit_entry = AuditLog(\n            action=\"phi_detection\",\n            resource_type=\"phi\",\n            resource_id=None,\n            user_id=user_id,\n            additional_data={\n                \"phi_types\": phi_types,\n                \"action_taken\": action,\n                **(details or {}),\n            },\n            ip_address=None,\n            success=True,\n            service_name=\"api-gateway\",\n            hash=\"\",  # Will be calculated\n        )\n        # Calculate integrity hash\n        audit_entry.hash = audit_entry.calculate_hash()\n        db.add(audit_entry)\n        db.commit()\n    except Exception as e:\n        logger.error(f\"Failed to log PHI detection audit: {e}\")\n        db.rollback()\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n\n@router.get(\"/rules\")\nasync def list_phi_rules(\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"List all PHI detection rules with their status.\n\n    Returns both built-in rules and any custom rules.\n    \"\"\"\n    rules = get_builtin_rules()\n\n    # Apply status from Redis\n    for rule in rules:\n        rule.status = get_rule_status(rule.id)\n\n    return success_response(\n        data={\n            \"rules\": [rule.model_dump() for rule in rules],\n            \"total\": len(rules),\n            \"enabled\": sum(1 for r in rules if r.status == PHIRuleStatus.ENABLED),\n        }\n    )\n\n\n@router.get(\"/rules/{rule_id}\")\nasync def get_phi_rule(\n    rule_id: str,\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"Get details of a specific PHI detection rule.\"\"\"\n    rules = get_builtin_rules()\n    rule = next((r for r in rules if r.id == rule_id), None)\n\n    if not rule:\n        raise HTTPException(status_code=404, detail=f\"Rule '{rule_id}' not found\")\n\n    rule.status = get_rule_status(rule.id)\n\n    return success_response(data=rule.model_dump())\n\n\n@router.put(\"/rules/{rule_id}\")\nasync def update_phi_rule(\n    rule_id: str,\n    update: PHIRuleUpdate,\n    admin_user=Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Update a PHI detection rule (enable/disable).\n\n    Built-in rules can only be enabled or disabled, not modified.\n    \"\"\"\n    rules = get_builtin_rules()\n    rule = next((r for r in rules if r.id == rule_id), None)\n\n    if not rule:\n        raise HTTPException(status_code=404, detail=f\"Rule '{rule_id}' not found\")\n\n    # Update status\n    set_rule_status(rule_id, update.status)\n    rule.status = update.status\n\n    # Audit log\n    log_phi_detection_audit(\n        db,\n        phi_types=[rule.phi_type.value],\n        action=f\"rule_{update.status.value}\",\n        user_id=str(admin_user.id) if admin_user else None,\n        details={\"rule_id\": rule_id},\n    )\n\n    logger.info(f\"PHI rule '{rule_id}' updated to {update.status.value} by admin\")\n\n    return success_response(\n        data=rule.model_dump(),\n        message=f\"Rule '{rule.name}' has been {update.status.value}\",\n    )\n\n\n@router.post(\"/test\")\nasync def test_phi_detection(\n    request: PHITestRequest,\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"Test PHI detection on provided text.\n\n    This endpoint allows admins to test the PHI detection system\n    without affecting any user data or statistics.\n    \"\"\"\n    # Run detection\n    result = _phi_detector.detect(request.text)\n\n    # Optionally get redacted text\n    redacted_text = None\n    if request.include_redacted and result.contains_phi:\n        redacted_text = _phi_detector.sanitize(request.text)\n\n    return success_response(\n        data=PHITestResult(\n            contains_phi=result.contains_phi,\n            phi_types=result.phi_types,\n            confidence=result.confidence,\n            details=result.details,\n            redacted_text=redacted_text,\n        ).model_dump()\n    )\n\n\n@router.post(\"/redact\")\nasync def redact_phi_text(\n    request: PHITestRequest,\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"Redact PHI from provided text.\n\n    Returns the text with all detected PHI replaced with redaction markers.\n    \"\"\"\n    redacted = redact_phi(request.text)\n    original_length = len(request.text)\n    redacted_length = len(redacted)\n\n    # Count redactions\n    redaction_count = redacted.count(\"[REDACTED]\")\n\n    return success_response(\n        data={\n            \"original_length\": original_length,\n            \"redacted_length\": redacted_length,\n            \"redaction_count\": redaction_count,\n            \"redacted_text\": redacted,\n        }\n    )\n\n\n@router.get(\"/routing\")\nasync def get_phi_routing(\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"Get current PHI routing configuration.\n\n    Routing determines how queries containing PHI are processed:\n    - local_only: Always use local LLM (most secure)\n    - cloud_allowed: Allow cloud with redaction\n    - hybrid: Use local for high-confidence PHI, cloud for low\n    \"\"\"\n    config = get_routing_config()\n\n    return success_response(data=config.model_dump())\n\n\n@router.patch(\"/routing\")\nasync def update_phi_routing(\n    update: PHIRoutingUpdate,\n    admin_user=Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Update PHI routing configuration.\n\n    Changes affect how future queries with PHI are processed.\n    \"\"\"\n    current = get_routing_config()\n\n    # Apply updates\n    if update.mode is not None:\n        current.mode = update.mode\n    if update.confidence_threshold is not None:\n        current.confidence_threshold = update.confidence_threshold\n    if update.redact_before_cloud is not None:\n        current.redact_before_cloud = update.redact_before_cloud\n    if update.audit_all_phi is not None:\n        current.audit_all_phi = update.audit_all_phi\n\n    set_routing_config(current)\n\n    # Audit log\n    log_phi_detection_audit(\n        db,\n        phi_types=[],\n        action=\"routing_config_updated\",\n        user_id=str(admin_user.id) if admin_user else None,\n        details=update.model_dump(exclude_none=True),\n    )\n\n    logger.info(f\"PHI routing config updated by admin: {update.model_dump(exclude_none=True)}\")\n\n    return success_response(\n        data=current.model_dump(),\n        message=\"PHI routing configuration updated\",\n    )\n\n\n@router.get(\"/stats\")\nasync def get_phi_stats(\n    days: int = Query(7, ge=1, le=90),\n    admin_user=Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Get PHI detection statistics.\n\n    Returns detection counts by type, by day, and routing statistics.\n    \"\"\"\n    stats = PHIStats(\n        total_detections=0,\n        detections_today=0,\n        detections_this_week=0,\n        by_type={},\n        by_day=[],\n        routing_stats={\n            \"routed_local\": 0,\n            \"redacted_cloud\": 0,\n            \"blocked\": 0,\n        },\n    )\n\n    try:\n        # Get total by type from Redis\n        totals = redis_client.hgetall(f\"{REDIS_PHI_STATS_KEY}:total\")\n        if totals:\n            stats.total_detections = int(totals.get(\"all\", 0))\n            stats.by_type = {k: int(v) for k, v in totals.items() if k != \"all\"}\n\n        # Get daily stats\n        today = datetime.now(timezone.utc)\n        for i in range(days):\n            day = (today - timedelta(days=i)).strftime(\"%Y-%m-%d\")\n            daily = redis_client.hgetall(f\"{REDIS_PHI_STATS_KEY}:daily:{day}\")\n            if daily:\n                total = sum(int(v) for v in daily.values())\n                stats.by_day.append(\n                    {\n                        \"date\": day,\n                        \"count\": total,\n                        \"by_type\": {k: int(v) for k, v in daily.items()},\n                    }\n                )\n\n                if i == 0:\n                    stats.detections_today = total\n                if i < 7:\n                    stats.detections_this_week += total\n\n        # Sort by_day chronologically\n        stats.by_day.sort(key=lambda x: x[\"date\"])\n\n    except Exception as e:\n        logger.error(f\"Failed to get PHI stats from Redis: {e}\")\n\n    # Get routing stats from audit logs\n    # Note: AuditLog model uses 'timestamp' not 'created_at', and 'additional_data' not 'details'\n    try:\n        one_week_ago = datetime.now(timezone.utc) - timedelta(days=7)\n        routing_counts = (\n            db.query(\n                func.json_extract(AuditLog.additional_data, \"$.action_taken\").label(\"action\"),\n                func.count().label(\"count\"),\n            )\n            .filter(\n                AuditLog.action == \"phi_detection\",\n                AuditLog.timestamp >= one_week_ago,\n            )\n            .group_by(func.json_extract(AuditLog.additional_data, \"$.action_taken\"))\n            .all()\n        )\n        for action, count in routing_counts:\n            if action and action.strip('\"') in stats.routing_stats:\n                stats.routing_stats[action.strip('\"')] = count\n    except Exception as e:\n        logger.warning(f\"Failed to get routing stats from audit logs: {e}\")\n\n    return success_response(data=stats.model_dump())\n\n\n@router.get(\"/events\")\nasync def get_phi_events(\n    limit: int = Query(50, ge=1, le=500),\n    offset: int = Query(0, ge=0),\n    admin_user=Depends(get_current_admin_user),\n    db: Session = Depends(get_db),\n) -> Dict[str, Any]:\n    \"\"\"Get recent PHI detection events from audit logs.\n\n    Returns a paginated list of PHI detection events.\n    \"\"\"\n    try:\n        # Query audit logs for PHI detections\n        # Note: AuditLog model uses 'timestamp' not 'created_at', and 'additional_data' not 'details'\n        query = db.query(AuditLog).filter(AuditLog.action == \"phi_detection\").order_by(desc(AuditLog.timestamp))\n\n        total = query.count()\n        events = query.offset(offset).limit(limit).all()\n\n        event_list = []\n        for event in events:\n            details = event.additional_data or {}\n            event_list.append(\n                PHIEvent(\n                    id=str(event.id),\n                    timestamp=event.timestamp.isoformat() if event.timestamp else \"\",\n                    phi_types=details.get(\"phi_types\", []),\n                    confidence=details.get(\"confidence\", 0.0),\n                    action_taken=details.get(\"action_taken\", \"unknown\"),\n                    user_id=str(event.user_id) if event.user_id else None,\n                    session_id=details.get(\"session_id\"),\n                ).model_dump()\n            )\n\n        return success_response(\n            data={\n                \"events\": event_list,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n            }\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to get PHI events: {e}\")\n        return error_response(\n            code=\"PHI_EVENTS_ERROR\",\n            message=\"Failed to retrieve PHI events\",\n            status_code=500,\n        )\n\n\n@router.get(\"/health\")\nasync def get_phi_health(\n    admin_user=Depends(get_current_admin_user),\n) -> Dict[str, Any]:\n    \"\"\"Get PHI detection system health status.\n\n    Returns status of all PHI-related components.\n    \"\"\"\n    health = {\n        \"detector\": \"healthy\",\n        \"redis_config\": \"unknown\",\n        \"local_llm\": \"not_configured\",\n        \"audit_logging\": \"healthy\",\n    }\n\n    # Check Redis config access\n    try:\n        redis_client.ping()\n        redis_client.get(REDIS_PHI_ROUTING_KEY)\n        health[\"redis_config\"] = \"healthy\"\n    except Exception as e:\n        health[\"redis_config\"] = f\"error: {str(e)}\"\n\n    # Check local LLM status\n    routing = get_routing_config()\n    if routing.local_llm_enabled and routing.local_llm_url:\n        health[\"local_llm\"] = \"configured\"\n        # Could add actual connectivity check here\n\n    overall = \"healthy\"\n    if any(\"error\" in str(v) for v in health.values()):\n        overall = \"degraded\"\n\n    return success_response(\n        data={\n            \"overall\": overall,\n            \"components\": health,\n            \"routing_mode\": routing.mode.value,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n    )\n"
}
