import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";

function normalizeOperations(spec) {
  const operations = [];
  const paths = spec.paths || {};

  Object.entries(paths).forEach(([pathKey, methods]) => {
    Object.entries(methods).forEach(([method, operation]) => {
      const id = `${method}-${pathKey}`.replace(/[^a-z0-9-_]/gi, "-").replace(/-+/g, "-");

      const parameters = (operation.parameters || []).map((param) => ({
        name: param.name,
        in: param.in,
        required: Boolean(param.required),
        description: param.description,
        schema: param.schema,
      }));

      const [contentType, requestBody] = operation.requestBody?.content
        ? Object.entries(operation.requestBody.content)[0]
        : [];

      const responses = Object.entries(operation.responses || {}).map(([status, response]) => {
        const responseContent = response.content || {};
        const firstResponse = Object.entries(responseContent)[0];

        return {
          status,
          description: response.description,
          contentTypes: Object.keys(responseContent),
          schema: firstResponse ? firstResponse[1].schema : undefined,
        };
      });

      operations.push({
        id,
        method: method.toUpperCase(),
        path: pathKey,
        summary: operation.summary || operation.operationId,
        description: operation.description,
        tags: operation.tags || [],
        parameters,
        requestBody: requestBody
          ? {
              description: operation.requestBody?.description,
              contentType: contentType,
              schema: requestBody.schema,
            }
          : undefined,
        responses,
      });
    });
  });

  return operations.sort((a, b) => {
    if (a.path === b.path) {
      return a.method.localeCompare(b.method);
    }
    return a.path.localeCompare(b.path);
  });
}

function writeGeneratedFile(data) {
  const outputDir = path.join(process.cwd(), "src", "app", "reference", "api", "generated");
  fs.mkdirSync(outputDir, { recursive: true });
  const outputPath = path.join(outputDir, "api-spec.ts");
  const fileContents = `// Auto-generated by scripts/generate-api-reference.mjs\n// Do not edit directly.\n\nexport const generatedApiSpec = ${JSON.stringify(
    data,
    null,
    2
  )} as const;\n\nexport type GeneratedApiSpec = typeof generatedApiSpec;\n`;

  fs.writeFileSync(outputPath, fileContents);
  console.log(`API reference generated at ${outputPath}`);
}

function main() {
  const specPath = process.env.OPENAPI_SPEC_PATH || path.join(process.cwd(), "openapi", "openapi.json");

  if (!fs.existsSync(specPath)) {
    console.error(`OpenAPI spec not found at ${specPath}`);
    process.exit(1);
  }

  const raw = fs.readFileSync(specPath, "utf8");
  const spec = JSON.parse(raw);

  const operations = normalizeOperations(spec);

  const output = {
    info: spec.info || {},
    servers: spec.servers || [],
    tags: spec.tags || [],
    operations,
  };

  writeGeneratedFile(output);
}

if (import.meta.url === pathToFileURL(process.argv[1])?.href) {
  main();
}
